
disco-rec_Appli.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000034c  34000400  34000400  00000400  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000c154  3400074c  3400074c  0000074c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000220  3400c8a0  3400c8a0  0000c8a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  3400cac0  3400cac0  0000db00  2**0
                  CONTENTS
  4 .ARM          00000008  3400cac0  3400cac0  0000cac0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  3400cac8  3400cac8  0000db00  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  3400cac8  3400cac8  0000cac8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  3400cacc  3400cacc  0000cacc  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         0000000c  34080000  3400cad0  0000d000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .noncacheable 00000004  3408000c  3400cadc  0000d00c  2**0
                  ALLOC
 10 .gnu.sgstubs  00000020  3400cae0  3400cae0  0000dae0  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .bss          00000194  34080010  34080010  0000e010  2**2
                  ALLOC
 12 ._user_heap_stack 00000a04  340801a4  340801a4  0000e010  2**0
                  ALLOC
 13 .ARM.attributes 0000003a  00000000  00000000  0000db00  2**0
                  CONTENTS, READONLY
 14 .debug_info   00021892  00000000  00000000  0000db3a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_abbrev 0000251e  00000000  00000000  0002f3cc  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_aranges 00001e28  00000000  00000000  000318f0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_rnglists 00001733  00000000  00000000  00033718  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_macro  00053825  00000000  00000000  00034e4b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_line   00017fa6  00000000  00000000  00088670  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_str    002184da  00000000  00000000  000a0616  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .comment      00000043  00000000  00000000  002b8af0  2**0
                  CONTENTS, READONLY
 22 .debug_frame  00008340  00000000  00000000  002b8b34  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .debug_line_str 00000068  00000000  00000000  002c0e74  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

3400074c <__do_global_dtors_aux>:
3400074c:	b510      	push	{r4, lr}
3400074e:	4c05      	ldr	r4, [pc, #20]	@ (34000764 <__do_global_dtors_aux+0x18>)
34000750:	7823      	ldrb	r3, [r4, #0]
34000752:	b933      	cbnz	r3, 34000762 <__do_global_dtors_aux+0x16>
34000754:	4b04      	ldr	r3, [pc, #16]	@ (34000768 <__do_global_dtors_aux+0x1c>)
34000756:	b113      	cbz	r3, 3400075e <__do_global_dtors_aux+0x12>
34000758:	4804      	ldr	r0, [pc, #16]	@ (3400076c <__do_global_dtors_aux+0x20>)
3400075a:	f3af 8000 	nop.w
3400075e:	2301      	movs	r3, #1
34000760:	7023      	strb	r3, [r4, #0]
34000762:	bd10      	pop	{r4, pc}
34000764:	34080010 	.word	0x34080010
34000768:	00000000 	.word	0x00000000
3400076c:	3400c888 	.word	0x3400c888

34000770 <frame_dummy>:
34000770:	b508      	push	{r3, lr}
34000772:	4b03      	ldr	r3, [pc, #12]	@ (34000780 <frame_dummy+0x10>)
34000774:	b11b      	cbz	r3, 3400077e <frame_dummy+0xe>
34000776:	4903      	ldr	r1, [pc, #12]	@ (34000784 <frame_dummy+0x14>)
34000778:	4803      	ldr	r0, [pc, #12]	@ (34000788 <frame_dummy+0x18>)
3400077a:	f3af 8000 	nop.w
3400077e:	bd08      	pop	{r3, pc}
34000780:	00000000 	.word	0x00000000
34000784:	34080014 	.word	0x34080014
34000788:	3400c888 	.word	0x3400c888

3400078c <__aeabi_uldivmod>:
3400078c:	b953      	cbnz	r3, 340007a4 <__aeabi_uldivmod+0x18>
3400078e:	b94a      	cbnz	r2, 340007a4 <__aeabi_uldivmod+0x18>
34000790:	2900      	cmp	r1, #0
34000792:	bf08      	it	eq
34000794:	2800      	cmpeq	r0, #0
34000796:	bf1c      	itt	ne
34000798:	f04f 31ff 	movne.w	r1, #4294967295	@ 0xffffffff
3400079c:	f04f 30ff 	movne.w	r0, #4294967295	@ 0xffffffff
340007a0:	f000 b9b0 	b.w	34000b04 <__aeabi_idiv0>
340007a4:	f1ad 0c08 	sub.w	ip, sp, #8
340007a8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
340007ac:	f000 f806 	bl	340007bc <__udivmoddi4>
340007b0:	f8dd e004 	ldr.w	lr, [sp, #4]
340007b4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
340007b8:	b004      	add	sp, #16
340007ba:	4770      	bx	lr

340007bc <__udivmoddi4>:
340007bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
340007c0:	9d09      	ldr	r5, [sp, #36]	@ 0x24
340007c2:	4688      	mov	r8, r1
340007c4:	4604      	mov	r4, r0
340007c6:	468e      	mov	lr, r1
340007c8:	2b00      	cmp	r3, #0
340007ca:	d14a      	bne.n	34000862 <__udivmoddi4+0xa6>
340007cc:	428a      	cmp	r2, r1
340007ce:	4617      	mov	r7, r2
340007d0:	d95f      	bls.n	34000892 <__udivmoddi4+0xd6>
340007d2:	fab2 f682 	clz	r6, r2
340007d6:	b14e      	cbz	r6, 340007ec <__udivmoddi4+0x30>
340007d8:	f1c6 0320 	rsb	r3, r6, #32
340007dc:	fa01 fe06 	lsl.w	lr, r1, r6
340007e0:	40b7      	lsls	r7, r6
340007e2:	40b4      	lsls	r4, r6
340007e4:	fa20 f303 	lsr.w	r3, r0, r3
340007e8:	ea43 0e0e 	orr.w	lr, r3, lr
340007ec:	ea4f 4817 	mov.w	r8, r7, lsr #16
340007f0:	fa1f fc87 	uxth.w	ip, r7
340007f4:	0c23      	lsrs	r3, r4, #16
340007f6:	fbbe f1f8 	udiv	r1, lr, r8
340007fa:	fb08 ee11 	mls	lr, r8, r1, lr
340007fe:	fb01 f20c 	mul.w	r2, r1, ip
34000802:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
34000806:	429a      	cmp	r2, r3
34000808:	d907      	bls.n	3400081a <__udivmoddi4+0x5e>
3400080a:	18fb      	adds	r3, r7, r3
3400080c:	f101 30ff 	add.w	r0, r1, #4294967295	@ 0xffffffff
34000810:	d202      	bcs.n	34000818 <__udivmoddi4+0x5c>
34000812:	429a      	cmp	r2, r3
34000814:	f200 8154 	bhi.w	34000ac0 <__udivmoddi4+0x304>
34000818:	4601      	mov	r1, r0
3400081a:	1a9b      	subs	r3, r3, r2
3400081c:	b2a2      	uxth	r2, r4
3400081e:	fbb3 f0f8 	udiv	r0, r3, r8
34000822:	fb08 3310 	mls	r3, r8, r0, r3
34000826:	fb00 fc0c 	mul.w	ip, r0, ip
3400082a:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
3400082e:	4594      	cmp	ip, r2
34000830:	d90b      	bls.n	3400084a <__udivmoddi4+0x8e>
34000832:	18ba      	adds	r2, r7, r2
34000834:	f100 33ff 	add.w	r3, r0, #4294967295	@ 0xffffffff
34000838:	bf2c      	ite	cs
3400083a:	2401      	movcs	r4, #1
3400083c:	2400      	movcc	r4, #0
3400083e:	4594      	cmp	ip, r2
34000840:	d902      	bls.n	34000848 <__udivmoddi4+0x8c>
34000842:	2c00      	cmp	r4, #0
34000844:	f000 813f 	beq.w	34000ac6 <__udivmoddi4+0x30a>
34000848:	4618      	mov	r0, r3
3400084a:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
3400084e:	eba2 020c 	sub.w	r2, r2, ip
34000852:	2100      	movs	r1, #0
34000854:	b11d      	cbz	r5, 3400085e <__udivmoddi4+0xa2>
34000856:	40f2      	lsrs	r2, r6
34000858:	2300      	movs	r3, #0
3400085a:	e9c5 2300 	strd	r2, r3, [r5]
3400085e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
34000862:	428b      	cmp	r3, r1
34000864:	d905      	bls.n	34000872 <__udivmoddi4+0xb6>
34000866:	b10d      	cbz	r5, 3400086c <__udivmoddi4+0xb0>
34000868:	e9c5 0100 	strd	r0, r1, [r5]
3400086c:	2100      	movs	r1, #0
3400086e:	4608      	mov	r0, r1
34000870:	e7f5      	b.n	3400085e <__udivmoddi4+0xa2>
34000872:	fab3 f183 	clz	r1, r3
34000876:	2900      	cmp	r1, #0
34000878:	d14e      	bne.n	34000918 <__udivmoddi4+0x15c>
3400087a:	4543      	cmp	r3, r8
3400087c:	f0c0 8112 	bcc.w	34000aa4 <__udivmoddi4+0x2e8>
34000880:	4282      	cmp	r2, r0
34000882:	f240 810f 	bls.w	34000aa4 <__udivmoddi4+0x2e8>
34000886:	4608      	mov	r0, r1
34000888:	2d00      	cmp	r5, #0
3400088a:	d0e8      	beq.n	3400085e <__udivmoddi4+0xa2>
3400088c:	e9c5 4e00 	strd	r4, lr, [r5]
34000890:	e7e5      	b.n	3400085e <__udivmoddi4+0xa2>
34000892:	2a00      	cmp	r2, #0
34000894:	f000 80ac 	beq.w	340009f0 <__udivmoddi4+0x234>
34000898:	fab2 f682 	clz	r6, r2
3400089c:	2e00      	cmp	r6, #0
3400089e:	f040 80bb 	bne.w	34000a18 <__udivmoddi4+0x25c>
340008a2:	1a8b      	subs	r3, r1, r2
340008a4:	ea4f 4e12 	mov.w	lr, r2, lsr #16
340008a8:	b2bc      	uxth	r4, r7
340008aa:	2101      	movs	r1, #1
340008ac:	0c02      	lsrs	r2, r0, #16
340008ae:	b280      	uxth	r0, r0
340008b0:	fbb3 fcfe 	udiv	ip, r3, lr
340008b4:	fb0e 331c 	mls	r3, lr, ip, r3
340008b8:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
340008bc:	fb04 f20c 	mul.w	r2, r4, ip
340008c0:	429a      	cmp	r2, r3
340008c2:	d90e      	bls.n	340008e2 <__udivmoddi4+0x126>
340008c4:	18fb      	adds	r3, r7, r3
340008c6:	f10c 38ff 	add.w	r8, ip, #4294967295	@ 0xffffffff
340008ca:	bf2c      	ite	cs
340008cc:	f04f 0901 	movcs.w	r9, #1
340008d0:	f04f 0900 	movcc.w	r9, #0
340008d4:	429a      	cmp	r2, r3
340008d6:	d903      	bls.n	340008e0 <__udivmoddi4+0x124>
340008d8:	f1b9 0f00 	cmp.w	r9, #0
340008dc:	f000 80ec 	beq.w	34000ab8 <__udivmoddi4+0x2fc>
340008e0:	46c4      	mov	ip, r8
340008e2:	1a9b      	subs	r3, r3, r2
340008e4:	fbb3 f8fe 	udiv	r8, r3, lr
340008e8:	fb0e 3318 	mls	r3, lr, r8, r3
340008ec:	fb04 f408 	mul.w	r4, r4, r8
340008f0:	ea40 4203 	orr.w	r2, r0, r3, lsl #16
340008f4:	4294      	cmp	r4, r2
340008f6:	d90b      	bls.n	34000910 <__udivmoddi4+0x154>
340008f8:	18ba      	adds	r2, r7, r2
340008fa:	f108 33ff 	add.w	r3, r8, #4294967295	@ 0xffffffff
340008fe:	bf2c      	ite	cs
34000900:	2001      	movcs	r0, #1
34000902:	2000      	movcc	r0, #0
34000904:	4294      	cmp	r4, r2
34000906:	d902      	bls.n	3400090e <__udivmoddi4+0x152>
34000908:	2800      	cmp	r0, #0
3400090a:	f000 80d1 	beq.w	34000ab0 <__udivmoddi4+0x2f4>
3400090e:	4698      	mov	r8, r3
34000910:	1b12      	subs	r2, r2, r4
34000912:	ea48 400c 	orr.w	r0, r8, ip, lsl #16
34000916:	e79d      	b.n	34000854 <__udivmoddi4+0x98>
34000918:	f1c1 0620 	rsb	r6, r1, #32
3400091c:	408b      	lsls	r3, r1
3400091e:	fa08 f401 	lsl.w	r4, r8, r1
34000922:	fa00 f901 	lsl.w	r9, r0, r1
34000926:	fa22 f706 	lsr.w	r7, r2, r6
3400092a:	fa28 f806 	lsr.w	r8, r8, r6
3400092e:	408a      	lsls	r2, r1
34000930:	431f      	orrs	r7, r3
34000932:	fa20 f306 	lsr.w	r3, r0, r6
34000936:	0c38      	lsrs	r0, r7, #16
34000938:	4323      	orrs	r3, r4
3400093a:	fa1f fc87 	uxth.w	ip, r7
3400093e:	0c1c      	lsrs	r4, r3, #16
34000940:	fbb8 fef0 	udiv	lr, r8, r0
34000944:	fb00 881e 	mls	r8, r0, lr, r8
34000948:	ea44 4408 	orr.w	r4, r4, r8, lsl #16
3400094c:	fb0e f80c 	mul.w	r8, lr, ip
34000950:	45a0      	cmp	r8, r4
34000952:	d90e      	bls.n	34000972 <__udivmoddi4+0x1b6>
34000954:	193c      	adds	r4, r7, r4
34000956:	f10e 3aff 	add.w	sl, lr, #4294967295	@ 0xffffffff
3400095a:	bf2c      	ite	cs
3400095c:	f04f 0b01 	movcs.w	fp, #1
34000960:	f04f 0b00 	movcc.w	fp, #0
34000964:	45a0      	cmp	r8, r4
34000966:	d903      	bls.n	34000970 <__udivmoddi4+0x1b4>
34000968:	f1bb 0f00 	cmp.w	fp, #0
3400096c:	f000 80b8 	beq.w	34000ae0 <__udivmoddi4+0x324>
34000970:	46d6      	mov	lr, sl
34000972:	eba4 0408 	sub.w	r4, r4, r8
34000976:	fa1f f883 	uxth.w	r8, r3
3400097a:	fbb4 f3f0 	udiv	r3, r4, r0
3400097e:	fb00 4413 	mls	r4, r0, r3, r4
34000982:	fb03 fc0c 	mul.w	ip, r3, ip
34000986:	ea48 4404 	orr.w	r4, r8, r4, lsl #16
3400098a:	45a4      	cmp	ip, r4
3400098c:	d90e      	bls.n	340009ac <__udivmoddi4+0x1f0>
3400098e:	193c      	adds	r4, r7, r4
34000990:	f103 30ff 	add.w	r0, r3, #4294967295	@ 0xffffffff
34000994:	bf2c      	ite	cs
34000996:	f04f 0801 	movcs.w	r8, #1
3400099a:	f04f 0800 	movcc.w	r8, #0
3400099e:	45a4      	cmp	ip, r4
340009a0:	d903      	bls.n	340009aa <__udivmoddi4+0x1ee>
340009a2:	f1b8 0f00 	cmp.w	r8, #0
340009a6:	f000 809f 	beq.w	34000ae8 <__udivmoddi4+0x32c>
340009aa:	4603      	mov	r3, r0
340009ac:	ea43 400e 	orr.w	r0, r3, lr, lsl #16
340009b0:	eba4 040c 	sub.w	r4, r4, ip
340009b4:	fba0 ec02 	umull	lr, ip, r0, r2
340009b8:	4564      	cmp	r4, ip
340009ba:	4673      	mov	r3, lr
340009bc:	46e0      	mov	r8, ip
340009be:	d302      	bcc.n	340009c6 <__udivmoddi4+0x20a>
340009c0:	d107      	bne.n	340009d2 <__udivmoddi4+0x216>
340009c2:	45f1      	cmp	r9, lr
340009c4:	d205      	bcs.n	340009d2 <__udivmoddi4+0x216>
340009c6:	ebbe 0302 	subs.w	r3, lr, r2
340009ca:	eb6c 0c07 	sbc.w	ip, ip, r7
340009ce:	3801      	subs	r0, #1
340009d0:	46e0      	mov	r8, ip
340009d2:	b15d      	cbz	r5, 340009ec <__udivmoddi4+0x230>
340009d4:	ebb9 0203 	subs.w	r2, r9, r3
340009d8:	eb64 0408 	sbc.w	r4, r4, r8
340009dc:	fa04 f606 	lsl.w	r6, r4, r6
340009e0:	fa22 f301 	lsr.w	r3, r2, r1
340009e4:	40cc      	lsrs	r4, r1
340009e6:	431e      	orrs	r6, r3
340009e8:	e9c5 6400 	strd	r6, r4, [r5]
340009ec:	2100      	movs	r1, #0
340009ee:	e736      	b.n	3400085e <__udivmoddi4+0xa2>
340009f0:	fbb1 fcf2 	udiv	ip, r1, r2
340009f4:	0c01      	lsrs	r1, r0, #16
340009f6:	4614      	mov	r4, r2
340009f8:	b280      	uxth	r0, r0
340009fa:	4696      	mov	lr, r2
340009fc:	ea41 4108 	orr.w	r1, r1, r8, lsl #16
34000a00:	2620      	movs	r6, #32
34000a02:	4690      	mov	r8, r2
34000a04:	ea40 4301 	orr.w	r3, r0, r1, lsl #16
34000a08:	4610      	mov	r0, r2
34000a0a:	fbb1 f1f2 	udiv	r1, r1, r2
34000a0e:	eba3 0308 	sub.w	r3, r3, r8
34000a12:	ea41 410c 	orr.w	r1, r1, ip, lsl #16
34000a16:	e74b      	b.n	340008b0 <__udivmoddi4+0xf4>
34000a18:	40b7      	lsls	r7, r6
34000a1a:	f1c6 0320 	rsb	r3, r6, #32
34000a1e:	fa01 f206 	lsl.w	r2, r1, r6
34000a22:	fa21 f803 	lsr.w	r8, r1, r3
34000a26:	ea4f 4e17 	mov.w	lr, r7, lsr #16
34000a2a:	fa20 f303 	lsr.w	r3, r0, r3
34000a2e:	b2bc      	uxth	r4, r7
34000a30:	40b0      	lsls	r0, r6
34000a32:	4313      	orrs	r3, r2
34000a34:	0c02      	lsrs	r2, r0, #16
34000a36:	0c19      	lsrs	r1, r3, #16
34000a38:	b280      	uxth	r0, r0
34000a3a:	fbb8 f9fe 	udiv	r9, r8, lr
34000a3e:	fb0e 8819 	mls	r8, lr, r9, r8
34000a42:	ea41 4108 	orr.w	r1, r1, r8, lsl #16
34000a46:	fb09 f804 	mul.w	r8, r9, r4
34000a4a:	4588      	cmp	r8, r1
34000a4c:	d951      	bls.n	34000af2 <__udivmoddi4+0x336>
34000a4e:	1879      	adds	r1, r7, r1
34000a50:	f109 3cff 	add.w	ip, r9, #4294967295	@ 0xffffffff
34000a54:	bf2c      	ite	cs
34000a56:	f04f 0a01 	movcs.w	sl, #1
34000a5a:	f04f 0a00 	movcc.w	sl, #0
34000a5e:	4588      	cmp	r8, r1
34000a60:	d902      	bls.n	34000a68 <__udivmoddi4+0x2ac>
34000a62:	f1ba 0f00 	cmp.w	sl, #0
34000a66:	d031      	beq.n	34000acc <__udivmoddi4+0x310>
34000a68:	eba1 0108 	sub.w	r1, r1, r8
34000a6c:	fbb1 f9fe 	udiv	r9, r1, lr
34000a70:	fb09 f804 	mul.w	r8, r9, r4
34000a74:	fb0e 1119 	mls	r1, lr, r9, r1
34000a78:	b29b      	uxth	r3, r3
34000a7a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34000a7e:	4543      	cmp	r3, r8
34000a80:	d235      	bcs.n	34000aee <__udivmoddi4+0x332>
34000a82:	18fb      	adds	r3, r7, r3
34000a84:	f109 31ff 	add.w	r1, r9, #4294967295	@ 0xffffffff
34000a88:	bf2c      	ite	cs
34000a8a:	f04f 0a01 	movcs.w	sl, #1
34000a8e:	f04f 0a00 	movcc.w	sl, #0
34000a92:	4543      	cmp	r3, r8
34000a94:	d2bb      	bcs.n	34000a0e <__udivmoddi4+0x252>
34000a96:	f1ba 0f00 	cmp.w	sl, #0
34000a9a:	d1b8      	bne.n	34000a0e <__udivmoddi4+0x252>
34000a9c:	f1a9 0102 	sub.w	r1, r9, #2
34000aa0:	443b      	add	r3, r7
34000aa2:	e7b4      	b.n	34000a0e <__udivmoddi4+0x252>
34000aa4:	1a84      	subs	r4, r0, r2
34000aa6:	eb68 0203 	sbc.w	r2, r8, r3
34000aaa:	2001      	movs	r0, #1
34000aac:	4696      	mov	lr, r2
34000aae:	e6eb      	b.n	34000888 <__udivmoddi4+0xcc>
34000ab0:	443a      	add	r2, r7
34000ab2:	f1a8 0802 	sub.w	r8, r8, #2
34000ab6:	e72b      	b.n	34000910 <__udivmoddi4+0x154>
34000ab8:	f1ac 0c02 	sub.w	ip, ip, #2
34000abc:	443b      	add	r3, r7
34000abe:	e710      	b.n	340008e2 <__udivmoddi4+0x126>
34000ac0:	3902      	subs	r1, #2
34000ac2:	443b      	add	r3, r7
34000ac4:	e6a9      	b.n	3400081a <__udivmoddi4+0x5e>
34000ac6:	443a      	add	r2, r7
34000ac8:	3802      	subs	r0, #2
34000aca:	e6be      	b.n	3400084a <__udivmoddi4+0x8e>
34000acc:	eba7 0808 	sub.w	r8, r7, r8
34000ad0:	f1a9 0c02 	sub.w	ip, r9, #2
34000ad4:	4441      	add	r1, r8
34000ad6:	fbb1 f9fe 	udiv	r9, r1, lr
34000ada:	fb09 f804 	mul.w	r8, r9, r4
34000ade:	e7c9      	b.n	34000a74 <__udivmoddi4+0x2b8>
34000ae0:	f1ae 0e02 	sub.w	lr, lr, #2
34000ae4:	443c      	add	r4, r7
34000ae6:	e744      	b.n	34000972 <__udivmoddi4+0x1b6>
34000ae8:	3b02      	subs	r3, #2
34000aea:	443c      	add	r4, r7
34000aec:	e75e      	b.n	340009ac <__udivmoddi4+0x1f0>
34000aee:	4649      	mov	r1, r9
34000af0:	e78d      	b.n	34000a0e <__udivmoddi4+0x252>
34000af2:	eba1 0108 	sub.w	r1, r1, r8
34000af6:	46cc      	mov	ip, r9
34000af8:	fbb1 f9fe 	udiv	r9, r1, lr
34000afc:	fb09 f804 	mul.w	r8, r9, r4
34000b00:	e7b8      	b.n	34000a74 <__udivmoddi4+0x2b8>
34000b02:	bf00      	nop

34000b04 <__aeabi_idiv0>:
34000b04:	4770      	bx	lr
34000b06:	bf00      	nop

34000b08 <LL_AHB4_GRP1_EnableClock>:
  *         @arg @ref LL_AHB4_GRP1_PERIPH_PWR
  *         @arg @ref LL_AHB4_GRP1_PERIPH_CRC
  * @retval None
  */
__STATIC_INLINE void LL_AHB4_GRP1_EnableClock(uint32_t Periphs)
{
34000b08:	b480      	push	{r7}
34000b0a:	b085      	sub	sp, #20
34000b0c:	af00      	add	r7, sp, #0
34000b0e:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34000b10:	4a07      	ldr	r2, [pc, #28]	@ (34000b30 <LL_AHB4_GRP1_EnableClock+0x28>)
34000b12:	687b      	ldr	r3, [r7, #4]
34000b14:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB4ENR);
34000b18:	4b05      	ldr	r3, [pc, #20]	@ (34000b30 <LL_AHB4_GRP1_EnableClock+0x28>)
34000b1a:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
34000b1e:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34000b20:	68fb      	ldr	r3, [r7, #12]
}
34000b22:	bf00      	nop
34000b24:	3714      	adds	r7, #20
34000b26:	46bd      	mov	sp, r7
34000b28:	f85d 7b04 	ldr.w	r7, [sp], #4
34000b2c:	4770      	bx	lr
34000b2e:	bf00      	nop
34000b30:	56028000 	.word	0x56028000

34000b34 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
34000b34:	b580      	push	{r7, lr}
34000b36:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/
  HAL_Init();
34000b38:	f000 febb 	bl	340018b2 <HAL_Init>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
34000b3c:	f000 f98e 	bl	34000e5c <MX_GPIO_Init>
  MX_DCMIPP_Init();
34000b40:	f000 f80a 	bl	34000b58 <MX_DCMIPP_Init>
  MX_VENC_Init();
34000b44:	f000 f8ce 	bl	34000ce4 <MX_VENC_Init>
  MX_USART1_UART_Init();
34000b48:	f000 f880 	bl	34000c4c <MX_USART1_UART_Init>
  MX_XSPI1_Init();
34000b4c:	f000 f8d2 	bl	34000cf4 <MX_XSPI1_Init>
  MX_XSPI2_Init();
34000b50:	f000 f92a 	bl	34000da8 <MX_XSPI2_Init>

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
34000b54:	bf00      	nop
34000b56:	e7fd      	b.n	34000b54 <main+0x20>

34000b58 <MX_DCMIPP_Init>:
  * @brief DCMIPP Initialization Function
  * @param None
  * @retval None
  */
static void MX_DCMIPP_Init(void)
{
34000b58:	b580      	push	{r7, lr}
34000b5a:	b08a      	sub	sp, #40	@ 0x28
34000b5c:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN DCMIPP_Init 0 */

  /* USER CODE END DCMIPP_Init 0 */

  DCMIPP_CSI_PIPE_ConfTypeDef pCSI_PipeConfig = {0};
34000b5e:	f107 031c 	add.w	r3, r7, #28
34000b62:	2200      	movs	r2, #0
34000b64:	601a      	str	r2, [r3, #0]
34000b66:	605a      	str	r2, [r3, #4]
34000b68:	609a      	str	r2, [r3, #8]
  DCMIPP_CSI_ConfTypeDef pCSI_Config = {0};
34000b6a:	f107 0310 	add.w	r3, r7, #16
34000b6e:	2200      	movs	r2, #0
34000b70:	601a      	str	r2, [r3, #0]
34000b72:	605a      	str	r2, [r3, #4]
34000b74:	609a      	str	r2, [r3, #8]
  DCMIPP_PipeConfTypeDef pPipeConfig = {0};
34000b76:	1d3b      	adds	r3, r7, #4
34000b78:	2200      	movs	r2, #0
34000b7a:	601a      	str	r2, [r3, #0]
34000b7c:	605a      	str	r2, [r3, #4]
34000b7e:	609a      	str	r2, [r3, #8]

  /* USER CODE BEGIN DCMIPP_Init 1 */

  /* USER CODE END DCMIPP_Init 1 */
  hdcmipp.Instance = DCMIPP;
34000b80:	4b30      	ldr	r3, [pc, #192]	@ (34000c44 <MX_DCMIPP_Init+0xec>)
34000b82:	4a31      	ldr	r2, [pc, #196]	@ (34000c48 <MX_DCMIPP_Init+0xf0>)
34000b84:	601a      	str	r2, [r3, #0]
  if (HAL_DCMIPP_Init(&hdcmipp) != HAL_OK)
34000b86:	482f      	ldr	r0, [pc, #188]	@ (34000c44 <MX_DCMIPP_Init+0xec>)
34000b88:	f001 f834 	bl	34001bf4 <HAL_DCMIPP_Init>
34000b8c:	4603      	mov	r3, r0
34000b8e:	2b00      	cmp	r3, #0
34000b90:	d001      	beq.n	34000b96 <MX_DCMIPP_Init+0x3e>
  {
    Error_Handler();
34000b92:	f000 f976 	bl	34000e82 <Error_Handler>
  }

  /** Pipe 1 Config
  */
  pCSI_PipeConfig.DataTypeMode = DCMIPP_DTMODE_DTIDA;
34000b96:	2300      	movs	r3, #0
34000b98:	61fb      	str	r3, [r7, #28]
  pCSI_PipeConfig.DataTypeIDA = DCMIPP_DT_YUV420_8;
34000b9a:	2318      	movs	r3, #24
34000b9c:	623b      	str	r3, [r7, #32]
  pCSI_PipeConfig.DataTypeIDB = DCMIPP_DT_YUV420_8;
34000b9e:	2318      	movs	r3, #24
34000ba0:	627b      	str	r3, [r7, #36]	@ 0x24
  if (HAL_DCMIPP_CSI_PIPE_SetConfig(&hdcmipp, DCMIPP_PIPE1, &pCSI_PipeConfig) != HAL_OK)
34000ba2:	f107 031c 	add.w	r3, r7, #28
34000ba6:	461a      	mov	r2, r3
34000ba8:	2101      	movs	r1, #1
34000baa:	4826      	ldr	r0, [pc, #152]	@ (34000c44 <MX_DCMIPP_Init+0xec>)
34000bac:	f001 f9b4 	bl	34001f18 <HAL_DCMIPP_CSI_PIPE_SetConfig>
34000bb0:	4603      	mov	r3, r0
34000bb2:	2b00      	cmp	r3, #0
34000bb4:	d001      	beq.n	34000bba <MX_DCMIPP_Init+0x62>
  {
    Error_Handler();
34000bb6:	f000 f964 	bl	34000e82 <Error_Handler>
  }
  pCSI_Config.PHYBitrate = DCMIPP_CSI_PHY_BT_80;
34000bba:	2300      	movs	r3, #0
34000bbc:	61bb      	str	r3, [r7, #24]
  pCSI_Config.DataLaneMapping = DCMIPP_CSI_PHYSICAL_DATA_LANES;
34000bbe:	2301      	movs	r3, #1
34000bc0:	617b      	str	r3, [r7, #20]
  pCSI_Config.NumberOfLanes = DCMIPP_CSI_ONE_DATA_LANE;
34000bc2:	f44f 7380 	mov.w	r3, #256	@ 0x100
34000bc6:	613b      	str	r3, [r7, #16]
  HAL_DCMIPP_CSI_SetConfig(&hdcmipp, &pCSI_Config);
34000bc8:	f107 0310 	add.w	r3, r7, #16
34000bcc:	4619      	mov	r1, r3
34000bce:	481d      	ldr	r0, [pc, #116]	@ (34000c44 <MX_DCMIPP_Init+0xec>)
34000bd0:	f001 f83e 	bl	34001c50 <HAL_DCMIPP_CSI_SetConfig>
  pPipeConfig.FrameRate = DCMIPP_FRAME_RATE_ALL;
34000bd4:	2300      	movs	r3, #0
34000bd6:	607b      	str	r3, [r7, #4]
  pPipeConfig.PixelPipePitch = 10;
34000bd8:	230a      	movs	r3, #10
34000bda:	60bb      	str	r3, [r7, #8]
  pPipeConfig.PixelPackerFormat = DCMIPP_PIXEL_PACKER_FORMAT_RGB888_YUV444_1;
34000bdc:	2300      	movs	r3, #0
34000bde:	60fb      	str	r3, [r7, #12]
  if (HAL_DCMIPP_PIPE_SetConfig(&hdcmipp, DCMIPP_PIPE1, &pPipeConfig) != HAL_OK)
34000be0:	1d3b      	adds	r3, r7, #4
34000be2:	461a      	mov	r2, r3
34000be4:	2101      	movs	r1, #1
34000be6:	4817      	ldr	r0, [pc, #92]	@ (34000c44 <MX_DCMIPP_Init+0xec>)
34000be8:	f001 fa78 	bl	340020dc <HAL_DCMIPP_PIPE_SetConfig>
34000bec:	4603      	mov	r3, r0
34000bee:	2b00      	cmp	r3, #0
34000bf0:	d001      	beq.n	34000bf6 <MX_DCMIPP_Init+0x9e>
  {
    Error_Handler();
34000bf2:	f000 f946 	bl	34000e82 <Error_Handler>
  }
  if (HAL_DCMIPP_CSI_SetVCConfig(&hdcmipp, 0U, DCMIPP_CSI_DT_BPP6) != HAL_OK)
34000bf6:	2200      	movs	r2, #0
34000bf8:	2100      	movs	r1, #0
34000bfa:	4812      	ldr	r0, [pc, #72]	@ (34000c44 <MX_DCMIPP_Init+0xec>)
34000bfc:	f001 fa2c 	bl	34002058 <HAL_DCMIPP_CSI_SetVCConfig>
34000c00:	4603      	mov	r3, r0
34000c02:	2b00      	cmp	r3, #0
34000c04:	d001      	beq.n	34000c0a <MX_DCMIPP_Init+0xb2>
  {
    Error_Handler();
34000c06:	f000 f93c 	bl	34000e82 <Error_Handler>
  }

  /** Pipe 2 Config
  */
  pCSI_PipeConfig.DataTypeIDB = DCMIPP_DT_RGB565;
34000c0a:	2322      	movs	r3, #34	@ 0x22
34000c0c:	627b      	str	r3, [r7, #36]	@ 0x24
  if (HAL_DCMIPP_CSI_PIPE_SetConfig(&hdcmipp, DCMIPP_PIPE2, &pCSI_PipeConfig) != HAL_OK)
34000c0e:	f107 031c 	add.w	r3, r7, #28
34000c12:	461a      	mov	r2, r3
34000c14:	2102      	movs	r1, #2
34000c16:	480b      	ldr	r0, [pc, #44]	@ (34000c44 <MX_DCMIPP_Init+0xec>)
34000c18:	f001 f97e 	bl	34001f18 <HAL_DCMIPP_CSI_PIPE_SetConfig>
34000c1c:	4603      	mov	r3, r0
34000c1e:	2b00      	cmp	r3, #0
34000c20:	d001      	beq.n	34000c26 <MX_DCMIPP_Init+0xce>
  {
    Error_Handler();
34000c22:	f000 f92e 	bl	34000e82 <Error_Handler>
  }
  if (HAL_DCMIPP_PIPE_SetConfig(&hdcmipp, DCMIPP_PIPE2, &pPipeConfig) != HAL_OK)
34000c26:	1d3b      	adds	r3, r7, #4
34000c28:	461a      	mov	r2, r3
34000c2a:	2102      	movs	r1, #2
34000c2c:	4805      	ldr	r0, [pc, #20]	@ (34000c44 <MX_DCMIPP_Init+0xec>)
34000c2e:	f001 fa55 	bl	340020dc <HAL_DCMIPP_PIPE_SetConfig>
34000c32:	4603      	mov	r3, r0
34000c34:	2b00      	cmp	r3, #0
34000c36:	d001      	beq.n	34000c3c <MX_DCMIPP_Init+0xe4>
  {
    Error_Handler();
34000c38:	f000 f923 	bl	34000e82 <Error_Handler>
  }
  /* USER CODE BEGIN DCMIPP_Init 2 */

  /* USER CODE END DCMIPP_Init 2 */

}
34000c3c:	bf00      	nop
34000c3e:	3728      	adds	r7, #40	@ 0x28
34000c40:	46bd      	mov	sp, r7
34000c42:	bd80      	pop	{r7, pc}
34000c44:	3408002c 	.word	0x3408002c
34000c48:	58002000 	.word	0x58002000

34000c4c <MX_USART1_UART_Init>:
  * @brief USART1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART1_UART_Init(void)
{
34000c4c:	b580      	push	{r7, lr}
34000c4e:	af00      	add	r7, sp, #0
  /* USER CODE END USART1_Init 0 */

  /* USER CODE BEGIN USART1_Init 1 */

  /* USER CODE END USART1_Init 1 */
  huart1.Instance = USART1;
34000c50:	4b22      	ldr	r3, [pc, #136]	@ (34000cdc <MX_USART1_UART_Init+0x90>)
34000c52:	4a23      	ldr	r2, [pc, #140]	@ (34000ce0 <MX_USART1_UART_Init+0x94>)
34000c54:	601a      	str	r2, [r3, #0]
  huart1.Init.BaudRate = 115200;
34000c56:	4b21      	ldr	r3, [pc, #132]	@ (34000cdc <MX_USART1_UART_Init+0x90>)
34000c58:	f44f 32e1 	mov.w	r2, #115200	@ 0x1c200
34000c5c:	605a      	str	r2, [r3, #4]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
34000c5e:	4b1f      	ldr	r3, [pc, #124]	@ (34000cdc <MX_USART1_UART_Init+0x90>)
34000c60:	2200      	movs	r2, #0
34000c62:	609a      	str	r2, [r3, #8]
  huart1.Init.StopBits = UART_STOPBITS_1;
34000c64:	4b1d      	ldr	r3, [pc, #116]	@ (34000cdc <MX_USART1_UART_Init+0x90>)
34000c66:	2200      	movs	r2, #0
34000c68:	60da      	str	r2, [r3, #12]
  huart1.Init.Parity = UART_PARITY_NONE;
34000c6a:	4b1c      	ldr	r3, [pc, #112]	@ (34000cdc <MX_USART1_UART_Init+0x90>)
34000c6c:	2200      	movs	r2, #0
34000c6e:	611a      	str	r2, [r3, #16]
  huart1.Init.Mode = UART_MODE_TX_RX;
34000c70:	4b1a      	ldr	r3, [pc, #104]	@ (34000cdc <MX_USART1_UART_Init+0x90>)
34000c72:	220c      	movs	r2, #12
34000c74:	615a      	str	r2, [r3, #20]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
34000c76:	4b19      	ldr	r3, [pc, #100]	@ (34000cdc <MX_USART1_UART_Init+0x90>)
34000c78:	2200      	movs	r2, #0
34000c7a:	619a      	str	r2, [r3, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
34000c7c:	4b17      	ldr	r3, [pc, #92]	@ (34000cdc <MX_USART1_UART_Init+0x90>)
34000c7e:	2200      	movs	r2, #0
34000c80:	61da      	str	r2, [r3, #28]
  huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
34000c82:	4b16      	ldr	r3, [pc, #88]	@ (34000cdc <MX_USART1_UART_Init+0x90>)
34000c84:	2200      	movs	r2, #0
34000c86:	621a      	str	r2, [r3, #32]
  huart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
34000c88:	4b14      	ldr	r3, [pc, #80]	@ (34000cdc <MX_USART1_UART_Init+0x90>)
34000c8a:	2200      	movs	r2, #0
34000c8c:	625a      	str	r2, [r3, #36]	@ 0x24
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
34000c8e:	4b13      	ldr	r3, [pc, #76]	@ (34000cdc <MX_USART1_UART_Init+0x90>)
34000c90:	2200      	movs	r2, #0
34000c92:	629a      	str	r2, [r3, #40]	@ 0x28
  if (HAL_UART_Init(&huart1) != HAL_OK)
34000c94:	4811      	ldr	r0, [pc, #68]	@ (34000cdc <MX_USART1_UART_Init+0x90>)
34000c96:	f00a fd61 	bl	3400b75c <HAL_UART_Init>
34000c9a:	4603      	mov	r3, r0
34000c9c:	2b00      	cmp	r3, #0
34000c9e:	d001      	beq.n	34000ca4 <MX_USART1_UART_Init+0x58>
  {
    Error_Handler();
34000ca0:	f000 f8ef 	bl	34000e82 <Error_Handler>
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
34000ca4:	2100      	movs	r1, #0
34000ca6:	480d      	ldr	r0, [pc, #52]	@ (34000cdc <MX_USART1_UART_Init+0x90>)
34000ca8:	f00b f9ec 	bl	3400c084 <HAL_UARTEx_SetTxFifoThreshold>
34000cac:	4603      	mov	r3, r0
34000cae:	2b00      	cmp	r3, #0
34000cb0:	d001      	beq.n	34000cb6 <MX_USART1_UART_Init+0x6a>
  {
    Error_Handler();
34000cb2:	f000 f8e6 	bl	34000e82 <Error_Handler>
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
34000cb6:	2100      	movs	r1, #0
34000cb8:	4808      	ldr	r0, [pc, #32]	@ (34000cdc <MX_USART1_UART_Init+0x90>)
34000cba:	f00b fa21 	bl	3400c100 <HAL_UARTEx_SetRxFifoThreshold>
34000cbe:	4603      	mov	r3, r0
34000cc0:	2b00      	cmp	r3, #0
34000cc2:	d001      	beq.n	34000cc8 <MX_USART1_UART_Init+0x7c>
  {
    Error_Handler();
34000cc4:	f000 f8dd 	bl	34000e82 <Error_Handler>
  }
  if (HAL_UARTEx_DisableFifoMode(&huart1) != HAL_OK)
34000cc8:	4804      	ldr	r0, [pc, #16]	@ (34000cdc <MX_USART1_UART_Init+0x90>)
34000cca:	f00b f9a2 	bl	3400c012 <HAL_UARTEx_DisableFifoMode>
34000cce:	4603      	mov	r3, r0
34000cd0:	2b00      	cmp	r3, #0
34000cd2:	d001      	beq.n	34000cd8 <MX_USART1_UART_Init+0x8c>
  {
    Error_Handler();
34000cd4:	f000 f8d5 	bl	34000e82 <Error_Handler>
  }
  /* USER CODE BEGIN USART1_Init 2 */

  /* USER CODE END USART1_Init 2 */

}
34000cd8:	bf00      	nop
34000cda:	bd80      	pop	{r7, pc}
34000cdc:	34080038 	.word	0x34080038
34000ce0:	52001000 	.word	0x52001000

34000ce4 <MX_VENC_Init>:
  * @brief VENC Initialization Function
  * @param None
  * @retval None
  */
static void MX_VENC_Init(void)
{
34000ce4:	b480      	push	{r7}
34000ce6:	af00      	add	r7, sp, #0
  /* USER CODE END VENC_Init 1 */
  /* USER CODE BEGIN VENC_Init 2 */

  /* USER CODE END VENC_Init 2 */

}
34000ce8:	bf00      	nop
34000cea:	46bd      	mov	sp, r7
34000cec:	f85d 7b04 	ldr.w	r7, [sp], #4
34000cf0:	4770      	bx	lr
	...

34000cf4 <MX_XSPI1_Init>:
  * @brief XSPI1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_XSPI1_Init(void)
{
34000cf4:	b580      	push	{r7, lr}
34000cf6:	b084      	sub	sp, #16
34000cf8:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN XSPI1_Init 0 */

  /* USER CODE END XSPI1_Init 0 */

  XSPIM_CfgTypeDef sXspiManagerCfg = {0};
34000cfa:	1d3b      	adds	r3, r7, #4
34000cfc:	2200      	movs	r2, #0
34000cfe:	601a      	str	r2, [r3, #0]
34000d00:	605a      	str	r2, [r3, #4]
34000d02:	609a      	str	r2, [r3, #8]

  /* USER CODE BEGIN XSPI1_Init 1 */

  /* USER CODE END XSPI1_Init 1 */
  /* XSPI1 parameter configuration*/
  hxspi1.Instance = XSPI1;
34000d04:	4b26      	ldr	r3, [pc, #152]	@ (34000da0 <MX_XSPI1_Init+0xac>)
34000d06:	4a27      	ldr	r2, [pc, #156]	@ (34000da4 <MX_XSPI1_Init+0xb0>)
34000d08:	601a      	str	r2, [r3, #0]
  hxspi1.Init.FifoThresholdByte = 1;
34000d0a:	4b25      	ldr	r3, [pc, #148]	@ (34000da0 <MX_XSPI1_Init+0xac>)
34000d0c:	2201      	movs	r2, #1
34000d0e:	605a      	str	r2, [r3, #4]
  hxspi1.Init.MemoryMode = HAL_XSPI_SINGLE_MEM;
34000d10:	4b23      	ldr	r3, [pc, #140]	@ (34000da0 <MX_XSPI1_Init+0xac>)
34000d12:	2200      	movs	r2, #0
34000d14:	609a      	str	r2, [r3, #8]
  hxspi1.Init.MemoryType = HAL_XSPI_MEMTYPE_MICRON;
34000d16:	4b22      	ldr	r3, [pc, #136]	@ (34000da0 <MX_XSPI1_Init+0xac>)
34000d18:	2200      	movs	r2, #0
34000d1a:	60da      	str	r2, [r3, #12]
  hxspi1.Init.MemorySize = HAL_XSPI_SIZE_16B;
34000d1c:	4b20      	ldr	r3, [pc, #128]	@ (34000da0 <MX_XSPI1_Init+0xac>)
34000d1e:	2200      	movs	r2, #0
34000d20:	611a      	str	r2, [r3, #16]
  hxspi1.Init.ChipSelectHighTimeCycle = 1;
34000d22:	4b1f      	ldr	r3, [pc, #124]	@ (34000da0 <MX_XSPI1_Init+0xac>)
34000d24:	2201      	movs	r2, #1
34000d26:	615a      	str	r2, [r3, #20]
  hxspi1.Init.FreeRunningClock = HAL_XSPI_FREERUNCLK_DISABLE;
34000d28:	4b1d      	ldr	r3, [pc, #116]	@ (34000da0 <MX_XSPI1_Init+0xac>)
34000d2a:	2200      	movs	r2, #0
34000d2c:	619a      	str	r2, [r3, #24]
  hxspi1.Init.ClockMode = HAL_XSPI_CLOCK_MODE_0;
34000d2e:	4b1c      	ldr	r3, [pc, #112]	@ (34000da0 <MX_XSPI1_Init+0xac>)
34000d30:	2200      	movs	r2, #0
34000d32:	61da      	str	r2, [r3, #28]
  hxspi1.Init.WrapSize = HAL_XSPI_WRAP_NOT_SUPPORTED;
34000d34:	4b1a      	ldr	r3, [pc, #104]	@ (34000da0 <MX_XSPI1_Init+0xac>)
34000d36:	2200      	movs	r2, #0
34000d38:	621a      	str	r2, [r3, #32]
  hxspi1.Init.ClockPrescaler = 0;
34000d3a:	4b19      	ldr	r3, [pc, #100]	@ (34000da0 <MX_XSPI1_Init+0xac>)
34000d3c:	2200      	movs	r2, #0
34000d3e:	625a      	str	r2, [r3, #36]	@ 0x24
  hxspi1.Init.SampleShifting = HAL_XSPI_SAMPLE_SHIFT_NONE;
34000d40:	4b17      	ldr	r3, [pc, #92]	@ (34000da0 <MX_XSPI1_Init+0xac>)
34000d42:	2200      	movs	r2, #0
34000d44:	629a      	str	r2, [r3, #40]	@ 0x28
  hxspi1.Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_DISABLE;
34000d46:	4b16      	ldr	r3, [pc, #88]	@ (34000da0 <MX_XSPI1_Init+0xac>)
34000d48:	2200      	movs	r2, #0
34000d4a:	62da      	str	r2, [r3, #44]	@ 0x2c
  hxspi1.Init.ChipSelectBoundary = HAL_XSPI_BONDARYOF_NONE;
34000d4c:	4b14      	ldr	r3, [pc, #80]	@ (34000da0 <MX_XSPI1_Init+0xac>)
34000d4e:	2200      	movs	r2, #0
34000d50:	631a      	str	r2, [r3, #48]	@ 0x30
  hxspi1.Init.MaxTran = 0;
34000d52:	4b13      	ldr	r3, [pc, #76]	@ (34000da0 <MX_XSPI1_Init+0xac>)
34000d54:	2200      	movs	r2, #0
34000d56:	635a      	str	r2, [r3, #52]	@ 0x34
  hxspi1.Init.Refresh = 0;
34000d58:	4b11      	ldr	r3, [pc, #68]	@ (34000da0 <MX_XSPI1_Init+0xac>)
34000d5a:	2200      	movs	r2, #0
34000d5c:	639a      	str	r2, [r3, #56]	@ 0x38
  hxspi1.Init.MemorySelect = HAL_XSPI_CSSEL_NCS1;
34000d5e:	4b10      	ldr	r3, [pc, #64]	@ (34000da0 <MX_XSPI1_Init+0xac>)
34000d60:	2200      	movs	r2, #0
34000d62:	63da      	str	r2, [r3, #60]	@ 0x3c
  if (HAL_XSPI_Init(&hxspi1) != HAL_OK)
34000d64:	480e      	ldr	r0, [pc, #56]	@ (34000da0 <MX_XSPI1_Init+0xac>)
34000d66:	f00b fa6f 	bl	3400c248 <HAL_XSPI_Init>
34000d6a:	4603      	mov	r3, r0
34000d6c:	2b00      	cmp	r3, #0
34000d6e:	d001      	beq.n	34000d74 <MX_XSPI1_Init+0x80>
  {
    Error_Handler();
34000d70:	f000 f887 	bl	34000e82 <Error_Handler>
  }
  sXspiManagerCfg.nCSOverride = HAL_XSPI_CSSEL_OVR_NCS1;
34000d74:	2310      	movs	r3, #16
34000d76:	607b      	str	r3, [r7, #4]
  sXspiManagerCfg.IOPort = HAL_XSPIM_IOPORT_1;
34000d78:	2300      	movs	r3, #0
34000d7a:	60bb      	str	r3, [r7, #8]
  sXspiManagerCfg.Req2AckTime = 1;
34000d7c:	2301      	movs	r3, #1
34000d7e:	60fb      	str	r3, [r7, #12]
  if (HAL_XSPIM_Config(&hxspi1, &sXspiManagerCfg, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34000d80:	1d3b      	adds	r3, r7, #4
34000d82:	f241 3288 	movw	r2, #5000	@ 0x1388
34000d86:	4619      	mov	r1, r3
34000d88:	4805      	ldr	r0, [pc, #20]	@ (34000da0 <MX_XSPI1_Init+0xac>)
34000d8a:	f00b fb7d 	bl	3400c488 <HAL_XSPIM_Config>
34000d8e:	4603      	mov	r3, r0
34000d90:	2b00      	cmp	r3, #0
34000d92:	d001      	beq.n	34000d98 <MX_XSPI1_Init+0xa4>
  {
    Error_Handler();
34000d94:	f000 f875 	bl	34000e82 <Error_Handler>
  }
  /* USER CODE BEGIN XSPI1_Init 2 */

  /* USER CODE END XSPI1_Init 2 */

}
34000d98:	bf00      	nop
34000d9a:	3710      	adds	r7, #16
34000d9c:	46bd      	mov	sp, r7
34000d9e:	bd80      	pop	{r7, pc}
34000da0:	340800cc 	.word	0x340800cc
34000da4:	58025000 	.word	0x58025000

34000da8 <MX_XSPI2_Init>:
  * @brief XSPI2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_XSPI2_Init(void)
{
34000da8:	b580      	push	{r7, lr}
34000daa:	b084      	sub	sp, #16
34000dac:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN XSPI2_Init 0 */

  /* USER CODE END XSPI2_Init 0 */

  XSPIM_CfgTypeDef sXspiManagerCfg = {0};
34000dae:	1d3b      	adds	r3, r7, #4
34000db0:	2200      	movs	r2, #0
34000db2:	601a      	str	r2, [r3, #0]
34000db4:	605a      	str	r2, [r3, #4]
34000db6:	609a      	str	r2, [r3, #8]

  /* USER CODE BEGIN XSPI2_Init 1 */

  /* USER CODE END XSPI2_Init 1 */
  /* XSPI2 parameter configuration*/
  hxspi2.Instance = XSPI2;
34000db8:	4b26      	ldr	r3, [pc, #152]	@ (34000e54 <MX_XSPI2_Init+0xac>)
34000dba:	4a27      	ldr	r2, [pc, #156]	@ (34000e58 <MX_XSPI2_Init+0xb0>)
34000dbc:	601a      	str	r2, [r3, #0]
  hxspi2.Init.FifoThresholdByte = 1;
34000dbe:	4b25      	ldr	r3, [pc, #148]	@ (34000e54 <MX_XSPI2_Init+0xac>)
34000dc0:	2201      	movs	r2, #1
34000dc2:	605a      	str	r2, [r3, #4]
  hxspi2.Init.MemoryMode = HAL_XSPI_SINGLE_MEM;
34000dc4:	4b23      	ldr	r3, [pc, #140]	@ (34000e54 <MX_XSPI2_Init+0xac>)
34000dc6:	2200      	movs	r2, #0
34000dc8:	609a      	str	r2, [r3, #8]
  hxspi2.Init.MemoryType = HAL_XSPI_MEMTYPE_MICRON;
34000dca:	4b22      	ldr	r3, [pc, #136]	@ (34000e54 <MX_XSPI2_Init+0xac>)
34000dcc:	2200      	movs	r2, #0
34000dce:	60da      	str	r2, [r3, #12]
  hxspi2.Init.MemorySize = HAL_XSPI_SIZE_16B;
34000dd0:	4b20      	ldr	r3, [pc, #128]	@ (34000e54 <MX_XSPI2_Init+0xac>)
34000dd2:	2200      	movs	r2, #0
34000dd4:	611a      	str	r2, [r3, #16]
  hxspi2.Init.ChipSelectHighTimeCycle = 1;
34000dd6:	4b1f      	ldr	r3, [pc, #124]	@ (34000e54 <MX_XSPI2_Init+0xac>)
34000dd8:	2201      	movs	r2, #1
34000dda:	615a      	str	r2, [r3, #20]
  hxspi2.Init.FreeRunningClock = HAL_XSPI_FREERUNCLK_DISABLE;
34000ddc:	4b1d      	ldr	r3, [pc, #116]	@ (34000e54 <MX_XSPI2_Init+0xac>)
34000dde:	2200      	movs	r2, #0
34000de0:	619a      	str	r2, [r3, #24]
  hxspi2.Init.ClockMode = HAL_XSPI_CLOCK_MODE_0;
34000de2:	4b1c      	ldr	r3, [pc, #112]	@ (34000e54 <MX_XSPI2_Init+0xac>)
34000de4:	2200      	movs	r2, #0
34000de6:	61da      	str	r2, [r3, #28]
  hxspi2.Init.WrapSize = HAL_XSPI_WRAP_NOT_SUPPORTED;
34000de8:	4b1a      	ldr	r3, [pc, #104]	@ (34000e54 <MX_XSPI2_Init+0xac>)
34000dea:	2200      	movs	r2, #0
34000dec:	621a      	str	r2, [r3, #32]
  hxspi2.Init.ClockPrescaler = 0;
34000dee:	4b19      	ldr	r3, [pc, #100]	@ (34000e54 <MX_XSPI2_Init+0xac>)
34000df0:	2200      	movs	r2, #0
34000df2:	625a      	str	r2, [r3, #36]	@ 0x24
  hxspi2.Init.SampleShifting = HAL_XSPI_SAMPLE_SHIFT_NONE;
34000df4:	4b17      	ldr	r3, [pc, #92]	@ (34000e54 <MX_XSPI2_Init+0xac>)
34000df6:	2200      	movs	r2, #0
34000df8:	629a      	str	r2, [r3, #40]	@ 0x28
  hxspi2.Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_DISABLE;
34000dfa:	4b16      	ldr	r3, [pc, #88]	@ (34000e54 <MX_XSPI2_Init+0xac>)
34000dfc:	2200      	movs	r2, #0
34000dfe:	62da      	str	r2, [r3, #44]	@ 0x2c
  hxspi2.Init.ChipSelectBoundary = HAL_XSPI_BONDARYOF_NONE;
34000e00:	4b14      	ldr	r3, [pc, #80]	@ (34000e54 <MX_XSPI2_Init+0xac>)
34000e02:	2200      	movs	r2, #0
34000e04:	631a      	str	r2, [r3, #48]	@ 0x30
  hxspi2.Init.MaxTran = 0;
34000e06:	4b13      	ldr	r3, [pc, #76]	@ (34000e54 <MX_XSPI2_Init+0xac>)
34000e08:	2200      	movs	r2, #0
34000e0a:	635a      	str	r2, [r3, #52]	@ 0x34
  hxspi2.Init.Refresh = 0;
34000e0c:	4b11      	ldr	r3, [pc, #68]	@ (34000e54 <MX_XSPI2_Init+0xac>)
34000e0e:	2200      	movs	r2, #0
34000e10:	639a      	str	r2, [r3, #56]	@ 0x38
  hxspi2.Init.MemorySelect = HAL_XSPI_CSSEL_NCS1;
34000e12:	4b10      	ldr	r3, [pc, #64]	@ (34000e54 <MX_XSPI2_Init+0xac>)
34000e14:	2200      	movs	r2, #0
34000e16:	63da      	str	r2, [r3, #60]	@ 0x3c
  if (HAL_XSPI_Init(&hxspi2) != HAL_OK)
34000e18:	480e      	ldr	r0, [pc, #56]	@ (34000e54 <MX_XSPI2_Init+0xac>)
34000e1a:	f00b fa15 	bl	3400c248 <HAL_XSPI_Init>
34000e1e:	4603      	mov	r3, r0
34000e20:	2b00      	cmp	r3, #0
34000e22:	d001      	beq.n	34000e28 <MX_XSPI2_Init+0x80>
  {
    Error_Handler();
34000e24:	f000 f82d 	bl	34000e82 <Error_Handler>
  }
  sXspiManagerCfg.nCSOverride = HAL_XSPI_CSSEL_OVR_NCS1;
34000e28:	2310      	movs	r3, #16
34000e2a:	607b      	str	r3, [r7, #4]
  sXspiManagerCfg.IOPort = HAL_XSPIM_IOPORT_2;
34000e2c:	2301      	movs	r3, #1
34000e2e:	60bb      	str	r3, [r7, #8]
  sXspiManagerCfg.Req2AckTime = 1;
34000e30:	2301      	movs	r3, #1
34000e32:	60fb      	str	r3, [r7, #12]
  if (HAL_XSPIM_Config(&hxspi2, &sXspiManagerCfg, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34000e34:	1d3b      	adds	r3, r7, #4
34000e36:	f241 3288 	movw	r2, #5000	@ 0x1388
34000e3a:	4619      	mov	r1, r3
34000e3c:	4805      	ldr	r0, [pc, #20]	@ (34000e54 <MX_XSPI2_Init+0xac>)
34000e3e:	f00b fb23 	bl	3400c488 <HAL_XSPIM_Config>
34000e42:	4603      	mov	r3, r0
34000e44:	2b00      	cmp	r3, #0
34000e46:	d001      	beq.n	34000e4c <MX_XSPI2_Init+0xa4>
  {
    Error_Handler();
34000e48:	f000 f81b 	bl	34000e82 <Error_Handler>
  }
  /* USER CODE BEGIN XSPI2_Init 2 */

  /* USER CODE END XSPI2_Init 2 */

}
34000e4c:	bf00      	nop
34000e4e:	3710      	adds	r7, #16
34000e50:	46bd      	mov	sp, r7
34000e52:	bd80      	pop	{r7, pc}
34000e54:	34080130 	.word	0x34080130
34000e58:	5802a000 	.word	0x5802a000

34000e5c <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
34000e5c:	b580      	push	{r7, lr}
34000e5e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
34000e60:	2010      	movs	r0, #16
34000e62:	f7ff fe51 	bl	34000b08 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOP_CLK_ENABLE();
34000e66:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
34000e6a:	f7ff fe4d 	bl	34000b08 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOO_CLK_ENABLE();
34000e6e:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
34000e72:	f7ff fe49 	bl	34000b08 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPION_CLK_ENABLE();
34000e76:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34000e7a:	f7ff fe45 	bl	34000b08 <LL_AHB4_GRP1_EnableClock>

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}
34000e7e:	bf00      	nop
34000e80:	bd80      	pop	{r7, pc}

34000e82 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
34000e82:	b480      	push	{r7}
34000e84:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
34000e86:	b672      	cpsid	i
}
34000e88:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
34000e8a:	bf00      	nop
34000e8c:	e7fd      	b.n	34000e8a <Error_Handler+0x8>
	...

34000e90 <__acle_se_SECURE_RegisterCallback>:
  * @param  CallbackId  callback identifier
  * @param  func        pointer to non-secure function
  * @retval None
  */
  CMSE_NS_ENTRY void SECURE_RegisterCallback(SECURE_CallbackIDTypeDef CallbackId, void *func)
  {
34000e90:	b2c0      	uxtb	r0, r0
34000e92:	ed6d cf81 	vstr	FPCXTNS, [sp, #-4]!
34000e96:	b480      	push	{r7}
34000e98:	b082      	sub	sp, #8
34000e9a:	af00      	add	r7, sp, #0
34000e9c:	4603      	mov	r3, r0
34000e9e:	6039      	str	r1, [r7, #0]
34000ea0:	71fb      	strb	r3, [r7, #7]
      if(func != NULL)
34000ea2:	683b      	ldr	r3, [r7, #0]
34000ea4:	2b00      	cmp	r3, #0
34000ea6:	d00d      	beq.n	34000ec4 <__acle_se_SECURE_RegisterCallback+0x34>
      {
        switch(CallbackId)
34000ea8:	79fb      	ldrb	r3, [r7, #7]
34000eaa:	2b00      	cmp	r3, #0
34000eac:	d002      	beq.n	34000eb4 <__acle_se_SECURE_RegisterCallback+0x24>
34000eae:	2b01      	cmp	r3, #1
34000eb0:	d004      	beq.n	34000ebc <__acle_se_SECURE_RegisterCallback+0x2c>
          case IAC_ERROR_CB_ID:             /* Illegal Access Interrupt occurred */
          pSecureErrorCallback = func;
          break;
          default:
          /* unknown */
          break;
34000eb2:	e007      	b.n	34000ec4 <__acle_se_SECURE_RegisterCallback+0x34>
          pSecureFaultCallback = func;
34000eb4:	4a09      	ldr	r2, [pc, #36]	@ (34000edc <__acle_se_SECURE_RegisterCallback+0x4c>)
34000eb6:	683b      	ldr	r3, [r7, #0]
34000eb8:	6013      	str	r3, [r2, #0]
          break;
34000eba:	e003      	b.n	34000ec4 <__acle_se_SECURE_RegisterCallback+0x34>
          pSecureErrorCallback = func;
34000ebc:	4a08      	ldr	r2, [pc, #32]	@ (34000ee0 <__acle_se_SECURE_RegisterCallback+0x50>)
34000ebe:	683b      	ldr	r3, [r7, #0]
34000ec0:	6013      	str	r3, [r2, #0]
          break;
34000ec2:	bf00      	nop
        }
      }
  }
34000ec4:	bf00      	nop
34000ec6:	3708      	adds	r7, #8
34000ec8:	46bd      	mov	sp, r7
34000eca:	f85d 7b04 	ldr.w	r7, [sp], #4
34000ece:	ec9f 0a10 	vscclrm	{s0-s15, VPR}
34000ed2:	e89f 900f 	clrm	{r0, r1, r2, r3, ip, APSR}
34000ed6:	ecfd cf81 	vldr	FPCXTNS, [sp], #4
34000eda:	4774      	bxns	lr
34000edc:	34080194 	.word	0x34080194
34000ee0:	34080198 	.word	0x34080198

34000ee4 <LL_AHB4_GRP1_EnableClock>:
{
34000ee4:	b480      	push	{r7}
34000ee6:	b085      	sub	sp, #20
34000ee8:	af00      	add	r7, sp, #0
34000eea:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34000eec:	4a07      	ldr	r2, [pc, #28]	@ (34000f0c <LL_AHB4_GRP1_EnableClock+0x28>)
34000eee:	687b      	ldr	r3, [r7, #4]
34000ef0:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34000ef4:	4b05      	ldr	r3, [pc, #20]	@ (34000f0c <LL_AHB4_GRP1_EnableClock+0x28>)
34000ef6:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
34000efa:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34000efc:	68fb      	ldr	r3, [r7, #12]
}
34000efe:	bf00      	nop
34000f00:	3714      	adds	r7, #20
34000f02:	46bd      	mov	sp, r7
34000f04:	f85d 7b04 	ldr.w	r7, [sp], #4
34000f08:	4770      	bx	lr
34000f0a:	bf00      	nop
34000f0c:	56028000 	.word	0x56028000

34000f10 <LL_AHB5_GRP1_EnableClock>:
  *
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE void LL_AHB5_GRP1_EnableClock(uint32_t Periphs)
{
34000f10:	b480      	push	{r7}
34000f12:	b085      	sub	sp, #20
34000f14:	af00      	add	r7, sp, #0
34000f16:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34000f18:	4a07      	ldr	r2, [pc, #28]	@ (34000f38 <LL_AHB5_GRP1_EnableClock+0x28>)
34000f1a:	687b      	ldr	r3, [r7, #4]
34000f1c:	f8c2 3a60 	str.w	r3, [r2, #2656]	@ 0xa60
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB5ENR);
34000f20:	4b05      	ldr	r3, [pc, #20]	@ (34000f38 <LL_AHB5_GRP1_EnableClock+0x28>)
34000f22:	f8d3 3260 	ldr.w	r3, [r3, #608]	@ 0x260
34000f26:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34000f28:	68fb      	ldr	r3, [r7, #12]
}
34000f2a:	bf00      	nop
34000f2c:	3714      	adds	r7, #20
34000f2e:	46bd      	mov	sp, r7
34000f30:	f85d 7b04 	ldr.w	r7, [sp], #4
34000f34:	4770      	bx	lr
34000f36:	bf00      	nop
34000f38:	56028000 	.word	0x56028000

34000f3c <LL_APB2_GRP1_EnableClock>:
  *         @arg @ref LL_APB2_GRP1_PERIPH_UART9
  *         @arg @ref LL_APB2_GRP1_PERIPH_USART10
  * @retval None
  */
__STATIC_INLINE void LL_APB2_GRP1_EnableClock(uint32_t Periphs)
{
34000f3c:	b480      	push	{r7}
34000f3e:	b085      	sub	sp, #20
34000f40:	af00      	add	r7, sp, #0
34000f42:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->APB2ENSR, Periphs);
34000f44:	4a07      	ldr	r2, [pc, #28]	@ (34000f64 <LL_APB2_GRP1_EnableClock+0x28>)
34000f46:	687b      	ldr	r3, [r7, #4]
34000f48:	f8c2 3a6c 	str.w	r3, [r2, #2668]	@ 0xa6c
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->APB2ENR);
34000f4c:	4b05      	ldr	r3, [pc, #20]	@ (34000f64 <LL_APB2_GRP1_EnableClock+0x28>)
34000f4e:	f8d3 326c 	ldr.w	r3, [r3, #620]	@ 0x26c
34000f52:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34000f54:	68fb      	ldr	r3, [r7, #12]
}
34000f56:	bf00      	nop
34000f58:	3714      	adds	r7, #20
34000f5a:	46bd      	mov	sp, r7
34000f5c:	f85d 7b04 	ldr.w	r7, [sp], #4
34000f60:	4770      	bx	lr
34000f62:	bf00      	nop
34000f64:	56028000 	.word	0x56028000

34000f68 <LL_APB5_GRP1_EnableClock>:
  *         @arg @ref LL_APB5_GRP1_PERIPH_LTDC
  *         @arg @ref LL_APB5_GRP1_PERIPH_VENC
  * @retval None
  */
__STATIC_INLINE void LL_APB5_GRP1_EnableClock(uint32_t Periphs)
{
34000f68:	b480      	push	{r7}
34000f6a:	b085      	sub	sp, #20
34000f6c:	af00      	add	r7, sp, #0
34000f6e:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->APB5ENSR, Periphs);
34000f70:	4a07      	ldr	r2, [pc, #28]	@ (34000f90 <LL_APB5_GRP1_EnableClock+0x28>)
34000f72:	687b      	ldr	r3, [r7, #4]
34000f74:	f8c2 3a7c 	str.w	r3, [r2, #2684]	@ 0xa7c
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->APB5ENR);
34000f78:	4b05      	ldr	r3, [pc, #20]	@ (34000f90 <LL_APB5_GRP1_EnableClock+0x28>)
34000f7a:	f8d3 327c 	ldr.w	r3, [r3, #636]	@ 0x27c
34000f7e:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34000f80:	68fb      	ldr	r3, [r7, #12]
}
34000f82:	bf00      	nop
34000f84:	3714      	adds	r7, #20
34000f86:	46bd      	mov	sp, r7
34000f88:	f85d 7b04 	ldr.w	r7, [sp], #4
34000f8c:	4770      	bx	lr
34000f8e:	bf00      	nop
34000f90:	56028000 	.word	0x56028000

34000f94 <LL_APB5_GRP1_ForceReset>:
  *         @arg @ref LL_APB5_GRP1_PERIPH_LTDC
  *         @arg @ref LL_APB5_GRP1_PERIPH_VENC
  * @retval None
  */
__STATIC_INLINE void LL_APB5_GRP1_ForceReset(uint32_t Periphs)
{
34000f94:	b480      	push	{r7}
34000f96:	b083      	sub	sp, #12
34000f98:	af00      	add	r7, sp, #0
34000f9a:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB5RSTSR, Periphs);
34000f9c:	4a04      	ldr	r2, [pc, #16]	@ (34000fb0 <LL_APB5_GRP1_ForceReset+0x1c>)
34000f9e:	687b      	ldr	r3, [r7, #4]
34000fa0:	f8c2 3a3c 	str.w	r3, [r2, #2620]	@ 0xa3c
}
34000fa4:	bf00      	nop
34000fa6:	370c      	adds	r7, #12
34000fa8:	46bd      	mov	sp, r7
34000faa:	f85d 7b04 	ldr.w	r7, [sp], #4
34000fae:	4770      	bx	lr
34000fb0:	56028000 	.word	0x56028000

34000fb4 <LL_APB5_GRP1_ReleaseReset>:
  *         @arg @ref LL_APB5_GRP1_PERIPH_LTDC
  *         @arg @ref LL_APB5_GRP1_PERIPH_VENC
  * @retval None
  */
__STATIC_INLINE void LL_APB5_GRP1_ReleaseReset(uint32_t Periphs)
{
34000fb4:	b480      	push	{r7}
34000fb6:	b083      	sub	sp, #12
34000fb8:	af00      	add	r7, sp, #0
34000fba:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB5RSTCR, Periphs);
34000fbc:	4b06      	ldr	r3, [pc, #24]	@ (34000fd8 <LL_APB5_GRP1_ReleaseReset+0x24>)
34000fbe:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34000fc2:	461a      	mov	r2, r3
34000fc4:	687b      	ldr	r3, [r7, #4]
34000fc6:	f8c2 323c 	str.w	r3, [r2, #572]	@ 0x23c
}
34000fca:	bf00      	nop
34000fcc:	370c      	adds	r7, #12
34000fce:	46bd      	mov	sp, r7
34000fd0:	f85d 7b04 	ldr.w	r7, [sp], #4
34000fd4:	4770      	bx	lr
34000fd6:	bf00      	nop
34000fd8:	56028000 	.word	0x56028000

34000fdc <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
34000fdc:	b580      	push	{r7, lr}
34000fde:	af00      	add	r7, sp, #0

  /* USER CODE END MspInit 0 */

  /* System interrupt init*/

  HAL_PWREx_EnableVddIO2();
34000fe0:	f002 fac8 	bl	34003574 <HAL_PWREx_EnableVddIO2>

  HAL_PWREx_EnableVddIO3();
34000fe4:	f002 fad6 	bl	34003594 <HAL_PWREx_EnableVddIO3>

  HAL_PWREx_EnableVddIO4();
34000fe8:	f002 fae4 	bl	340035b4 <HAL_PWREx_EnableVddIO4>

  HAL_PWREx_EnableVddIO5();
34000fec:	f002 faf2 	bl	340035d4 <HAL_PWREx_EnableVddIO5>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
34000ff0:	bf00      	nop
34000ff2:	bd80      	pop	{r7, pc}

34000ff4 <HAL_DCMIPP_MspInit>:
  * This function configures the hardware resources used in this example
  * @param hdcmipp: DCMIPP handle pointer
  * @retval None
  */
void HAL_DCMIPP_MspInit(DCMIPP_HandleTypeDef* hdcmipp)
{
34000ff4:	b580      	push	{r7, lr}
34000ff6:	b0e6      	sub	sp, #408	@ 0x198
34000ff8:	af00      	add	r7, sp, #0
34000ffa:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34000ffe:	f5a3 73ca 	sub.w	r3, r3, #404	@ 0x194
34001002:	6018      	str	r0, [r3, #0]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
34001004:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34001008:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
3400100c:	4618      	mov	r0, r3
3400100e:	f44f 73c8 	mov.w	r3, #400	@ 0x190
34001012:	461a      	mov	r2, r3
34001014:	2100      	movs	r1, #0
34001016:	f00b fbfd 	bl	3400c814 <memset>
  if(hdcmipp->Instance==DCMIPP)
3400101a:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
3400101e:	f5a3 73ca 	sub.w	r3, r3, #404	@ 0x194
34001022:	681b      	ldr	r3, [r3, #0]
34001024:	681b      	ldr	r3, [r3, #0]
34001026:	4a27      	ldr	r2, [pc, #156]	@ (340010c4 <HAL_DCMIPP_MspInit+0xd0>)
34001028:	4293      	cmp	r3, r2
3400102a:	d145      	bne.n	340010b8 <HAL_DCMIPP_MspInit+0xc4>

    /* USER CODE END DCMIPP_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_DCMIPP|RCC_PERIPHCLK_CSI;
3400102c:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34001030:	f5a3 71c8 	sub.w	r1, r3, #400	@ 0x190
34001034:	f04f 0218 	mov.w	r2, #24
34001038:	f04f 0300 	mov.w	r3, #0
3400103c:	e9c1 2300 	strd	r2, r3, [r1]
    PeriphClkInitStruct.DcmippClockSelection = RCC_DCMIPPCLKSOURCE_PCLK5;
34001040:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34001044:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
34001048:	2200      	movs	r2, #0
3400104a:	f8c3 20c8 	str.w	r2, [r3, #200]	@ 0xc8
    PeriphClkInitStruct.ICSelection[RCC_IC18].ClockSelection = RCC_ICCLKSOURCE_PLL4;
3400104e:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34001052:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
34001056:	f04f 5240 	mov.w	r2, #805306368	@ 0x30000000
3400105a:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
    PeriphClkInitStruct.ICSelection[RCC_IC18].ClockDivider = 1;
3400105e:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34001062:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
34001066:	2201      	movs	r2, #1
34001068:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
3400106c:	f107 0308 	add.w	r3, r7, #8
34001070:	4618      	mov	r0, r3
34001072:	f003 fec7 	bl	34004e04 <HAL_RCCEx_PeriphCLKConfig>
34001076:	4603      	mov	r3, r0
34001078:	2b00      	cmp	r3, #0
3400107a:	d001      	beq.n	34001080 <HAL_DCMIPP_MspInit+0x8c>
    {
      Error_Handler();
3400107c:	f7ff ff01 	bl	34000e82 <Error_Handler>
    }

    /* Peripheral clock enable */
    __HAL_RCC_DCMIPP_CLK_ENABLE();
34001080:	2004      	movs	r0, #4
34001082:	f7ff ff71 	bl	34000f68 <LL_APB5_GRP1_EnableClock>
    __HAL_RCC_CSI_CLK_ENABLE();
34001086:	2040      	movs	r0, #64	@ 0x40
34001088:	f7ff ff6e 	bl	34000f68 <LL_APB5_GRP1_EnableClock>
    __HAL_RCC_CSI_FORCE_RESET();
3400108c:	2040      	movs	r0, #64	@ 0x40
3400108e:	f7ff ff81 	bl	34000f94 <LL_APB5_GRP1_ForceReset>
    __HAL_RCC_CSI_RELEASE_RESET();
34001092:	2040      	movs	r0, #64	@ 0x40
34001094:	f7ff ff8e 	bl	34000fb4 <LL_APB5_GRP1_ReleaseReset>
    /* DCMIPP interrupt Init */
    HAL_NVIC_SetPriority(DCMIPP_IRQn, 0, 0);
34001098:	2200      	movs	r2, #0
3400109a:	2100      	movs	r1, #0
3400109c:	2030      	movs	r0, #48	@ 0x30
3400109e:	f000 fd72 	bl	34001b86 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(DCMIPP_IRQn);
340010a2:	2030      	movs	r0, #48	@ 0x30
340010a4:	f000 fd8c 	bl	34001bc0 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(CSI_IRQn, 0, 0);
340010a8:	2200      	movs	r2, #0
340010aa:	2100      	movs	r1, #0
340010ac:	202f      	movs	r0, #47	@ 0x2f
340010ae:	f000 fd6a 	bl	34001b86 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(CSI_IRQn);
340010b2:	202f      	movs	r0, #47	@ 0x2f
340010b4:	f000 fd84 	bl	34001bc0 <HAL_NVIC_EnableIRQ>

    /* USER CODE END DCMIPP_MspInit 1 */

  }

}
340010b8:	bf00      	nop
340010ba:	f507 77cc 	add.w	r7, r7, #408	@ 0x198
340010be:	46bd      	mov	sp, r7
340010c0:	bd80      	pop	{r7, pc}
340010c2:	bf00      	nop
340010c4:	58002000 	.word	0x58002000

340010c8 <HAL_UART_MspInit>:
  * This function configures the hardware resources used in this example
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
340010c8:	b580      	push	{r7, lr}
340010ca:	b0ec      	sub	sp, #432	@ 0x1b0
340010cc:	af00      	add	r7, sp, #0
340010ce:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
340010d2:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
340010d6:	6018      	str	r0, [r3, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
340010d8:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
340010dc:	2200      	movs	r2, #0
340010de:	601a      	str	r2, [r3, #0]
340010e0:	605a      	str	r2, [r3, #4]
340010e2:	609a      	str	r2, [r3, #8]
340010e4:	60da      	str	r2, [r3, #12]
340010e6:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
340010e8:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
340010ec:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
340010f0:	4618      	mov	r0, r3
340010f2:	f44f 73c8 	mov.w	r3, #400	@ 0x190
340010f6:	461a      	mov	r2, r3
340010f8:	2100      	movs	r1, #0
340010fa:	f00b fb8b 	bl	3400c814 <memset>
  if(huart->Instance==USART1)
340010fe:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34001102:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
34001106:	681b      	ldr	r3, [r3, #0]
34001108:	681b      	ldr	r3, [r3, #0]
3400110a:	4a1f      	ldr	r2, [pc, #124]	@ (34001188 <HAL_UART_MspInit+0xc0>)
3400110c:	4293      	cmp	r3, r2
3400110e:	d135      	bne.n	3400117c <HAL_UART_MspInit+0xb4>

    /* USER CODE END USART1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART1;
34001110:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34001114:	f5a3 71d4 	sub.w	r1, r3, #424	@ 0x1a8
34001118:	f04f 0200 	mov.w	r2, #0
3400111c:	f44f 7380 	mov.w	r3, #256	@ 0x100
34001120:	e9c1 2300 	strd	r2, r3, [r1]
    PeriphClkInitStruct.Usart1ClockSelection = RCC_USART1CLKSOURCE_CLKP;
34001124:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34001128:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
3400112c:	4a17      	ldr	r2, [pc, #92]	@ (3400118c <HAL_UART_MspInit+0xc4>)
3400112e:	f8c3 2150 	str.w	r2, [r3, #336]	@ 0x150
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
34001132:	f107 0308 	add.w	r3, r7, #8
34001136:	4618      	mov	r0, r3
34001138:	f003 fe64 	bl	34004e04 <HAL_RCCEx_PeriphCLKConfig>
3400113c:	4603      	mov	r3, r0
3400113e:	2b00      	cmp	r3, #0
34001140:	d001      	beq.n	34001146 <HAL_UART_MspInit+0x7e>
    {
      Error_Handler();
34001142:	f7ff fe9e 	bl	34000e82 <Error_Handler>
    }

    /* Peripheral clock enable */
    __HAL_RCC_USART1_CLK_ENABLE();
34001146:	2010      	movs	r0, #16
34001148:	f7ff fef8 	bl	34000f3c <LL_APB2_GRP1_EnableClock>

    __HAL_RCC_GPIOE_CLK_ENABLE();
3400114c:	2010      	movs	r0, #16
3400114e:	f7ff fec9 	bl	34000ee4 <LL_AHB4_GRP1_EnableClock>
    /**USART1 GPIO Configuration
    PE5     ------> USART1_TX
    PE6     ------> USART1_RX
    */
    GPIO_InitStruct.Pin = VCP_TX_Pin|VCP_RX_Pin;
34001152:	2360      	movs	r3, #96	@ 0x60
34001154:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
34001158:	2302      	movs	r3, #2
3400115a:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
3400115e:	2300      	movs	r3, #0
34001160:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
34001164:	2300      	movs	r3, #0
34001166:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
3400116a:	2307      	movs	r3, #7
3400116c:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
34001170:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34001174:	4619      	mov	r1, r3
34001176:	4806      	ldr	r0, [pc, #24]	@ (34001190 <HAL_UART_MspInit+0xc8>)
34001178:	f002 f84a 	bl	34003210 <HAL_GPIO_Init>

    /* USER CODE END USART1_MspInit 1 */

  }

}
3400117c:	bf00      	nop
3400117e:	f507 77d8 	add.w	r7, r7, #432	@ 0x1b0
34001182:	46bd      	mov	sp, r7
34001184:	bd80      	pop	{r7, pc}
34001186:	bf00      	nop
34001188:	52001000 	.word	0x52001000
3400118c:	07010030 	.word	0x07010030
34001190:	56021000 	.word	0x56021000

34001194 <HAL_XSPI_MspInit>:
  * This function configures the hardware resources used in this example
  * @param hxspi: XSPI handle pointer
  * @retval None
  */
void HAL_XSPI_MspInit(XSPI_HandleTypeDef* hxspi)
{
34001194:	b580      	push	{r7, lr}
34001196:	b0ec      	sub	sp, #432	@ 0x1b0
34001198:	af00      	add	r7, sp, #0
3400119a:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
3400119e:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
340011a2:	6018      	str	r0, [r3, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
340011a4:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
340011a8:	2200      	movs	r2, #0
340011aa:	601a      	str	r2, [r3, #0]
340011ac:	605a      	str	r2, [r3, #4]
340011ae:	609a      	str	r2, [r3, #8]
340011b0:	60da      	str	r2, [r3, #12]
340011b2:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
340011b4:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
340011b8:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
340011bc:	4618      	mov	r0, r3
340011be:	f44f 73c8 	mov.w	r3, #400	@ 0x190
340011c2:	461a      	mov	r2, r3
340011c4:	2100      	movs	r1, #0
340011c6:	f00b fb25 	bl	3400c814 <memset>
  if(hxspi->Instance==XSPI1)
340011ca:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
340011ce:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
340011d2:	681b      	ldr	r3, [r3, #0]
340011d4:	681b      	ldr	r3, [r3, #0]
340011d6:	4a5b      	ldr	r2, [pc, #364]	@ (34001344 <HAL_XSPI_MspInit+0x1b0>)
340011d8:	4293      	cmp	r3, r2
340011da:	d15e      	bne.n	3400129a <HAL_XSPI_MspInit+0x106>

    /* USER CODE END XSPI1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_XSPI1;
340011dc:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
340011e0:	f5a3 71d4 	sub.w	r1, r3, #424	@ 0x1a8
340011e4:	f04f 0200 	mov.w	r2, #0
340011e8:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
340011ec:	e9c1 2300 	strd	r2, r3, [r1]
    PeriphClkInitStruct.Xspi1ClockSelection = RCC_XSPI1CLKSOURCE_HCLK;
340011f0:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
340011f4:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
340011f8:	4a53      	ldr	r2, [pc, #332]	@ (34001348 <HAL_XSPI_MspInit+0x1b4>)
340011fa:	f8c3 20ac 	str.w	r2, [r3, #172]	@ 0xac
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
340011fe:	f107 0308 	add.w	r3, r7, #8
34001202:	4618      	mov	r0, r3
34001204:	f003 fdfe 	bl	34004e04 <HAL_RCCEx_PeriphCLKConfig>
34001208:	4603      	mov	r3, r0
3400120a:	2b00      	cmp	r3, #0
3400120c:	d001      	beq.n	34001212 <HAL_XSPI_MspInit+0x7e>
    {
      Error_Handler();
3400120e:	f7ff fe38 	bl	34000e82 <Error_Handler>
    }

    /* Peripheral clock enable */
    HAL_RCC_XSPIM_CLK_ENABLED++;
34001212:	4b4e      	ldr	r3, [pc, #312]	@ (3400134c <HAL_XSPI_MspInit+0x1b8>)
34001214:	681b      	ldr	r3, [r3, #0]
34001216:	3301      	adds	r3, #1
34001218:	4a4c      	ldr	r2, [pc, #304]	@ (3400134c <HAL_XSPI_MspInit+0x1b8>)
3400121a:	6013      	str	r3, [r2, #0]
    if(HAL_RCC_XSPIM_CLK_ENABLED==1){
3400121c:	4b4b      	ldr	r3, [pc, #300]	@ (3400134c <HAL_XSPI_MspInit+0x1b8>)
3400121e:	681b      	ldr	r3, [r3, #0]
34001220:	2b01      	cmp	r3, #1
34001222:	d103      	bne.n	3400122c <HAL_XSPI_MspInit+0x98>
      __HAL_RCC_XSPIM_CLK_ENABLE();
34001224:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34001228:	f7ff fe72 	bl	34000f10 <LL_AHB5_GRP1_EnableClock>
    }
    __HAL_RCC_XSPI1_CLK_ENABLE();
3400122c:	2020      	movs	r0, #32
3400122e:	f7ff fe6f 	bl	34000f10 <LL_AHB5_GRP1_EnableClock>

    __HAL_RCC_GPIOP_CLK_ENABLE();
34001232:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
34001236:	f7ff fe55 	bl	34000ee4 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOO_CLK_ENABLE();
3400123a:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
3400123e:	f7ff fe51 	bl	34000ee4 <LL_AHB4_GRP1_EnableClock>
    PO0     ------> XSPIM_P1_NCS1
    PP9     ------> XSPIM_P1_IO9
    PP10     ------> XSPIM_P1_IO10
    PO4     ------> XSPIM_P1_CLK
    */
    GPIO_InitStruct.Pin = HEXASPI_IO_7_Pin|HEXASPI_IO_6_Pin|HEXASPI_IO_0_Pin|HEXASPI_IO_4_Pin
34001242:	f64f 73ff 	movw	r3, #65535	@ 0xffff
34001246:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
                          |HEXASPI_IO_1_Pin|HEXASPI_IO_15_Pin|HEXASPI_IO_5_Pin|HEXASPI_IO_12_Pin
                          |HEXASPI_IO_3_Pin|HEXASPI_IO_2_Pin|HEXASPI_IO_13_Pin|HEXASPI_IO_11_Pin
                          |HEXASPI_IO_8_Pin|HEXASPI_IO_14_Pin|HEXASPI_IO_9_Pin|HEXASPI_IO_10_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
3400124a:	2302      	movs	r3, #2
3400124c:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
34001250:	2300      	movs	r3, #0
34001252:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34001256:	2303      	movs	r3, #3
34001258:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF9_XSPIM_P1;
3400125c:	2309      	movs	r3, #9
3400125e:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOP, &GPIO_InitStruct);
34001262:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34001266:	4619      	mov	r1, r3
34001268:	4839      	ldr	r0, [pc, #228]	@ (34001350 <HAL_XSPI_MspInit+0x1bc>)
3400126a:	f001 ffd1 	bl	34003210 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = HEXASPI_DQS0_Pin|HEXASPI_DQS1_Pin|HEXASPI_NCS_Pin|HEXASPI_CLK_Pin;
3400126e:	231d      	movs	r3, #29
34001270:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
34001274:	2302      	movs	r3, #2
34001276:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
3400127a:	2300      	movs	r3, #0
3400127c:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34001280:	2303      	movs	r3, #3
34001282:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF9_XSPIM_P1;
34001286:	2309      	movs	r3, #9
34001288:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOO, &GPIO_InitStruct);
3400128c:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34001290:	4619      	mov	r1, r3
34001292:	4830      	ldr	r0, [pc, #192]	@ (34001354 <HAL_XSPI_MspInit+0x1c0>)
34001294:	f001 ffbc 	bl	34003210 <HAL_GPIO_Init>
    /* USER CODE BEGIN XSPI2_MspInit 1 */

    /* USER CODE END XSPI2_MspInit 1 */
  }

}
34001298:	e04e      	b.n	34001338 <HAL_XSPI_MspInit+0x1a4>
  else if(hxspi->Instance==XSPI2)
3400129a:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
3400129e:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
340012a2:	681b      	ldr	r3, [r3, #0]
340012a4:	681b      	ldr	r3, [r3, #0]
340012a6:	4a2c      	ldr	r2, [pc, #176]	@ (34001358 <HAL_XSPI_MspInit+0x1c4>)
340012a8:	4293      	cmp	r3, r2
340012aa:	d145      	bne.n	34001338 <HAL_XSPI_MspInit+0x1a4>
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_XSPI2;
340012ac:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
340012b0:	f5a3 71d4 	sub.w	r1, r3, #424	@ 0x1a8
340012b4:	f04f 0200 	mov.w	r2, #0
340012b8:	f44f 0300 	mov.w	r3, #8388608	@ 0x800000
340012bc:	e9c1 2300 	strd	r2, r3, [r1]
    PeriphClkInitStruct.Xspi2ClockSelection = RCC_XSPI2CLKSOURCE_HCLK;
340012c0:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
340012c4:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
340012c8:	4a24      	ldr	r2, [pc, #144]	@ (3400135c <HAL_XSPI_MspInit+0x1c8>)
340012ca:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
340012ce:	f107 0308 	add.w	r3, r7, #8
340012d2:	4618      	mov	r0, r3
340012d4:	f003 fd96 	bl	34004e04 <HAL_RCCEx_PeriphCLKConfig>
340012d8:	4603      	mov	r3, r0
340012da:	2b00      	cmp	r3, #0
340012dc:	d001      	beq.n	340012e2 <HAL_XSPI_MspInit+0x14e>
      Error_Handler();
340012de:	f7ff fdd0 	bl	34000e82 <Error_Handler>
    HAL_RCC_XSPIM_CLK_ENABLED++;
340012e2:	4b1a      	ldr	r3, [pc, #104]	@ (3400134c <HAL_XSPI_MspInit+0x1b8>)
340012e4:	681b      	ldr	r3, [r3, #0]
340012e6:	3301      	adds	r3, #1
340012e8:	4a18      	ldr	r2, [pc, #96]	@ (3400134c <HAL_XSPI_MspInit+0x1b8>)
340012ea:	6013      	str	r3, [r2, #0]
    if(HAL_RCC_XSPIM_CLK_ENABLED==1){
340012ec:	4b17      	ldr	r3, [pc, #92]	@ (3400134c <HAL_XSPI_MspInit+0x1b8>)
340012ee:	681b      	ldr	r3, [r3, #0]
340012f0:	2b01      	cmp	r3, #1
340012f2:	d103      	bne.n	340012fc <HAL_XSPI_MspInit+0x168>
      __HAL_RCC_XSPIM_CLK_ENABLE();
340012f4:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
340012f8:	f7ff fe0a 	bl	34000f10 <LL_AHB5_GRP1_EnableClock>
    __HAL_RCC_XSPI2_CLK_ENABLE();
340012fc:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
34001300:	f7ff fe06 	bl	34000f10 <LL_AHB5_GRP1_EnableClock>
    __HAL_RCC_GPION_CLK_ENABLE();
34001304:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34001308:	f7ff fdec 	bl	34000ee4 <LL_AHB4_GRP1_EnableClock>
    GPIO_InitStruct.Pin = OCTOSPI_IO2_Pin|OCTOSPI_CLK_Pin|OCTOSPI_IO4_Pin|OCTOSPI_DQS_Pin
3400130c:	f640 737f 	movw	r3, #3967	@ 0xf7f
34001310:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
34001314:	2302      	movs	r3, #2
34001316:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
3400131a:	2300      	movs	r3, #0
3400131c:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34001320:	2303      	movs	r3, #3
34001322:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF9_XSPIM_P2;
34001326:	2309      	movs	r3, #9
34001328:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPION, &GPIO_InitStruct);
3400132c:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34001330:	4619      	mov	r1, r3
34001332:	480b      	ldr	r0, [pc, #44]	@ (34001360 <HAL_XSPI_MspInit+0x1cc>)
34001334:	f001 ff6c 	bl	34003210 <HAL_GPIO_Init>
}
34001338:	bf00      	nop
3400133a:	f507 77d8 	add.w	r7, r7, #432	@ 0x1b0
3400133e:	46bd      	mov	sp, r7
34001340:	bd80      	pop	{r7, pc}
34001342:	bf00      	nop
34001344:	58025000 	.word	0x58025000
34001348:	03000014 	.word	0x03000014
3400134c:	3408019c 	.word	0x3408019c
34001350:	56023c00 	.word	0x56023c00
34001354:	56023800 	.word	0x56023800
34001358:	5802a000 	.word	0x5802a000
3400135c:	03000414 	.word	0x03000414
34001360:	56023400 	.word	0x56023400

34001364 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
34001364:	b480      	push	{r7}
34001366:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
34001368:	bf00      	nop
3400136a:	e7fd      	b.n	34001368 <NMI_Handler+0x4>

3400136c <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
3400136c:	b480      	push	{r7}
3400136e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
34001370:	bf00      	nop
34001372:	e7fd      	b.n	34001370 <HardFault_Handler+0x4>

34001374 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
34001374:	b480      	push	{r7}
34001376:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
34001378:	bf00      	nop
3400137a:	e7fd      	b.n	34001378 <MemManage_Handler+0x4>

3400137c <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
3400137c:	b480      	push	{r7}
3400137e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
34001380:	bf00      	nop
34001382:	e7fd      	b.n	34001380 <BusFault_Handler+0x4>

34001384 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
34001384:	b480      	push	{r7}
34001386:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
34001388:	bf00      	nop
3400138a:	e7fd      	b.n	34001388 <UsageFault_Handler+0x4>

3400138c <SecureFault_Handler>:

/**
  * @brief This function handles Secure fault.
  */
void SecureFault_Handler(void)
{
3400138c:	b480      	push	{r7}
3400138e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SecureFault_IRQn 0 */

  /* USER CODE END SecureFault_IRQn 0 */
  while (1)
34001390:	bf00      	nop
34001392:	e7fd      	b.n	34001390 <SecureFault_Handler+0x4>

34001394 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
34001394:	b480      	push	{r7}
34001396:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
34001398:	bf00      	nop
3400139a:	46bd      	mov	sp, r7
3400139c:	f85d 7b04 	ldr.w	r7, [sp], #4
340013a0:	4770      	bx	lr

340013a2 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
340013a2:	b480      	push	{r7}
340013a4:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
340013a6:	bf00      	nop
340013a8:	46bd      	mov	sp, r7
340013aa:	f85d 7b04 	ldr.w	r7, [sp], #4
340013ae:	4770      	bx	lr

340013b0 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
340013b0:	b480      	push	{r7}
340013b2:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
340013b4:	bf00      	nop
340013b6:	46bd      	mov	sp, r7
340013b8:	f85d 7b04 	ldr.w	r7, [sp], #4
340013bc:	4770      	bx	lr

340013be <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
340013be:	b580      	push	{r7, lr}
340013c0:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
340013c2:	f000 fac1 	bl	34001948 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
340013c6:	bf00      	nop
340013c8:	bd80      	pop	{r7, pc}
	...

340013cc <DCMIPP_IRQHandler>:

/**
  * @brief This function handles DCMIPP global interrupt.
  */
void DCMIPP_IRQHandler(void)
{
340013cc:	b580      	push	{r7, lr}
340013ce:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DCMIPP_IRQn 0 */

  /* USER CODE END DCMIPP_IRQn 0 */
  HAL_DCMIPP_IRQHandler(&hdcmipp);
340013d0:	4802      	ldr	r0, [pc, #8]	@ (340013dc <DCMIPP_IRQHandler+0x10>)
340013d2:	f000 fec8 	bl	34002166 <HAL_DCMIPP_IRQHandler>
  /* USER CODE BEGIN DCMIPP_IRQn 1 */

  /* USER CODE END DCMIPP_IRQn 1 */
}
340013d6:	bf00      	nop
340013d8:	bd80      	pop	{r7, pc}
340013da:	bf00      	nop
340013dc:	3408002c 	.word	0x3408002c

340013e0 <CSI_IRQHandler>:

/**
  * @brief This function handles CSI global interrupt.
  */
void CSI_IRQHandler(void)
{
340013e0:	b580      	push	{r7, lr}
340013e2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN CSI_IRQn 0 */

  /* USER CODE END CSI_IRQn 0 */
  HAL_DCMIPP_CSI_IRQHandler(&hdcmipp);
340013e4:	4802      	ldr	r0, [pc, #8]	@ (340013f0 <CSI_IRQHandler+0x10>)
340013e6:	f001 f8a3 	bl	34002530 <HAL_DCMIPP_CSI_IRQHandler>
  /* USER CODE BEGIN CSI_IRQn 1 */

  /* USER CODE END CSI_IRQn 1 */
}
340013ea:	bf00      	nop
340013ec:	bd80      	pop	{r7, pc}
340013ee:	bf00      	nop
340013f0:	3408002c 	.word	0x3408002c

340013f4 <TZ_SAU_Setup>:
  \brief   Setup a SAU Region
  \details Writes the region information contained in SAU_Region to the
           registers SAU_RNR, SAU_RBAR, and SAU_RLAR
 */
__STATIC_INLINE void TZ_SAU_Setup (void)
{
340013f4:	b480      	push	{r7}
340013f6:	af00      	add	r7, sp, #0
  #endif /* defined (SCB_CSR_AIRCR_INIT) && (SCB_CSR_AIRCR_INIT == 1U) */

  #if defined (__FPU_USED) && (__FPU_USED == 1U) && \
      defined (TZ_FPU_NS_USAGE) && (TZ_FPU_NS_USAGE == 1U)

    SCB->NSACR = (SCB->NSACR & ~(SCB_NSACR_CP10_Msk | SCB_NSACR_CP11_Msk)) |
340013f8:	4b18      	ldr	r3, [pc, #96]	@ (3400145c <TZ_SAU_Setup+0x68>)
340013fa:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
340013fe:	4a17      	ldr	r2, [pc, #92]	@ (3400145c <TZ_SAU_Setup+0x68>)
34001400:	f443 6340 	orr.w	r3, r3, #3072	@ 0xc00
34001404:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
                   ((SCB_NSACR_CP10_11_VAL << SCB_NSACR_CP10_Pos) & (SCB_NSACR_CP10_Msk | SCB_NSACR_CP11_Msk));

    FPU->FPCCR = (FPU->FPCCR & ~(FPU_FPCCR_TS_Msk | FPU_FPCCR_CLRONRETS_Msk | FPU_FPCCR_CLRONRET_Msk)) |
34001408:	4b15      	ldr	r3, [pc, #84]	@ (34001460 <TZ_SAU_Setup+0x6c>)
3400140a:	685b      	ldr	r3, [r3, #4]
                   ((FPU_FPCCR_TS_VAL        << FPU_FPCCR_TS_Pos       ) & FPU_FPCCR_TS_Msk       ) |
3400140c:	f023 53e0 	bic.w	r3, r3, #469762048	@ 0x1c000000
    FPU->FPCCR = (FPU->FPCCR & ~(FPU_FPCCR_TS_Msk | FPU_FPCCR_CLRONRETS_Msk | FPU_FPCCR_CLRONRET_Msk)) |
34001410:	4a13      	ldr	r2, [pc, #76]	@ (34001460 <TZ_SAU_Setup+0x6c>)
                   ((FPU_FPCCR_CLRONRETS_VAL << FPU_FPCCR_CLRONRETS_Pos) & FPU_FPCCR_CLRONRETS_Msk) |
34001412:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
    FPU->FPCCR = (FPU->FPCCR & ~(FPU_FPCCR_TS_Msk | FPU_FPCCR_CLRONRETS_Msk | FPU_FPCCR_CLRONRET_Msk)) |
34001416:	6053      	str	r3, [r2, #4]
                   ((FPU_FPCCR_CLRONRET_VAL  << FPU_FPCCR_CLRONRET_Pos ) & FPU_FPCCR_CLRONRET_Msk );
  #endif

  #if defined (NVIC_INIT_ITNS0) && (NVIC_INIT_ITNS0 == 1U)
    NVIC->ITNS[0] = NVIC_INIT_ITNS0_VAL;
34001418:	4b12      	ldr	r3, [pc, #72]	@ (34001464 <TZ_SAU_Setup+0x70>)
3400141a:	2200      	movs	r2, #0
3400141c:	f8c3 2280 	str.w	r2, [r3, #640]	@ 0x280
  #endif

  #if defined (NVIC_INIT_ITNS1) && (NVIC_INIT_ITNS1 == 1U)
    NVIC->ITNS[1] = NVIC_INIT_ITNS1_VAL;
34001420:	4b10      	ldr	r3, [pc, #64]	@ (34001464 <TZ_SAU_Setup+0x70>)
34001422:	2200      	movs	r2, #0
34001424:	f8c3 2284 	str.w	r2, [r3, #644]	@ 0x284
  #endif

  #if defined (NVIC_INIT_ITNS2) && (NVIC_INIT_ITNS2 == 1U)
    NVIC->ITNS[2] = NVIC_INIT_ITNS2_VAL;
34001428:	4b0e      	ldr	r3, [pc, #56]	@ (34001464 <TZ_SAU_Setup+0x70>)
3400142a:	2200      	movs	r2, #0
3400142c:	f8c3 2288 	str.w	r2, [r3, #648]	@ 0x288
  #endif

  #if defined (NVIC_INIT_ITNS3) && (NVIC_INIT_ITNS3 == 1U)
    NVIC->ITNS[3] = NVIC_INIT_ITNS3_VAL;
34001430:	4b0c      	ldr	r3, [pc, #48]	@ (34001464 <TZ_SAU_Setup+0x70>)
34001432:	2200      	movs	r2, #0
34001434:	f8c3 228c 	str.w	r2, [r3, #652]	@ 0x28c
  #endif

  #if defined (NVIC_INIT_ITNS4) && (NVIC_INIT_ITNS4 == 1U)
    NVIC->ITNS[4] = NVIC_INIT_ITNS4_VAL;
34001438:	4b0a      	ldr	r3, [pc, #40]	@ (34001464 <TZ_SAU_Setup+0x70>)
3400143a:	2200      	movs	r2, #0
3400143c:	f8c3 2290 	str.w	r2, [r3, #656]	@ 0x290
  #endif

  #if defined (NVIC_INIT_ITNS5) && (NVIC_INIT_ITNS5 == 1U)
    NVIC->ITNS[5] = NVIC_INIT_ITNS5_VAL;
34001440:	4b08      	ldr	r3, [pc, #32]	@ (34001464 <TZ_SAU_Setup+0x70>)
34001442:	2200      	movs	r2, #0
34001444:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294
  #endif

  #if defined (NVIC_INIT_ITNS6) && (NVIC_INIT_ITNS6 == 1U)
    NVIC->ITNS[6] = NVIC_INIT_ITNS6_VAL;
34001448:	4b06      	ldr	r3, [pc, #24]	@ (34001464 <TZ_SAU_Setup+0x70>)
3400144a:	2200      	movs	r2, #0
3400144c:	f8c3 2298 	str.w	r2, [r3, #664]	@ 0x298
  #endif

}
34001450:	bf00      	nop
34001452:	46bd      	mov	sp, r7
34001454:	f85d 7b04 	ldr.w	r7, [sp], #4
34001458:	4770      	bx	lr
3400145a:	bf00      	nop
3400145c:	e000ed00 	.word	0xe000ed00
34001460:	e000ef30 	.word	0xe000ef30
34001464:	e000e100 	.word	0xe000e100

34001468 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @retval None
  */

void SystemInit(void)
{
34001468:	b580      	push	{r7, lr}
3400146a:	af00      	add	r7, sp, #0
  /* SAU/IDAU, FPU and Interrupts secure/non-secure allocation settings */
  TZ_SAU_Setup();
3400146c:	f7ff ffc2 	bl	340013f4 <TZ_SAU_Setup>

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET;
#else
  SCB->VTOR = INTVECT_START;
34001470:	4b14      	ldr	r3, [pc, #80]	@ (340014c4 <SystemInit+0x5c>)
34001472:	4a15      	ldr	r2, [pc, #84]	@ (340014c8 <SystemInit+0x60>)
34001474:	609a      	str	r2, [r3, #8]
#endif  /* USER_VECT_TAB_ADDRESS */

  /* System configuration setup */
  RCC->APB4ENSR2 = RCC_APB4ENSR2_SYSCFGENS;
34001476:	4b15      	ldr	r3, [pc, #84]	@ (340014cc <SystemInit+0x64>)
34001478:	2201      	movs	r2, #1
3400147a:	f8c3 2a78 	str.w	r2, [r3, #2680]	@ 0xa78
  /* Delay after an RCC peripheral clock enabling */
  (void)RCC->APB4ENR2;
3400147e:	4b13      	ldr	r3, [pc, #76]	@ (340014cc <SystemInit+0x64>)
34001480:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278

  /* Set default Vector Table location after system reset or return from Standby */
  SYSCFG->INITSVTORCR = SCB->VTOR;
34001484:	4b0f      	ldr	r3, [pc, #60]	@ (340014c4 <SystemInit+0x5c>)
34001486:	4a12      	ldr	r2, [pc, #72]	@ (340014d0 <SystemInit+0x68>)
34001488:	689b      	ldr	r3, [r3, #8]
3400148a:	6113      	str	r3, [r2, #16]
  /* Read back the value to make sure it is written before deactivating SYSCFG */
  (void) SYSCFG->INITSVTORCR;
3400148c:	4b10      	ldr	r3, [pc, #64]	@ (340014d0 <SystemInit+0x68>)
3400148e:	691b      	ldr	r3, [r3, #16]
  /* Deactivate SYSCFG clock */
  RCC->APB4ENCR2 = RCC_APB4ENCR2_SYSCFGENC;
34001490:	4b0e      	ldr	r3, [pc, #56]	@ (340014cc <SystemInit+0x64>)
34001492:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34001496:	461a      	mov	r2, r3
34001498:	2301      	movs	r3, #1
3400149a:	f8c2 3278 	str.w	r3, [r2, #632]	@ 0x278
  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
3400149e:	4b09      	ldr	r3, [pc, #36]	@ (340014c4 <SystemInit+0x5c>)
340014a0:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
340014a4:	4a07      	ldr	r2, [pc, #28]	@ (340014c4 <SystemInit+0x5c>)
340014a6:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
340014aa:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  SCB_NS->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
340014ae:	4b09      	ldr	r3, [pc, #36]	@ (340014d4 <SystemInit+0x6c>)
340014b0:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
340014b4:	4a07      	ldr	r2, [pc, #28]	@ (340014d4 <SystemInit+0x6c>)
340014b6:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
340014ba:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
#endif /* __FPU_PRESENT && __FPU_USED */

}
340014be:	bf00      	nop
340014c0:	bd80      	pop	{r7, pc}
340014c2:	bf00      	nop
340014c4:	e000ed00 	.word	0xe000ed00
340014c8:	34000400 	.word	0x34000400
340014cc:	56028000 	.word	0x56028000
340014d0:	56008000 	.word	0x56008000
340014d4:	e002ed00 	.word	0xe002ed00

340014d8 <SystemCoreClockUpdate>:
  *           value for HSE crystal.
  *
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
340014d8:	b480      	push	{r7}
340014da:	b08d      	sub	sp, #52	@ 0x34
340014dc:	af00      	add	r7, sp, #0
  uint32_t sysclk = 0;
340014de:	2300      	movs	r3, #0
340014e0:	62fb      	str	r3, [r7, #44]	@ 0x2c
  uint32_t pllm = 0;
340014e2:	2300      	movs	r3, #0
340014e4:	62bb      	str	r3, [r7, #40]	@ 0x28
  uint32_t plln = 0;
340014e6:	2300      	movs	r3, #0
340014e8:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t pllfracn = 0;
340014ea:	2300      	movs	r3, #0
340014ec:	623b      	str	r3, [r7, #32]
  uint32_t pllp1 = 0;
340014ee:	2300      	movs	r3, #0
340014f0:	61fb      	str	r3, [r7, #28]
  uint32_t pllp2 = 0;
340014f2:	2300      	movs	r3, #0
340014f4:	61bb      	str	r3, [r7, #24]
  uint32_t pllcfgr, pllsource, pllbypass, ic_divider;
  float_t pllvco;

  /* Get CPUCLK source -------------------------------------------------------*/
  switch (RCC->CFGR1 & RCC_CFGR1_CPUSWS)
340014f6:	4b9b      	ldr	r3, [pc, #620]	@ (34001764 <SystemCoreClockUpdate+0x28c>)
340014f8:	6a1b      	ldr	r3, [r3, #32]
340014fa:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
340014fe:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34001502:	d029      	beq.n	34001558 <SystemCoreClockUpdate+0x80>
34001504:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34001508:	f200 8180 	bhi.w	3400180c <SystemCoreClockUpdate+0x334>
3400150c:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34001510:	d01f      	beq.n	34001552 <SystemCoreClockUpdate+0x7a>
34001512:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34001516:	f200 8179 	bhi.w	3400180c <SystemCoreClockUpdate+0x334>
3400151a:	2b00      	cmp	r3, #0
3400151c:	d003      	beq.n	34001526 <SystemCoreClockUpdate+0x4e>
3400151e:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
34001522:	d00a      	beq.n	3400153a <SystemCoreClockUpdate+0x62>
    ic_divider = (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL;
    sysclk = sysclk / ic_divider;
    break;
  default:
    /* Nothing to do, should not occur */
    break;
34001524:	e172      	b.n	3400180c <SystemCoreClockUpdate+0x334>
    sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
34001526:	4b8f      	ldr	r3, [pc, #572]	@ (34001764 <SystemCoreClockUpdate+0x28c>)
34001528:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400152a:	09db      	lsrs	r3, r3, #7
3400152c:	f003 0303 	and.w	r3, r3, #3
34001530:	4a8d      	ldr	r2, [pc, #564]	@ (34001768 <SystemCoreClockUpdate+0x290>)
34001532:	fa22 f303 	lsr.w	r3, r2, r3
34001536:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34001538:	e169      	b.n	3400180e <SystemCoreClockUpdate+0x336>
    if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
3400153a:	4b8a      	ldr	r3, [pc, #552]	@ (34001764 <SystemCoreClockUpdate+0x28c>)
3400153c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400153e:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34001542:	2b00      	cmp	r3, #0
34001544:	d102      	bne.n	3400154c <SystemCoreClockUpdate+0x74>
      sysclk = MSI_VALUE;
34001546:	4b89      	ldr	r3, [pc, #548]	@ (3400176c <SystemCoreClockUpdate+0x294>)
34001548:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
3400154a:	e160      	b.n	3400180e <SystemCoreClockUpdate+0x336>
      sysclk = 16000000UL;
3400154c:	4b88      	ldr	r3, [pc, #544]	@ (34001770 <SystemCoreClockUpdate+0x298>)
3400154e:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34001550:	e15d      	b.n	3400180e <SystemCoreClockUpdate+0x336>
    sysclk = HSE_VALUE;
34001552:	4b88      	ldr	r3, [pc, #544]	@ (34001774 <SystemCoreClockUpdate+0x29c>)
34001554:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34001556:	e15a      	b.n	3400180e <SystemCoreClockUpdate+0x336>
    switch (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL))
34001558:	4b82      	ldr	r3, [pc, #520]	@ (34001764 <SystemCoreClockUpdate+0x28c>)
3400155a:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3400155e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
34001562:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34001566:	d066      	beq.n	34001636 <SystemCoreClockUpdate+0x15e>
34001568:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400156c:	f200 8091 	bhi.w	34001692 <SystemCoreClockUpdate+0x1ba>
34001570:	2b00      	cmp	r3, #0
34001572:	d003      	beq.n	3400157c <SystemCoreClockUpdate+0xa4>
34001574:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34001578:	d02f      	beq.n	340015da <SystemCoreClockUpdate+0x102>
3400157a:	e08a      	b.n	34001692 <SystemCoreClockUpdate+0x1ba>
      pllcfgr = READ_REG(RCC->PLL1CFGR1);
3400157c:	4b79      	ldr	r3, [pc, #484]	@ (34001764 <SystemCoreClockUpdate+0x28c>)
3400157e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34001582:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL1CFGR1_PLL1SEL;
34001584:	68fb      	ldr	r3, [r7, #12]
34001586:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
3400158a:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL1CFGR1_PLL1BYP;
3400158c:	68fb      	ldr	r3, [r7, #12]
3400158e:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34001592:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34001594:	693b      	ldr	r3, [r7, #16]
34001596:	2b00      	cmp	r3, #0
34001598:	f040 80a9 	bne.w	340016ee <SystemCoreClockUpdate+0x216>
        pllm = (pllcfgr & RCC_PLL1CFGR1_PLL1DIVM) >>  RCC_PLL1CFGR1_PLL1DIVM_Pos;
3400159c:	68fb      	ldr	r3, [r7, #12]
3400159e:	0d1b      	lsrs	r3, r3, #20
340015a0:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
340015a4:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL1CFGR1_PLL1DIVN) >>  RCC_PLL1CFGR1_PLL1DIVN_Pos;
340015a6:	68fb      	ldr	r3, [r7, #12]
340015a8:	0a1b      	lsrs	r3, r3, #8
340015aa:	f3c3 030b 	ubfx	r3, r3, #0, #12
340015ae:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >>  RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos;
340015b0:	4b6c      	ldr	r3, [pc, #432]	@ (34001764 <SystemCoreClockUpdate+0x28c>)
340015b2:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
340015b6:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
340015ba:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL1CFGR3);
340015bc:	4b69      	ldr	r3, [pc, #420]	@ (34001764 <SystemCoreClockUpdate+0x28c>)
340015be:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
340015c2:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL1CFGR3_PLL1PDIV1) >>  RCC_PLL1CFGR3_PLL1PDIV1_Pos;
340015c4:	68fb      	ldr	r3, [r7, #12]
340015c6:	0edb      	lsrs	r3, r3, #27
340015c8:	f003 0307 	and.w	r3, r3, #7
340015cc:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL1CFGR3_PLL1PDIV2) >>  RCC_PLL1CFGR3_PLL1PDIV2_Pos;
340015ce:	68fb      	ldr	r3, [r7, #12]
340015d0:	0e1b      	lsrs	r3, r3, #24
340015d2:	f003 0307 	and.w	r3, r3, #7
340015d6:	61bb      	str	r3, [r7, #24]
      break;
340015d8:	e089      	b.n	340016ee <SystemCoreClockUpdate+0x216>
      pllcfgr = READ_REG(RCC->PLL2CFGR1);
340015da:	4b62      	ldr	r3, [pc, #392]	@ (34001764 <SystemCoreClockUpdate+0x28c>)
340015dc:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
340015e0:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL2CFGR1_PLL2SEL;
340015e2:	68fb      	ldr	r3, [r7, #12]
340015e4:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
340015e8:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL2CFGR1_PLL2BYP;
340015ea:	68fb      	ldr	r3, [r7, #12]
340015ec:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
340015f0:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
340015f2:	693b      	ldr	r3, [r7, #16]
340015f4:	2b00      	cmp	r3, #0
340015f6:	d17c      	bne.n	340016f2 <SystemCoreClockUpdate+0x21a>
        pllm = (pllcfgr & RCC_PLL2CFGR1_PLL2DIVM) >>  RCC_PLL2CFGR1_PLL2DIVM_Pos;
340015f8:	68fb      	ldr	r3, [r7, #12]
340015fa:	0d1b      	lsrs	r3, r3, #20
340015fc:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34001600:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL2CFGR1_PLL2DIVN) >>  RCC_PLL2CFGR1_PLL2DIVN_Pos;
34001602:	68fb      	ldr	r3, [r7, #12]
34001604:	0a1b      	lsrs	r3, r3, #8
34001606:	f3c3 030b 	ubfx	r3, r3, #0, #12
3400160a:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >>  RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos;
3400160c:	4b55      	ldr	r3, [pc, #340]	@ (34001764 <SystemCoreClockUpdate+0x28c>)
3400160e:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
34001612:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34001616:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL2CFGR3);
34001618:	4b52      	ldr	r3, [pc, #328]	@ (34001764 <SystemCoreClockUpdate+0x28c>)
3400161a:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
3400161e:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL2CFGR3_PLL2PDIV1) >>  RCC_PLL2CFGR3_PLL2PDIV1_Pos;
34001620:	68fb      	ldr	r3, [r7, #12]
34001622:	0edb      	lsrs	r3, r3, #27
34001624:	f003 0307 	and.w	r3, r3, #7
34001628:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL2CFGR3_PLL2PDIV2) >>  RCC_PLL2CFGR3_PLL2PDIV2_Pos;
3400162a:	68fb      	ldr	r3, [r7, #12]
3400162c:	0e1b      	lsrs	r3, r3, #24
3400162e:	f003 0307 	and.w	r3, r3, #7
34001632:	61bb      	str	r3, [r7, #24]
      break;
34001634:	e05d      	b.n	340016f2 <SystemCoreClockUpdate+0x21a>
      pllcfgr = READ_REG(RCC->PLL3CFGR1);
34001636:	4b4b      	ldr	r3, [pc, #300]	@ (34001764 <SystemCoreClockUpdate+0x28c>)
34001638:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3400163c:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL3CFGR1_PLL3SEL;
3400163e:	68fb      	ldr	r3, [r7, #12]
34001640:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34001644:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL3CFGR1_PLL3BYP;
34001646:	68fb      	ldr	r3, [r7, #12]
34001648:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3400164c:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
3400164e:	693b      	ldr	r3, [r7, #16]
34001650:	2b00      	cmp	r3, #0
34001652:	d150      	bne.n	340016f6 <SystemCoreClockUpdate+0x21e>
        pllm = (pllcfgr & RCC_PLL3CFGR1_PLL3DIVM) >>  RCC_PLL3CFGR1_PLL3DIVM_Pos;
34001654:	68fb      	ldr	r3, [r7, #12]
34001656:	0d1b      	lsrs	r3, r3, #20
34001658:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
3400165c:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL3CFGR1_PLL3DIVN) >>  RCC_PLL3CFGR1_PLL3DIVN_Pos;
3400165e:	68fb      	ldr	r3, [r7, #12]
34001660:	0a1b      	lsrs	r3, r3, #8
34001662:	f3c3 030b 	ubfx	r3, r3, #0, #12
34001666:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >>  RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos;
34001668:	4b3e      	ldr	r3, [pc, #248]	@ (34001764 <SystemCoreClockUpdate+0x28c>)
3400166a:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
3400166e:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34001672:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL3CFGR3);
34001674:	4b3b      	ldr	r3, [pc, #236]	@ (34001764 <SystemCoreClockUpdate+0x28c>)
34001676:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3400167a:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL3CFGR3_PLL3PDIV1) >>  RCC_PLL3CFGR3_PLL3PDIV1_Pos;
3400167c:	68fb      	ldr	r3, [r7, #12]
3400167e:	0edb      	lsrs	r3, r3, #27
34001680:	f003 0307 	and.w	r3, r3, #7
34001684:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL3CFGR3_PLL3PDIV2) >>  RCC_PLL3CFGR3_PLL3PDIV2_Pos;
34001686:	68fb      	ldr	r3, [r7, #12]
34001688:	0e1b      	lsrs	r3, r3, #24
3400168a:	f003 0307 	and.w	r3, r3, #7
3400168e:	61bb      	str	r3, [r7, #24]
      break;
34001690:	e031      	b.n	340016f6 <SystemCoreClockUpdate+0x21e>
      pllcfgr = READ_REG(RCC->PLL4CFGR1);
34001692:	4b34      	ldr	r3, [pc, #208]	@ (34001764 <SystemCoreClockUpdate+0x28c>)
34001694:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34001698:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL4CFGR1_PLL4SEL;
3400169a:	68fb      	ldr	r3, [r7, #12]
3400169c:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
340016a0:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL4CFGR1_PLL4BYP;
340016a2:	68fb      	ldr	r3, [r7, #12]
340016a4:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
340016a8:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
340016aa:	693b      	ldr	r3, [r7, #16]
340016ac:	2b00      	cmp	r3, #0
340016ae:	d124      	bne.n	340016fa <SystemCoreClockUpdate+0x222>
        pllm = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVM) >>  RCC_PLL4CFGR1_PLL4DIVM_Pos;
340016b0:	68fb      	ldr	r3, [r7, #12]
340016b2:	0d1b      	lsrs	r3, r3, #20
340016b4:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
340016b8:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVN) >>  RCC_PLL4CFGR1_PLL4DIVN_Pos;
340016ba:	68fb      	ldr	r3, [r7, #12]
340016bc:	0a1b      	lsrs	r3, r3, #8
340016be:	f3c3 030b 	ubfx	r3, r3, #0, #12
340016c2:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >>  RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos;
340016c4:	4b27      	ldr	r3, [pc, #156]	@ (34001764 <SystemCoreClockUpdate+0x28c>)
340016c6:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
340016ca:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
340016ce:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL4CFGR3);
340016d0:	4b24      	ldr	r3, [pc, #144]	@ (34001764 <SystemCoreClockUpdate+0x28c>)
340016d2:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
340016d6:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV1) >>  RCC_PLL4CFGR3_PLL4PDIV1_Pos;
340016d8:	68fb      	ldr	r3, [r7, #12]
340016da:	0edb      	lsrs	r3, r3, #27
340016dc:	f003 0307 	and.w	r3, r3, #7
340016e0:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV2) >>  RCC_PLL4CFGR3_PLL4PDIV2_Pos;
340016e2:	68fb      	ldr	r3, [r7, #12]
340016e4:	0e1b      	lsrs	r3, r3, #24
340016e6:	f003 0307 	and.w	r3, r3, #7
340016ea:	61bb      	str	r3, [r7, #24]
      break;
340016ec:	e005      	b.n	340016fa <SystemCoreClockUpdate+0x222>
      break;
340016ee:	bf00      	nop
340016f0:	e004      	b.n	340016fc <SystemCoreClockUpdate+0x224>
      break;
340016f2:	bf00      	nop
340016f4:	e002      	b.n	340016fc <SystemCoreClockUpdate+0x224>
      break;
340016f6:	bf00      	nop
340016f8:	e000      	b.n	340016fc <SystemCoreClockUpdate+0x224>
      break;
340016fa:	bf00      	nop
    switch (pllsource)
340016fc:	697b      	ldr	r3, [r7, #20]
340016fe:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34001702:	d02c      	beq.n	3400175e <SystemCoreClockUpdate+0x286>
34001704:	697b      	ldr	r3, [r7, #20]
34001706:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400170a:	d839      	bhi.n	34001780 <SystemCoreClockUpdate+0x2a8>
3400170c:	697b      	ldr	r3, [r7, #20]
3400170e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34001712:	d021      	beq.n	34001758 <SystemCoreClockUpdate+0x280>
34001714:	697b      	ldr	r3, [r7, #20]
34001716:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400171a:	d831      	bhi.n	34001780 <SystemCoreClockUpdate+0x2a8>
3400171c:	697b      	ldr	r3, [r7, #20]
3400171e:	2b00      	cmp	r3, #0
34001720:	d004      	beq.n	3400172c <SystemCoreClockUpdate+0x254>
34001722:	697b      	ldr	r3, [r7, #20]
34001724:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34001728:	d00a      	beq.n	34001740 <SystemCoreClockUpdate+0x268>
      break;
3400172a:	e029      	b.n	34001780 <SystemCoreClockUpdate+0x2a8>
      sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
3400172c:	4b0d      	ldr	r3, [pc, #52]	@ (34001764 <SystemCoreClockUpdate+0x28c>)
3400172e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34001730:	09db      	lsrs	r3, r3, #7
34001732:	f003 0303 	and.w	r3, r3, #3
34001736:	4a0c      	ldr	r2, [pc, #48]	@ (34001768 <SystemCoreClockUpdate+0x290>)
34001738:	fa22 f303 	lsr.w	r3, r2, r3
3400173c:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
3400173e:	e020      	b.n	34001782 <SystemCoreClockUpdate+0x2aa>
      if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
34001740:	4b08      	ldr	r3, [pc, #32]	@ (34001764 <SystemCoreClockUpdate+0x28c>)
34001742:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34001744:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34001748:	2b00      	cmp	r3, #0
3400174a:	d102      	bne.n	34001752 <SystemCoreClockUpdate+0x27a>
        sysclk = MSI_VALUE;
3400174c:	4b07      	ldr	r3, [pc, #28]	@ (3400176c <SystemCoreClockUpdate+0x294>)
3400174e:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34001750:	e017      	b.n	34001782 <SystemCoreClockUpdate+0x2aa>
        sysclk = 16000000UL;
34001752:	4b07      	ldr	r3, [pc, #28]	@ (34001770 <SystemCoreClockUpdate+0x298>)
34001754:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34001756:	e014      	b.n	34001782 <SystemCoreClockUpdate+0x2aa>
      sysclk = HSE_VALUE;
34001758:	4b06      	ldr	r3, [pc, #24]	@ (34001774 <SystemCoreClockUpdate+0x29c>)
3400175a:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
3400175c:	e011      	b.n	34001782 <SystemCoreClockUpdate+0x2aa>
      sysclk = EXTERNAL_I2S_CLOCK_VALUE;
3400175e:	4b06      	ldr	r3, [pc, #24]	@ (34001778 <SystemCoreClockUpdate+0x2a0>)
34001760:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34001762:	e00e      	b.n	34001782 <SystemCoreClockUpdate+0x2aa>
34001764:	56028000 	.word	0x56028000
34001768:	03d09000 	.word	0x03d09000
3400176c:	003d0900 	.word	0x003d0900
34001770:	00f42400 	.word	0x00f42400
34001774:	016e3600 	.word	0x016e3600
34001778:	00bb8000 	.word	0x00bb8000
3400177c:	4b800000 	.word	0x4b800000
      break;
34001780:	bf00      	nop
    if (pllbypass == 0U)
34001782:	693b      	ldr	r3, [r7, #16]
34001784:	2b00      	cmp	r3, #0
34001786:	d134      	bne.n	340017f2 <SystemCoreClockUpdate+0x31a>
      pllvco = ((float_t)sysclk * ((float_t)plln + ((float_t)pllfracn/(float_t)0x1000000UL))) / (float_t)pllm;
34001788:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3400178a:	ee07 3a90 	vmov	s15, r3
3400178e:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34001792:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34001794:	ee07 3a90 	vmov	s15, r3
34001798:	eef8 6a67 	vcvt.f32.u32	s13, s15
3400179c:	6a3b      	ldr	r3, [r7, #32]
3400179e:	ee07 3a90 	vmov	s15, r3
340017a2:	eeb8 6a67 	vcvt.f32.u32	s12, s15
340017a6:	ed5f 5a0b 	vldr	s11, [pc, #-44]	@ 3400177c <SystemCoreClockUpdate+0x2a4>
340017aa:	eec6 7a25 	vdiv.f32	s15, s12, s11
340017ae:	ee76 7aa7 	vadd.f32	s15, s13, s15
340017b2:	ee67 6a27 	vmul.f32	s13, s14, s15
340017b6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340017b8:	ee07 3a90 	vmov	s15, r3
340017bc:	eeb8 7a67 	vcvt.f32.u32	s14, s15
340017c0:	eec6 7a87 	vdiv.f32	s15, s13, s14
340017c4:	edc7 7a02 	vstr	s15, [r7, #8]
      sysclk = (uint32_t)((float_t)(pllvco/(((float_t)pllp1) * ((float_t)pllp2))));
340017c8:	69fb      	ldr	r3, [r7, #28]
340017ca:	ee07 3a90 	vmov	s15, r3
340017ce:	eeb8 7a67 	vcvt.f32.u32	s14, s15
340017d2:	69bb      	ldr	r3, [r7, #24]
340017d4:	ee07 3a90 	vmov	s15, r3
340017d8:	eef8 7a67 	vcvt.f32.u32	s15, s15
340017dc:	ee27 7a27 	vmul.f32	s14, s14, s15
340017e0:	edd7 6a02 	vldr	s13, [r7, #8]
340017e4:	eec6 7a87 	vdiv.f32	s15, s13, s14
340017e8:	eefc 7ae7 	vcvt.u32.f32	s15, s15
340017ec:	ee17 3a90 	vmov	r3, s15
340017f0:	62fb      	str	r3, [r7, #44]	@ 0x2c
    ic_divider = (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL;
340017f2:	4b0b      	ldr	r3, [pc, #44]	@ (34001820 <SystemCoreClockUpdate+0x348>)
340017f4:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
340017f8:	0c1b      	lsrs	r3, r3, #16
340017fa:	b2db      	uxtb	r3, r3
340017fc:	3301      	adds	r3, #1
340017fe:	607b      	str	r3, [r7, #4]
    sysclk = sysclk / ic_divider;
34001800:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34001802:	687b      	ldr	r3, [r7, #4]
34001804:	fbb2 f3f3 	udiv	r3, r2, r3
34001808:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
3400180a:	e000      	b.n	3400180e <SystemCoreClockUpdate+0x336>
    break;
3400180c:	bf00      	nop
  }

  /* Return system clock frequency (CPU frequency) */
  SystemCoreClock = sysclk;
3400180e:	4a05      	ldr	r2, [pc, #20]	@ (34001824 <SystemCoreClockUpdate+0x34c>)
34001810:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34001812:	6013      	str	r3, [r2, #0]
}
34001814:	bf00      	nop
34001816:	3734      	adds	r7, #52	@ 0x34
34001818:	46bd      	mov	sp, r7
3400181a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400181e:	4770      	bx	lr
34001820:	56028000 	.word	0x56028000
34001824:	34080000 	.word	0x34080000

34001828 <__acle_se_SECURE_SystemCoreClockUpdate>:
  *         be used by the user application to setup the SysTick timer or configure
  *         other parameters.
  * @retval SystemCoreClock value
  */
CMSE_NS_ENTRY uint32_t SECURE_SystemCoreClockUpdate(void)
{
34001828:	ed6d cf81 	vstr	FPCXTNS, [sp, #-4]!
3400182c:	b588      	push	{r3, r7, lr}
3400182e:	af00      	add	r7, sp, #0
  SystemCoreClockUpdate();
34001830:	f7ff fe52 	bl	340014d8 <SystemCoreClockUpdate>

  return SystemCoreClock;
34001834:	4b06      	ldr	r3, [pc, #24]	@ (34001850 <__acle_se_SECURE_SystemCoreClockUpdate+0x28>)
34001836:	681b      	ldr	r3, [r3, #0]
}
34001838:	4618      	mov	r0, r3
3400183a:	46bd      	mov	sp, r7
3400183c:	e8bd 4088 	ldmia.w	sp!, {r3, r7, lr}
34001840:	ec9f 0a10 	vscclrm	{s0-s15, VPR}
34001844:	e89f 900e 	clrm	{r1, r2, r3, ip, APSR}
34001848:	ecfd cf81 	vldr	FPCXTNS, [sp], #4
3400184c:	4774      	bxns	lr
3400184e:	bf00      	nop
34001850:	34080000 	.word	0x34080000

34001854 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_sstack
34001854:	480f      	ldr	r0, [pc, #60]	@ (34001894 <LoopForever+0x4>)
  msr   MSPLIM, r0
34001856:	f380 880a 	msr	MSPLIM, r0
  ldr   r0, =_estack
3400185a:	480f      	ldr	r0, [pc, #60]	@ (34001898 <LoopForever+0x8>)
  mov   sp, r0          /* set stack pointer */
3400185c:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
3400185e:	f7ff fe03 	bl	34001468 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
34001862:	480e      	ldr	r0, [pc, #56]	@ (3400189c <LoopForever+0xc>)
  ldr r1, =_edata
34001864:	490e      	ldr	r1, [pc, #56]	@ (340018a0 <LoopForever+0x10>)
  ldr r2, =_sidata
34001866:	4a0f      	ldr	r2, [pc, #60]	@ (340018a4 <LoopForever+0x14>)
  movs r3, #0
34001868:	2300      	movs	r3, #0
  b LoopCopyDataInit
3400186a:	e002      	b.n	34001872 <LoopCopyDataInit>

3400186c <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
3400186c:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
3400186e:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
34001870:	3304      	adds	r3, #4

34001872 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
34001872:	18c4      	adds	r4, r0, r3
  cmp r4, r1
34001874:	428c      	cmp	r4, r1
  bcc CopyDataInit
34001876:	d3f9      	bcc.n	3400186c <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
34001878:	4a0b      	ldr	r2, [pc, #44]	@ (340018a8 <LoopForever+0x18>)
  ldr r4, =_ebss
3400187a:	4c0c      	ldr	r4, [pc, #48]	@ (340018ac <LoopForever+0x1c>)
  movs r3, #0
3400187c:	2300      	movs	r3, #0
  b LoopFillZerobss
3400187e:	e001      	b.n	34001884 <LoopFillZerobss>

34001880 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
34001880:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
34001882:	3204      	adds	r2, #4

34001884 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
34001884:	42a2      	cmp	r2, r4
  bcc FillZerobss
34001886:	d3fb      	bcc.n	34001880 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
34001888:	f00a ffcc 	bl	3400c824 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
3400188c:	f7ff f952 	bl	34000b34 <main>

34001890 <LoopForever>:

LoopForever:
  b LoopForever
34001890:	e7fe      	b.n	34001890 <LoopForever>
34001892:	0000      	.short	0x0000
  ldr   r0, =_sstack
34001894:	341ff800 	.word	0x341ff800
  ldr   r0, =_estack
34001898:	34200000 	.word	0x34200000
  ldr r0, =_sdata
3400189c:	34080000 	.word	0x34080000
  ldr r1, =_edata
340018a0:	3408000c 	.word	0x3408000c
  ldr r2, =_sidata
340018a4:	3400cad0 	.word	0x3400cad0
  ldr r2, =_sbss
340018a8:	34080010 	.word	0x34080010
  ldr r4, =_ebss
340018ac:	340801a4 	.word	0x340801a4

340018b0 <ADC1_2_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
340018b0:	e7fe      	b.n	340018b0 <ADC1_2_IRQHandler>

340018b2 <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
340018b2:	b580      	push	{r7, lr}
340018b4:	af00      	add	r7, sp, #0
  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
340018b6:	2003      	movs	r0, #3
340018b8:	f000 f95a 	bl	34001b70 <HAL_NVIC_SetPriorityGrouping>

  /* Ensure time base clock coherency in SystemCoreClock global variable */
  SystemCoreClockUpdate();
340018bc:	f7ff fe0c 	bl	340014d8 <SystemCoreClockUpdate>

  /* Initialize 1ms tick time base (default SysTick based on HSI clock after Reset) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
340018c0:	200f      	movs	r0, #15
340018c2:	f000 f80b 	bl	340018dc <HAL_InitTick>
340018c6:	4603      	mov	r3, r0
340018c8:	2b00      	cmp	r3, #0
340018ca:	d001      	beq.n	340018d0 <HAL_Init+0x1e>
  {
    return HAL_ERROR;
340018cc:	2301      	movs	r3, #1
340018ce:	e002      	b.n	340018d6 <HAL_Init+0x24>
  }

  /* Init the low level hardware */
  HAL_MspInit();
340018d0:	f7ff fb84 	bl	34000fdc <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
340018d4:	2300      	movs	r3, #0
}
340018d6:	4618      	mov	r0, r3
340018d8:	bd80      	pop	{r7, pc}
	...

340018dc <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
340018dc:	b580      	push	{r7, lr}
340018de:	b082      	sub	sp, #8
340018e0:	af00      	add	r7, sp, #0
340018e2:	6078      	str	r0, [r7, #4]
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if ((uint32_t)uwTickFreq == 0UL)
340018e4:	4b15      	ldr	r3, [pc, #84]	@ (3400193c <HAL_InitTick+0x60>)
340018e6:	781b      	ldrb	r3, [r3, #0]
340018e8:	2b00      	cmp	r3, #0
340018ea:	d101      	bne.n	340018f0 <HAL_InitTick+0x14>
  {
    return HAL_ERROR;
340018ec:	2301      	movs	r3, #1
340018ee:	e021      	b.n	34001934 <HAL_InitTick+0x58>
  }

  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
340018f0:	4b13      	ldr	r3, [pc, #76]	@ (34001940 <HAL_InitTick+0x64>)
340018f2:	681a      	ldr	r2, [r3, #0]
340018f4:	4b11      	ldr	r3, [pc, #68]	@ (3400193c <HAL_InitTick+0x60>)
340018f6:	781b      	ldrb	r3, [r3, #0]
340018f8:	4619      	mov	r1, r3
340018fa:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
340018fe:	fbb3 f3f1 	udiv	r3, r3, r1
34001902:	fbb2 f3f3 	udiv	r3, r2, r3
34001906:	4618      	mov	r0, r3
34001908:	f000 f968 	bl	34001bdc <HAL_SYSTICK_Config>
3400190c:	4603      	mov	r3, r0
3400190e:	2b00      	cmp	r3, #0
34001910:	d001      	beq.n	34001916 <HAL_InitTick+0x3a>
  {
    return HAL_ERROR;
34001912:	2301      	movs	r3, #1
34001914:	e00e      	b.n	34001934 <HAL_InitTick+0x58>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
34001916:	687b      	ldr	r3, [r7, #4]
34001918:	2b0f      	cmp	r3, #15
3400191a:	d80a      	bhi.n	34001932 <HAL_InitTick+0x56>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
3400191c:	2200      	movs	r2, #0
3400191e:	6879      	ldr	r1, [r7, #4]
34001920:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
34001924:	f000 f92f 	bl	34001b86 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
34001928:	4a06      	ldr	r2, [pc, #24]	@ (34001944 <HAL_InitTick+0x68>)
3400192a:	687b      	ldr	r3, [r7, #4]
3400192c:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
3400192e:	2300      	movs	r3, #0
34001930:	e000      	b.n	34001934 <HAL_InitTick+0x58>
    return HAL_ERROR;
34001932:	2301      	movs	r3, #1
}
34001934:	4618      	mov	r0, r3
34001936:	3708      	adds	r7, #8
34001938:	46bd      	mov	sp, r7
3400193a:	bd80      	pop	{r7, pc}
3400193c:	34080008 	.word	0x34080008
34001940:	34080000 	.word	0x34080000
34001944:	34080004 	.word	0x34080004

34001948 <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
34001948:	b480      	push	{r7}
3400194a:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
3400194c:	4b06      	ldr	r3, [pc, #24]	@ (34001968 <HAL_IncTick+0x20>)
3400194e:	781b      	ldrb	r3, [r3, #0]
34001950:	461a      	mov	r2, r3
34001952:	4b06      	ldr	r3, [pc, #24]	@ (3400196c <HAL_IncTick+0x24>)
34001954:	681b      	ldr	r3, [r3, #0]
34001956:	4413      	add	r3, r2
34001958:	4a04      	ldr	r2, [pc, #16]	@ (3400196c <HAL_IncTick+0x24>)
3400195a:	6013      	str	r3, [r2, #0]
}
3400195c:	bf00      	nop
3400195e:	46bd      	mov	sp, r7
34001960:	f85d 7b04 	ldr.w	r7, [sp], #4
34001964:	4770      	bx	lr
34001966:	bf00      	nop
34001968:	34080008 	.word	0x34080008
3400196c:	340801a0 	.word	0x340801a0

34001970 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
34001970:	b480      	push	{r7}
34001972:	af00      	add	r7, sp, #0
  return uwTick;
34001974:	4b03      	ldr	r3, [pc, #12]	@ (34001984 <HAL_GetTick+0x14>)
34001976:	681b      	ldr	r3, [r3, #0]
}
34001978:	4618      	mov	r0, r3
3400197a:	46bd      	mov	sp, r7
3400197c:	f85d 7b04 	ldr.w	r7, [sp], #4
34001980:	4770      	bx	lr
34001982:	bf00      	nop
34001984:	340801a0 	.word	0x340801a0

34001988 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay Specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
34001988:	b580      	push	{r7, lr}
3400198a:	b084      	sub	sp, #16
3400198c:	af00      	add	r7, sp, #0
3400198e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
34001990:	f7ff ffee 	bl	34001970 <HAL_GetTick>
34001994:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
34001996:	687b      	ldr	r3, [r7, #4]
34001998:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
3400199a:	68fb      	ldr	r3, [r7, #12]
3400199c:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
340019a0:	d005      	beq.n	340019ae <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
340019a2:	4b0a      	ldr	r3, [pc, #40]	@ (340019cc <HAL_Delay+0x44>)
340019a4:	781b      	ldrb	r3, [r3, #0]
340019a6:	461a      	mov	r2, r3
340019a8:	68fb      	ldr	r3, [r7, #12]
340019aa:	4413      	add	r3, r2
340019ac:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
340019ae:	bf00      	nop
340019b0:	f7ff ffde 	bl	34001970 <HAL_GetTick>
340019b4:	4602      	mov	r2, r0
340019b6:	68bb      	ldr	r3, [r7, #8]
340019b8:	1ad3      	subs	r3, r2, r3
340019ba:	68fa      	ldr	r2, [r7, #12]
340019bc:	429a      	cmp	r2, r3
340019be:	d8f7      	bhi.n	340019b0 <HAL_Delay+0x28>
  {
  }
}
340019c0:	bf00      	nop
340019c2:	bf00      	nop
340019c4:	3710      	adds	r7, #16
340019c6:	46bd      	mov	sp, r7
340019c8:	bd80      	pop	{r7, pc}
340019ca:	bf00      	nop
340019cc:	34080008 	.word	0x34080008

340019d0 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
340019d0:	b480      	push	{r7}
340019d2:	b085      	sub	sp, #20
340019d4:	af00      	add	r7, sp, #0
340019d6:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
340019d8:	687b      	ldr	r3, [r7, #4]
340019da:	f003 0307 	and.w	r3, r3, #7
340019de:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
340019e0:	4b0c      	ldr	r3, [pc, #48]	@ (34001a14 <__NVIC_SetPriorityGrouping+0x44>)
340019e2:	68db      	ldr	r3, [r3, #12]
340019e4:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
340019e6:	68ba      	ldr	r2, [r7, #8]
340019e8:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
340019ec:	4013      	ands	r3, r2
340019ee:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
340019f0:	68fb      	ldr	r3, [r7, #12]
340019f2:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
340019f4:	68bb      	ldr	r3, [r7, #8]
340019f6:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
340019f8:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
340019fc:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
34001a00:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
34001a02:	4a04      	ldr	r2, [pc, #16]	@ (34001a14 <__NVIC_SetPriorityGrouping+0x44>)
34001a04:	68bb      	ldr	r3, [r7, #8]
34001a06:	60d3      	str	r3, [r2, #12]
}
34001a08:	bf00      	nop
34001a0a:	3714      	adds	r7, #20
34001a0c:	46bd      	mov	sp, r7
34001a0e:	f85d 7b04 	ldr.w	r7, [sp], #4
34001a12:	4770      	bx	lr
34001a14:	e000ed00 	.word	0xe000ed00

34001a18 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
34001a18:	b480      	push	{r7}
34001a1a:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
34001a1c:	4b04      	ldr	r3, [pc, #16]	@ (34001a30 <__NVIC_GetPriorityGrouping+0x18>)
34001a1e:	68db      	ldr	r3, [r3, #12]
34001a20:	0a1b      	lsrs	r3, r3, #8
34001a22:	f003 0307 	and.w	r3, r3, #7
}
34001a26:	4618      	mov	r0, r3
34001a28:	46bd      	mov	sp, r7
34001a2a:	f85d 7b04 	ldr.w	r7, [sp], #4
34001a2e:	4770      	bx	lr
34001a30:	e000ed00 	.word	0xe000ed00

34001a34 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
34001a34:	b480      	push	{r7}
34001a36:	b083      	sub	sp, #12
34001a38:	af00      	add	r7, sp, #0
34001a3a:	4603      	mov	r3, r0
34001a3c:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
34001a3e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
34001a42:	2b00      	cmp	r3, #0
34001a44:	db0b      	blt.n	34001a5e <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
34001a46:	88fb      	ldrh	r3, [r7, #6]
34001a48:	f003 021f 	and.w	r2, r3, #31
34001a4c:	4907      	ldr	r1, [pc, #28]	@ (34001a6c <__NVIC_EnableIRQ+0x38>)
34001a4e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
34001a52:	095b      	lsrs	r3, r3, #5
34001a54:	2001      	movs	r0, #1
34001a56:	fa00 f202 	lsl.w	r2, r0, r2
34001a5a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
34001a5e:	bf00      	nop
34001a60:	370c      	adds	r7, #12
34001a62:	46bd      	mov	sp, r7
34001a64:	f85d 7b04 	ldr.w	r7, [sp], #4
34001a68:	4770      	bx	lr
34001a6a:	bf00      	nop
34001a6c:	e000e100 	.word	0xe000e100

34001a70 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
34001a70:	b480      	push	{r7}
34001a72:	b083      	sub	sp, #12
34001a74:	af00      	add	r7, sp, #0
34001a76:	4603      	mov	r3, r0
34001a78:	6039      	str	r1, [r7, #0]
34001a7a:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
34001a7c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
34001a80:	2b00      	cmp	r3, #0
34001a82:	db0a      	blt.n	34001a9a <__NVIC_SetPriority+0x2a>
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34001a84:	683b      	ldr	r3, [r7, #0]
34001a86:	b2da      	uxtb	r2, r3
34001a88:	490c      	ldr	r1, [pc, #48]	@ (34001abc <__NVIC_SetPriority+0x4c>)
34001a8a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
34001a8e:	0112      	lsls	r2, r2, #4
34001a90:	b2d2      	uxtb	r2, r2
34001a92:	440b      	add	r3, r1
34001a94:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
34001a98:	e00a      	b.n	34001ab0 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34001a9a:	683b      	ldr	r3, [r7, #0]
34001a9c:	b2da      	uxtb	r2, r3
34001a9e:	4908      	ldr	r1, [pc, #32]	@ (34001ac0 <__NVIC_SetPriority+0x50>)
34001aa0:	88fb      	ldrh	r3, [r7, #6]
34001aa2:	f003 030f 	and.w	r3, r3, #15
34001aa6:	3b04      	subs	r3, #4
34001aa8:	0112      	lsls	r2, r2, #4
34001aaa:	b2d2      	uxtb	r2, r2
34001aac:	440b      	add	r3, r1
34001aae:	761a      	strb	r2, [r3, #24]
}
34001ab0:	bf00      	nop
34001ab2:	370c      	adds	r7, #12
34001ab4:	46bd      	mov	sp, r7
34001ab6:	f85d 7b04 	ldr.w	r7, [sp], #4
34001aba:	4770      	bx	lr
34001abc:	e000e100 	.word	0xe000e100
34001ac0:	e000ed00 	.word	0xe000ed00

34001ac4 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
34001ac4:	b480      	push	{r7}
34001ac6:	b089      	sub	sp, #36	@ 0x24
34001ac8:	af00      	add	r7, sp, #0
34001aca:	60f8      	str	r0, [r7, #12]
34001acc:	60b9      	str	r1, [r7, #8]
34001ace:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
34001ad0:	68fb      	ldr	r3, [r7, #12]
34001ad2:	f003 0307 	and.w	r3, r3, #7
34001ad6:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
34001ad8:	69fb      	ldr	r3, [r7, #28]
34001ada:	f1c3 0307 	rsb	r3, r3, #7
34001ade:	2b04      	cmp	r3, #4
34001ae0:	bf28      	it	cs
34001ae2:	2304      	movcs	r3, #4
34001ae4:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
34001ae6:	69fb      	ldr	r3, [r7, #28]
34001ae8:	3304      	adds	r3, #4
34001aea:	2b06      	cmp	r3, #6
34001aec:	d902      	bls.n	34001af4 <NVIC_EncodePriority+0x30>
34001aee:	69fb      	ldr	r3, [r7, #28]
34001af0:	3b03      	subs	r3, #3
34001af2:	e000      	b.n	34001af6 <NVIC_EncodePriority+0x32>
34001af4:	2300      	movs	r3, #0
34001af6:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
34001af8:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
34001afc:	69bb      	ldr	r3, [r7, #24]
34001afe:	fa02 f303 	lsl.w	r3, r2, r3
34001b02:	43da      	mvns	r2, r3
34001b04:	68bb      	ldr	r3, [r7, #8]
34001b06:	401a      	ands	r2, r3
34001b08:	697b      	ldr	r3, [r7, #20]
34001b0a:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
34001b0c:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
34001b10:	697b      	ldr	r3, [r7, #20]
34001b12:	fa01 f303 	lsl.w	r3, r1, r3
34001b16:	43d9      	mvns	r1, r3
34001b18:	687b      	ldr	r3, [r7, #4]
34001b1a:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
34001b1c:	4313      	orrs	r3, r2
         );
}
34001b1e:	4618      	mov	r0, r3
34001b20:	3724      	adds	r7, #36	@ 0x24
34001b22:	46bd      	mov	sp, r7
34001b24:	f85d 7b04 	ldr.w	r7, [sp], #4
34001b28:	4770      	bx	lr
	...

34001b2c <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
34001b2c:	b580      	push	{r7, lr}
34001b2e:	b082      	sub	sp, #8
34001b30:	af00      	add	r7, sp, #0
34001b32:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
34001b34:	687b      	ldr	r3, [r7, #4]
34001b36:	3b01      	subs	r3, #1
34001b38:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
34001b3c:	d301      	bcc.n	34001b42 <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
34001b3e:	2301      	movs	r3, #1
34001b40:	e00f      	b.n	34001b62 <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
34001b42:	4a0a      	ldr	r2, [pc, #40]	@ (34001b6c <SysTick_Config+0x40>)
34001b44:	687b      	ldr	r3, [r7, #4]
34001b46:	3b01      	subs	r3, #1
34001b48:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
34001b4a:	210f      	movs	r1, #15
34001b4c:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
34001b50:	f7ff ff8e 	bl	34001a70 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
34001b54:	4b05      	ldr	r3, [pc, #20]	@ (34001b6c <SysTick_Config+0x40>)
34001b56:	2200      	movs	r2, #0
34001b58:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
34001b5a:	4b04      	ldr	r3, [pc, #16]	@ (34001b6c <SysTick_Config+0x40>)
34001b5c:	2207      	movs	r2, #7
34001b5e:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
34001b60:	2300      	movs	r3, #0
}
34001b62:	4618      	mov	r0, r3
34001b64:	3708      	adds	r7, #8
34001b66:	46bd      	mov	sp, r7
34001b68:	bd80      	pop	{r7, pc}
34001b6a:	bf00      	nop
34001b6c:	e000e010 	.word	0xe000e010

34001b70 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
34001b70:	b580      	push	{r7, lr}
34001b72:	b082      	sub	sp, #8
34001b74:	af00      	add	r7, sp, #0
34001b76:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
34001b78:	6878      	ldr	r0, [r7, #4]
34001b7a:	f7ff ff29 	bl	340019d0 <__NVIC_SetPriorityGrouping>
}
34001b7e:	bf00      	nop
34001b80:	3708      	adds	r7, #8
34001b82:	46bd      	mov	sp, r7
34001b84:	bd80      	pop	{r7, pc}

34001b86 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
34001b86:	b580      	push	{r7, lr}
34001b88:	b086      	sub	sp, #24
34001b8a:	af00      	add	r7, sp, #0
34001b8c:	4603      	mov	r3, r0
34001b8e:	60b9      	str	r1, [r7, #8]
34001b90:	607a      	str	r2, [r7, #4]
34001b92:	81fb      	strh	r3, [r7, #14]
  uint32_t prioritygroup;

  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_INTERRUPT(IRQn));

  prioritygroup = (NVIC_GetPriorityGrouping() & 0x7U);
34001b94:	f7ff ff40 	bl	34001a18 <__NVIC_GetPriorityGrouping>
34001b98:	4603      	mov	r3, r0
34001b9a:	f003 0307 	and.w	r3, r3, #7
34001b9e:	617b      	str	r3, [r7, #20]
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority, prioritygroup));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority, prioritygroup));

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
34001ba0:	687a      	ldr	r2, [r7, #4]
34001ba2:	68b9      	ldr	r1, [r7, #8]
34001ba4:	6978      	ldr	r0, [r7, #20]
34001ba6:	f7ff ff8d 	bl	34001ac4 <NVIC_EncodePriority>
34001baa:	4602      	mov	r2, r0
34001bac:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
34001bb0:	4611      	mov	r1, r2
34001bb2:	4618      	mov	r0, r3
34001bb4:	f7ff ff5c 	bl	34001a70 <__NVIC_SetPriority>
}
34001bb8:	bf00      	nop
34001bba:	3718      	adds	r7, #24
34001bbc:	46bd      	mov	sp, r7
34001bbe:	bd80      	pop	{r7, pc}

34001bc0 <HAL_NVIC_EnableIRQ>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer
  *         to the appropriate CMSIS device file (stm32n6xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
34001bc0:	b580      	push	{r7, lr}
34001bc2:	b082      	sub	sp, #8
34001bc4:	af00      	add	r7, sp, #0
34001bc6:	4603      	mov	r3, r0
34001bc8:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
34001bca:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
34001bce:	4618      	mov	r0, r3
34001bd0:	f7ff ff30 	bl	34001a34 <__NVIC_EnableIRQ>
}
34001bd4:	bf00      	nop
34001bd6:	3708      	adds	r7, #8
34001bd8:	46bd      	mov	sp, r7
34001bda:	bd80      	pop	{r7, pc}

34001bdc <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
34001bdc:	b580      	push	{r7, lr}
34001bde:	b082      	sub	sp, #8
34001be0:	af00      	add	r7, sp, #0
34001be2:	6078      	str	r0, [r7, #4]
  return SysTick_Config(TicksNumb);
34001be4:	6878      	ldr	r0, [r7, #4]
34001be6:	f7ff ffa1 	bl	34001b2c <SysTick_Config>
34001bea:	4603      	mov	r3, r0
}
34001bec:	4618      	mov	r0, r3
34001bee:	3708      	adds	r7, #8
34001bf0:	46bd      	mov	sp, r7
34001bf2:	bd80      	pop	{r7, pc}

34001bf4 <HAL_DCMIPP_Init>:
  * @brief  Initialize the selected HAL DCMIPP handle and associate a DCMIPP peripheral instance.
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_Init(DCMIPP_HandleTypeDef *hdcmipp)
{
34001bf4:	b580      	push	{r7, lr}
34001bf6:	b084      	sub	sp, #16
34001bf8:	af00      	add	r7, sp, #0
34001bfa:	6078      	str	r0, [r7, #4]
  uint32_t pipe_index;

  /* Check pointer validity */
  if (hdcmipp == NULL)
34001bfc:	687b      	ldr	r3, [r7, #4]
34001bfe:	2b00      	cmp	r3, #0
34001c00:	d101      	bne.n	34001c06 <HAL_DCMIPP_Init+0x12>
  {
    return HAL_ERROR;
34001c02:	2301      	movs	r3, #1
34001c04:	e020      	b.n	34001c48 <HAL_DCMIPP_Init+0x54>
  }

  /* Check function parameters */
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));

  if (hdcmipp->State == HAL_DCMIPP_STATE_RESET)
34001c06:	687b      	ldr	r3, [r7, #4]
34001c08:	791b      	ldrb	r3, [r3, #4]
34001c0a:	b2db      	uxtb	r3, r3
34001c0c:	2b00      	cmp	r3, #0
34001c0e:	d102      	bne.n	34001c16 <HAL_DCMIPP_Init+0x22>
    }
    /* Initialize the low level hardware (MSP) */
    hdcmipp->MspInitCallback(hdcmipp);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_DCMIPP_MspInit(hdcmipp);
34001c10:	6878      	ldr	r0, [r7, #4]
34001c12:	f7ff f9ef 	bl	34000ff4 <HAL_DCMIPP_MspInit>
#endif /* (USE_HAL_DCMIPP_REGISTER_CALLBACKS) */
  }

  /* Change the DCMIPP state */
  hdcmipp->State = HAL_DCMIPP_STATE_BUSY;
34001c16:	687b      	ldr	r3, [r7, #4]
34001c18:	2203      	movs	r2, #3
34001c1a:	711a      	strb	r2, [r3, #4]

  /* Reset DCMIPP Pipe state */
  for (pipe_index = 0U; pipe_index < DCMIPP_NUM_OF_PIPES; pipe_index++)
34001c1c:	2300      	movs	r3, #0
34001c1e:	60fb      	str	r3, [r7, #12]
34001c20:	e008      	b.n	34001c34 <HAL_DCMIPP_Init+0x40>
  {
    hdcmipp->PipeState[pipe_index] = HAL_DCMIPP_PIPE_STATE_RESET;
34001c22:	687a      	ldr	r2, [r7, #4]
34001c24:	68fb      	ldr	r3, [r7, #12]
34001c26:	4413      	add	r3, r2
34001c28:	3305      	adds	r3, #5
34001c2a:	2200      	movs	r2, #0
34001c2c:	701a      	strb	r2, [r3, #0]
  for (pipe_index = 0U; pipe_index < DCMIPP_NUM_OF_PIPES; pipe_index++)
34001c2e:	68fb      	ldr	r3, [r7, #12]
34001c30:	3301      	adds	r3, #1
34001c32:	60fb      	str	r3, [r7, #12]
34001c34:	68fb      	ldr	r3, [r7, #12]
34001c36:	2b02      	cmp	r3, #2
34001c38:	d9f3      	bls.n	34001c22 <HAL_DCMIPP_Init+0x2e>
  }

  /* Update error code */
  hdcmipp->ErrorCode = HAL_DCMIPP_ERROR_NONE;
34001c3a:	687b      	ldr	r3, [r7, #4]
34001c3c:	2200      	movs	r2, #0
34001c3e:	609a      	str	r2, [r3, #8]

  /* Update the DCMIPP state*/
  hdcmipp->State = HAL_DCMIPP_STATE_INIT;
34001c40:	687b      	ldr	r3, [r7, #4]
34001c42:	2201      	movs	r2, #1
34001c44:	711a      	strb	r2, [r3, #4]

  return HAL_OK;
34001c46:	2300      	movs	r3, #0
}
34001c48:	4618      	mov	r0, r3
34001c4a:	3710      	adds	r7, #16
34001c4c:	46bd      	mov	sp, r7
34001c4e:	bd80      	pop	{r7, pc}

34001c50 <HAL_DCMIPP_CSI_SetConfig>:
  *                     configuration information for DCMIPP.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_CSI_SetConfig(const DCMIPP_HandleTypeDef *hdcmipp,
                                           const DCMIPP_CSI_ConfTypeDef *pCSI_Config)
{
34001c50:	b580      	push	{r7, lr}
34001c52:	f5ad 7d02 	sub.w	sp, sp, #520	@ 0x208
34001c56:	af00      	add	r7, sp, #0
34001c58:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34001c5c:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
34001c60:	6018      	str	r0, [r3, #0]
34001c62:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34001c66:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
34001c6a:	6019      	str	r1, [r3, #0]
  CSI_TypeDef *csi_instance;
  csi_instance = CSI;
34001c6c:	4ba8      	ldr	r3, [pc, #672]	@ (34001f10 <HAL_DCMIPP_CSI_SetConfig+0x2c0>)
34001c6e:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204

  const SNPS_FreqsTypeDef SNPS_Freqs[63] =
34001c72:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34001c76:	f5a3 73fe 	sub.w	r3, r3, #508	@ 0x1fc
34001c7a:	4aa6      	ldr	r2, [pc, #664]	@ (34001f14 <HAL_DCMIPP_CSI_SetConfig+0x2c4>)
34001c7c:	4618      	mov	r0, r3
34001c7e:	4611      	mov	r1, r2
34001c80:	f44f 73fc 	mov.w	r3, #504	@ 0x1f8
34001c84:	461a      	mov	r2, r3
34001c86:	f00a fdf1 	bl	3400c86c <memcpy>
    { 0x48U, 451U },  /* HAL_CSI_BT_2450 */
    { 0x49U, 460U },  /* HAL_CSI_BT_2500 */
  };

  /* Check parameters */
  if ((hdcmipp == NULL) || (pCSI_Config == NULL))
34001c8a:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34001c8e:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
34001c92:	681b      	ldr	r3, [r3, #0]
34001c94:	2b00      	cmp	r3, #0
34001c96:	d006      	beq.n	34001ca6 <HAL_DCMIPP_CSI_SetConfig+0x56>
34001c98:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34001c9c:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
34001ca0:	681b      	ldr	r3, [r3, #0]
34001ca2:	2b00      	cmp	r3, #0
34001ca4:	d101      	bne.n	34001caa <HAL_DCMIPP_CSI_SetConfig+0x5a>
  {
    return HAL_ERROR;
34001ca6:	2301      	movs	r3, #1
34001ca8:	e12c      	b.n	34001f04 <HAL_DCMIPP_CSI_SetConfig+0x2b4>
  assert_param(IS_DCMIPP_NUMBER_OF_LANES(pCSI_Config->NumberOfLanes));
  assert_param(IS_DCMIPP_CSI_DATA_LANE_MAPPING(pCSI_Config->DataLaneMapping));
  assert_param(IS_DCMIPP_CSI_DATA_PHY_BITRATE(pCSI_Config->PHYBitrate));

  /* Ensure the CSI is disabled */
  CLEAR_BIT(csi_instance->CR, CSI_CR_CSIEN);
34001caa:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34001cae:	681b      	ldr	r3, [r3, #0]
34001cb0:	f023 0201 	bic.w	r2, r3, #1
34001cb4:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34001cb8:	601a      	str	r2, [r3, #0]

  /* Configure the Lane Merger */
  if (pCSI_Config->DataLaneMapping == DCMIPP_CSI_PHYSICAL_DATA_LANES)
34001cba:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34001cbe:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
34001cc2:	681b      	ldr	r3, [r3, #0]
34001cc4:	685b      	ldr	r3, [r3, #4]
34001cc6:	2b01      	cmp	r3, #1
34001cc8:	d10b      	bne.n	34001ce2 <HAL_DCMIPP_CSI_SetConfig+0x92>
  {
    WRITE_REG(csi_instance->LMCFGR, pCSI_Config->NumberOfLanes | (DCMIPP_CSI_DATA_LANE0 << CSI_LMCFGR_DL0MAP_Pos) | \
34001cca:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34001cce:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
34001cd2:	681b      	ldr	r3, [r3, #0]
34001cd4:	681b      	ldr	r3, [r3, #0]
34001cd6:	f443 1204 	orr.w	r2, r3, #2162688	@ 0x210000
34001cda:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34001cde:	671a      	str	r2, [r3, #112]	@ 0x70
34001ce0:	e015      	b.n	34001d0e <HAL_DCMIPP_CSI_SetConfig+0xbe>
              (DCMIPP_CSI_DATA_LANE1 << CSI_LMCFGR_DL1MAP_Pos));
  }
  else if (pCSI_Config->DataLaneMapping == DCMIPP_CSI_INVERTED_DATA_LANES)
34001ce2:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34001ce6:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
34001cea:	681b      	ldr	r3, [r3, #0]
34001cec:	685b      	ldr	r3, [r3, #4]
34001cee:	2b02      	cmp	r3, #2
34001cf0:	d10b      	bne.n	34001d0a <HAL_DCMIPP_CSI_SetConfig+0xba>
  {
    WRITE_REG(csi_instance->LMCFGR, pCSI_Config->NumberOfLanes | (DCMIPP_CSI_DATA_LANE1 << CSI_LMCFGR_DL0MAP_Pos) | \
34001cf2:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34001cf6:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
34001cfa:	681b      	ldr	r3, [r3, #0]
34001cfc:	681b      	ldr	r3, [r3, #0]
34001cfe:	f443 1290 	orr.w	r2, r3, #1179648	@ 0x120000
34001d02:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34001d06:	671a      	str	r2, [r3, #112]	@ 0x70
34001d08:	e001      	b.n	34001d0e <HAL_DCMIPP_CSI_SetConfig+0xbe>
              (DCMIPP_CSI_DATA_LANE0 << CSI_LMCFGR_DL1MAP_Pos));
  }
  else
  {
    return HAL_ERROR;
34001d0a:	2301      	movs	r3, #1
34001d0c:	e0fa      	b.n	34001f04 <HAL_DCMIPP_CSI_SetConfig+0x2b4>
  }

  /* Enable the CSI */
  SET_BIT(csi_instance->CR, CSI_CR_CSIEN);
34001d0e:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34001d12:	681b      	ldr	r3, [r3, #0]
34001d14:	f043 0201 	orr.w	r2, r3, #1
34001d18:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34001d1c:	601a      	str	r2, [r3, #0]

  /* Enable some interrupts, not related to virtual channels - all error cases */
  __HAL_DCMIPP_CSI_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_CCFIFO |  DCMIPP_CSI_IT_SYNCERR | \
34001d1e:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34001d22:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34001d26:	f043 43b0 	orr.w	r3, r3, #1476395008	@ 0x58000000
34001d2a:	f443 1304 	orr.w	r3, r3, #2162688	@ 0x210000
34001d2e:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
34001d32:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
                             DCMIPP_CSI_IT_SPKTERR | DCMIPP_CSI_IT_IDERR | \
                             DCMIPP_CSI_IT_SPKT);

  /* Enable D-PHY Interrupts */
  if (pCSI_Config->NumberOfLanes == DCMIPP_CSI_ONE_DATA_LANE)
34001d36:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34001d3a:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
34001d3e:	681b      	ldr	r3, [r3, #0]
34001d40:	681b      	ldr	r3, [r3, #0]
34001d42:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34001d46:	d11d      	bne.n	34001d84 <HAL_DCMIPP_CSI_SetConfig+0x134>
  {
    if (pCSI_Config->DataLaneMapping == DCMIPP_CSI_PHYSICAL_DATA_LANES)
34001d48:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34001d4c:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
34001d50:	681b      	ldr	r3, [r3, #0]
34001d52:	685b      	ldr	r3, [r3, #4]
34001d54:	2b01      	cmp	r3, #1
34001d56:	d10a      	bne.n	34001d6e <HAL_DCMIPP_CSI_SetConfig+0x11e>
    {
      __HAL_DCMIPP_CSI_DPHY_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL0 | DCMIPP_CSI_IT_ESOTSYNCDL0 |
34001d58:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34001d5c:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34001d60:	f043 021f 	orr.w	r2, r3, #31
34001d64:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34001d68:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
34001d6c:	e016      	b.n	34001d9c <HAL_DCMIPP_CSI_SetConfig+0x14c>
                                      DCMIPP_CSI_IT_EESCDL0 | DCMIPP_CSI_IT_ESYNCESCDL0 |
                                      DCMIPP_CSI_IT_ECTRLDL0);
    }
    else
    {
      __HAL_DCMIPP_CSI_DPHY_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1 | DCMIPP_CSI_IT_ESOTSYNCDL1 |
34001d6e:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34001d72:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34001d76:	f443 52f8 	orr.w	r2, r3, #7936	@ 0x1f00
34001d7a:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34001d7e:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
34001d82:	e00b      	b.n	34001d9c <HAL_DCMIPP_CSI_SetConfig+0x14c>
                                      DCMIPP_CSI_IT_ECTRLDL1);
    }
  }
  else
  {
    __HAL_DCMIPP_CSI_DPHY_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1 | DCMIPP_CSI_IT_ESOTSYNCDL1 |
34001d84:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34001d88:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34001d8c:	f443 53f8 	orr.w	r3, r3, #7936	@ 0x1f00
34001d90:	f043 031f 	orr.w	r3, r3, #31
34001d94:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
34001d98:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84
                                    DCMIPP_CSI_IT_ECTRLDL0);
  }

  /* Start D-PHY Configuration */
  /* Stop the D-PHY */
  CLEAR_BIT(csi_instance->PRCR, CSI_PRCR_PEN);
34001d9c:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34001da0:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34001da4:	681b      	ldr	r3, [r3, #0]
34001da6:	f023 0302 	bic.w	r3, r3, #2
34001daa:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
34001dae:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34001db2:	6013      	str	r3, [r2, #0]

  /* Get the D-PHY enabledb but with all lanes disabled */
  CLEAR_REG(csi_instance-> PCR);
34001db4:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34001db8:	2200      	movs	r2, #0
34001dba:	605a      	str	r2, [r3, #4]

  /* Set the testclk (clock enable) on during 15ns */
  SET_BIT(csi_instance->PTCR0, CSI_PTCR0_TCKEN);
34001dbc:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34001dc0:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34001dc4:	691b      	ldr	r3, [r3, #16]
34001dc6:	f043 0301 	orr.w	r3, r3, #1
34001dca:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
34001dce:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34001dd2:	6113      	str	r3, [r2, #16]

  HAL_Delay(1);
34001dd4:	2001      	movs	r0, #1
34001dd6:	f7ff fdd7 	bl	34001988 <HAL_Delay>

  CLEAR_REG(csi_instance->PTCR0);
34001dda:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34001dde:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34001de2:	461a      	mov	r2, r3
34001de4:	2300      	movs	r3, #0
34001de6:	6113      	str	r3, [r2, #16]

  /* Set hsfreqrange */
  MODIFY_REG(csi_instance->PFCR, CSI_PFCR_HSFR, (0x28U << CSI_PFCR_CCFR_Pos) |
34001de8:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34001dec:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34001df0:	689b      	ldr	r3, [r3, #8]
34001df2:	f423 42fe 	bic.w	r2, r3, #32512	@ 0x7f00
34001df6:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34001dfa:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
34001dfe:	681b      	ldr	r3, [r3, #0]
34001e00:	6899      	ldr	r1, [r3, #8]
34001e02:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34001e06:	f5a3 73fe 	sub.w	r3, r3, #508	@ 0x1fc
34001e0a:	f853 3031 	ldr.w	r3, [r3, r1, lsl #3]
34001e0e:	021b      	lsls	r3, r3, #8
34001e10:	4313      	orrs	r3, r2
34001e12:	f043 0328 	orr.w	r3, r3, #40	@ 0x28
34001e16:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
34001e1a:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34001e1e:	6093      	str	r3, [r2, #8]
             (SNPS_Freqs[pCSI_Config->PHYBitrate].hsfreqrange << CSI_PFCR_HSFR_Pos));

  /* set reg @08 deskew_polarity_rw 1'b1 */
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0x08, 0x38);
34001e20:	2338      	movs	r3, #56	@ 0x38
34001e22:	2208      	movs	r2, #8
34001e24:	2100      	movs	r1, #0
34001e26:	f8d7 0204 	ldr.w	r0, [r7, #516]	@ 0x204
34001e2a:	f001 f956 	bl	340030da <DCMIPP_CSI_WritePHYReg>

  /* set reg @0xE4 counter_for_des_en_config_if_rx 0x10 + DLL prog EN */
  /* This is because 13<= cfgclkfreqrange[5:0]<=38 */
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0xe4, 0x11);
34001e2e:	2311      	movs	r3, #17
34001e30:	22e4      	movs	r2, #228	@ 0xe4
34001e32:	2100      	movs	r1, #0
34001e34:	f8d7 0204 	ldr.w	r0, [r7, #516]	@ 0x204
34001e38:	f001 f94f 	bl	340030da <DCMIPP_CSI_WritePHYReg>

  /* set reg @0xe3 & reg @0xe2 value DLL target oscilation freq */
  /* Based on the table page 77, osc_freq_target */
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0xe3, SNPS_Freqs[pCSI_Config->PHYBitrate].osc_freq_target >> 8);
34001e3c:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34001e40:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
34001e44:	681b      	ldr	r3, [r3, #0]
34001e46:	689b      	ldr	r3, [r3, #8]
34001e48:	f507 7202 	add.w	r2, r7, #520	@ 0x208
34001e4c:	f5a2 72fe 	sub.w	r2, r2, #508	@ 0x1fc
34001e50:	00db      	lsls	r3, r3, #3
34001e52:	4413      	add	r3, r2
34001e54:	685b      	ldr	r3, [r3, #4]
34001e56:	0a1b      	lsrs	r3, r3, #8
34001e58:	22e3      	movs	r2, #227	@ 0xe3
34001e5a:	2100      	movs	r1, #0
34001e5c:	f8d7 0204 	ldr.w	r0, [r7, #516]	@ 0x204
34001e60:	f001 f93b 	bl	340030da <DCMIPP_CSI_WritePHYReg>
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0xe3, SNPS_Freqs[pCSI_Config->PHYBitrate].osc_freq_target & 0xFFU);
34001e64:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34001e68:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
34001e6c:	681b      	ldr	r3, [r3, #0]
34001e6e:	689b      	ldr	r3, [r3, #8]
34001e70:	f507 7202 	add.w	r2, r7, #520	@ 0x208
34001e74:	f5a2 72fe 	sub.w	r2, r2, #508	@ 0x1fc
34001e78:	00db      	lsls	r3, r3, #3
34001e7a:	4413      	add	r3, r2
34001e7c:	685b      	ldr	r3, [r3, #4]
34001e7e:	b2db      	uxtb	r3, r3
34001e80:	22e3      	movs	r2, #227	@ 0xe3
34001e82:	2100      	movs	r1, #0
34001e84:	f8d7 0204 	ldr.w	r0, [r7, #516]	@ 0x204
34001e88:	f001 f927 	bl	340030da <DCMIPP_CSI_WritePHYReg>

  /* set basedir_0 to RX DLD 0 RX, 1 TX. Synopsys 1 RX 0 TX  + freq range */
  WRITE_REG(csi_instance-> PFCR, (0x28U << CSI_PFCR_CCFR_Pos) |
34001e8c:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34001e90:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
34001e94:	681b      	ldr	r3, [r3, #0]
34001e96:	689a      	ldr	r2, [r3, #8]
34001e98:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34001e9c:	f5a3 73fe 	sub.w	r3, r3, #508	@ 0x1fc
34001ea0:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
34001ea4:	021b      	lsls	r3, r3, #8
34001ea6:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
34001eaa:	f043 0328 	orr.w	r3, r3, #40	@ 0x28
34001eae:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
34001eb2:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34001eb6:	6093      	str	r3, [r2, #8]
            (SNPS_Freqs[pCSI_Config->PHYBitrate].hsfreqrange << CSI_PFCR_HSFR_Pos) | CSI_PFCR_DLD);

  /* Enable the D-PHY_RX lane(s) etc */
  if (pCSI_Config->NumberOfLanes == DCMIPP_CSI_ONE_DATA_LANE)
34001eb8:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34001ebc:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
34001ec0:	681b      	ldr	r3, [r3, #0]
34001ec2:	681b      	ldr	r3, [r3, #0]
34001ec4:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34001ec8:	d104      	bne.n	34001ed4 <HAL_DCMIPP_CSI_SetConfig+0x284>
  {
    WRITE_REG(csi_instance->PCR, CSI_PCR_DL0EN | CSI_PCR_CLEN | CSI_PCR_PWRDOWN);
34001eca:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34001ece:	2207      	movs	r2, #7
34001ed0:	605a      	str	r2, [r3, #4]
34001ed2:	e003      	b.n	34001edc <HAL_DCMIPP_CSI_SetConfig+0x28c>
  }
  else
  {
    WRITE_REG(csi_instance->PCR, CSI_PCR_DL0EN | CSI_PCR_DL1EN | CSI_PCR_CLEN | CSI_PCR_PWRDOWN);
34001ed4:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34001ed8:	220f      	movs	r2, #15
34001eda:	605a      	str	r2, [r3, #4]
  }


  /* Enable PHY, out of reset */
  SET_BIT(csi_instance->PRCR, CSI_PRCR_PEN);
34001edc:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34001ee0:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34001ee4:	681b      	ldr	r3, [r3, #0]
34001ee6:	f043 0302 	orr.w	r3, r3, #2
34001eea:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
34001eee:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34001ef2:	6013      	str	r3, [r2, #0]

  /* Remove the force */
  CLEAR_REG(csi_instance->PMCR);
34001ef4:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34001ef8:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34001efc:	461a      	mov	r2, r3
34001efe:	2300      	movs	r3, #0
34001f00:	6053      	str	r3, [r2, #4]

  return HAL_OK;
34001f02:	2300      	movs	r3, #0

}
34001f04:	4618      	mov	r0, r3
34001f06:	f507 7702 	add.w	r7, r7, #520	@ 0x208
34001f0a:	46bd      	mov	sp, r7
34001f0c:	bd80      	pop	{r7, pc}
34001f0e:	bf00      	nop
34001f10:	58006000 	.word	0x58006000
34001f14:	3400c8a0 	.word	0x3400c8a0

34001f18 <HAL_DCMIPP_CSI_PIPE_SetConfig>:
  *                         the CSI Pipe configuration information for DCMIPP.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_CSI_PIPE_SetConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                const DCMIPP_CSI_PIPE_ConfTypeDef *pCSI_PipeConfig)
{
34001f18:	b480      	push	{r7}
34001f1a:	b087      	sub	sp, #28
34001f1c:	af00      	add	r7, sp, #0
34001f1e:	60f8      	str	r0, [r7, #12]
34001f20:	60b9      	str	r1, [r7, #8]
34001f22:	607a      	str	r2, [r7, #4]
  uint32_t pxfscr_reg = 0;
34001f24:	2300      	movs	r3, #0
34001f26:	617b      	str	r3, [r7, #20]
  HAL_DCMIPP_StateTypeDef state;

  /* Check the DCMIPP peripheral handle parameter and pCSI_Config parameter */
  if ((hdcmipp == NULL) || (pCSI_PipeConfig == NULL))
34001f28:	68fb      	ldr	r3, [r7, #12]
34001f2a:	2b00      	cmp	r3, #0
34001f2c:	d002      	beq.n	34001f34 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x1c>
34001f2e:	687b      	ldr	r3, [r7, #4]
34001f30:	2b00      	cmp	r3, #0
34001f32:	d101      	bne.n	34001f38 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x20>
  {
    return HAL_ERROR;
34001f34:	2301      	movs	r3, #1
34001f36:	e087      	b.n	34002048 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x130>
  /* Check the parameters */
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_DATA_TYPE_MODE(pCSI_PipeConfig->DataTypeMode));

  if (Pipe != DCMIPP_PIPE2)
34001f38:	68bb      	ldr	r3, [r7, #8]
34001f3a:	2b02      	cmp	r3, #2
34001f3c:	d003      	beq.n	34001f46 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x2e>
  {
    assert_param(IS_DCMIPP_DATA_TYPE_MODE(pCSI_PipeConfig->DataTypeMode));

    if ((pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_DTIDA_OR_DTIDB)
34001f3e:	687b      	ldr	r3, [r7, #4]
34001f40:	681b      	ldr	r3, [r3, #0]
34001f42:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
  if (pCSI_PipeConfig->DataTypeMode != DCMIPP_DTMODE_ALL)
  {
    assert_param(IS_DCMIPP_DATA_TYPE(pCSI_PipeConfig->DataTypeIDA));
  }

  state = hdcmipp->State;
34001f46:	68fb      	ldr	r3, [r7, #12]
34001f48:	791b      	ldrb	r3, [r3, #4]
34001f4a:	74fb      	strb	r3, [r7, #19]
  if ((state == HAL_DCMIPP_STATE_INIT) || (state == HAL_DCMIPP_STATE_READY))
34001f4c:	7cfb      	ldrb	r3, [r7, #19]
34001f4e:	2b01      	cmp	r3, #1
34001f50:	d002      	beq.n	34001f58 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x40>
34001f52:	7cfb      	ldrb	r3, [r7, #19]
34001f54:	2b02      	cmp	r3, #2
34001f56:	d173      	bne.n	34002040 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x128>
  {
    if (((pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL) || \
34001f58:	687b      	ldr	r3, [r7, #4]
34001f5a:	681b      	ldr	r3, [r3, #0]
34001f5c:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34001f60:	d004      	beq.n	34001f6c <HAL_DCMIPP_CSI_PIPE_SetConfig+0x54>
         (pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL_EXCEPT_DTIA_DTIB)) && (Pipe != DCMIPP_PIPE0))
34001f62:	687b      	ldr	r3, [r7, #4]
34001f64:	681b      	ldr	r3, [r3, #0]
    if (((pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL) || \
34001f66:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34001f6a:	d104      	bne.n	34001f76 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x5e>
         (pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL_EXCEPT_DTIA_DTIB)) && (Pipe != DCMIPP_PIPE0))
34001f6c:	68bb      	ldr	r3, [r7, #8]
34001f6e:	2b00      	cmp	r3, #0
34001f70:	d001      	beq.n	34001f76 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x5e>
    {
      return HAL_ERROR;
34001f72:	2301      	movs	r3, #1
34001f74:	e068      	b.n	34002048 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x130>
    }

    /* Add Data Type Mode for the selected Pipe except Pipe2 */
    if (Pipe != DCMIPP_PIPE2)
34001f76:	68bb      	ldr	r3, [r7, #8]
34001f78:	2b02      	cmp	r3, #2
34001f7a:	d004      	beq.n	34001f86 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x6e>
    {
      pxfscr_reg |= (uint32_t)(pCSI_PipeConfig->DataTypeMode);
34001f7c:	687b      	ldr	r3, [r7, #4]
34001f7e:	681b      	ldr	r3, [r3, #0]
34001f80:	697a      	ldr	r2, [r7, #20]
34001f82:	4313      	orrs	r3, r2
34001f84:	617b      	str	r3, [r7, #20]
    }

    if (pCSI_PipeConfig->DataTypeMode != DCMIPP_DTMODE_ALL)
34001f86:	687b      	ldr	r3, [r7, #4]
34001f88:	681b      	ldr	r3, [r3, #0]
34001f8a:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34001f8e:	d004      	beq.n	34001f9a <HAL_DCMIPP_CSI_PIPE_SetConfig+0x82>
    {
      /* Add Data Type IDA for the selected Pipe */
      pxfscr_reg |= (uint32_t)(pCSI_PipeConfig->DataTypeIDA << DCMIPP_P0FSCR_DTIDA_Pos);
34001f90:	687b      	ldr	r3, [r7, #4]
34001f92:	685b      	ldr	r3, [r3, #4]
34001f94:	697a      	ldr	r2, [r7, #20]
34001f96:	4313      	orrs	r3, r2
34001f98:	617b      	str	r3, [r7, #20]
    }

    if ((pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_DTIDA_OR_DTIDB)
34001f9a:	687b      	ldr	r3, [r7, #4]
34001f9c:	681b      	ldr	r3, [r3, #0]
34001f9e:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34001fa2:	d004      	beq.n	34001fae <HAL_DCMIPP_CSI_PIPE_SetConfig+0x96>
        || (pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL_EXCEPT_DTIA_DTIB))
34001fa4:	687b      	ldr	r3, [r7, #4]
34001fa6:	681b      	ldr	r3, [r3, #0]
34001fa8:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34001fac:	d108      	bne.n	34001fc0 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xa8>
    {
      if (Pipe != DCMIPP_PIPE2)
34001fae:	68bb      	ldr	r3, [r7, #8]
34001fb0:	2b02      	cmp	r3, #2
34001fb2:	d005      	beq.n	34001fc0 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xa8>
      {
        /* Add Data Type IDB for the selected Pipe except Pipe2 */
        pxfscr_reg |= (uint32_t)(pCSI_PipeConfig->DataTypeIDB << DCMIPP_P0FSCR_DTIDB_Pos);
34001fb4:	687b      	ldr	r3, [r7, #4]
34001fb6:	689b      	ldr	r3, [r3, #8]
34001fb8:	021b      	lsls	r3, r3, #8
34001fba:	697a      	ldr	r2, [r7, #20]
34001fbc:	4313      	orrs	r3, r2
34001fbe:	617b      	str	r3, [r7, #20]
      }
    }

    if (Pipe == DCMIPP_PIPE0)
34001fc0:	68bb      	ldr	r3, [r7, #8]
34001fc2:	2b00      	cmp	r3, #0
34001fc4:	d10c      	bne.n	34001fe0 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xc8>
    {
      MODIFY_REG(hdcmipp->Instance->P0FSCR, DCMIPP_P0FSCR_DTMODE | DCMIPP_P0FSCR_DTIDA |
34001fc6:	68fb      	ldr	r3, [r7, #12]
34001fc8:	681b      	ldr	r3, [r3, #0]
34001fca:	f8d3 2404 	ldr.w	r2, [r3, #1028]	@ 0x404
34001fce:	4b21      	ldr	r3, [pc, #132]	@ (34002054 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x13c>)
34001fd0:	4013      	ands	r3, r2
34001fd2:	68fa      	ldr	r2, [r7, #12]
34001fd4:	6812      	ldr	r2, [r2, #0]
34001fd6:	6979      	ldr	r1, [r7, #20]
34001fd8:	430b      	orrs	r3, r1
34001fda:	f8c2 3404 	str.w	r3, [r2, #1028]	@ 0x404
34001fde:	e01b      	b.n	34002018 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x100>
                 DCMIPP_P0FSCR_DTIDB, pxfscr_reg);
    }
    else if (Pipe == DCMIPP_PIPE1)
34001fe0:	68bb      	ldr	r3, [r7, #8]
34001fe2:	2b01      	cmp	r3, #1
34001fe4:	d10c      	bne.n	34002000 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xe8>
    {
      MODIFY_REG(hdcmipp->Instance->P1FSCR, (DCMIPP_P1FSCR_DTIDA | DCMIPP_P1FSCR_DTIDB |
34001fe6:	68fb      	ldr	r3, [r7, #12]
34001fe8:	681b      	ldr	r3, [r3, #0]
34001fea:	f8d3 2804 	ldr.w	r2, [r3, #2052]	@ 0x804
34001fee:	4b19      	ldr	r3, [pc, #100]	@ (34002054 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x13c>)
34001ff0:	4013      	ands	r3, r2
34001ff2:	68fa      	ldr	r2, [r7, #12]
34001ff4:	6812      	ldr	r2, [r2, #0]
34001ff6:	6979      	ldr	r1, [r7, #20]
34001ff8:	430b      	orrs	r3, r1
34001ffa:	f8c2 3804 	str.w	r3, [r2, #2052]	@ 0x804
34001ffe:	e00b      	b.n	34002018 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x100>
                                             DCMIPP_P1FSCR_DTMODE), pxfscr_reg);
    }
    else
    {
      MODIFY_REG(hdcmipp->Instance->P2FSCR, DCMIPP_P2FSCR_DTIDA, pxfscr_reg);
34002000:	68fb      	ldr	r3, [r7, #12]
34002002:	681b      	ldr	r3, [r3, #0]
34002004:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	@ 0xc04
34002008:	f023 013f 	bic.w	r1, r3, #63	@ 0x3f
3400200c:	68fb      	ldr	r3, [r7, #12]
3400200e:	681b      	ldr	r3, [r3, #0]
34002010:	697a      	ldr	r2, [r7, #20]
34002012:	430a      	orrs	r2, r1
34002014:	f8c3 2c04 	str.w	r2, [r3, #3076]	@ 0xc04
    }

    /* Disable Parallel interface */
    CLEAR_BIT(hdcmipp->Instance->PRCR, DCMIPP_PRCR_ENABLE);
34002018:	68fb      	ldr	r3, [r7, #12]
3400201a:	681b      	ldr	r3, [r3, #0]
3400201c:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
34002020:	68fb      	ldr	r3, [r7, #12]
34002022:	681b      	ldr	r3, [r3, #0]
34002024:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
34002028:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

    /* Set CSI Input Selection  */
    SET_BIT(hdcmipp->Instance->CMCR, DCMIPP_CMCR_INSEL);
3400202c:	68fb      	ldr	r3, [r7, #12]
3400202e:	681b      	ldr	r3, [r3, #0]
34002030:	f8d3 2204 	ldr.w	r2, [r3, #516]	@ 0x204
34002034:	68fb      	ldr	r3, [r7, #12]
34002036:	681b      	ldr	r3, [r3, #0]
34002038:	f042 0201 	orr.w	r2, r2, #1
3400203c:	f8c3 2204 	str.w	r2, [r3, #516]	@ 0x204
  }

  /* Update the DCMIPP state */
  hdcmipp->State = HAL_DCMIPP_STATE_READY;
34002040:	68fb      	ldr	r3, [r7, #12]
34002042:	2202      	movs	r2, #2
34002044:	711a      	strb	r2, [r3, #4]

  return HAL_OK;
34002046:	2300      	movs	r3, #0
}
34002048:	4618      	mov	r0, r3
3400204a:	371c      	adds	r7, #28
3400204c:	46bd      	mov	sp, r7
3400204e:	f85d 7b04 	ldr.w	r7, [sp], #4
34002052:	4770      	bx	lr
34002054:	fffcc0c0 	.word	0xfffcc0c0

34002058 <HAL_DCMIPP_CSI_SetVCConfig>:
  * @param  DataTypeFormat Specifies the Data Type Format, can be a value from @ref DCMIPP_CSI_DataTypeFormat.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_CSI_SetVCConfig(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t VirtualChannel,
                                             uint32_t DataTypeFormat)
{
34002058:	b480      	push	{r7}
3400205a:	b087      	sub	sp, #28
3400205c:	af00      	add	r7, sp, #0
3400205e:	60f8      	str	r0, [r7, #12]
34002060:	60b9      	str	r1, [r7, #8]
34002062:	607a      	str	r2, [r7, #4]
  CSI_TypeDef *csi_instance;
  csi_instance = CSI;
34002064:	4b1c      	ldr	r3, [pc, #112]	@ (340020d8 <HAL_DCMIPP_CSI_SetVCConfig+0x80>)
34002066:	617b      	str	r3, [r7, #20]

  assert_param(IS_DCMIPP_VCID(VirtualChannel));
  assert_param(IS_DCMIPP_CSI_DATA_TYPE_FORMAT(DataTypeFormat));

  /* Check pointer and input values validity */
  if (hdcmipp == NULL)
34002068:	68fb      	ldr	r3, [r7, #12]
3400206a:	2b00      	cmp	r3, #0
3400206c:	d101      	bne.n	34002072 <HAL_DCMIPP_CSI_SetVCConfig+0x1a>
  {
    return HAL_ERROR;
3400206e:	2301      	movs	r3, #1
34002070:	e02c      	b.n	340020cc <HAL_DCMIPP_CSI_SetVCConfig+0x74>
  }

  /* Set the common format for all data type for the selected virtual channel */
  switch (VirtualChannel)
34002072:	68bb      	ldr	r3, [r7, #8]
34002074:	2b03      	cmp	r3, #3
34002076:	d827      	bhi.n	340020c8 <HAL_DCMIPP_CSI_SetVCConfig+0x70>
34002078:	a201      	add	r2, pc, #4	@ (adr r2, 34002080 <HAL_DCMIPP_CSI_SetVCConfig+0x28>)
3400207a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3400207e:	bf00      	nop
34002080:	34002091 	.word	0x34002091
34002084:	3400209f 	.word	0x3400209f
34002088:	340020ad 	.word	0x340020ad
3400208c:	340020bb 	.word	0x340020bb
  {
    case DCMIPP_VIRTUAL_CHANNEL0:
    {
      WRITE_REG(csi_instance->VC0CFGR1, (DataTypeFormat << CSI_VC0CFGR1_CDTFT_Pos) | CSI_VC0CFGR1_ALLDT);
34002090:	687b      	ldr	r3, [r7, #4]
34002092:	021b      	lsls	r3, r3, #8
34002094:	f043 0201 	orr.w	r2, r3, #1
34002098:	697b      	ldr	r3, [r7, #20]
3400209a:	611a      	str	r2, [r3, #16]
      break;
3400209c:	e015      	b.n	340020ca <HAL_DCMIPP_CSI_SetVCConfig+0x72>
    }
    case DCMIPP_VIRTUAL_CHANNEL1:
    {
      WRITE_REG(csi_instance->VC1CFGR1, (DataTypeFormat << CSI_VC1CFGR1_CDTFT_Pos) | CSI_VC1CFGR1_ALLDT);
3400209e:	687b      	ldr	r3, [r7, #4]
340020a0:	021b      	lsls	r3, r3, #8
340020a2:	f043 0201 	orr.w	r2, r3, #1
340020a6:	697b      	ldr	r3, [r7, #20]
340020a8:	621a      	str	r2, [r3, #32]
      break;
340020aa:	e00e      	b.n	340020ca <HAL_DCMIPP_CSI_SetVCConfig+0x72>
    }
    case DCMIPP_VIRTUAL_CHANNEL2:
    {
      WRITE_REG(csi_instance->VC2CFGR1, (DataTypeFormat << CSI_VC2CFGR1_CDTFT_Pos) | CSI_VC2CFGR1_ALLDT);
340020ac:	687b      	ldr	r3, [r7, #4]
340020ae:	021b      	lsls	r3, r3, #8
340020b0:	f043 0201 	orr.w	r2, r3, #1
340020b4:	697b      	ldr	r3, [r7, #20]
340020b6:	631a      	str	r2, [r3, #48]	@ 0x30
      break;
340020b8:	e007      	b.n	340020ca <HAL_DCMIPP_CSI_SetVCConfig+0x72>
    }
    case DCMIPP_VIRTUAL_CHANNEL3:
    {
      WRITE_REG(csi_instance->VC3CFGR1, (DataTypeFormat << CSI_VC3CFGR1_CDTFT_Pos) | CSI_VC3CFGR1_ALLDT);
340020ba:	687b      	ldr	r3, [r7, #4]
340020bc:	021b      	lsls	r3, r3, #8
340020be:	f043 0201 	orr.w	r2, r3, #1
340020c2:	697b      	ldr	r3, [r7, #20]
340020c4:	641a      	str	r2, [r3, #64]	@ 0x40
      break;
340020c6:	e000      	b.n	340020ca <HAL_DCMIPP_CSI_SetVCConfig+0x72>
    }
    default:
      break;
340020c8:	bf00      	nop
  }

  return HAL_OK;
340020ca:	2300      	movs	r3, #0
}
340020cc:	4618      	mov	r0, r3
340020ce:	371c      	adds	r7, #28
340020d0:	46bd      	mov	sp, r7
340020d2:	f85d 7b04 	ldr.w	r7, [sp], #4
340020d6:	4770      	bx	lr
340020d8:	58006000 	.word	0x58006000

340020dc <HAL_DCMIPP_PIPE_SetConfig>:
  * @param  pPipeConfig pointer to pipe configuration structure
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                            const DCMIPP_PipeConfTypeDef *pPipeConfig)
{
340020dc:	b580      	push	{r7, lr}
340020de:	b086      	sub	sp, #24
340020e0:	af00      	add	r7, sp, #0
340020e2:	60f8      	str	r0, [r7, #12]
340020e4:	60b9      	str	r1, [r7, #8]
340020e6:	607a      	str	r2, [r7, #4]
  HAL_DCMIPP_PipeStateTypeDef pipe_state;

  /* Check the DCMIPP peripheral handle parameter and pPipeConfig parameter */
  if ((hdcmipp == NULL) || (pPipeConfig == NULL))
340020e8:	68fb      	ldr	r3, [r7, #12]
340020ea:	2b00      	cmp	r3, #0
340020ec:	d002      	beq.n	340020f4 <HAL_DCMIPP_PIPE_SetConfig+0x18>
340020ee:	687b      	ldr	r3, [r7, #4]
340020f0:	2b00      	cmp	r3, #0
340020f2:	d101      	bne.n	340020f8 <HAL_DCMIPP_PIPE_SetConfig+0x1c>
  {
    return HAL_ERROR;
340020f4:	2301      	movs	r3, #1
340020f6:	e032      	b.n	3400215e <HAL_DCMIPP_PIPE_SetConfig+0x82>
  {
    assert_param(IS_DCMIPP_PIXEL_PACKER_FORMAT(pPipeConfig->PixelPackerFormat));
    assert_param(IS_DCMIPP_PIXEL_PIPE_PITCH(pPipeConfig->PixelPipePitch));
  }

  if ((Pipe == DCMIPP_PIPE2) && ((pPipeConfig->PixelPackerFormat) > DCMIPP_PIXEL_PACKER_FORMAT_YUV422_1))
340020f8:	68bb      	ldr	r3, [r7, #8]
340020fa:	2b02      	cmp	r3, #2
340020fc:	d105      	bne.n	3400210a <HAL_DCMIPP_PIPE_SetConfig+0x2e>
340020fe:	687b      	ldr	r3, [r7, #4]
34002100:	689b      	ldr	r3, [r3, #8]
34002102:	2b06      	cmp	r3, #6
34002104:	d901      	bls.n	3400210a <HAL_DCMIPP_PIPE_SetConfig+0x2e>
  {
    return HAL_ERROR;
34002106:	2301      	movs	r3, #1
34002108:	e029      	b.n	3400215e <HAL_DCMIPP_PIPE_SetConfig+0x82>
  }
  /* Get Pipe State */
  pipe_state = hdcmipp->PipeState[Pipe];
3400210a:	68fa      	ldr	r2, [r7, #12]
3400210c:	68bb      	ldr	r3, [r7, #8]
3400210e:	4413      	add	r3, r2
34002110:	3305      	adds	r3, #5
34002112:	781b      	ldrb	r3, [r3, #0]
34002114:	75fb      	strb	r3, [r7, #23]

  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34002116:	68fb      	ldr	r3, [r7, #12]
34002118:	791b      	ldrb	r3, [r3, #4]
3400211a:	b2db      	uxtb	r3, r3
3400211c:	2b02      	cmp	r3, #2
3400211e:	d11d      	bne.n	3400215c <HAL_DCMIPP_PIPE_SetConfig+0x80>
  {
    if ((pipe_state == HAL_DCMIPP_PIPE_STATE_READY) || (pipe_state == HAL_DCMIPP_PIPE_STATE_RESET) ||
34002120:	7dfb      	ldrb	r3, [r7, #23]
34002122:	2b01      	cmp	r3, #1
34002124:	d005      	beq.n	34002132 <HAL_DCMIPP_PIPE_SetConfig+0x56>
34002126:	7dfb      	ldrb	r3, [r7, #23]
34002128:	2b00      	cmp	r3, #0
3400212a:	d002      	beq.n	34002132 <HAL_DCMIPP_PIPE_SetConfig+0x56>
3400212c:	7dfb      	ldrb	r3, [r7, #23]
3400212e:	2b04      	cmp	r3, #4
34002130:	d112      	bne.n	34002158 <HAL_DCMIPP_PIPE_SetConfig+0x7c>
        (pipe_state == HAL_DCMIPP_PIPE_STATE_ERROR))
    {
      /* Update the DCMIPP PIPE state */
      hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
34002132:	68fa      	ldr	r2, [r7, #12]
34002134:	68bb      	ldr	r3, [r7, #8]
34002136:	4413      	add	r3, r2
34002138:	3305      	adds	r3, #5
3400213a:	2202      	movs	r2, #2
3400213c:	701a      	strb	r2, [r3, #0]

      /* Initialize the DCMIPP Pipe registers */
      Pipe_Config(hdcmipp, Pipe, pPipeConfig);
3400213e:	687a      	ldr	r2, [r7, #4]
34002140:	68b9      	ldr	r1, [r7, #8]
34002142:	68f8      	ldr	r0, [r7, #12]
34002144:	f000 ff2a 	bl	34002f9c <Pipe_Config>

      /* Update the DCMIPP pipe state */
      hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_READY;
34002148:	68fa      	ldr	r2, [r7, #12]
3400214a:	68bb      	ldr	r3, [r7, #8]
3400214c:	4413      	add	r3, r2
3400214e:	3305      	adds	r3, #5
34002150:	2201      	movs	r2, #1
34002152:	701a      	strb	r2, [r3, #0]
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34002154:	2300      	movs	r3, #0
34002156:	e002      	b.n	3400215e <HAL_DCMIPP_PIPE_SetConfig+0x82>
      return HAL_ERROR;
34002158:	2301      	movs	r3, #1
3400215a:	e000      	b.n	3400215e <HAL_DCMIPP_PIPE_SetConfig+0x82>
    return HAL_ERROR;
3400215c:	2301      	movs	r3, #1
}
3400215e:	4618      	mov	r0, r3
34002160:	3718      	adds	r7, #24
34002162:	46bd      	mov	sp, r7
34002164:	bd80      	pop	{r7, pc}

34002166 <HAL_DCMIPP_IRQHandler>:
  * @brief  Handles DCMIPP interrupt request.
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval None
  */
void HAL_DCMIPP_IRQHandler(DCMIPP_HandleTypeDef *hdcmipp)
{
34002166:	b580      	push	{r7, lr}
34002168:	b084      	sub	sp, #16
3400216a:	af00      	add	r7, sp, #0
3400216c:	6078      	str	r0, [r7, #4]
  uint32_t cmsr2flags = READ_REG(hdcmipp->Instance->CMSR2);
3400216e:	687b      	ldr	r3, [r7, #4]
34002170:	681b      	ldr	r3, [r3, #0]
34002172:	f8d3 33f8 	ldr.w	r3, [r3, #1016]	@ 0x3f8
34002176:	60fb      	str	r3, [r7, #12]
  uint32_t cmierflags = READ_REG(hdcmipp->Instance->CMIER);
34002178:	687b      	ldr	r3, [r7, #4]
3400217a:	681b      	ldr	r3, [r3, #0]
3400217c:	f8d3 33f0 	ldr.w	r3, [r3, #1008]	@ 0x3f0
34002180:	60bb      	str	r3, [r7, #8]

  /* ========================= PIPE0 INTERRUPTS ==================== */
  /* Limit error on the PIPE0 ********************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_LIMIT) != 0U)
34002182:	68fb      	ldr	r3, [r7, #12]
34002184:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34002188:	2b00      	cmp	r3, #0
3400218a:	d01e      	beq.n	340021ca <HAL_DCMIPP_IRQHandler+0x64>
  {
    if ((cmierflags & DCMIPP_IT_PIPE0_LIMIT) != 0U)
3400218c:	68bb      	ldr	r3, [r7, #8]
3400218e:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34002192:	2b00      	cmp	r3, #0
34002194:	d019      	beq.n	340021ca <HAL_DCMIPP_IRQHandler+0x64>
    {
      /* Disable Limit error Interrupt for pipe0 */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_LIMIT);
34002196:	687b      	ldr	r3, [r7, #4]
34002198:	681b      	ldr	r3, [r3, #0]
3400219a:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
3400219e:	687b      	ldr	r3, [r7, #4]
340021a0:	681b      	ldr	r3, [r3, #0]
340021a2:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
340021a6:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE0_LIMIT;
340021aa:	687b      	ldr	r3, [r7, #4]
340021ac:	689b      	ldr	r3, [r3, #8]
340021ae:	f043 0204 	orr.w	r2, r3, #4
340021b2:	687b      	ldr	r3, [r7, #4]
340021b4:	609a      	str	r2, [r3, #8]

      /* Clear the Limit error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_LIMIT);
340021b6:	687b      	ldr	r3, [r7, #4]
340021b8:	681b      	ldr	r3, [r3, #0]
340021ba:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
340021be:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* LIMIT Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_LimitEventCallback(hdcmipp, DCMIPP_PIPE0);
#else
      HAL_DCMIPP_PIPE_LimitEventCallback(hdcmipp, DCMIPP_PIPE0);
340021c2:	2100      	movs	r1, #0
340021c4:	6878      	ldr	r0, [r7, #4]
340021c6:	f000 fe7e 	bl	34002ec6 <HAL_DCMIPP_PIPE_LimitEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* VSYNC interrupt management **********************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_VSYNC) != 0U)
340021ca:	68fb      	ldr	r3, [r7, #12]
340021cc:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
340021d0:	2b00      	cmp	r3, #0
340021d2:	d00e      	beq.n	340021f2 <HAL_DCMIPP_IRQHandler+0x8c>
  {
    if ((cmierflags & DCMIPP_IT_PIPE0_VSYNC) != 0U)
340021d4:	68bb      	ldr	r3, [r7, #8]
340021d6:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
340021da:	2b00      	cmp	r3, #0
340021dc:	d009      	beq.n	340021f2 <HAL_DCMIPP_IRQHandler+0x8c>
    {
      /* Clear the VSYNC flag for pipe0 */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_VSYNC);
340021de:	687b      	ldr	r3, [r7, #4]
340021e0:	681b      	ldr	r3, [r3, #0]
340021e2:	f44f 6280 	mov.w	r2, #1024	@ 0x400
340021e6:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* VSYNC Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE0);
#else
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE0);
340021ea:	2100      	movs	r1, #0
340021ec:	6878      	ldr	r0, [r7, #4]
340021ee:	f000 fe54 	bl	34002e9a <HAL_DCMIPP_PIPE_VsyncEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* FRAME interrupt management ****************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_FRAME) != 0U)
340021f2:	68fb      	ldr	r3, [r7, #12]
340021f4:	f403 7300 	and.w	r3, r3, #512	@ 0x200
340021f8:	2b00      	cmp	r3, #0
340021fa:	d023      	beq.n	34002244 <HAL_DCMIPP_IRQHandler+0xde>
  {
    if ((cmierflags & DCMIPP_IT_PIPE0_FRAME) != 0U)
340021fc:	68bb      	ldr	r3, [r7, #8]
340021fe:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34002202:	2b00      	cmp	r3, #0
34002204:	d01e      	beq.n	34002244 <HAL_DCMIPP_IRQHandler+0xde>
    {
      /* When snapshot mode, disable Vsync, Error and Overrun interrupts */
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34002206:	687b      	ldr	r3, [r7, #4]
34002208:	681b      	ldr	r3, [r3, #0]
3400220a:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
3400220e:	f003 0304 	and.w	r3, r3, #4
34002212:	2b04      	cmp	r3, #4
34002214:	d10c      	bne.n	34002230 <HAL_DCMIPP_IRQHandler+0xca>
      {
        __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_FRAME | DCMIPP_IT_PIPE0_VSYNC | DCMIPP_IT_PIPE0_OVR);
34002216:	687b      	ldr	r3, [r7, #4]
34002218:	681b      	ldr	r3, [r3, #0]
3400221a:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
3400221e:	687b      	ldr	r3, [r7, #4]
34002220:	681b      	ldr	r3, [r3, #0]
34002222:	f422 4206 	bic.w	r2, r2, #34304	@ 0x8600
34002226:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

        /* Update Pipe State */
        hdcmipp->PipeState[0] = HAL_DCMIPP_PIPE_STATE_READY;
3400222a:	687b      	ldr	r3, [r7, #4]
3400222c:	2201      	movs	r2, #1
3400222e:	715a      	strb	r2, [r3, #5]
      }

      /* Clear the End of Frame flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_FRAME);
34002230:	687b      	ldr	r3, [r7, #4]
34002232:	681b      	ldr	r3, [r3, #0]
34002234:	f44f 7200 	mov.w	r2, #512	@ 0x200
34002238:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Frame Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE0);
#else
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE0);
3400223c:	2100      	movs	r1, #0
3400223e:	6878      	ldr	r0, [r7, #4]
34002240:	f000 fe20 	bl	34002e84 <HAL_DCMIPP_PIPE_FrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* LINE interrupt management **********************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_LINE) != 0U)
34002244:	68fb      	ldr	r3, [r7, #12]
34002246:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3400224a:	2b00      	cmp	r3, #0
3400224c:	d00e      	beq.n	3400226c <HAL_DCMIPP_IRQHandler+0x106>
  {
    if ((cmierflags & DCMIPP_IT_PIPE0_LINE) != 0U)
3400224e:	68bb      	ldr	r3, [r7, #8]
34002250:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34002254:	2b00      	cmp	r3, #0
34002256:	d009      	beq.n	3400226c <HAL_DCMIPP_IRQHandler+0x106>
    {
      /* Clear the LINE flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_LINE);
34002258:	687b      	ldr	r3, [r7, #4]
3400225a:	681b      	ldr	r3, [r3, #0]
3400225c:	f44f 7280 	mov.w	r2, #256	@ 0x100
34002260:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* LINE Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE0);
#else
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE0);
34002264:	2100      	movs	r1, #0
34002266:	6878      	ldr	r0, [r7, #4]
34002268:	f000 fe22 	bl	34002eb0 <HAL_DCMIPP_PIPE_LineEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Overrun error interrupt for Pipe0 ***************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_OVR) != 0U)
3400226c:	68fb      	ldr	r3, [r7, #12]
3400226e:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
34002272:	2b00      	cmp	r3, #0
34002274:	d021      	beq.n	340022ba <HAL_DCMIPP_IRQHandler+0x154>
  {
    if ((cmierflags & DCMIPP_IT_PIPE0_OVR) != 0U)
34002276:	68bb      	ldr	r3, [r7, #8]
34002278:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
3400227c:	2b00      	cmp	r3, #0
3400227e:	d01c      	beq.n	340022ba <HAL_DCMIPP_IRQHandler+0x154>
    {
      /* Disable Overrun Error Interrupt for pipe0 */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_OVR);
34002280:	687b      	ldr	r3, [r7, #4]
34002282:	681b      	ldr	r3, [r3, #0]
34002284:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34002288:	687b      	ldr	r3, [r7, #4]
3400228a:	681b      	ldr	r3, [r3, #0]
3400228c:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
34002290:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE0_OVR;
34002294:	687b      	ldr	r3, [r7, #4]
34002296:	689b      	ldr	r3, [r3, #8]
34002298:	f043 0208 	orr.w	r2, r3, #8
3400229c:	687b      	ldr	r3, [r7, #4]
3400229e:	609a      	str	r2, [r3, #8]

      /* Clear the overrun error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_OVR);
340022a0:	687b      	ldr	r3, [r7, #4]
340022a2:	681b      	ldr	r3, [r3, #0]
340022a4:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
340022a8:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Change DCMIPP Pipe state */
      hdcmipp->PipeState[0] = HAL_DCMIPP_PIPE_STATE_ERROR;
340022ac:	687b      	ldr	r3, [r7, #4]
340022ae:	2204      	movs	r2, #4
340022b0:	715a      	strb	r2, [r3, #5]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE0);
#else
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE0);
340022b2:	2100      	movs	r1, #0
340022b4:	6878      	ldr	r0, [r7, #4]
340022b6:	f000 fe11 	bl	34002edc <HAL_DCMIPP_PIPE_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* ========================= PIPE1 INTERRUPTS ==================== */
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_LINE) != 0U)
340022ba:	68fb      	ldr	r3, [r7, #12]
340022bc:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
340022c0:	2b00      	cmp	r3, #0
340022c2:	d00e      	beq.n	340022e2 <HAL_DCMIPP_IRQHandler+0x17c>
  {
    if ((cmierflags & DCMIPP_FLAG_PIPE1_LINE) != 0U)
340022c4:	68bb      	ldr	r3, [r7, #8]
340022c6:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
340022ca:	2b00      	cmp	r3, #0
340022cc:	d009      	beq.n	340022e2 <HAL_DCMIPP_IRQHandler+0x17c>
    {
      /* Clear the End of Frame flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_LINE);
340022ce:	687b      	ldr	r3, [r7, #4]
340022d0:	681b      	ldr	r3, [r3, #0]
340022d2:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
340022d6:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Frame Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE1);
#else
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE1);
340022da:	2101      	movs	r1, #1
340022dc:	6878      	ldr	r0, [r7, #4]
340022de:	f000 fde7 	bl	34002eb0 <HAL_DCMIPP_PIPE_LineEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* VSYNC interrupt management **********************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_VSYNC) != 0U)
340022e2:	68fb      	ldr	r3, [r7, #12]
340022e4:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
340022e8:	2b00      	cmp	r3, #0
340022ea:	d00e      	beq.n	3400230a <HAL_DCMIPP_IRQHandler+0x1a4>
  {
    if ((cmierflags & DCMIPP_IT_PIPE1_VSYNC) != 0U)
340022ec:	68bb      	ldr	r3, [r7, #8]
340022ee:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
340022f2:	2b00      	cmp	r3, #0
340022f4:	d009      	beq.n	3400230a <HAL_DCMIPP_IRQHandler+0x1a4>
    {
      /* Clear the VSYNC flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_VSYNC);
340022f6:	687b      	ldr	r3, [r7, #4]
340022f8:	681b      	ldr	r3, [r3, #0]
340022fa:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
340022fe:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* VSYNC Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE1);
#else
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE1);
34002302:	2101      	movs	r1, #1
34002304:	6878      	ldr	r0, [r7, #4]
34002306:	f000 fdc8 	bl	34002e9a <HAL_DCMIPP_PIPE_VsyncEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_FRAME) != 0U)
3400230a:	68fb      	ldr	r3, [r7, #12]
3400230c:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34002310:	2b00      	cmp	r3, #0
34002312:	d023      	beq.n	3400235c <HAL_DCMIPP_IRQHandler+0x1f6>
  {
    if ((cmierflags & DCMIPP_IT_PIPE1_FRAME) != 0U)
34002314:	68bb      	ldr	r3, [r7, #8]
34002316:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
3400231a:	2b00      	cmp	r3, #0
3400231c:	d01e      	beq.n	3400235c <HAL_DCMIPP_IRQHandler+0x1f6>
    {
      /* When snapshot mode, disable Vsync, Error and Overrun interrupts */
      if ((hdcmipp->Instance->P1FCTCR & DCMIPP_P1FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400231e:	687b      	ldr	r3, [r7, #4]
34002320:	681b      	ldr	r3, [r3, #0]
34002322:	f8d3 3900 	ldr.w	r3, [r3, #2304]	@ 0x900
34002326:	f003 0304 	and.w	r3, r3, #4
3400232a:	2b04      	cmp	r3, #4
3400232c:	d10c      	bne.n	34002348 <HAL_DCMIPP_IRQHandler+0x1e2>
      {
        __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_FRAME | DCMIPP_IT_PIPE1_VSYNC | DCMIPP_IT_PIPE1_OVR);
3400232e:	687b      	ldr	r3, [r7, #4]
34002330:	681b      	ldr	r3, [r3, #0]
34002332:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34002336:	687b      	ldr	r3, [r7, #4]
34002338:	681b      	ldr	r3, [r3, #0]
3400233a:	f422 0206 	bic.w	r2, r2, #8781824	@ 0x860000
3400233e:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

        /* Update Pipe State */
        hdcmipp->PipeState[1] = HAL_DCMIPP_PIPE_STATE_READY;
34002342:	687b      	ldr	r3, [r7, #4]
34002344:	2201      	movs	r2, #1
34002346:	719a      	strb	r2, [r3, #6]
      }

      /* Clear the End of Frame flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_FRAME);
34002348:	687b      	ldr	r3, [r7, #4]
3400234a:	681b      	ldr	r3, [r3, #0]
3400234c:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
34002350:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Frame Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE1);
#else
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE1);
34002354:	2101      	movs	r1, #1
34002356:	6878      	ldr	r0, [r7, #4]
34002358:	f000 fd94 	bl	34002e84 <HAL_DCMIPP_PIPE_FrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Overrun error on the PIPE1 **************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_OVR) != 0U)
3400235c:	68fb      	ldr	r3, [r7, #12]
3400235e:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
34002362:	2b00      	cmp	r3, #0
34002364:	d021      	beq.n	340023aa <HAL_DCMIPP_IRQHandler+0x244>
  {
    if ((cmierflags & DCMIPP_IT_PIPE1_OVR) != 0U)
34002366:	68bb      	ldr	r3, [r7, #8]
34002368:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
3400236c:	2b00      	cmp	r3, #0
3400236e:	d01c      	beq.n	340023aa <HAL_DCMIPP_IRQHandler+0x244>
    {
      /* Disable Overrun Error Interrupt for pipe1 */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_OVR);
34002370:	687b      	ldr	r3, [r7, #4]
34002372:	681b      	ldr	r3, [r3, #0]
34002374:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34002378:	687b      	ldr	r3, [r7, #4]
3400237a:	681b      	ldr	r3, [r3, #0]
3400237c:	f422 0200 	bic.w	r2, r2, #8388608	@ 0x800000
34002380:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE1_OVR;
34002384:	687b      	ldr	r3, [r7, #4]
34002386:	689b      	ldr	r3, [r3, #8]
34002388:	f043 0210 	orr.w	r2, r3, #16
3400238c:	687b      	ldr	r3, [r7, #4]
3400238e:	609a      	str	r2, [r3, #8]

      /* Clear the overrun error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_OVR);
34002390:	687b      	ldr	r3, [r7, #4]
34002392:	681b      	ldr	r3, [r3, #0]
34002394:	f44f 0200 	mov.w	r2, #8388608	@ 0x800000
34002398:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Change DCMIPP state */
      hdcmipp->PipeState[1] = HAL_DCMIPP_PIPE_STATE_ERROR;
3400239c:	687b      	ldr	r3, [r7, #4]
3400239e:	2204      	movs	r2, #4
340023a0:	719a      	strb	r2, [r3, #6]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE1);
#else
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE1);
340023a2:	2101      	movs	r1, #1
340023a4:	6878      	ldr	r0, [r7, #4]
340023a6:	f000 fd99 	bl	34002edc <HAL_DCMIPP_PIPE_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* ========================= PIPE2 INTERRUPTS ==================== */
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_LINE) != 0U)
340023aa:	68fb      	ldr	r3, [r7, #12]
340023ac:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
340023b0:	2b00      	cmp	r3, #0
340023b2:	d00e      	beq.n	340023d2 <HAL_DCMIPP_IRQHandler+0x26c>
  {
    if ((cmierflags & DCMIPP_IT_PIPE2_LINE) != 0U)
340023b4:	68bb      	ldr	r3, [r7, #8]
340023b6:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
340023ba:	2b00      	cmp	r3, #0
340023bc:	d009      	beq.n	340023d2 <HAL_DCMIPP_IRQHandler+0x26c>
    {
      /* Clear the End of Line flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_LINE);
340023be:	687b      	ldr	r3, [r7, #4]
340023c0:	681b      	ldr	r3, [r3, #0]
340023c2:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
340023c6:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Frame Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE2);
#else
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE2);
340023ca:	2102      	movs	r1, #2
340023cc:	6878      	ldr	r0, [r7, #4]
340023ce:	f000 fd6f 	bl	34002eb0 <HAL_DCMIPP_PIPE_LineEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* VSYNC interrupt management **********************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_VSYNC) != 0U)
340023d2:	68fb      	ldr	r3, [r7, #12]
340023d4:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
340023d8:	2b00      	cmp	r3, #0
340023da:	d00e      	beq.n	340023fa <HAL_DCMIPP_IRQHandler+0x294>
  {
    if ((cmierflags & DCMIPP_IT_PIPE2_VSYNC) != 0U)
340023dc:	68bb      	ldr	r3, [r7, #8]
340023de:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
340023e2:	2b00      	cmp	r3, #0
340023e4:	d009      	beq.n	340023fa <HAL_DCMIPP_IRQHandler+0x294>
    {
      /* Clear the VSYNC flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_VSYNC);
340023e6:	687b      	ldr	r3, [r7, #4]
340023e8:	681b      	ldr	r3, [r3, #0]
340023ea:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
340023ee:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* VSYNC Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE2);
#else
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE2);
340023f2:	2102      	movs	r1, #2
340023f4:	6878      	ldr	r0, [r7, #4]
340023f6:	f000 fd50 	bl	34002e9a <HAL_DCMIPP_PIPE_VsyncEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_FRAME) != 0U)
340023fa:	68fb      	ldr	r3, [r7, #12]
340023fc:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
34002400:	2b00      	cmp	r3, #0
34002402:	d023      	beq.n	3400244c <HAL_DCMIPP_IRQHandler+0x2e6>
  {
    if ((cmierflags & DCMIPP_IT_PIPE2_FRAME) != 0U)
34002404:	68bb      	ldr	r3, [r7, #8]
34002406:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
3400240a:	2b00      	cmp	r3, #0
3400240c:	d01e      	beq.n	3400244c <HAL_DCMIPP_IRQHandler+0x2e6>
    {
      /* When snapshot mode, disable Vsync, Error and Overrun interrupts */
      if ((hdcmipp->Instance->P2FCTCR & DCMIPP_P2FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400240e:	687b      	ldr	r3, [r7, #4]
34002410:	681b      	ldr	r3, [r3, #0]
34002412:	f8d3 3d00 	ldr.w	r3, [r3, #3328]	@ 0xd00
34002416:	f003 0304 	and.w	r3, r3, #4
3400241a:	2b04      	cmp	r3, #4
3400241c:	d10c      	bne.n	34002438 <HAL_DCMIPP_IRQHandler+0x2d2>
      {
        __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_FRAME | DCMIPP_IT_PIPE2_VSYNC | DCMIPP_IT_PIPE2_OVR);
3400241e:	687b      	ldr	r3, [r7, #4]
34002420:	681b      	ldr	r3, [r3, #0]
34002422:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34002426:	687b      	ldr	r3, [r7, #4]
34002428:	681b      	ldr	r3, [r3, #0]
3400242a:	f022 4206 	bic.w	r2, r2, #2248146944	@ 0x86000000
3400242e:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

        /* Update Pipe State */
        hdcmipp->PipeState[2] = HAL_DCMIPP_PIPE_STATE_READY;
34002432:	687b      	ldr	r3, [r7, #4]
34002434:	2201      	movs	r2, #1
34002436:	71da      	strb	r2, [r3, #7]
      }

      /* Clear the End of Frame flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_FRAME);
34002438:	687b      	ldr	r3, [r7, #4]
3400243a:	681b      	ldr	r3, [r3, #0]
3400243c:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
34002440:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Frame Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE2);
#else
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE2);
34002444:	2102      	movs	r1, #2
34002446:	6878      	ldr	r0, [r7, #4]
34002448:	f000 fd1c 	bl	34002e84 <HAL_DCMIPP_PIPE_FrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }
  /* Overrun error on the PIPE2 **************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_OVR) != 0U)
3400244c:	68fb      	ldr	r3, [r7, #12]
3400244e:	2b00      	cmp	r3, #0
34002450:	da1f      	bge.n	34002492 <HAL_DCMIPP_IRQHandler+0x32c>
  {
    if ((cmierflags & DCMIPP_IT_PIPE2_OVR) != 0U)
34002452:	68bb      	ldr	r3, [r7, #8]
34002454:	2b00      	cmp	r3, #0
34002456:	da1c      	bge.n	34002492 <HAL_DCMIPP_IRQHandler+0x32c>
    {
      /* Disable Overrun Error Interrupt for pipe1 */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_OVR);
34002458:	687b      	ldr	r3, [r7, #4]
3400245a:	681b      	ldr	r3, [r3, #0]
3400245c:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34002460:	687b      	ldr	r3, [r7, #4]
34002462:	681b      	ldr	r3, [r3, #0]
34002464:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
34002468:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE2_OVR;
3400246c:	687b      	ldr	r3, [r7, #4]
3400246e:	689b      	ldr	r3, [r3, #8]
34002470:	f043 0220 	orr.w	r2, r3, #32
34002474:	687b      	ldr	r3, [r7, #4]
34002476:	609a      	str	r2, [r3, #8]

      /* Clear the overrun error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_OVR);
34002478:	687b      	ldr	r3, [r7, #4]
3400247a:	681b      	ldr	r3, [r3, #0]
3400247c:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
34002480:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Change DCMIPP state */
      hdcmipp->PipeState[2] = HAL_DCMIPP_PIPE_STATE_ERROR;
34002484:	687b      	ldr	r3, [r7, #4]
34002486:	2204      	movs	r2, #4
34002488:	71da      	strb	r2, [r3, #7]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE2);
#else
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE2);
3400248a:	2102      	movs	r1, #2
3400248c:	6878      	ldr	r0, [r7, #4]
3400248e:	f000 fd25 	bl	34002edc <HAL_DCMIPP_PIPE_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Synchronization Error Interrupt on the parallel interface  **************/
  if ((cmsr2flags & DCMIPP_FLAG_PARALLEL_SYNC_ERROR) != 0U)
34002492:	68fb      	ldr	r3, [r7, #12]
34002494:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34002498:	2b00      	cmp	r3, #0
3400249a:	d01f      	beq.n	340024dc <HAL_DCMIPP_IRQHandler+0x376>
  {
    if ((cmierflags & DCMIPP_IT_PARALLEL_SYNC_ERROR) != 0U)
3400249c:	68bb      	ldr	r3, [r7, #8]
3400249e:	f003 0340 	and.w	r3, r3, #64	@ 0x40
340024a2:	2b00      	cmp	r3, #0
340024a4:	d01a      	beq.n	340024dc <HAL_DCMIPP_IRQHandler+0x376>
    {
      /* Disable Synchronization error interrupt on parallel interface */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PARALLEL_SYNC_ERROR);
340024a6:	687b      	ldr	r3, [r7, #4]
340024a8:	681b      	ldr	r3, [r3, #0]
340024aa:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
340024ae:	687b      	ldr	r3, [r7, #4]
340024b0:	681b      	ldr	r3, [r3, #0]
340024b2:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
340024b6:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PARALLEL_SYNC;
340024ba:	687b      	ldr	r3, [r7, #4]
340024bc:	689b      	ldr	r3, [r3, #8]
340024be:	f043 0202 	orr.w	r2, r3, #2
340024c2:	687b      	ldr	r3, [r7, #4]
340024c4:	609a      	str	r2, [r3, #8]

      /* Clear the synchronization error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PARALLEL_SYNC_ERROR);
340024c6:	687b      	ldr	r3, [r7, #4]
340024c8:	681b      	ldr	r3, [r3, #0]
340024ca:	2240      	movs	r2, #64	@ 0x40
340024cc:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Change DCMIPP state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
340024d0:	687b      	ldr	r3, [r7, #4]
340024d2:	2204      	movs	r2, #4
340024d4:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
340024d6:	6878      	ldr	r0, [r7, #4]
340024d8:	f000 fd0b 	bl	34002ef2 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* IPPLUG AXI transfer Error Interrupt     *********************************/
  if ((cmsr2flags & DCMIPP_FLAG_AXI_TRANSFER_ERROR) != 0U)
340024dc:	68fb      	ldr	r3, [r7, #12]
340024de:	f003 0320 	and.w	r3, r3, #32
340024e2:	2b00      	cmp	r3, #0
340024e4:	d01f      	beq.n	34002526 <HAL_DCMIPP_IRQHandler+0x3c0>
  {
    if ((cmierflags & DCMIPP_IT_AXI_TRANSFER_ERROR) != 0U)
340024e6:	68bb      	ldr	r3, [r7, #8]
340024e8:	f003 0320 	and.w	r3, r3, #32
340024ec:	2b00      	cmp	r3, #0
340024ee:	d01a      	beq.n	34002526 <HAL_DCMIPP_IRQHandler+0x3c0>
    {
      /* Disable IPPLUG AXI transfer Error Interrupt */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_AXI_TRANSFER_ERROR);
340024f0:	687b      	ldr	r3, [r7, #4]
340024f2:	681b      	ldr	r3, [r3, #0]
340024f4:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
340024f8:	687b      	ldr	r3, [r7, #4]
340024fa:	681b      	ldr	r3, [r3, #0]
340024fc:	f022 0220 	bic.w	r2, r2, #32
34002500:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_AXI_TRANSFER;
34002504:	687b      	ldr	r3, [r7, #4]
34002506:	689b      	ldr	r3, [r3, #8]
34002508:	f043 0201 	orr.w	r2, r3, #1
3400250c:	687b      	ldr	r3, [r7, #4]
3400250e:	609a      	str	r2, [r3, #8]

      /* Clear the AXI transfer error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_AXI_TRANSFER_ERROR);
34002510:	687b      	ldr	r3, [r7, #4]
34002512:	681b      	ldr	r3, [r3, #0]
34002514:	2220      	movs	r2, #32
34002516:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Change DCMIPP state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
3400251a:	687b      	ldr	r3, [r7, #4]
3400251c:	2204      	movs	r2, #4
3400251e:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34002520:	6878      	ldr	r0, [r7, #4]
34002522:	f000 fce6 	bl	34002ef2 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }
}
34002526:	bf00      	nop
34002528:	3710      	adds	r7, #16
3400252a:	46bd      	mov	sp, r7
3400252c:	bd80      	pop	{r7, pc}
	...

34002530 <HAL_DCMIPP_CSI_IRQHandler>:
  * @brief  Handles DCMIPP CSI interrupt request.
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval None
  */
void HAL_DCMIPP_CSI_IRQHandler(DCMIPP_HandleTypeDef *hdcmipp)
{
34002530:	b580      	push	{r7, lr}
34002532:	b088      	sub	sp, #32
34002534:	af00      	add	r7, sp, #0
34002536:	6078      	str	r0, [r7, #4]
  CSI_TypeDef *csi_instance;
  csi_instance = CSI;
34002538:	4bb1      	ldr	r3, [pc, #708]	@ (34002800 <HAL_DCMIPP_CSI_IRQHandler+0x2d0>)
3400253a:	61fb      	str	r3, [r7, #28]

  /* Read the SR0 register once */
  uint32_t sr0flags = READ_REG(csi_instance->SR0);
3400253c:	69fb      	ldr	r3, [r7, #28]
3400253e:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34002542:	61bb      	str	r3, [r7, #24]
  uint32_t sr1flags = READ_REG(csi_instance->SR1);
34002544:	69fb      	ldr	r3, [r7, #28]
34002546:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
3400254a:	617b      	str	r3, [r7, #20]

  uint32_t ier0_flags = READ_REG(csi_instance->IER0);
3400254c:	69fb      	ldr	r3, [r7, #28]
3400254e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34002552:	613b      	str	r3, [r7, #16]
  uint32_t ier1_flags = READ_REG(csi_instance->IER1);
34002554:	69fb      	ldr	r3, [r7, #28]
34002556:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
3400255a:	60fb      	str	r3, [r7, #12]

  /* Clock changer FIFO full event */
  if ((sr0flags & DCMIPP_CSI_FLAG_CCFIFO) != 0U)
3400255c:	69bb      	ldr	r3, [r7, #24]
3400255e:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
34002562:	2b00      	cmp	r3, #0
34002564:	d014      	beq.n	34002590 <HAL_DCMIPP_CSI_IRQHandler+0x60>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_CCFIFO) != 0U)
34002566:	693b      	ldr	r3, [r7, #16]
34002568:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
3400256c:	2b00      	cmp	r3, #0
3400256e:	d00f      	beq.n	34002590 <HAL_DCMIPP_CSI_IRQHandler+0x60>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CCFIFO);
34002570:	69fb      	ldr	r3, [r7, #28]
34002572:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34002576:	f423 1200 	bic.w	r2, r3, #2097152	@ 0x200000
3400257a:	69fb      	ldr	r3, [r7, #28]
3400257c:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_CCFIFO);
34002580:	69fb      	ldr	r3, [r7, #28]
34002582:	f44f 1200 	mov.w	r2, #2097152	@ 0x200000
34002586:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ClockChangerFifoFullEventCallback(hdcmipp);
#else
      HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback(hdcmipp);
3400258a:	6878      	ldr	r0, [r7, #4]
3400258c:	f000 fcc6 	bl	34002f1c <HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback>
  }

  /*###############################
     Byte/Line Counter Interrupt
  ##############################*/
  if ((sr0flags & DCMIPP_CSI_FLAG_LB3) != 0U)
34002590:	69bb      	ldr	r3, [r7, #24]
34002592:	f003 0308 	and.w	r3, r3, #8
34002596:	2b00      	cmp	r3, #0
34002598:	d01c      	beq.n	340025d4 <HAL_DCMIPP_CSI_IRQHandler+0xa4>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_LB3) != 0U)
3400259a:	693b      	ldr	r3, [r7, #16]
3400259c:	f003 0308 	and.w	r3, r3, #8
340025a0:	2b00      	cmp	r3, #0
340025a2:	d017      	beq.n	340025d4 <HAL_DCMIPP_CSI_IRQHandler+0xa4>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340025a4:	687b      	ldr	r3, [r7, #4]
340025a6:	681b      	ldr	r3, [r3, #0]
340025a8:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
340025ac:	f003 0304 	and.w	r3, r3, #4
340025b0:	2b04      	cmp	r3, #4
340025b2:	d107      	bne.n	340025c4 <HAL_DCMIPP_CSI_IRQHandler+0x94>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB3);
340025b4:	69fb      	ldr	r3, [r7, #28]
340025b6:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340025ba:	f023 0208 	bic.w	r2, r3, #8
340025be:	69fb      	ldr	r3, [r7, #28]
340025c0:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB3);
340025c4:	69fb      	ldr	r3, [r7, #28]
340025c6:	2208      	movs	r2, #8
340025c8:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* LineByte Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER3);
#else
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER3);
340025cc:	2103      	movs	r1, #3
340025ce:	6878      	ldr	r0, [r7, #4]
340025d0:	f000 fcd9 	bl	34002f86 <HAL_DCMIPP_CSI_LineByteEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_LB2) != 0U)
340025d4:	69bb      	ldr	r3, [r7, #24]
340025d6:	f003 0304 	and.w	r3, r3, #4
340025da:	2b00      	cmp	r3, #0
340025dc:	d01c      	beq.n	34002618 <HAL_DCMIPP_CSI_IRQHandler+0xe8>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_LB2) != 0U)
340025de:	693b      	ldr	r3, [r7, #16]
340025e0:	f003 0304 	and.w	r3, r3, #4
340025e4:	2b00      	cmp	r3, #0
340025e6:	d017      	beq.n	34002618 <HAL_DCMIPP_CSI_IRQHandler+0xe8>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340025e8:	687b      	ldr	r3, [r7, #4]
340025ea:	681b      	ldr	r3, [r3, #0]
340025ec:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
340025f0:	f003 0304 	and.w	r3, r3, #4
340025f4:	2b04      	cmp	r3, #4
340025f6:	d107      	bne.n	34002608 <HAL_DCMIPP_CSI_IRQHandler+0xd8>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB2);
340025f8:	69fb      	ldr	r3, [r7, #28]
340025fa:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340025fe:	f023 0204 	bic.w	r2, r3, #4
34002602:	69fb      	ldr	r3, [r7, #28]
34002604:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB2);
34002608:	69fb      	ldr	r3, [r7, #28]
3400260a:	2204      	movs	r2, #4
3400260c:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* LineByte Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER2);
#else
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER2);
34002610:	2102      	movs	r1, #2
34002612:	6878      	ldr	r0, [r7, #4]
34002614:	f000 fcb7 	bl	34002f86 <HAL_DCMIPP_CSI_LineByteEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_LB1) != 0U)
34002618:	69bb      	ldr	r3, [r7, #24]
3400261a:	f003 0302 	and.w	r3, r3, #2
3400261e:	2b00      	cmp	r3, #0
34002620:	d01c      	beq.n	3400265c <HAL_DCMIPP_CSI_IRQHandler+0x12c>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_LB1) != 0U)
34002622:	693b      	ldr	r3, [r7, #16]
34002624:	f003 0302 	and.w	r3, r3, #2
34002628:	2b00      	cmp	r3, #0
3400262a:	d017      	beq.n	3400265c <HAL_DCMIPP_CSI_IRQHandler+0x12c>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400262c:	687b      	ldr	r3, [r7, #4]
3400262e:	681b      	ldr	r3, [r3, #0]
34002630:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34002634:	f003 0304 	and.w	r3, r3, #4
34002638:	2b04      	cmp	r3, #4
3400263a:	d107      	bne.n	3400264c <HAL_DCMIPP_CSI_IRQHandler+0x11c>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB1);
3400263c:	69fb      	ldr	r3, [r7, #28]
3400263e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34002642:	f023 0202 	bic.w	r2, r3, #2
34002646:	69fb      	ldr	r3, [r7, #28]
34002648:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB1);
3400264c:	69fb      	ldr	r3, [r7, #28]
3400264e:	2202      	movs	r2, #2
34002650:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* LineByte Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER1);
#else
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER1);
34002654:	2101      	movs	r1, #1
34002656:	6878      	ldr	r0, [r7, #4]
34002658:	f000 fc95 	bl	34002f86 <HAL_DCMIPP_CSI_LineByteEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_LB0) != 0U)
3400265c:	69bb      	ldr	r3, [r7, #24]
3400265e:	f003 0301 	and.w	r3, r3, #1
34002662:	2b00      	cmp	r3, #0
34002664:	d01c      	beq.n	340026a0 <HAL_DCMIPP_CSI_IRQHandler+0x170>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_LB0) != 0U)
34002666:	693b      	ldr	r3, [r7, #16]
34002668:	f003 0301 	and.w	r3, r3, #1
3400266c:	2b00      	cmp	r3, #0
3400266e:	d017      	beq.n	340026a0 <HAL_DCMIPP_CSI_IRQHandler+0x170>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34002670:	687b      	ldr	r3, [r7, #4]
34002672:	681b      	ldr	r3, [r3, #0]
34002674:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34002678:	f003 0304 	and.w	r3, r3, #4
3400267c:	2b04      	cmp	r3, #4
3400267e:	d107      	bne.n	34002690 <HAL_DCMIPP_CSI_IRQHandler+0x160>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB0);
34002680:	69fb      	ldr	r3, [r7, #28]
34002682:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34002686:	f023 0201 	bic.w	r2, r3, #1
3400268a:	69fb      	ldr	r3, [r7, #28]
3400268c:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB0);
34002690:	69fb      	ldr	r3, [r7, #28]
34002692:	2201      	movs	r2, #1
34002694:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* LineByte Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER0);
#else
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER0);
34002698:	2100      	movs	r1, #0
3400269a:	6878      	ldr	r0, [r7, #4]
3400269c:	f000 fc73 	bl	34002f86 <HAL_DCMIPP_CSI_LineByteEventCallback>
  }

  /*###############################
            End Of Frame
    ##############################*/
  if ((sr0flags & DCMIPP_CSI_FLAG_EOF3) != 0U)
340026a0:	69bb      	ldr	r3, [r7, #24]
340026a2:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
340026a6:	2b00      	cmp	r3, #0
340026a8:	d01d      	beq.n	340026e6 <HAL_DCMIPP_CSI_IRQHandler+0x1b6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_EOF3) != 0U)
340026aa:	693b      	ldr	r3, [r7, #16]
340026ac:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
340026b0:	2b00      	cmp	r3, #0
340026b2:	d018      	beq.n	340026e6 <HAL_DCMIPP_CSI_IRQHandler+0x1b6>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340026b4:	687b      	ldr	r3, [r7, #4]
340026b6:	681b      	ldr	r3, [r3, #0]
340026b8:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
340026bc:	f003 0304 	and.w	r3, r3, #4
340026c0:	2b04      	cmp	r3, #4
340026c2:	d107      	bne.n	340026d4 <HAL_DCMIPP_CSI_IRQHandler+0x1a4>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF3);
340026c4:	69fb      	ldr	r3, [r7, #28]
340026c6:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340026ca:	f423 4200 	bic.w	r2, r3, #32768	@ 0x8000
340026ce:	69fb      	ldr	r3, [r7, #28]
340026d0:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF3);
340026d4:	69fb      	ldr	r3, [r7, #28]
340026d6:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
340026da:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
#else
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
340026de:	2103      	movs	r1, #3
340026e0:	6878      	ldr	r0, [r7, #4]
340026e2:	f000 fc2f 	bl	34002f44 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_EOF2) != 0U)
340026e6:	69bb      	ldr	r3, [r7, #24]
340026e8:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
340026ec:	2b00      	cmp	r3, #0
340026ee:	d01d      	beq.n	3400272c <HAL_DCMIPP_CSI_IRQHandler+0x1fc>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_EOF2) != 0U)
340026f0:	693b      	ldr	r3, [r7, #16]
340026f2:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
340026f6:	2b00      	cmp	r3, #0
340026f8:	d018      	beq.n	3400272c <HAL_DCMIPP_CSI_IRQHandler+0x1fc>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340026fa:	687b      	ldr	r3, [r7, #4]
340026fc:	681b      	ldr	r3, [r3, #0]
340026fe:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34002702:	f003 0304 	and.w	r3, r3, #4
34002706:	2b04      	cmp	r3, #4
34002708:	d107      	bne.n	3400271a <HAL_DCMIPP_CSI_IRQHandler+0x1ea>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF2);
3400270a:	69fb      	ldr	r3, [r7, #28]
3400270c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34002710:	f423 4280 	bic.w	r2, r3, #16384	@ 0x4000
34002714:	69fb      	ldr	r3, [r7, #28]
34002716:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF2);
3400271a:	69fb      	ldr	r3, [r7, #28]
3400271c:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
34002720:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
#else
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
34002724:	2102      	movs	r1, #2
34002726:	6878      	ldr	r0, [r7, #4]
34002728:	f000 fc0c 	bl	34002f44 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_EOF1) != 0U)
3400272c:	69bb      	ldr	r3, [r7, #24]
3400272e:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
34002732:	2b00      	cmp	r3, #0
34002734:	d01d      	beq.n	34002772 <HAL_DCMIPP_CSI_IRQHandler+0x242>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_EOF1) != 0U)
34002736:	693b      	ldr	r3, [r7, #16]
34002738:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
3400273c:	2b00      	cmp	r3, #0
3400273e:	d018      	beq.n	34002772 <HAL_DCMIPP_CSI_IRQHandler+0x242>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34002740:	687b      	ldr	r3, [r7, #4]
34002742:	681b      	ldr	r3, [r3, #0]
34002744:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34002748:	f003 0304 	and.w	r3, r3, #4
3400274c:	2b04      	cmp	r3, #4
3400274e:	d107      	bne.n	34002760 <HAL_DCMIPP_CSI_IRQHandler+0x230>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF1);
34002750:	69fb      	ldr	r3, [r7, #28]
34002752:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34002756:	f423 5200 	bic.w	r2, r3, #8192	@ 0x2000
3400275a:	69fb      	ldr	r3, [r7, #28]
3400275c:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF1);
34002760:	69fb      	ldr	r3, [r7, #28]
34002762:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
34002766:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
#else
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
3400276a:	2101      	movs	r1, #1
3400276c:	6878      	ldr	r0, [r7, #4]
3400276e:	f000 fbe9 	bl	34002f44 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_EOF0) != 0U)
34002772:	69bb      	ldr	r3, [r7, #24]
34002774:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
34002778:	2b00      	cmp	r3, #0
3400277a:	d01d      	beq.n	340027b8 <HAL_DCMIPP_CSI_IRQHandler+0x288>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_EOF0) != 0U)
3400277c:	693b      	ldr	r3, [r7, #16]
3400277e:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
34002782:	2b00      	cmp	r3, #0
34002784:	d018      	beq.n	340027b8 <HAL_DCMIPP_CSI_IRQHandler+0x288>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34002786:	687b      	ldr	r3, [r7, #4]
34002788:	681b      	ldr	r3, [r3, #0]
3400278a:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
3400278e:	f003 0304 	and.w	r3, r3, #4
34002792:	2b04      	cmp	r3, #4
34002794:	d107      	bne.n	340027a6 <HAL_DCMIPP_CSI_IRQHandler+0x276>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF0);
34002796:	69fb      	ldr	r3, [r7, #28]
34002798:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400279c:	f423 5280 	bic.w	r2, r3, #4096	@ 0x1000
340027a0:	69fb      	ldr	r3, [r7, #28]
340027a2:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF0);
340027a6:	69fb      	ldr	r3, [r7, #28]
340027a8:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
340027ac:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_CSIREGISTER_CALLBACKS == 1)
      hdcmipp->EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
#else
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
340027b0:	2100      	movs	r1, #0
340027b2:	6878      	ldr	r0, [r7, #4]
340027b4:	f000 fbc6 	bl	34002f44 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
  }

  /*###############################
           Start Of Frame
  ##############################*/
  if ((sr0flags & DCMIPP_CSI_FLAG_SOF3) != 0U)
340027b8:	69bb      	ldr	r3, [r7, #24]
340027ba:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
340027be:	2b00      	cmp	r3, #0
340027c0:	d020      	beq.n	34002804 <HAL_DCMIPP_CSI_IRQHandler+0x2d4>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SOF3) != 0U)
340027c2:	693b      	ldr	r3, [r7, #16]
340027c4:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
340027c8:	2b00      	cmp	r3, #0
340027ca:	d01b      	beq.n	34002804 <HAL_DCMIPP_CSI_IRQHandler+0x2d4>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340027cc:	687b      	ldr	r3, [r7, #4]
340027ce:	681b      	ldr	r3, [r3, #0]
340027d0:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
340027d4:	f003 0304 	and.w	r3, r3, #4
340027d8:	2b04      	cmp	r3, #4
340027da:	d107      	bne.n	340027ec <HAL_DCMIPP_CSI_IRQHandler+0x2bc>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF3);
340027dc:	69fb      	ldr	r3, [r7, #28]
340027de:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340027e2:	f423 6200 	bic.w	r2, r3, #2048	@ 0x800
340027e6:	69fb      	ldr	r3, [r7, #28]
340027e8:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF3);
340027ec:	69fb      	ldr	r3, [r7, #28]
340027ee:	f44f 6200 	mov.w	r2, #2048	@ 0x800
340027f2:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
#else
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
340027f6:	2103      	movs	r1, #3
340027f8:	6878      	ldr	r0, [r7, #4]
340027fa:	f000 fbae 	bl	34002f5a <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
340027fe:	e001      	b.n	34002804 <HAL_DCMIPP_CSI_IRQHandler+0x2d4>
34002800:	58006000 	.word	0x58006000
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_SOF2) != 0U)
34002804:	69bb      	ldr	r3, [r7, #24]
34002806:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3400280a:	2b00      	cmp	r3, #0
3400280c:	d01d      	beq.n	3400284a <HAL_DCMIPP_CSI_IRQHandler+0x31a>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SOF2) != 0U)
3400280e:	693b      	ldr	r3, [r7, #16]
34002810:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34002814:	2b00      	cmp	r3, #0
34002816:	d018      	beq.n	3400284a <HAL_DCMIPP_CSI_IRQHandler+0x31a>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34002818:	687b      	ldr	r3, [r7, #4]
3400281a:	681b      	ldr	r3, [r3, #0]
3400281c:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34002820:	f003 0304 	and.w	r3, r3, #4
34002824:	2b04      	cmp	r3, #4
34002826:	d107      	bne.n	34002838 <HAL_DCMIPP_CSI_IRQHandler+0x308>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF2);
34002828:	69fb      	ldr	r3, [r7, #28]
3400282a:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400282e:	f423 6280 	bic.w	r2, r3, #1024	@ 0x400
34002832:	69fb      	ldr	r3, [r7, #28]
34002834:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF2);
34002838:	69fb      	ldr	r3, [r7, #28]
3400283a:	f44f 6280 	mov.w	r2, #1024	@ 0x400
3400283e:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
#else
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
34002842:	2102      	movs	r1, #2
34002844:	6878      	ldr	r0, [r7, #4]
34002846:	f000 fb88 	bl	34002f5a <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_SOF1) != 0U)
3400284a:	69bb      	ldr	r3, [r7, #24]
3400284c:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34002850:	2b00      	cmp	r3, #0
34002852:	d01d      	beq.n	34002890 <HAL_DCMIPP_CSI_IRQHandler+0x360>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SOF1) != 0U)
34002854:	693b      	ldr	r3, [r7, #16]
34002856:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3400285a:	2b00      	cmp	r3, #0
3400285c:	d018      	beq.n	34002890 <HAL_DCMIPP_CSI_IRQHandler+0x360>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400285e:	687b      	ldr	r3, [r7, #4]
34002860:	681b      	ldr	r3, [r3, #0]
34002862:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34002866:	f003 0304 	and.w	r3, r3, #4
3400286a:	2b04      	cmp	r3, #4
3400286c:	d107      	bne.n	3400287e <HAL_DCMIPP_CSI_IRQHandler+0x34e>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF1);
3400286e:	69fb      	ldr	r3, [r7, #28]
34002870:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34002874:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
34002878:	69fb      	ldr	r3, [r7, #28]
3400287a:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF1);
3400287e:	69fb      	ldr	r3, [r7, #28]
34002880:	f44f 7200 	mov.w	r2, #512	@ 0x200
34002884:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
#else
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
34002888:	2101      	movs	r1, #1
3400288a:	6878      	ldr	r0, [r7, #4]
3400288c:	f000 fb65 	bl	34002f5a <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_SOF0) != 0U)
34002890:	69bb      	ldr	r3, [r7, #24]
34002892:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34002896:	2b00      	cmp	r3, #0
34002898:	d01d      	beq.n	340028d6 <HAL_DCMIPP_CSI_IRQHandler+0x3a6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SOF0) != 0U)
3400289a:	693b      	ldr	r3, [r7, #16]
3400289c:	f403 7380 	and.w	r3, r3, #256	@ 0x100
340028a0:	2b00      	cmp	r3, #0
340028a2:	d018      	beq.n	340028d6 <HAL_DCMIPP_CSI_IRQHandler+0x3a6>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340028a4:	687b      	ldr	r3, [r7, #4]
340028a6:	681b      	ldr	r3, [r3, #0]
340028a8:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
340028ac:	f003 0304 	and.w	r3, r3, #4
340028b0:	2b04      	cmp	r3, #4
340028b2:	d107      	bne.n	340028c4 <HAL_DCMIPP_CSI_IRQHandler+0x394>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF0);
340028b4:	69fb      	ldr	r3, [r7, #28]
340028b6:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340028ba:	f423 7280 	bic.w	r2, r3, #256	@ 0x100
340028be:	69fb      	ldr	r3, [r7, #28]
340028c0:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF0);
340028c4:	69fb      	ldr	r3, [r7, #28]
340028c6:	f44f 7280 	mov.w	r2, #256	@ 0x100
340028ca:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
#else
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
340028ce:	2100      	movs	r1, #0
340028d0:	6878      	ldr	r0, [r7, #4]
340028d2:	f000 fb42 	bl	34002f5a <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
  }

  /*###############################
           Timer Interrupt
  ##############################*/
  if ((sr0flags & DCMIPP_CSI_FLAG_TIM3) != 0U)
340028d6:	69bb      	ldr	r3, [r7, #24]
340028d8:	f003 0380 	and.w	r3, r3, #128	@ 0x80
340028dc:	2b00      	cmp	r3, #0
340028de:	d01c      	beq.n	3400291a <HAL_DCMIPP_CSI_IRQHandler+0x3ea>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_TIM3) != 0U)
340028e0:	693b      	ldr	r3, [r7, #16]
340028e2:	f003 0380 	and.w	r3, r3, #128	@ 0x80
340028e6:	2b00      	cmp	r3, #0
340028e8:	d017      	beq.n	3400291a <HAL_DCMIPP_CSI_IRQHandler+0x3ea>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340028ea:	687b      	ldr	r3, [r7, #4]
340028ec:	681b      	ldr	r3, [r3, #0]
340028ee:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
340028f2:	f003 0304 	and.w	r3, r3, #4
340028f6:	2b04      	cmp	r3, #4
340028f8:	d107      	bne.n	3400290a <HAL_DCMIPP_CSI_IRQHandler+0x3da>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM3);
340028fa:	69fb      	ldr	r3, [r7, #28]
340028fc:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34002900:	f023 0280 	bic.w	r2, r3, #128	@ 0x80
34002904:	69fb      	ldr	r3, [r7, #28]
34002906:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM3);
3400290a:	69fb      	ldr	r3, [r7, #28]
3400290c:	2280      	movs	r2, #128	@ 0x80
3400290e:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER3);
#else
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER3);
34002912:	2103      	movs	r1, #3
34002914:	6878      	ldr	r0, [r7, #4]
34002916:	f000 fb2b 	bl	34002f70 <HAL_DCMIPP_CSI_TimerCounterEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_TIM2) != 0U)
3400291a:	69bb      	ldr	r3, [r7, #24]
3400291c:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34002920:	2b00      	cmp	r3, #0
34002922:	d01c      	beq.n	3400295e <HAL_DCMIPP_CSI_IRQHandler+0x42e>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_TIM2) != 0U)
34002924:	693b      	ldr	r3, [r7, #16]
34002926:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3400292a:	2b00      	cmp	r3, #0
3400292c:	d017      	beq.n	3400295e <HAL_DCMIPP_CSI_IRQHandler+0x42e>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400292e:	687b      	ldr	r3, [r7, #4]
34002930:	681b      	ldr	r3, [r3, #0]
34002932:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34002936:	f003 0304 	and.w	r3, r3, #4
3400293a:	2b04      	cmp	r3, #4
3400293c:	d107      	bne.n	3400294e <HAL_DCMIPP_CSI_IRQHandler+0x41e>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM2);
3400293e:	69fb      	ldr	r3, [r7, #28]
34002940:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34002944:	f023 0240 	bic.w	r2, r3, #64	@ 0x40
34002948:	69fb      	ldr	r3, [r7, #28]
3400294a:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM2);
3400294e:	69fb      	ldr	r3, [r7, #28]
34002950:	2240      	movs	r2, #64	@ 0x40
34002952:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER2);
#else
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER2);
34002956:	2102      	movs	r1, #2
34002958:	6878      	ldr	r0, [r7, #4]
3400295a:	f000 fb09 	bl	34002f70 <HAL_DCMIPP_CSI_TimerCounterEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_TIM1) != 0U)
3400295e:	69bb      	ldr	r3, [r7, #24]
34002960:	f003 0320 	and.w	r3, r3, #32
34002964:	2b00      	cmp	r3, #0
34002966:	d01c      	beq.n	340029a2 <HAL_DCMIPP_CSI_IRQHandler+0x472>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_TIM1) != 0U)
34002968:	693b      	ldr	r3, [r7, #16]
3400296a:	f003 0320 	and.w	r3, r3, #32
3400296e:	2b00      	cmp	r3, #0
34002970:	d017      	beq.n	340029a2 <HAL_DCMIPP_CSI_IRQHandler+0x472>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34002972:	687b      	ldr	r3, [r7, #4]
34002974:	681b      	ldr	r3, [r3, #0]
34002976:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
3400297a:	f003 0304 	and.w	r3, r3, #4
3400297e:	2b04      	cmp	r3, #4
34002980:	d107      	bne.n	34002992 <HAL_DCMIPP_CSI_IRQHandler+0x462>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM1);
34002982:	69fb      	ldr	r3, [r7, #28]
34002984:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34002988:	f023 0220 	bic.w	r2, r3, #32
3400298c:	69fb      	ldr	r3, [r7, #28]
3400298e:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM1);
34002992:	69fb      	ldr	r3, [r7, #28]
34002994:	2220      	movs	r2, #32
34002996:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER1);
#else
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER1);
3400299a:	2101      	movs	r1, #1
3400299c:	6878      	ldr	r0, [r7, #4]
3400299e:	f000 fae7 	bl	34002f70 <HAL_DCMIPP_CSI_TimerCounterEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_TIM0) != 0U)
340029a2:	69bb      	ldr	r3, [r7, #24]
340029a4:	f003 0310 	and.w	r3, r3, #16
340029a8:	2b00      	cmp	r3, #0
340029aa:	d01c      	beq.n	340029e6 <HAL_DCMIPP_CSI_IRQHandler+0x4b6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_TIM0) != 0U)
340029ac:	693b      	ldr	r3, [r7, #16]
340029ae:	f003 0310 	and.w	r3, r3, #16
340029b2:	2b00      	cmp	r3, #0
340029b4:	d017      	beq.n	340029e6 <HAL_DCMIPP_CSI_IRQHandler+0x4b6>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
340029b6:	687b      	ldr	r3, [r7, #4]
340029b8:	681b      	ldr	r3, [r3, #0]
340029ba:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
340029be:	f003 0304 	and.w	r3, r3, #4
340029c2:	2b04      	cmp	r3, #4
340029c4:	d107      	bne.n	340029d6 <HAL_DCMIPP_CSI_IRQHandler+0x4a6>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM0);
340029c6:	69fb      	ldr	r3, [r7, #28]
340029c8:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340029cc:	f023 0210 	bic.w	r2, r3, #16
340029d0:	69fb      	ldr	r3, [r7, #28]
340029d2:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM0);
340029d6:	69fb      	ldr	r3, [r7, #28]
340029d8:	2210      	movs	r2, #16
340029da:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER0);
#else
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER0);
340029de:	2100      	movs	r1, #0
340029e0:	6878      	ldr	r0, [r7, #4]
340029e2:	f000 fac5 	bl	34002f70 <HAL_DCMIPP_CSI_TimerCounterEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Synchronization error  */
  if ((sr0flags & DCMIPP_CSI_FLAG_SYNCERR) != 0U)
340029e6:	69bb      	ldr	r3, [r7, #24]
340029e8:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
340029ec:	2b00      	cmp	r3, #0
340029ee:	d01a      	beq.n	34002a26 <HAL_DCMIPP_CSI_IRQHandler+0x4f6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SYNCERR) != 0U)
340029f0:	693b      	ldr	r3, [r7, #16]
340029f2:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
340029f6:	2b00      	cmp	r3, #0
340029f8:	d015      	beq.n	34002a26 <HAL_DCMIPP_CSI_IRQHandler+0x4f6>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SYNCERR);
340029fa:	69fb      	ldr	r3, [r7, #28]
340029fc:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34002a00:	f023 4280 	bic.w	r2, r3, #1073741824	@ 0x40000000
34002a04:	69fb      	ldr	r3, [r7, #28]
34002a06:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SYNCERR);
34002a0a:	69fb      	ldr	r3, [r7, #28]
34002a0c:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
34002a10:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SYNC;
34002a14:	687b      	ldr	r3, [r7, #4]
34002a16:	689b      	ldr	r3, [r3, #8]
34002a18:	f443 7280 	orr.w	r2, r3, #256	@ 0x100
34002a1c:	687b      	ldr	r3, [r7, #4]
34002a1e:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34002a20:	6878      	ldr	r0, [r7, #4]
34002a22:	f000 fa66 	bl	34002ef2 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_WDERR) != 0U)
34002a26:	69bb      	ldr	r3, [r7, #24]
34002a28:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
34002a2c:	2b00      	cmp	r3, #0
34002a2e:	d01a      	beq.n	34002a66 <HAL_DCMIPP_CSI_IRQHandler+0x536>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_WDERR) != 0U)
34002a30:	693b      	ldr	r3, [r7, #16]
34002a32:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
34002a36:	2b00      	cmp	r3, #0
34002a38:	d015      	beq.n	34002a66 <HAL_DCMIPP_CSI_IRQHandler+0x536>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_WDERR);
34002a3a:	69fb      	ldr	r3, [r7, #28]
34002a3c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34002a40:	f023 5200 	bic.w	r2, r3, #536870912	@ 0x20000000
34002a44:	69fb      	ldr	r3, [r7, #28]
34002a46:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_WDERR);
34002a4a:	69fb      	ldr	r3, [r7, #28]
34002a4c:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
34002a50:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_WDG;
34002a54:	687b      	ldr	r3, [r7, #4]
34002a56:	689b      	ldr	r3, [r3, #8]
34002a58:	f443 7200 	orr.w	r2, r3, #512	@ 0x200
34002a5c:	687b      	ldr	r3, [r7, #4]
34002a5e:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34002a60:	6878      	ldr	r0, [r7, #4]
34002a62:	f000 fa46 	bl	34002ef2 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_SPKTERR) != 0U)
34002a66:	69bb      	ldr	r3, [r7, #24]
34002a68:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
34002a6c:	2b00      	cmp	r3, #0
34002a6e:	d01a      	beq.n	34002aa6 <HAL_DCMIPP_CSI_IRQHandler+0x576>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SPKTERR) != 0U)
34002a70:	693b      	ldr	r3, [r7, #16]
34002a72:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
34002a76:	2b00      	cmp	r3, #0
34002a78:	d015      	beq.n	34002aa6 <HAL_DCMIPP_CSI_IRQHandler+0x576>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SPKTERR);
34002a7a:	69fb      	ldr	r3, [r7, #28]
34002a7c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34002a80:	f023 5280 	bic.w	r2, r3, #268435456	@ 0x10000000
34002a84:	69fb      	ldr	r3, [r7, #28]
34002a86:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SPKTERR);
34002a8a:	69fb      	ldr	r3, [r7, #28]
34002a8c:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
34002a90:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SPKT;
34002a94:	687b      	ldr	r3, [r7, #4]
34002a96:	689b      	ldr	r3, [r3, #8]
34002a98:	f443 6280 	orr.w	r2, r3, #1024	@ 0x400
34002a9c:	687b      	ldr	r3, [r7, #4]
34002a9e:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34002aa0:	6878      	ldr	r0, [r7, #4]
34002aa2:	f000 fa26 	bl	34002ef2 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_IDERR) != 0U)
34002aa6:	69bb      	ldr	r3, [r7, #24]
34002aa8:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34002aac:	2b00      	cmp	r3, #0
34002aae:	d01a      	beq.n	34002ae6 <HAL_DCMIPP_CSI_IRQHandler+0x5b6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_IDERR) != 0U)
34002ab0:	693b      	ldr	r3, [r7, #16]
34002ab2:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34002ab6:	2b00      	cmp	r3, #0
34002ab8:	d015      	beq.n	34002ae6 <HAL_DCMIPP_CSI_IRQHandler+0x5b6>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_IDERR);
34002aba:	69fb      	ldr	r3, [r7, #28]
34002abc:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34002ac0:	f023 6200 	bic.w	r2, r3, #134217728	@ 0x8000000
34002ac4:	69fb      	ldr	r3, [r7, #28]
34002ac6:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_IDERR);
34002aca:	69fb      	ldr	r3, [r7, #28]
34002acc:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
34002ad0:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DATA_ID;
34002ad4:	687b      	ldr	r3, [r7, #4]
34002ad6:	689b      	ldr	r3, [r3, #8]
34002ad8:	f443 6200 	orr.w	r2, r3, #2048	@ 0x800
34002adc:	687b      	ldr	r3, [r7, #4]
34002ade:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34002ae0:	6878      	ldr	r0, [r7, #4]
34002ae2:	f000 fa06 	bl	34002ef2 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_CECCERR) != 0U)
34002ae6:	69bb      	ldr	r3, [r7, #24]
34002ae8:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
34002aec:	2b00      	cmp	r3, #0
34002aee:	d01a      	beq.n	34002b26 <HAL_DCMIPP_CSI_IRQHandler+0x5f6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_CECCERR) != 0U)
34002af0:	693b      	ldr	r3, [r7, #16]
34002af2:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
34002af6:	2b00      	cmp	r3, #0
34002af8:	d015      	beq.n	34002b26 <HAL_DCMIPP_CSI_IRQHandler+0x5f6>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CECCERR);
34002afa:	69fb      	ldr	r3, [r7, #28]
34002afc:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34002b00:	f023 6280 	bic.w	r2, r3, #67108864	@ 0x4000000
34002b04:	69fb      	ldr	r3, [r7, #28]
34002b06:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_CECCERR);
34002b0a:	69fb      	ldr	r3, [r7, #28]
34002b0c:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
34002b10:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_CECC;
34002b14:	687b      	ldr	r3, [r7, #4]
34002b16:	689b      	ldr	r3, [r3, #8]
34002b18:	f443 5280 	orr.w	r2, r3, #4096	@ 0x1000
34002b1c:	687b      	ldr	r3, [r7, #4]
34002b1e:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34002b20:	6878      	ldr	r0, [r7, #4]
34002b22:	f000 f9e6 	bl	34002ef2 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_ECCERR) != 0U)
34002b26:	69bb      	ldr	r3, [r7, #24]
34002b28:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
34002b2c:	2b00      	cmp	r3, #0
34002b2e:	d01a      	beq.n	34002b66 <HAL_DCMIPP_CSI_IRQHandler+0x636>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_ECCERR) != 0U)
34002b30:	693b      	ldr	r3, [r7, #16]
34002b32:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
34002b36:	2b00      	cmp	r3, #0
34002b38:	d015      	beq.n	34002b66 <HAL_DCMIPP_CSI_IRQHandler+0x636>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECCERR);
34002b3a:	69fb      	ldr	r3, [r7, #28]
34002b3c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34002b40:	f023 7200 	bic.w	r2, r3, #33554432	@ 0x2000000
34002b44:	69fb      	ldr	r3, [r7, #28]
34002b46:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_ECCERR);
34002b4a:	69fb      	ldr	r3, [r7, #28]
34002b4c:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
34002b50:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_ECC;
34002b54:	687b      	ldr	r3, [r7, #4]
34002b56:	689b      	ldr	r3, [r3, #8]
34002b58:	f443 5200 	orr.w	r2, r3, #8192	@ 0x2000
34002b5c:	687b      	ldr	r3, [r7, #4]
34002b5e:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34002b60:	6878      	ldr	r0, [r7, #4]
34002b62:	f000 f9c6 	bl	34002ef2 <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_CRCERR) != 0U)
34002b66:	69bb      	ldr	r3, [r7, #24]
34002b68:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
34002b6c:	2b00      	cmp	r3, #0
34002b6e:	d01a      	beq.n	34002ba6 <HAL_DCMIPP_CSI_IRQHandler+0x676>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_CRCERR) != 0U)
34002b70:	693b      	ldr	r3, [r7, #16]
34002b72:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
34002b76:	2b00      	cmp	r3, #0
34002b78:	d015      	beq.n	34002ba6 <HAL_DCMIPP_CSI_IRQHandler+0x676>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CRCERR);
34002b7a:	69fb      	ldr	r3, [r7, #28]
34002b7c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34002b80:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
34002b84:	69fb      	ldr	r3, [r7, #28]
34002b86:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_CRCERR);
34002b8a:	69fb      	ldr	r3, [r7, #28]
34002b8c:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
34002b90:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_CRC;
34002b94:	687b      	ldr	r3, [r7, #4]
34002b96:	689b      	ldr	r3, [r3, #8]
34002b98:	f443 4280 	orr.w	r2, r3, #16384	@ 0x4000
34002b9c:	687b      	ldr	r3, [r7, #4]
34002b9e:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34002ba0:	6878      	ldr	r0, [r7, #4]
34002ba2:	f000 f9a6 	bl	34002ef2 <HAL_DCMIPP_ErrorCallback>
    }
  }

  /* Lane 0 Errors */
  /* Start Of Transmission error  */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTDL0) != 0U)
34002ba6:	697b      	ldr	r3, [r7, #20]
34002ba8:	f003 0301 	and.w	r3, r3, #1
34002bac:	2b00      	cmp	r3, #0
34002bae:	d01d      	beq.n	34002bec <HAL_DCMIPP_CSI_IRQHandler+0x6bc>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTDL0) != 0U)
34002bb0:	68fb      	ldr	r3, [r7, #12]
34002bb2:	f003 0301 	and.w	r3, r3, #1
34002bb6:	2b00      	cmp	r3, #0
34002bb8:	d018      	beq.n	34002bec <HAL_DCMIPP_CSI_IRQHandler+0x6bc>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL0);
34002bba:	69fb      	ldr	r3, [r7, #28]
34002bbc:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34002bc0:	f023 0201 	bic.w	r2, r3, #1
34002bc4:	69fb      	ldr	r3, [r7, #28]
34002bc6:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTDL0);
34002bca:	69fb      	ldr	r3, [r7, #28]
34002bcc:	2201      	movs	r2, #1
34002bce:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT;
34002bd2:	687b      	ldr	r3, [r7, #4]
34002bd4:	689b      	ldr	r3, [r3, #8]
34002bd6:	f443 2200 	orr.w	r2, r3, #524288	@ 0x80000
34002bda:	687b      	ldr	r3, [r7, #4]
34002bdc:	609a      	str	r2, [r3, #8]

      /* Change CSI state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34002bde:	687b      	ldr	r3, [r7, #4]
34002be0:	2204      	movs	r2, #4
34002be2:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34002be4:	2101      	movs	r1, #1
34002be6:	6878      	ldr	r0, [r7, #4]
34002be8:	f000 f98d 	bl	34002f06 <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Start Of Transmission Synchronisation error   */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTSYNCDL0) != 0U)
34002bec:	697b      	ldr	r3, [r7, #20]
34002bee:	f003 0302 	and.w	r3, r3, #2
34002bf2:	2b00      	cmp	r3, #0
34002bf4:	d01d      	beq.n	34002c32 <HAL_DCMIPP_CSI_IRQHandler+0x702>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTSYNCDL0) != 0U)
34002bf6:	68fb      	ldr	r3, [r7, #12]
34002bf8:	f003 0302 	and.w	r3, r3, #2
34002bfc:	2b00      	cmp	r3, #0
34002bfe:	d018      	beq.n	34002c32 <HAL_DCMIPP_CSI_IRQHandler+0x702>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTSYNCDL0);
34002c00:	69fb      	ldr	r3, [r7, #28]
34002c02:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34002c06:	f023 0202 	bic.w	r2, r3, #2
34002c0a:	69fb      	ldr	r3, [r7, #28]
34002c0c:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTSYNCDL0);
34002c10:	69fb      	ldr	r3, [r7, #28]
34002c12:	2202      	movs	r2, #2
34002c14:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT_SYNC;
34002c18:	687b      	ldr	r3, [r7, #4]
34002c1a:	689b      	ldr	r3, [r3, #8]
34002c1c:	f443 2280 	orr.w	r2, r3, #262144	@ 0x40000
34002c20:	687b      	ldr	r3, [r7, #4]
34002c22:	609a      	str	r2, [r3, #8]

      /* Change CSI state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34002c24:	687b      	ldr	r3, [r7, #4]
34002c26:	2204      	movs	r2, #4
34002c28:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34002c2a:	2101      	movs	r1, #1
34002c2c:	6878      	ldr	r0, [r7, #4]
34002c2e:	f000 f96a 	bl	34002f06 <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Escape entry error   */
  if ((sr1flags & DCMIPP_CSI_FLAG_EESCDL0) != 0U)
34002c32:	697b      	ldr	r3, [r7, #20]
34002c34:	f003 0304 	and.w	r3, r3, #4
34002c38:	2b00      	cmp	r3, #0
34002c3a:	d01a      	beq.n	34002c72 <HAL_DCMIPP_CSI_IRQHandler+0x742>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_EESCDL0) != 0U)
34002c3c:	68fb      	ldr	r3, [r7, #12]
34002c3e:	f003 0304 	and.w	r3, r3, #4
34002c42:	2b00      	cmp	r3, #0
34002c44:	d015      	beq.n	34002c72 <HAL_DCMIPP_CSI_IRQHandler+0x742>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EESCDL0);
34002c46:	69fb      	ldr	r3, [r7, #28]
34002c48:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34002c4c:	f023 0204 	bic.w	r2, r3, #4
34002c50:	69fb      	ldr	r3, [r7, #28]
34002c52:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_EESCDL0);
34002c56:	69fb      	ldr	r3, [r7, #28]
34002c58:	2204      	movs	r2, #4
34002c5a:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_ESCAPE;
34002c5e:	687b      	ldr	r3, [r7, #4]
34002c60:	689b      	ldr	r3, [r3, #8]
34002c62:	f443 3200 	orr.w	r2, r3, #131072	@ 0x20000
34002c66:	687b      	ldr	r3, [r7, #4]
34002c68:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34002c6a:	2101      	movs	r1, #1
34002c6c:	6878      	ldr	r0, [r7, #4]
34002c6e:	f000 f94a 	bl	34002f06 <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Low power data transmission synchronization error  */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESYNCESCDL0) != 0U)
34002c72:	697b      	ldr	r3, [r7, #20]
34002c74:	f003 0308 	and.w	r3, r3, #8
34002c78:	2b00      	cmp	r3, #0
34002c7a:	d01a      	beq.n	34002cb2 <HAL_DCMIPP_CSI_IRQHandler+0x782>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESYNCESCDL0) != 0U)
34002c7c:	68fb      	ldr	r3, [r7, #12]
34002c7e:	f003 0308 	and.w	r3, r3, #8
34002c82:	2b00      	cmp	r3, #0
34002c84:	d015      	beq.n	34002cb2 <HAL_DCMIPP_CSI_IRQHandler+0x782>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESYNCESCDL0);
34002c86:	69fb      	ldr	r3, [r7, #28]
34002c88:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34002c8c:	f023 0208 	bic.w	r2, r3, #8
34002c90:	69fb      	ldr	r3, [r7, #28]
34002c92:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESYNCESCDL0);
34002c96:	69fb      	ldr	r3, [r7, #28]
34002c98:	2208      	movs	r2, #8
34002c9a:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_LP_SYNC;
34002c9e:	687b      	ldr	r3, [r7, #4]
34002ca0:	689b      	ldr	r3, [r3, #8]
34002ca2:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
34002ca6:	687b      	ldr	r3, [r7, #4]
34002ca8:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34002caa:	2101      	movs	r1, #1
34002cac:	6878      	ldr	r0, [r7, #4]
34002cae:	f000 f92a 	bl	34002f06 <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Error control on data line */
  if ((sr1flags & DCMIPP_CSI_FLAG_ECTRLDL0) != 0U)
34002cb2:	697b      	ldr	r3, [r7, #20]
34002cb4:	f003 0310 	and.w	r3, r3, #16
34002cb8:	2b00      	cmp	r3, #0
34002cba:	d01a      	beq.n	34002cf2 <HAL_DCMIPP_CSI_IRQHandler+0x7c2>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ECTRLDL0) != 0U)
34002cbc:	68fb      	ldr	r3, [r7, #12]
34002cbe:	f003 0310 	and.w	r3, r3, #16
34002cc2:	2b00      	cmp	r3, #0
34002cc4:	d015      	beq.n	34002cf2 <HAL_DCMIPP_CSI_IRQHandler+0x7c2>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECTRLDL0);
34002cc6:	69fb      	ldr	r3, [r7, #28]
34002cc8:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34002ccc:	f023 0210 	bic.w	r2, r3, #16
34002cd0:	69fb      	ldr	r3, [r7, #28]
34002cd2:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ECTRLDL0);
34002cd6:	69fb      	ldr	r3, [r7, #28]
34002cd8:	2210      	movs	r2, #16
34002cda:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_CTRL;
34002cde:	687b      	ldr	r3, [r7, #4]
34002ce0:	689b      	ldr	r3, [r3, #8]
34002ce2:	f443 4200 	orr.w	r2, r3, #32768	@ 0x8000
34002ce6:	687b      	ldr	r3, [r7, #4]
34002ce8:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34002cea:	2101      	movs	r1, #1
34002cec:	6878      	ldr	r0, [r7, #4]
34002cee:	f000 f90a 	bl	34002f06 <HAL_DCMIPP_CSI_LineErrorCallback>
    }
  }

  /* Lane 1 Errors */
  /* Start Of Transmission error  */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTDL1) != 0U)
34002cf2:	697b      	ldr	r3, [r7, #20]
34002cf4:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34002cf8:	2b00      	cmp	r3, #0
34002cfa:	d01e      	beq.n	34002d3a <HAL_DCMIPP_CSI_IRQHandler+0x80a>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTDL1) != 0U)
34002cfc:	68fb      	ldr	r3, [r7, #12]
34002cfe:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34002d02:	2b00      	cmp	r3, #0
34002d04:	d019      	beq.n	34002d3a <HAL_DCMIPP_CSI_IRQHandler+0x80a>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1);
34002d06:	69fb      	ldr	r3, [r7, #28]
34002d08:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34002d0c:	f423 7280 	bic.w	r2, r3, #256	@ 0x100
34002d10:	69fb      	ldr	r3, [r7, #28]
34002d12:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTDL1);
34002d16:	69fb      	ldr	r3, [r7, #28]
34002d18:	f44f 7280 	mov.w	r2, #256	@ 0x100
34002d1c:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT;
34002d20:	687b      	ldr	r3, [r7, #4]
34002d22:	689b      	ldr	r3, [r3, #8]
34002d24:	f443 2200 	orr.w	r2, r3, #524288	@ 0x80000
34002d28:	687b      	ldr	r3, [r7, #4]
34002d2a:	609a      	str	r2, [r3, #8]

      /* Change CSI state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34002d2c:	687b      	ldr	r3, [r7, #4]
34002d2e:	2204      	movs	r2, #4
34002d30:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34002d32:	2102      	movs	r1, #2
34002d34:	6878      	ldr	r0, [r7, #4]
34002d36:	f000 f8e6 	bl	34002f06 <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Start Of Transmission Synchronisation error   */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTSYNCDL1) != 0U)
34002d3a:	697b      	ldr	r3, [r7, #20]
34002d3c:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34002d40:	2b00      	cmp	r3, #0
34002d42:	d01e      	beq.n	34002d82 <HAL_DCMIPP_CSI_IRQHandler+0x852>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTSYNCDL1) != 0U)
34002d44:	68fb      	ldr	r3, [r7, #12]
34002d46:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34002d4a:	2b00      	cmp	r3, #0
34002d4c:	d019      	beq.n	34002d82 <HAL_DCMIPP_CSI_IRQHandler+0x852>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTSYNCDL1);
34002d4e:	69fb      	ldr	r3, [r7, #28]
34002d50:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34002d54:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
34002d58:	69fb      	ldr	r3, [r7, #28]
34002d5a:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTSYNCDL1);
34002d5e:	69fb      	ldr	r3, [r7, #28]
34002d60:	f44f 7200 	mov.w	r2, #512	@ 0x200
34002d64:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT_SYNC;
34002d68:	687b      	ldr	r3, [r7, #4]
34002d6a:	689b      	ldr	r3, [r3, #8]
34002d6c:	f443 2280 	orr.w	r2, r3, #262144	@ 0x40000
34002d70:	687b      	ldr	r3, [r7, #4]
34002d72:	609a      	str	r2, [r3, #8]

      /* Change CSI state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34002d74:	687b      	ldr	r3, [r7, #4]
34002d76:	2204      	movs	r2, #4
34002d78:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34002d7a:	2102      	movs	r1, #2
34002d7c:	6878      	ldr	r0, [r7, #4]
34002d7e:	f000 f8c2 	bl	34002f06 <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Escape entry error   */
  if ((sr1flags & DCMIPP_CSI_FLAG_EESCDL1) != 0U)
34002d82:	697b      	ldr	r3, [r7, #20]
34002d84:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34002d88:	2b00      	cmp	r3, #0
34002d8a:	d01b      	beq.n	34002dc4 <HAL_DCMIPP_CSI_IRQHandler+0x894>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_EESCDL1) != 0U)
34002d8c:	68fb      	ldr	r3, [r7, #12]
34002d8e:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34002d92:	2b00      	cmp	r3, #0
34002d94:	d016      	beq.n	34002dc4 <HAL_DCMIPP_CSI_IRQHandler+0x894>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EESCDL1);
34002d96:	69fb      	ldr	r3, [r7, #28]
34002d98:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34002d9c:	f423 6280 	bic.w	r2, r3, #1024	@ 0x400
34002da0:	69fb      	ldr	r3, [r7, #28]
34002da2:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_EESCDL1);
34002da6:	69fb      	ldr	r3, [r7, #28]
34002da8:	f44f 6280 	mov.w	r2, #1024	@ 0x400
34002dac:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_ESCAPE;
34002db0:	687b      	ldr	r3, [r7, #4]
34002db2:	689b      	ldr	r3, [r3, #8]
34002db4:	f443 3200 	orr.w	r2, r3, #131072	@ 0x20000
34002db8:	687b      	ldr	r3, [r7, #4]
34002dba:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34002dbc:	2102      	movs	r1, #2
34002dbe:	6878      	ldr	r0, [r7, #4]
34002dc0:	f000 f8a1 	bl	34002f06 <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Low power data transmission synchronization error  */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESYNCESCDL1) != 0U)
34002dc4:	697b      	ldr	r3, [r7, #20]
34002dc6:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34002dca:	2b00      	cmp	r3, #0
34002dcc:	d01b      	beq.n	34002e06 <HAL_DCMIPP_CSI_IRQHandler+0x8d6>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESYNCESCDL1) != 0U)
34002dce:	68fb      	ldr	r3, [r7, #12]
34002dd0:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34002dd4:	2b00      	cmp	r3, #0
34002dd6:	d016      	beq.n	34002e06 <HAL_DCMIPP_CSI_IRQHandler+0x8d6>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESYNCESCDL1);
34002dd8:	69fb      	ldr	r3, [r7, #28]
34002dda:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34002dde:	f423 6200 	bic.w	r2, r3, #2048	@ 0x800
34002de2:	69fb      	ldr	r3, [r7, #28]
34002de4:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESYNCESCDL1);
34002de8:	69fb      	ldr	r3, [r7, #28]
34002dea:	f44f 6200 	mov.w	r2, #2048	@ 0x800
34002dee:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_LP_SYNC;
34002df2:	687b      	ldr	r3, [r7, #4]
34002df4:	689b      	ldr	r3, [r3, #8]
34002df6:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
34002dfa:	687b      	ldr	r3, [r7, #4]
34002dfc:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34002dfe:	2102      	movs	r1, #2
34002e00:	6878      	ldr	r0, [r7, #4]
34002e02:	f000 f880 	bl	34002f06 <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Error control on data line */
  if ((sr1flags & DCMIPP_CSI_IT_ECTRLDL1) != 0U)
34002e06:	697b      	ldr	r3, [r7, #20]
34002e08:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
34002e0c:	2b00      	cmp	r3, #0
34002e0e:	d01b      	beq.n	34002e48 <HAL_DCMIPP_CSI_IRQHandler+0x918>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ECTRLDL1) != 0U)
34002e10:	68fb      	ldr	r3, [r7, #12]
34002e12:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
34002e16:	2b00      	cmp	r3, #0
34002e18:	d016      	beq.n	34002e48 <HAL_DCMIPP_CSI_IRQHandler+0x918>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECTRLDL1);
34002e1a:	69fb      	ldr	r3, [r7, #28]
34002e1c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34002e20:	f423 5280 	bic.w	r2, r3, #4096	@ 0x1000
34002e24:	69fb      	ldr	r3, [r7, #28]
34002e26:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_IT_ECTRLDL1);
34002e2a:	69fb      	ldr	r3, [r7, #28]
34002e2c:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
34002e30:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_CTRL;
34002e34:	687b      	ldr	r3, [r7, #4]
34002e36:	689b      	ldr	r3, [r3, #8]
34002e38:	f443 4200 	orr.w	r2, r3, #32768	@ 0x8000
34002e3c:	687b      	ldr	r3, [r7, #4]
34002e3e:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34002e40:	2102      	movs	r1, #2
34002e42:	6878      	ldr	r0, [r7, #4]
34002e44:	f000 f85f 	bl	34002f06 <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_SPKT) != 0U)
34002e48:	69bb      	ldr	r3, [r7, #24]
34002e4a:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34002e4e:	2b00      	cmp	r3, #0
34002e50:	d014      	beq.n	34002e7c <HAL_DCMIPP_CSI_IRQHandler+0x94c>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SPKT) != 0U)
34002e52:	693b      	ldr	r3, [r7, #16]
34002e54:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34002e58:	2b00      	cmp	r3, #0
34002e5a:	d00f      	beq.n	34002e7c <HAL_DCMIPP_CSI_IRQHandler+0x94c>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SPKT);
34002e5c:	69fb      	ldr	r3, [r7, #28]
34002e5e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34002e62:	f423 3280 	bic.w	r2, r3, #65536	@ 0x10000
34002e66:	69fb      	ldr	r3, [r7, #28]
34002e68:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SPKT);
34002e6c:	69fb      	ldr	r3, [r7, #28]
34002e6e:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
34002e72:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ShortPacketDetectionEventCallback(hdcmipp);
#else
      HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback(hdcmipp);
34002e76:	6878      	ldr	r0, [r7, #4]
34002e78:	f000 f85a 	bl	34002f30 <HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }
}
34002e7c:	bf00      	nop
34002e7e:	3720      	adds	r7, #32
34002e80:	46bd      	mov	sp, r7
34002e82:	bd80      	pop	{r7, pc}

34002e84 <HAL_DCMIPP_PIPE_FrameEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval None
  */
__weak void HAL_DCMIPP_PIPE_FrameEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34002e84:	b480      	push	{r7}
34002e86:	b083      	sub	sp, #12
34002e88:	af00      	add	r7, sp, #0
34002e8a:	6078      	str	r0, [r7, #4]
34002e8c:	6039      	str	r1, [r7, #0]
            the HAL_DCMIPP_FrameEventDumpPipeCallback could be implemented in the user file
   */
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Pipe);
  UNUSED(hdcmipp);
}
34002e8e:	bf00      	nop
34002e90:	370c      	adds	r7, #12
34002e92:	46bd      	mov	sp, r7
34002e94:	f85d 7b04 	ldr.w	r7, [sp], #4
34002e98:	4770      	bx	lr

34002e9a <HAL_DCMIPP_PIPE_VsyncEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval None
  */
__weak void HAL_DCMIPP_PIPE_VsyncEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34002e9a:	b480      	push	{r7}
34002e9c:	b083      	sub	sp, #12
34002e9e:	af00      	add	r7, sp, #0
34002ea0:	6078      	str	r0, [r7, #4]
34002ea2:	6039      	str	r1, [r7, #0]
            the HAL_DCMIPP_VsyncEventDumpPipeCallback could be implemented in the user file
   */
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Pipe);
  UNUSED(hdcmipp);
}
34002ea4:	bf00      	nop
34002ea6:	370c      	adds	r7, #12
34002ea8:	46bd      	mov	sp, r7
34002eaa:	f85d 7b04 	ldr.w	r7, [sp], #4
34002eae:	4770      	bx	lr

34002eb0 <HAL_DCMIPP_PIPE_LineEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval None
  */
__weak void HAL_DCMIPP_PIPE_LineEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34002eb0:	b480      	push	{r7}
34002eb2:	b083      	sub	sp, #12
34002eb4:	af00      	add	r7, sp, #0
34002eb6:	6078      	str	r0, [r7, #4]
34002eb8:	6039      	str	r1, [r7, #0]
            the HAL_DCMIPP_LineEventMainPipeCallback could be implemented in the user file
   */
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Pipe);
  UNUSED(hdcmipp);
}
34002eba:	bf00      	nop
34002ebc:	370c      	adds	r7, #12
34002ebe:	46bd      	mov	sp, r7
34002ec0:	f85d 7b04 	ldr.w	r7, [sp], #4
34002ec4:	4770      	bx	lr

34002ec6 <HAL_DCMIPP_PIPE_LimitEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval None
  */
__weak void HAL_DCMIPP_PIPE_LimitEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34002ec6:	b480      	push	{r7}
34002ec8:	b083      	sub	sp, #12
34002eca:	af00      	add	r7, sp, #0
34002ecc:	6078      	str	r0, [r7, #4]
34002ece:	6039      	str	r1, [r7, #0]
            the HAL_DCMIPP_LimitEventDumpPipeCallback could be implemented in the user file
   */
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Pipe);
  UNUSED(hdcmipp);
}
34002ed0:	bf00      	nop
34002ed2:	370c      	adds	r7, #12
34002ed4:	46bd      	mov	sp, r7
34002ed6:	f85d 7b04 	ldr.w	r7, [sp], #4
34002eda:	4770      	bx	lr

34002edc <HAL_DCMIPP_PIPE_ErrorCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval None
  */
__weak void HAL_DCMIPP_PIPE_ErrorCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34002edc:	b480      	push	{r7}
34002ede:	b083      	sub	sp, #12
34002ee0:	af00      	add	r7, sp, #0
34002ee2:	6078      	str	r0, [r7, #4]
34002ee4:	6039      	str	r1, [r7, #0]
            the HAL_DCMIPP_SyncErrorEventCallback could be implemented in the user file
   */
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Pipe);
  UNUSED(hdcmipp);
}
34002ee6:	bf00      	nop
34002ee8:	370c      	adds	r7, #12
34002eea:	46bd      	mov	sp, r7
34002eec:	f85d 7b04 	ldr.w	r7, [sp], #4
34002ef0:	4770      	bx	lr

34002ef2 <HAL_DCMIPP_ErrorCallback>:
  * @brief  Error callback on DCMIPP
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval None
  */
__weak void HAL_DCMIPP_ErrorCallback(DCMIPP_HandleTypeDef *hdcmipp)
{
34002ef2:	b480      	push	{r7}
34002ef4:	b083      	sub	sp, #12
34002ef6:	af00      	add	r7, sp, #0
34002ef8:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_ErrorCallback could be implemented in the user file
   */
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hdcmipp);
}
34002efa:	bf00      	nop
34002efc:	370c      	adds	r7, #12
34002efe:	46bd      	mov	sp, r7
34002f00:	f85d 7b04 	ldr.w	r7, [sp], #4
34002f04:	4770      	bx	lr

34002f06 <HAL_DCMIPP_CSI_LineErrorCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  DataLane
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_LineErrorCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t DataLane)
{
34002f06:	b480      	push	{r7}
34002f08:	b083      	sub	sp, #12
34002f0a:	af00      	add	r7, sp, #0
34002f0c:	6078      	str	r0, [r7, #4]
34002f0e:	6039      	str	r1, [r7, #0]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_LineErrorCallback could be implemented in the user file
   */
  UNUSED(DataLane);
  UNUSED(hdcmipp);
}
34002f10:	bf00      	nop
34002f12:	370c      	adds	r7, #12
34002f14:	46bd      	mov	sp, r7
34002f16:	f85d 7b04 	ldr.w	r7, [sp], #4
34002f1a:	4770      	bx	lr

34002f1c <HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback>:
  * @brief  Clock Changer Fifo Full Event Callback
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback(DCMIPP_HandleTypeDef *hdcmipp)
{
34002f1c:	b480      	push	{r7}
34002f1e:	b083      	sub	sp, #12
34002f20:	af00      	add	r7, sp, #0
34002f22:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback could be implemented in the user file
   */
  UNUSED(hdcmipp);
}
34002f24:	bf00      	nop
34002f26:	370c      	adds	r7, #12
34002f28:	46bd      	mov	sp, r7
34002f2a:	f85d 7b04 	ldr.w	r7, [sp], #4
34002f2e:	4770      	bx	lr

34002f30 <HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback>:
  * @brief  Short Packet Detection Event Callback
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback(DCMIPP_HandleTypeDef *hdcmipp)
{
34002f30:	b480      	push	{r7}
34002f32:	b083      	sub	sp, #12
34002f34:	af00      	add	r7, sp, #0
34002f36:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback could be implemented in the user file
   */
  UNUSED(hdcmipp);
}
34002f38:	bf00      	nop
34002f3a:	370c      	adds	r7, #12
34002f3c:	46bd      	mov	sp, r7
34002f3e:	f85d 7b04 	ldr.w	r7, [sp], #4
34002f42:	4770      	bx	lr

34002f44 <HAL_DCMIPP_CSI_EndOfFrameEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  VirtualChannel
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_EndOfFrameEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t VirtualChannel)
{
34002f44:	b480      	push	{r7}
34002f46:	b083      	sub	sp, #12
34002f48:	af00      	add	r7, sp, #0
34002f4a:	6078      	str	r0, [r7, #4]
34002f4c:	6039      	str	r1, [r7, #0]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_EndOfFrameEventCallback could be implemented in the user file
   */
  UNUSED(hdcmipp);
  UNUSED(VirtualChannel);
}
34002f4e:	bf00      	nop
34002f50:	370c      	adds	r7, #12
34002f52:	46bd      	mov	sp, r7
34002f54:	f85d 7b04 	ldr.w	r7, [sp], #4
34002f58:	4770      	bx	lr

34002f5a <HAL_DCMIPP_CSI_StartOfFrameEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  VirtualChannel
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_StartOfFrameEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t VirtualChannel)
{
34002f5a:	b480      	push	{r7}
34002f5c:	b083      	sub	sp, #12
34002f5e:	af00      	add	r7, sp, #0
34002f60:	6078      	str	r0, [r7, #4]
34002f62:	6039      	str	r1, [r7, #0]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_StartOfFrameEventCallback could be implemented in the user file
   */
  UNUSED(hdcmipp);
  UNUSED(VirtualChannel);
}
34002f64:	bf00      	nop
34002f66:	370c      	adds	r7, #12
34002f68:	46bd      	mov	sp, r7
34002f6a:	f85d 7b04 	ldr.w	r7, [sp], #4
34002f6e:	4770      	bx	lr

34002f70 <HAL_DCMIPP_CSI_TimerCounterEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Timer
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_TimerCounterEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Timer)
{
34002f70:	b480      	push	{r7}
34002f72:	b083      	sub	sp, #12
34002f74:	af00      	add	r7, sp, #0
34002f76:	6078      	str	r0, [r7, #4]
34002f78:	6039      	str	r1, [r7, #0]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_TimerCounterEventCallback could be implemented in the user file
   */
  UNUSED(hdcmipp);
  UNUSED(Timer);
}
34002f7a:	bf00      	nop
34002f7c:	370c      	adds	r7, #12
34002f7e:	46bd      	mov	sp, r7
34002f80:	f85d 7b04 	ldr.w	r7, [sp], #4
34002f84:	4770      	bx	lr

34002f86 <HAL_DCMIPP_CSI_LineByteEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Counter
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_LineByteEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Counter)
{
34002f86:	b480      	push	{r7}
34002f88:	b083      	sub	sp, #12
34002f8a:	af00      	add	r7, sp, #0
34002f8c:	6078      	str	r0, [r7, #4]
34002f8e:	6039      	str	r1, [r7, #0]
  /* NOTE : This function Should not be modified, when the callback is needed,
          the HAL_DCMIPP_CSI_LineByteEventCallback could be implemented in the user file
  */
  UNUSED(hdcmipp);
  UNUSED(Counter);
}
34002f90:	bf00      	nop
34002f92:	370c      	adds	r7, #12
34002f94:	46bd      	mov	sp, r7
34002f96:	f85d 7b04 	ldr.w	r7, [sp], #4
34002f9a:	4770      	bx	lr

34002f9c <Pipe_Config>:
  * @param  pPipeConfig pointer to the DCMIPP_PipeConfTypeDef structure that contains
  *                     the configuration information for the pipe.
  * @retval None
  */
static void Pipe_Config(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe, const DCMIPP_PipeConfTypeDef *pPipeConfig)
{
34002f9c:	b480      	push	{r7}
34002f9e:	b085      	sub	sp, #20
34002fa0:	af00      	add	r7, sp, #0
34002fa2:	60f8      	str	r0, [r7, #12]
34002fa4:	60b9      	str	r1, [r7, #8]
34002fa6:	607a      	str	r2, [r7, #4]
  if (Pipe == DCMIPP_PIPE0)
34002fa8:	68bb      	ldr	r3, [r7, #8]
34002faa:	2b00      	cmp	r3, #0
34002fac:	d10d      	bne.n	34002fca <Pipe_Config+0x2e>
  {
    /* Configure Pipe0 */
    /* Configure Frame Rate */
    MODIFY_REG(hdcmipp->Instance->P0FCTCR, DCMIPP_P0FCTCR_FRATE, pPipeConfig->FrameRate);
34002fae:	68fb      	ldr	r3, [r7, #12]
34002fb0:	681b      	ldr	r3, [r3, #0]
34002fb2:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34002fb6:	f023 0103 	bic.w	r1, r3, #3
34002fba:	687b      	ldr	r3, [r7, #4]
34002fbc:	681a      	ldr	r2, [r3, #0]
34002fbe:	68fb      	ldr	r3, [r7, #12]
34002fc0:	681b      	ldr	r3, [r3, #0]
34002fc2:	430a      	orrs	r2, r1
34002fc4:	f8c3 2500 	str.w	r2, [r3, #1280]	@ 0x500

    /* Configure Pixel Pipe Pitch */
    MODIFY_REG(hdcmipp->Instance->P2PPM0PR, DCMIPP_P2PPM0PR_PITCH,
               pPipeConfig->PixelPipePitch << DCMIPP_P2PPM0PR_PITCH_Pos);
  }
}
34002fc8:	e081      	b.n	340030ce <Pipe_Config+0x132>
  else if (Pipe == DCMIPP_PIPE1)
34002fca:	68bb      	ldr	r3, [r7, #8]
34002fcc:	2b01      	cmp	r3, #1
34002fce:	d155      	bne.n	3400307c <Pipe_Config+0xe0>
    MODIFY_REG(hdcmipp->Instance->P1FCTCR, DCMIPP_P1FCTCR_FRATE, pPipeConfig->FrameRate);
34002fd0:	68fb      	ldr	r3, [r7, #12]
34002fd2:	681b      	ldr	r3, [r3, #0]
34002fd4:	f8d3 3900 	ldr.w	r3, [r3, #2304]	@ 0x900
34002fd8:	f023 0103 	bic.w	r1, r3, #3
34002fdc:	687b      	ldr	r3, [r7, #4]
34002fde:	681a      	ldr	r2, [r3, #0]
34002fe0:	68fb      	ldr	r3, [r7, #12]
34002fe2:	681b      	ldr	r3, [r3, #0]
34002fe4:	430a      	orrs	r2, r1
34002fe6:	f8c3 2900 	str.w	r2, [r3, #2304]	@ 0x900
    MODIFY_REG(hdcmipp->Instance->P1PPCR, DCMIPP_P1PPCR_FORMAT, pPipeConfig->PixelPackerFormat);
34002fea:	68fb      	ldr	r3, [r7, #12]
34002fec:	681b      	ldr	r3, [r3, #0]
34002fee:	f8d3 39c0 	ldr.w	r3, [r3, #2496]	@ 0x9c0
34002ff2:	f023 010f 	bic.w	r1, r3, #15
34002ff6:	687b      	ldr	r3, [r7, #4]
34002ff8:	689a      	ldr	r2, [r3, #8]
34002ffa:	68fb      	ldr	r3, [r7, #12]
34002ffc:	681b      	ldr	r3, [r3, #0]
34002ffe:	430a      	orrs	r2, r1
34003000:	f8c3 29c0 	str.w	r2, [r3, #2496]	@ 0x9c0
    MODIFY_REG(hdcmipp->Instance->P1PPM0PR, DCMIPP_P1PPM0PR_PITCH,
34003004:	68fb      	ldr	r3, [r7, #12]
34003006:	681b      	ldr	r3, [r3, #0]
34003008:	f8d3 39cc 	ldr.w	r3, [r3, #2508]	@ 0x9cc
3400300c:	f423 43ff 	bic.w	r3, r3, #32640	@ 0x7f80
34003010:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
34003014:	687a      	ldr	r2, [r7, #4]
34003016:	6851      	ldr	r1, [r2, #4]
34003018:	68fa      	ldr	r2, [r7, #12]
3400301a:	6812      	ldr	r2, [r2, #0]
3400301c:	430b      	orrs	r3, r1
3400301e:	f8c2 39cc 	str.w	r3, [r2, #2508]	@ 0x9cc
    if ((pPipeConfig->PixelPackerFormat == DCMIPP_PIXEL_PACKER_FORMAT_YUV422_2) ||
34003022:	687b      	ldr	r3, [r7, #4]
34003024:	689b      	ldr	r3, [r3, #8]
34003026:	2b07      	cmp	r3, #7
34003028:	d003      	beq.n	34003032 <Pipe_Config+0x96>
        (pPipeConfig->PixelPackerFormat == DCMIPP_PIXEL_PACKER_FORMAT_YUV420_2))
3400302a:	687b      	ldr	r3, [r7, #4]
3400302c:	689b      	ldr	r3, [r3, #8]
    if ((pPipeConfig->PixelPackerFormat == DCMIPP_PIXEL_PACKER_FORMAT_YUV422_2) ||
3400302e:	2b08      	cmp	r3, #8
34003030:	d10f      	bne.n	34003052 <Pipe_Config+0xb6>
      MODIFY_REG(hdcmipp->Instance->P1PPM1PR, DCMIPP_P1PPM1PR_PITCH,
34003032:	68fb      	ldr	r3, [r7, #12]
34003034:	681b      	ldr	r3, [r3, #0]
34003036:	f8d3 39dc 	ldr.w	r3, [r3, #2524]	@ 0x9dc
3400303a:	f423 43ff 	bic.w	r3, r3, #32640	@ 0x7f80
3400303e:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
34003042:	687a      	ldr	r2, [r7, #4]
34003044:	6851      	ldr	r1, [r2, #4]
34003046:	68fa      	ldr	r2, [r7, #12]
34003048:	6812      	ldr	r2, [r2, #0]
3400304a:	430b      	orrs	r3, r1
3400304c:	f8c2 39dc 	str.w	r3, [r2, #2524]	@ 0x9dc
}
34003050:	e03d      	b.n	340030ce <Pipe_Config+0x132>
    else if (pPipeConfig->PixelPackerFormat == DCMIPP_PIXEL_PACKER_FORMAT_YUV420_3)
34003052:	687b      	ldr	r3, [r7, #4]
34003054:	689b      	ldr	r3, [r3, #8]
34003056:	2b09      	cmp	r3, #9
34003058:	d139      	bne.n	340030ce <Pipe_Config+0x132>
      MODIFY_REG(hdcmipp->Instance->P1PPM1PR, DCMIPP_P1PPM1PR_PITCH,
3400305a:	68fb      	ldr	r3, [r7, #12]
3400305c:	681b      	ldr	r3, [r3, #0]
3400305e:	f8d3 39dc 	ldr.w	r3, [r3, #2524]	@ 0x9dc
34003062:	f423 43ff 	bic.w	r3, r3, #32640	@ 0x7f80
34003066:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
3400306a:	687a      	ldr	r2, [r7, #4]
3400306c:	6852      	ldr	r2, [r2, #4]
3400306e:	0851      	lsrs	r1, r2, #1
34003070:	68fa      	ldr	r2, [r7, #12]
34003072:	6812      	ldr	r2, [r2, #0]
34003074:	430b      	orrs	r3, r1
34003076:	f8c2 39dc 	str.w	r3, [r2, #2524]	@ 0x9dc
}
3400307a:	e028      	b.n	340030ce <Pipe_Config+0x132>
    MODIFY_REG(hdcmipp->Instance->P2FCTCR, DCMIPP_P2FCTCR_FRATE, pPipeConfig->FrameRate);
3400307c:	68fb      	ldr	r3, [r7, #12]
3400307e:	681b      	ldr	r3, [r3, #0]
34003080:	f8d3 3d00 	ldr.w	r3, [r3, #3328]	@ 0xd00
34003084:	f023 0103 	bic.w	r1, r3, #3
34003088:	687b      	ldr	r3, [r7, #4]
3400308a:	681a      	ldr	r2, [r3, #0]
3400308c:	68fb      	ldr	r3, [r7, #12]
3400308e:	681b      	ldr	r3, [r3, #0]
34003090:	430a      	orrs	r2, r1
34003092:	f8c3 2d00 	str.w	r2, [r3, #3328]	@ 0xd00
    MODIFY_REG(hdcmipp->Instance->P2PPCR, DCMIPP_P2PPCR_FORMAT, pPipeConfig->PixelPackerFormat);
34003096:	68fb      	ldr	r3, [r7, #12]
34003098:	681b      	ldr	r3, [r3, #0]
3400309a:	f8d3 3dc0 	ldr.w	r3, [r3, #3520]	@ 0xdc0
3400309e:	f023 010f 	bic.w	r1, r3, #15
340030a2:	687b      	ldr	r3, [r7, #4]
340030a4:	689a      	ldr	r2, [r3, #8]
340030a6:	68fb      	ldr	r3, [r7, #12]
340030a8:	681b      	ldr	r3, [r3, #0]
340030aa:	430a      	orrs	r2, r1
340030ac:	f8c3 2dc0 	str.w	r2, [r3, #3520]	@ 0xdc0
    MODIFY_REG(hdcmipp->Instance->P2PPM0PR, DCMIPP_P2PPM0PR_PITCH,
340030b0:	68fb      	ldr	r3, [r7, #12]
340030b2:	681b      	ldr	r3, [r3, #0]
340030b4:	f8d3 3dcc 	ldr.w	r3, [r3, #3532]	@ 0xdcc
340030b8:	f423 43ff 	bic.w	r3, r3, #32640	@ 0x7f80
340030bc:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
340030c0:	687a      	ldr	r2, [r7, #4]
340030c2:	6851      	ldr	r1, [r2, #4]
340030c4:	68fa      	ldr	r2, [r7, #12]
340030c6:	6812      	ldr	r2, [r2, #0]
340030c8:	430b      	orrs	r3, r1
340030ca:	f8c2 3dcc 	str.w	r3, [r2, #3532]	@ 0xdcc
}
340030ce:	bf00      	nop
340030d0:	3714      	adds	r7, #20
340030d2:	46bd      	mov	sp, r7
340030d4:	f85d 7b04 	ldr.w	r7, [sp], #4
340030d8:	4770      	bx	lr

340030da <DCMIPP_CSI_WritePHYReg>:
  * @param  reg_lsb specifies the testcode LSB in testdin
  * @param  val     specifies the page offset in testdin
  * @retval None
  */
static void DCMIPP_CSI_WritePHYReg(CSI_TypeDef *hcsi, uint32_t reg_msb, uint32_t reg_lsb, uint32_t val)
{
340030da:	b480      	push	{r7}
340030dc:	b085      	sub	sp, #20
340030de:	af00      	add	r7, sp, #0
340030e0:	60f8      	str	r0, [r7, #12]
340030e2:	60b9      	str	r1, [r7, #8]
340030e4:	607a      	str	r2, [r7, #4]
340030e6:	603b      	str	r3, [r7, #0]
  /* Based on sequence described at section 5.2.3.2 of DesignWave document */
  /* For writing the 4-bit testcode MSBs */
  /* Set testen to high */
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM);
340030e8:	68fb      	ldr	r3, [r7, #12]
340030ea:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
340030ee:	695b      	ldr	r3, [r3, #20]
340030f0:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
340030f4:	68fa      	ldr	r2, [r7, #12]
340030f6:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
340030fa:	6153      	str	r3, [r2, #20]

  /* Set testclk to high */
  SET_BIT(hcsi->PTCR0, CSI_PTCR0_TCKEN);
340030fc:	68fb      	ldr	r3, [r7, #12]
340030fe:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34003102:	691b      	ldr	r3, [r3, #16]
34003104:	f043 0301 	orr.w	r3, r3, #1
34003108:	68fa      	ldr	r2, [r7, #12]
3400310a:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
3400310e:	6113      	str	r3, [r2, #16]

  /* Place 0x00 in testdin */
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM);
34003110:	68fb      	ldr	r3, [r7, #12]
34003112:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34003116:	695b      	ldr	r3, [r3, #20]
34003118:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
3400311c:	68fa      	ldr	r2, [r7, #12]
3400311e:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34003122:	6153      	str	r3, [r2, #20]

  /* Set testclk to low (with the falling edge on testclk, the testdin signal content is latched internally) */
  CLEAR_REG(hcsi->PTCR0);
34003124:	68fb      	ldr	r3, [r7, #12]
34003126:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400312a:	461a      	mov	r2, r3
3400312c:	2300      	movs	r3, #0
3400312e:	6113      	str	r3, [r2, #16]

  /* Set testen to low */
  CLEAR_REG(hcsi->PTCR1);
34003130:	68fb      	ldr	r3, [r7, #12]
34003132:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34003136:	461a      	mov	r2, r3
34003138:	2300      	movs	r3, #0
3400313a:	6153      	str	r3, [r2, #20]

  /* Place the 8-bit word corresponding to the testcode MSBs in testdin */
  SET_BIT(hcsi->PTCR1, reg_msb & 0xFFU);
3400313c:	68fb      	ldr	r3, [r7, #12]
3400313e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34003142:	695a      	ldr	r2, [r3, #20]
34003144:	68bb      	ldr	r3, [r7, #8]
34003146:	b2db      	uxtb	r3, r3
34003148:	4313      	orrs	r3, r2
3400314a:	68fa      	ldr	r2, [r7, #12]
3400314c:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34003150:	6153      	str	r3, [r2, #20]

  /* Set testclk to high */
  SET_BIT(hcsi->PTCR0, CSI_PTCR0_TCKEN);
34003152:	68fb      	ldr	r3, [r7, #12]
34003154:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34003158:	691b      	ldr	r3, [r3, #16]
3400315a:	f043 0301 	orr.w	r3, r3, #1
3400315e:	68fa      	ldr	r2, [r7, #12]
34003160:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34003164:	6113      	str	r3, [r2, #16]

  /* For writing the 8-bit testcode LSBs */
  /* Set testclk to low */
  CLEAR_REG(hcsi->PTCR0);
34003166:	68fb      	ldr	r3, [r7, #12]
34003168:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400316c:	461a      	mov	r2, r3
3400316e:	2300      	movs	r3, #0
34003170:	6113      	str	r3, [r2, #16]

  /* Set testen to high */
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM);
34003172:	68fb      	ldr	r3, [r7, #12]
34003174:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34003178:	695b      	ldr	r3, [r3, #20]
3400317a:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
3400317e:	68fa      	ldr	r2, [r7, #12]
34003180:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34003184:	6153      	str	r3, [r2, #20]

  /* Set testclk to high */
  SET_BIT(hcsi->PTCR0, CSI_PTCR0_TCKEN);
34003186:	68fb      	ldr	r3, [r7, #12]
34003188:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400318c:	691b      	ldr	r3, [r3, #16]
3400318e:	f043 0301 	orr.w	r3, r3, #1
34003192:	68fa      	ldr	r2, [r7, #12]
34003194:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34003198:	6113      	str	r3, [r2, #16]

  /* Place the 8-bit word test data in testdin */
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM | (reg_lsb & 0xFFU));
3400319a:	68fb      	ldr	r3, [r7, #12]
3400319c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
340031a0:	695a      	ldr	r2, [r3, #20]
340031a2:	687b      	ldr	r3, [r7, #4]
340031a4:	b2db      	uxtb	r3, r3
340031a6:	4313      	orrs	r3, r2
340031a8:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
340031ac:	68fa      	ldr	r2, [r7, #12]
340031ae:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
340031b2:	6153      	str	r3, [r2, #20]

  /* Set testclk to low (with the falling edge on testclk, the testdin signal content is latched internally) */
  CLEAR_REG(hcsi->PTCR0);
340031b4:	68fb      	ldr	r3, [r7, #12]
340031b6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
340031ba:	461a      	mov	r2, r3
340031bc:	2300      	movs	r3, #0
340031be:	6113      	str	r3, [r2, #16]

  /* Set testen to low */
  CLEAR_REG(hcsi->PTCR1);
340031c0:	68fb      	ldr	r3, [r7, #12]
340031c2:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
340031c6:	461a      	mov	r2, r3
340031c8:	2300      	movs	r3, #0
340031ca:	6153      	str	r3, [r2, #20]

  /* For writing the data */
  /* Place the 8-bit word corresponding to the page offset in testdin */
  SET_BIT(hcsi->PTCR1, val & 0xFFU);
340031cc:	68fb      	ldr	r3, [r7, #12]
340031ce:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
340031d2:	695a      	ldr	r2, [r3, #20]
340031d4:	683b      	ldr	r3, [r7, #0]
340031d6:	b2db      	uxtb	r3, r3
340031d8:	4313      	orrs	r3, r2
340031da:	68fa      	ldr	r2, [r7, #12]
340031dc:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
340031e0:	6153      	str	r3, [r2, #20]

  /* Set testclk to high (test data is programmed internally */
  SET_BIT(hcsi->PTCR0, CSI_PTCR0_TCKEN);
340031e2:	68fb      	ldr	r3, [r7, #12]
340031e4:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
340031e8:	691b      	ldr	r3, [r3, #16]
340031ea:	f043 0301 	orr.w	r3, r3, #1
340031ee:	68fa      	ldr	r2, [r7, #12]
340031f0:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
340031f4:	6113      	str	r3, [r2, #16]

  /* Finish by setting testclk to low */
  CLEAR_REG(hcsi->PTCR0);
340031f6:	68fb      	ldr	r3, [r7, #12]
340031f8:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
340031fc:	461a      	mov	r2, r3
340031fe:	2300      	movs	r3, #0
34003200:	6113      	str	r3, [r2, #16]
}
34003202:	bf00      	nop
34003204:	3714      	adds	r7, #20
34003206:	46bd      	mov	sp, r7
34003208:	f85d 7b04 	ldr.w	r7, [sp], #4
3400320c:	4770      	bx	lr
	...

34003210 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *GPIO_Init)
{
34003210:	b480      	push	{r7}
34003212:	b087      	sub	sp, #28
34003214:	af00      	add	r7, sp, #0
34003216:	6078      	str	r0, [r7, #4]
34003218:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
3400321a:	2300      	movs	r3, #0
3400321c:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
3400321e:	e180      	b.n	34003522 <HAL_GPIO_Init+0x312>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
34003220:	683b      	ldr	r3, [r7, #0]
34003222:	681a      	ldr	r2, [r3, #0]
34003224:	2101      	movs	r1, #1
34003226:	697b      	ldr	r3, [r7, #20]
34003228:	fa01 f303 	lsl.w	r3, r1, r3
3400322c:	4013      	ands	r3, r2
3400322e:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00u)
34003230:	68fb      	ldr	r3, [r7, #12]
34003232:	2b00      	cmp	r3, #0
34003234:	f000 8172 	beq.w	3400351c <HAL_GPIO_Init+0x30c>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
34003238:	683b      	ldr	r3, [r7, #0]
3400323a:	685b      	ldr	r3, [r3, #4]
3400323c:	f003 0303 	and.w	r3, r3, #3
34003240:	2b01      	cmp	r3, #1
34003242:	d005      	beq.n	34003250 <HAL_GPIO_Init+0x40>
34003244:	683b      	ldr	r3, [r7, #0]
34003246:	685b      	ldr	r3, [r3, #4]
34003248:	f003 0303 	and.w	r3, r3, #3
3400324c:	2b02      	cmp	r3, #2
3400324e:	d130      	bne.n	340032b2 <HAL_GPIO_Init+0xa2>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));

        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
34003250:	687b      	ldr	r3, [r7, #4]
34003252:	689b      	ldr	r3, [r3, #8]
34003254:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
34003256:	697b      	ldr	r3, [r7, #20]
34003258:	005b      	lsls	r3, r3, #1
3400325a:	2203      	movs	r2, #3
3400325c:	fa02 f303 	lsl.w	r3, r2, r3
34003260:	43db      	mvns	r3, r3
34003262:	693a      	ldr	r2, [r7, #16]
34003264:	4013      	ands	r3, r2
34003266:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * GPIO_OSPEEDR_OSPEED1_Pos));
34003268:	683b      	ldr	r3, [r7, #0]
3400326a:	68da      	ldr	r2, [r3, #12]
3400326c:	697b      	ldr	r3, [r7, #20]
3400326e:	005b      	lsls	r3, r3, #1
34003270:	fa02 f303 	lsl.w	r3, r2, r3
34003274:	693a      	ldr	r2, [r7, #16]
34003276:	4313      	orrs	r3, r2
34003278:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
3400327a:	687b      	ldr	r3, [r7, #4]
3400327c:	693a      	ldr	r2, [r7, #16]
3400327e:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
34003280:	687b      	ldr	r3, [r7, #4]
34003282:	685b      	ldr	r3, [r3, #4]
34003284:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
34003286:	2201      	movs	r2, #1
34003288:	697b      	ldr	r3, [r7, #20]
3400328a:	fa02 f303 	lsl.w	r3, r2, r3
3400328e:	43db      	mvns	r3, r3
34003290:	693a      	ldr	r2, [r7, #16]
34003292:	4013      	ands	r3, r2
34003294:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
34003296:	683b      	ldr	r3, [r7, #0]
34003298:	685b      	ldr	r3, [r3, #4]
3400329a:	091b      	lsrs	r3, r3, #4
3400329c:	f003 0201 	and.w	r2, r3, #1
340032a0:	697b      	ldr	r3, [r7, #20]
340032a2:	fa02 f303 	lsl.w	r3, r2, r3
340032a6:	693a      	ldr	r2, [r7, #16]
340032a8:	4313      	orrs	r3, r2
340032aa:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
340032ac:	687b      	ldr	r3, [r7, #4]
340032ae:	693a      	ldr	r2, [r7, #16]
340032b0:	605a      	str	r2, [r3, #4]
      }

      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
340032b2:	683b      	ldr	r3, [r7, #0]
340032b4:	685b      	ldr	r3, [r3, #4]
340032b6:	f003 0303 	and.w	r3, r3, #3
340032ba:	2b03      	cmp	r3, #3
340032bc:	d109      	bne.n	340032d2 <HAL_GPIO_Init+0xc2>
          (((GPIO_Init->Mode & GPIO_MODE) == MODE_ANALOG) && (GPIO_Init->Pull != GPIO_PULLUP)))
340032be:	683b      	ldr	r3, [r7, #0]
340032c0:	685b      	ldr	r3, [r3, #4]
340032c2:	f003 0303 	and.w	r3, r3, #3
      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
340032c6:	2b03      	cmp	r3, #3
340032c8:	d11b      	bne.n	34003302 <HAL_GPIO_Init+0xf2>
          (((GPIO_Init->Mode & GPIO_MODE) == MODE_ANALOG) && (GPIO_Init->Pull != GPIO_PULLUP)))
340032ca:	683b      	ldr	r3, [r7, #0]
340032cc:	689b      	ldr	r3, [r3, #8]
340032ce:	2b01      	cmp	r3, #1
340032d0:	d017      	beq.n	34003302 <HAL_GPIO_Init+0xf2>
      {
        /* Check the Pull parameter */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
340032d2:	687b      	ldr	r3, [r7, #4]
340032d4:	68db      	ldr	r3, [r3, #12]
340032d6:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * GPIO_PUPDR_PUPD1_Pos));
340032d8:	697b      	ldr	r3, [r7, #20]
340032da:	005b      	lsls	r3, r3, #1
340032dc:	2203      	movs	r2, #3
340032de:	fa02 f303 	lsl.w	r3, r2, r3
340032e2:	43db      	mvns	r3, r3
340032e4:	693a      	ldr	r2, [r7, #16]
340032e6:	4013      	ands	r3, r2
340032e8:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * GPIO_PUPDR_PUPD1_Pos));
340032ea:	683b      	ldr	r3, [r7, #0]
340032ec:	689a      	ldr	r2, [r3, #8]
340032ee:	697b      	ldr	r3, [r7, #20]
340032f0:	005b      	lsls	r3, r3, #1
340032f2:	fa02 f303 	lsl.w	r3, r2, r3
340032f6:	693a      	ldr	r2, [r7, #16]
340032f8:	4313      	orrs	r3, r2
340032fa:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
340032fc:	687b      	ldr	r3, [r7, #4]
340032fe:	693a      	ldr	r2, [r7, #16]
34003300:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
34003302:	683b      	ldr	r3, [r7, #0]
34003304:	685b      	ldr	r3, [r3, #4]
34003306:	f003 0303 	and.w	r3, r3, #3
3400330a:	2b02      	cmp	r3, #2
3400330c:	d123      	bne.n	34003356 <HAL_GPIO_Init+0x146>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3u];
3400330e:	697b      	ldr	r3, [r7, #20]
34003310:	08da      	lsrs	r2, r3, #3
34003312:	687b      	ldr	r3, [r7, #4]
34003314:	3208      	adds	r2, #8
34003316:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
3400331a:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFu << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
3400331c:	697b      	ldr	r3, [r7, #20]
3400331e:	f003 0307 	and.w	r3, r3, #7
34003322:	009b      	lsls	r3, r3, #2
34003324:	220f      	movs	r2, #15
34003326:	fa02 f303 	lsl.w	r3, r2, r3
3400332a:	43db      	mvns	r3, r3
3400332c:	693a      	ldr	r2, [r7, #16]
3400332e:	4013      	ands	r3, r2
34003330:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
34003332:	683b      	ldr	r3, [r7, #0]
34003334:	691a      	ldr	r2, [r3, #16]
34003336:	697b      	ldr	r3, [r7, #20]
34003338:	f003 0307 	and.w	r3, r3, #7
3400333c:	009b      	lsls	r3, r3, #2
3400333e:	fa02 f303 	lsl.w	r3, r2, r3
34003342:	693a      	ldr	r2, [r7, #16]
34003344:	4313      	orrs	r3, r2
34003346:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3u] = temp;
34003348:	697b      	ldr	r3, [r7, #20]
3400334a:	08da      	lsrs	r2, r3, #3
3400334c:	687b      	ldr	r3, [r7, #4]
3400334e:	3208      	adds	r2, #8
34003350:	6939      	ldr	r1, [r7, #16]
34003352:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
34003356:	687b      	ldr	r3, [r7, #4]
34003358:	681b      	ldr	r3, [r3, #0]
3400335a:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
3400335c:	697b      	ldr	r3, [r7, #20]
3400335e:	005b      	lsls	r3, r3, #1
34003360:	2203      	movs	r2, #3
34003362:	fa02 f303 	lsl.w	r3, r2, r3
34003366:	43db      	mvns	r3, r3
34003368:	693a      	ldr	r2, [r7, #16]
3400336a:	4013      	ands	r3, r2
3400336c:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * GPIO_MODER_MODE1_Pos));
3400336e:	683b      	ldr	r3, [r7, #0]
34003370:	685b      	ldr	r3, [r3, #4]
34003372:	f003 0203 	and.w	r2, r3, #3
34003376:	697b      	ldr	r3, [r7, #20]
34003378:	005b      	lsls	r3, r3, #1
3400337a:	fa02 f303 	lsl.w	r3, r2, r3
3400337e:	693a      	ldr	r2, [r7, #16]
34003380:	4313      	orrs	r3, r2
34003382:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
34003384:	687b      	ldr	r3, [r7, #4]
34003386:	693a      	ldr	r2, [r7, #16]
34003388:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
3400338a:	683b      	ldr	r3, [r7, #0]
3400338c:	685b      	ldr	r3, [r3, #4]
3400338e:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
34003392:	2b00      	cmp	r3, #0
34003394:	f000 80c2 	beq.w	3400351c <HAL_GPIO_Init+0x30c>
      {
        temp = EXTI->EXTICR[position >> 2u];
34003398:	4a69      	ldr	r2, [pc, #420]	@ (34003540 <HAL_GPIO_Init+0x330>)
3400339a:	697b      	ldr	r3, [r7, #20]
3400339c:	089b      	lsrs	r3, r3, #2
3400339e:	3318      	adds	r3, #24
340033a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
340033a4:	613b      	str	r3, [r7, #16]
        temp &= ~(0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
340033a6:	697b      	ldr	r3, [r7, #20]
340033a8:	f003 0303 	and.w	r3, r3, #3
340033ac:	00db      	lsls	r3, r3, #3
340033ae:	220f      	movs	r2, #15
340033b0:	fa02 f303 	lsl.w	r3, r2, r3
340033b4:	43db      	mvns	r3, r3
340033b6:	693a      	ldr	r2, [r7, #16]
340033b8:	4013      	ands	r3, r2
340033ba:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
340033bc:	687b      	ldr	r3, [r7, #4]
340033be:	4a61      	ldr	r2, [pc, #388]	@ (34003544 <HAL_GPIO_Init+0x334>)
340033c0:	4293      	cmp	r3, r2
340033c2:	d043      	beq.n	3400344c <HAL_GPIO_Init+0x23c>
340033c4:	687b      	ldr	r3, [r7, #4]
340033c6:	4a60      	ldr	r2, [pc, #384]	@ (34003548 <HAL_GPIO_Init+0x338>)
340033c8:	4293      	cmp	r3, r2
340033ca:	d03d      	beq.n	34003448 <HAL_GPIO_Init+0x238>
340033cc:	687b      	ldr	r3, [r7, #4]
340033ce:	4a5f      	ldr	r2, [pc, #380]	@ (3400354c <HAL_GPIO_Init+0x33c>)
340033d0:	4293      	cmp	r3, r2
340033d2:	d037      	beq.n	34003444 <HAL_GPIO_Init+0x234>
340033d4:	687b      	ldr	r3, [r7, #4]
340033d6:	4a5e      	ldr	r2, [pc, #376]	@ (34003550 <HAL_GPIO_Init+0x340>)
340033d8:	4293      	cmp	r3, r2
340033da:	d031      	beq.n	34003440 <HAL_GPIO_Init+0x230>
340033dc:	687b      	ldr	r3, [r7, #4]
340033de:	4a5d      	ldr	r2, [pc, #372]	@ (34003554 <HAL_GPIO_Init+0x344>)
340033e0:	4293      	cmp	r3, r2
340033e2:	d02b      	beq.n	3400343c <HAL_GPIO_Init+0x22c>
340033e4:	687b      	ldr	r3, [r7, #4]
340033e6:	4a5c      	ldr	r2, [pc, #368]	@ (34003558 <HAL_GPIO_Init+0x348>)
340033e8:	4293      	cmp	r3, r2
340033ea:	d025      	beq.n	34003438 <HAL_GPIO_Init+0x228>
340033ec:	687b      	ldr	r3, [r7, #4]
340033ee:	4a5b      	ldr	r2, [pc, #364]	@ (3400355c <HAL_GPIO_Init+0x34c>)
340033f0:	4293      	cmp	r3, r2
340033f2:	d01f      	beq.n	34003434 <HAL_GPIO_Init+0x224>
340033f4:	687b      	ldr	r3, [r7, #4]
340033f6:	4a5a      	ldr	r2, [pc, #360]	@ (34003560 <HAL_GPIO_Init+0x350>)
340033f8:	4293      	cmp	r3, r2
340033fa:	d019      	beq.n	34003430 <HAL_GPIO_Init+0x220>
340033fc:	687b      	ldr	r3, [r7, #4]
340033fe:	4a59      	ldr	r2, [pc, #356]	@ (34003564 <HAL_GPIO_Init+0x354>)
34003400:	4293      	cmp	r3, r2
34003402:	d013      	beq.n	3400342c <HAL_GPIO_Init+0x21c>
34003404:	687b      	ldr	r3, [r7, #4]
34003406:	4a58      	ldr	r2, [pc, #352]	@ (34003568 <HAL_GPIO_Init+0x358>)
34003408:	4293      	cmp	r3, r2
3400340a:	d00d      	beq.n	34003428 <HAL_GPIO_Init+0x218>
3400340c:	687b      	ldr	r3, [r7, #4]
3400340e:	4a57      	ldr	r2, [pc, #348]	@ (3400356c <HAL_GPIO_Init+0x35c>)
34003410:	4293      	cmp	r3, r2
34003412:	d007      	beq.n	34003424 <HAL_GPIO_Init+0x214>
34003414:	687b      	ldr	r3, [r7, #4]
34003416:	4a56      	ldr	r2, [pc, #344]	@ (34003570 <HAL_GPIO_Init+0x360>)
34003418:	4293      	cmp	r3, r2
3400341a:	d101      	bne.n	34003420 <HAL_GPIO_Init+0x210>
3400341c:	230b      	movs	r3, #11
3400341e:	e016      	b.n	3400344e <HAL_GPIO_Init+0x23e>
34003420:	2310      	movs	r3, #16
34003422:	e014      	b.n	3400344e <HAL_GPIO_Init+0x23e>
34003424:	230a      	movs	r3, #10
34003426:	e012      	b.n	3400344e <HAL_GPIO_Init+0x23e>
34003428:	2309      	movs	r3, #9
3400342a:	e010      	b.n	3400344e <HAL_GPIO_Init+0x23e>
3400342c:	2308      	movs	r3, #8
3400342e:	e00e      	b.n	3400344e <HAL_GPIO_Init+0x23e>
34003430:	2307      	movs	r3, #7
34003432:	e00c      	b.n	3400344e <HAL_GPIO_Init+0x23e>
34003434:	2306      	movs	r3, #6
34003436:	e00a      	b.n	3400344e <HAL_GPIO_Init+0x23e>
34003438:	2305      	movs	r3, #5
3400343a:	e008      	b.n	3400344e <HAL_GPIO_Init+0x23e>
3400343c:	2304      	movs	r3, #4
3400343e:	e006      	b.n	3400344e <HAL_GPIO_Init+0x23e>
34003440:	2303      	movs	r3, #3
34003442:	e004      	b.n	3400344e <HAL_GPIO_Init+0x23e>
34003444:	2302      	movs	r3, #2
34003446:	e002      	b.n	3400344e <HAL_GPIO_Init+0x23e>
34003448:	2301      	movs	r3, #1
3400344a:	e000      	b.n	3400344e <HAL_GPIO_Init+0x23e>
3400344c:	2300      	movs	r3, #0
3400344e:	697a      	ldr	r2, [r7, #20]
34003450:	f002 0203 	and.w	r2, r2, #3
34003454:	00d2      	lsls	r2, r2, #3
34003456:	4093      	lsls	r3, r2
34003458:	693a      	ldr	r2, [r7, #16]
3400345a:	4313      	orrs	r3, r2
3400345c:	613b      	str	r3, [r7, #16]
        EXTI->EXTICR[position >> 2u] = temp;
3400345e:	4938      	ldr	r1, [pc, #224]	@ (34003540 <HAL_GPIO_Init+0x330>)
34003460:	697b      	ldr	r3, [r7, #20]
34003462:	089b      	lsrs	r3, r3, #2
34003464:	3318      	adds	r3, #24
34003466:	693a      	ldr	r2, [r7, #16]
34003468:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
3400346c:	4b34      	ldr	r3, [pc, #208]	@ (34003540 <HAL_GPIO_Init+0x330>)
3400346e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34003472:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
34003474:	68fb      	ldr	r3, [r7, #12]
34003476:	43db      	mvns	r3, r3
34003478:	693a      	ldr	r2, [r7, #16]
3400347a:	4013      	ands	r3, r2
3400347c:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
3400347e:	683b      	ldr	r3, [r7, #0]
34003480:	685b      	ldr	r3, [r3, #4]
34003482:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34003486:	2b00      	cmp	r3, #0
34003488:	d003      	beq.n	34003492 <HAL_GPIO_Init+0x282>
        {
          temp |= iocurrent;
3400348a:	693a      	ldr	r2, [r7, #16]
3400348c:	68fb      	ldr	r3, [r7, #12]
3400348e:	4313      	orrs	r3, r2
34003490:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR1 = temp;
34003492:	4a2b      	ldr	r2, [pc, #172]	@ (34003540 <HAL_GPIO_Init+0x330>)
34003494:	693b      	ldr	r3, [r7, #16]
34003496:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80

        temp = EXTI->EMR1;
3400349a:	4b29      	ldr	r3, [pc, #164]	@ (34003540 <HAL_GPIO_Init+0x330>)
3400349c:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
340034a0:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
340034a2:	68fb      	ldr	r3, [r7, #12]
340034a4:	43db      	mvns	r3, r3
340034a6:	693a      	ldr	r2, [r7, #16]
340034a8:	4013      	ands	r3, r2
340034aa:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
340034ac:	683b      	ldr	r3, [r7, #0]
340034ae:	685b      	ldr	r3, [r3, #4]
340034b0:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
340034b4:	2b00      	cmp	r3, #0
340034b6:	d003      	beq.n	340034c0 <HAL_GPIO_Init+0x2b0>
        {
          temp |= iocurrent;
340034b8:	693a      	ldr	r2, [r7, #16]
340034ba:	68fb      	ldr	r3, [r7, #12]
340034bc:	4313      	orrs	r3, r2
340034be:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR1 = temp;
340034c0:	4a1f      	ldr	r2, [pc, #124]	@ (34003540 <HAL_GPIO_Init+0x330>)
340034c2:	693b      	ldr	r3, [r7, #16]
340034c4:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
340034c8:	4b1d      	ldr	r3, [pc, #116]	@ (34003540 <HAL_GPIO_Init+0x330>)
340034ca:	681b      	ldr	r3, [r3, #0]
340034cc:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
340034ce:	68fb      	ldr	r3, [r7, #12]
340034d0:	43db      	mvns	r3, r3
340034d2:	693a      	ldr	r2, [r7, #16]
340034d4:	4013      	ands	r3, r2
340034d6:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
340034d8:	683b      	ldr	r3, [r7, #0]
340034da:	685b      	ldr	r3, [r3, #4]
340034dc:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
340034e0:	2b00      	cmp	r3, #0
340034e2:	d003      	beq.n	340034ec <HAL_GPIO_Init+0x2dc>
        {
          temp |= iocurrent;
340034e4:	693a      	ldr	r2, [r7, #16]
340034e6:	68fb      	ldr	r3, [r7, #12]
340034e8:	4313      	orrs	r3, r2
340034ea:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR1 = temp;
340034ec:	4a14      	ldr	r2, [pc, #80]	@ (34003540 <HAL_GPIO_Init+0x330>)
340034ee:	693b      	ldr	r3, [r7, #16]
340034f0:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
340034f2:	4b13      	ldr	r3, [pc, #76]	@ (34003540 <HAL_GPIO_Init+0x330>)
340034f4:	685b      	ldr	r3, [r3, #4]
340034f6:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
340034f8:	68fb      	ldr	r3, [r7, #12]
340034fa:	43db      	mvns	r3, r3
340034fc:	693a      	ldr	r2, [r7, #16]
340034fe:	4013      	ands	r3, r2
34003500:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
34003502:	683b      	ldr	r3, [r7, #0]
34003504:	685b      	ldr	r3, [r3, #4]
34003506:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
3400350a:	2b00      	cmp	r3, #0
3400350c:	d003      	beq.n	34003516 <HAL_GPIO_Init+0x306>
        {
          temp |= iocurrent;
3400350e:	693a      	ldr	r2, [r7, #16]
34003510:	68fb      	ldr	r3, [r7, #12]
34003512:	4313      	orrs	r3, r2
34003514:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR1 = temp;
34003516:	4a0a      	ldr	r2, [pc, #40]	@ (34003540 <HAL_GPIO_Init+0x330>)
34003518:	693b      	ldr	r3, [r7, #16]
3400351a:	6053      	str	r3, [r2, #4]
      }
    }

    position++;
3400351c:	697b      	ldr	r3, [r7, #20]
3400351e:	3301      	adds	r3, #1
34003520:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
34003522:	683b      	ldr	r3, [r7, #0]
34003524:	681a      	ldr	r2, [r3, #0]
34003526:	697b      	ldr	r3, [r7, #20]
34003528:	fa22 f303 	lsr.w	r3, r2, r3
3400352c:	2b00      	cmp	r3, #0
3400352e:	f47f ae77 	bne.w	34003220 <HAL_GPIO_Init+0x10>
  }
}
34003532:	bf00      	nop
34003534:	bf00      	nop
34003536:	371c      	adds	r7, #28
34003538:	46bd      	mov	sp, r7
3400353a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400353e:	4770      	bx	lr
34003540:	56025000 	.word	0x56025000
34003544:	56020000 	.word	0x56020000
34003548:	56020400 	.word	0x56020400
3400354c:	56020800 	.word	0x56020800
34003550:	56020c00 	.word	0x56020c00
34003554:	56021000 	.word	0x56021000
34003558:	56021400 	.word	0x56021400
3400355c:	56021800 	.word	0x56021800
34003560:	56021c00 	.word	0x56021c00
34003564:	56023400 	.word	0x56023400
34003568:	56023800 	.word	0x56023800
3400356c:	56023c00 	.word	0x56023c00
34003570:	56024000 	.word	0x56024000

34003574 <HAL_PWREx_EnableVddIO2>:
  * @brief  Enable VDDIO2 supply valid.
  * @note   Setting this bit is mandatory to use PO[5:0] and PP[15:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO2(void)
{
34003574:	b480      	push	{r7}
34003576:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_VDDIO2SV);
34003578:	4b05      	ldr	r3, [pc, #20]	@ (34003590 <HAL_PWREx_EnableVddIO2+0x1c>)
3400357a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400357c:	4a04      	ldr	r2, [pc, #16]	@ (34003590 <HAL_PWREx_EnableVddIO2+0x1c>)
3400357e:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
34003582:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
34003584:	bf00      	nop
34003586:	46bd      	mov	sp, r7
34003588:	f85d 7b04 	ldr.w	r7, [sp], #4
3400358c:	4770      	bx	lr
3400358e:	bf00      	nop
34003590:	56024800 	.word	0x56024800

34003594 <HAL_PWREx_EnableVddIO3>:
  * @brief  Enable VDDIO3 supply valid.
  * @note   Setting this bit is mandatory to use PN[12:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO3(void)
{
34003594:	b480      	push	{r7}
34003596:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_VDDIO3SV);
34003598:	4b05      	ldr	r3, [pc, #20]	@ (340035b0 <HAL_PWREx_EnableVddIO3+0x1c>)
3400359a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400359c:	4a04      	ldr	r2, [pc, #16]	@ (340035b0 <HAL_PWREx_EnableVddIO3+0x1c>)
3400359e:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
340035a2:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
340035a4:	bf00      	nop
340035a6:	46bd      	mov	sp, r7
340035a8:	f85d 7b04 	ldr.w	r7, [sp], #4
340035ac:	4770      	bx	lr
340035ae:	bf00      	nop
340035b0:	56024800 	.word	0x56024800

340035b4 <HAL_PWREx_EnableVddIO4>:
  * @brief  Enable VDDIO4 supply valid.
  * @note   Setting this bit is mandatory to use PB[9,8], PC[12:6], and PD[2] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO4(void)
{
340035b4:	b480      	push	{r7}
340035b6:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR1, PWR_SVMCR1_VDDIO4SV);
340035b8:	4b05      	ldr	r3, [pc, #20]	@ (340035d0 <HAL_PWREx_EnableVddIO4+0x1c>)
340035ba:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
340035bc:	4a04      	ldr	r2, [pc, #16]	@ (340035d0 <HAL_PWREx_EnableVddIO4+0x1c>)
340035be:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
340035c2:	6353      	str	r3, [r2, #52]	@ 0x34
}
340035c4:	bf00      	nop
340035c6:	46bd      	mov	sp, r7
340035c8:	f85d 7b04 	ldr.w	r7, [sp], #4
340035cc:	4770      	bx	lr
340035ce:	bf00      	nop
340035d0:	56024800 	.word	0x56024800

340035d4 <HAL_PWREx_EnableVddIO5>:
  * @brief  Enable VDDIO5 supply valid.
  * @note   Setting this bit is mandatory to use PN[12:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO5(void)
{
340035d4:	b480      	push	{r7}
340035d6:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR2, PWR_SVMCR2_VDDIO5SV);
340035d8:	4b05      	ldr	r3, [pc, #20]	@ (340035f0 <HAL_PWREx_EnableVddIO5+0x1c>)
340035da:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
340035dc:	4a04      	ldr	r2, [pc, #16]	@ (340035f0 <HAL_PWREx_EnableVddIO5+0x1c>)
340035de:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
340035e2:	6393      	str	r3, [r2, #56]	@ 0x38
}
340035e4:	bf00      	nop
340035e6:	46bd      	mov	sp, r7
340035e8:	f85d 7b04 	ldr.w	r7, [sp], #4
340035ec:	4770      	bx	lr
340035ee:	bf00      	nop
340035f0:	56024800 	.word	0x56024800

340035f4 <LL_RCC_HSI_GetDivider>:
  *         @arg @ref LL_RCC_HSI_DIV_2
  *         @arg @ref LL_RCC_HSI_DIV_4
  *         @arg @ref LL_RCC_HSI_DIV_8
  */
__STATIC_INLINE uint32_t LL_RCC_HSI_GetDivider(void)
{
340035f4:	b480      	push	{r7}
340035f6:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
340035f8:	4b04      	ldr	r3, [pc, #16]	@ (3400360c <LL_RCC_HSI_GetDivider+0x18>)
340035fa:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
340035fc:	f403 73c0 	and.w	r3, r3, #384	@ 0x180
}
34003600:	4618      	mov	r0, r3
34003602:	46bd      	mov	sp, r7
34003604:	f85d 7b04 	ldr.w	r7, [sp], #4
34003608:	4770      	bx	lr
3400360a:	bf00      	nop
3400360c:	56028000 	.word	0x56028000

34003610 <LL_RCC_GetSysClkSource>:
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_MSI
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_HSE
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_IC2_IC6_IC11
  */
__STATIC_INLINE uint32_t LL_RCC_GetSysClkSource(void)
{
34003610:	b480      	push	{r7}
34003612:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_SYSSWS));
34003614:	4b04      	ldr	r3, [pc, #16]	@ (34003628 <LL_RCC_GetSysClkSource+0x18>)
34003616:	6a1b      	ldr	r3, [r3, #32]
34003618:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400361c:	4618      	mov	r0, r3
3400361e:	46bd      	mov	sp, r7
34003620:	f85d 7b04 	ldr.w	r7, [sp], #4
34003624:	4770      	bx	lr
34003626:	bf00      	nop
34003628:	56028000 	.word	0x56028000

3400362c <LL_RCC_IC2_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC2_GetSource(void)
{
3400362c:	b480      	push	{r7}
3400362e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
34003630:	4b04      	ldr	r3, [pc, #16]	@ (34003644 <LL_RCC_IC2_GetSource+0x18>)
34003632:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
34003636:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400363a:	4618      	mov	r0, r3
3400363c:	46bd      	mov	sp, r7
3400363e:	f85d 7b04 	ldr.w	r7, [sp], #4
34003642:	4770      	bx	lr
34003644:	56028000 	.word	0x56028000

34003648 <LL_RCC_IC2_GetDivider>:
  * @brief  Get IC2 divider
  * @rmtoll IC2CFGR      IC2INT        LL_RCC_IC2_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC2_GetDivider(void)
{
34003648:	b480      	push	{r7}
3400364a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2INT) >> RCC_IC2CFGR_IC2INT_Pos) + 1UL);
3400364c:	4b05      	ldr	r3, [pc, #20]	@ (34003664 <LL_RCC_IC2_GetDivider+0x1c>)
3400364e:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
34003652:	0c1b      	lsrs	r3, r3, #16
34003654:	b2db      	uxtb	r3, r3
34003656:	3301      	adds	r3, #1
}
34003658:	4618      	mov	r0, r3
3400365a:	46bd      	mov	sp, r7
3400365c:	f85d 7b04 	ldr.w	r7, [sp], #4
34003660:	4770      	bx	lr
34003662:	bf00      	nop
34003664:	56028000 	.word	0x56028000

34003668 <HAL_RCC_GetSysClockFreq>:
  *         will be incorrect.
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
34003668:	b598      	push	{r3, r4, r7, lr}
3400366a:	af00      	add	r7, sp, #0
  return RCC_GetSysClockFreq(LL_RCC_IC2_GetSource(), LL_RCC_IC2_GetDivider());
3400366c:	f7ff ffde 	bl	3400362c <LL_RCC_IC2_GetSource>
34003670:	4604      	mov	r4, r0
34003672:	f7ff ffe9 	bl	34003648 <LL_RCC_IC2_GetDivider>
34003676:	4603      	mov	r3, r0
34003678:	4619      	mov	r1, r3
3400367a:	4620      	mov	r0, r4
3400367c:	f000 f804 	bl	34003688 <RCC_GetSysClockFreq>
34003680:	4603      	mov	r3, r0
}
34003682:	4618      	mov	r0, r3
34003684:	bd98      	pop	{r3, r4, r7, pc}
	...

34003688 <RCC_GetSysClockFreq>:
  * @param  icx_divider The intermediate clock divider
  *
  * @retval SYSCLK frequency
  */
static uint32_t RCC_GetSysClockFreq(uint32_t icx_source, uint32_t icx_divider)
{
34003688:	b580      	push	{r7, lr}
3400368a:	b084      	sub	sp, #16
3400368c:	af00      	add	r7, sp, #0
3400368e:	6078      	str	r0, [r7, #4]
34003690:	6039      	str	r1, [r7, #0]
  uint32_t frequency = 0U;
34003692:	2300      	movs	r3, #0
34003694:	60fb      	str	r3, [r7, #12]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (LL_RCC_GetSysClkSource())
34003696:	f7ff ffbb 	bl	34003610 <LL_RCC_GetSysClkSource>
3400369a:	4603      	mov	r3, r0
3400369c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340036a0:	d026      	beq.n	340036f0 <RCC_GetSysClockFreq+0x68>
340036a2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340036a6:	d861      	bhi.n	3400376c <RCC_GetSysClockFreq+0xe4>
340036a8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340036ac:	d01d      	beq.n	340036ea <RCC_GetSysClockFreq+0x62>
340036ae:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340036b2:	d85b      	bhi.n	3400376c <RCC_GetSysClockFreq+0xe4>
340036b4:	2b00      	cmp	r3, #0
340036b6:	d003      	beq.n	340036c0 <RCC_GetSysClockFreq+0x38>
340036b8:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340036bc:	d009      	beq.n	340036d2 <RCC_GetSysClockFreq+0x4a>
      }
      break;

    default:
      /* Unexpected case */
      break;
340036be:	e055      	b.n	3400376c <RCC_GetSysClockFreq+0xe4>
      frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
340036c0:	f7ff ff98 	bl	340035f4 <LL_RCC_HSI_GetDivider>
340036c4:	4603      	mov	r3, r0
340036c6:	09db      	lsrs	r3, r3, #7
340036c8:	4a2b      	ldr	r2, [pc, #172]	@ (34003778 <RCC_GetSysClockFreq+0xf0>)
340036ca:	fa22 f303 	lsr.w	r3, r2, r3
340036ce:	60fb      	str	r3, [r7, #12]
      break;
340036d0:	e04d      	b.n	3400376e <RCC_GetSysClockFreq+0xe6>
      frequency = RCC_GET_MSI_FREQUENCY();
340036d2:	4b2a      	ldr	r3, [pc, #168]	@ (3400377c <RCC_GetSysClockFreq+0xf4>)
340036d4:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340036d6:	f403 7300 	and.w	r3, r3, #512	@ 0x200
340036da:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
340036de:	d101      	bne.n	340036e4 <RCC_GetSysClockFreq+0x5c>
340036e0:	4b27      	ldr	r3, [pc, #156]	@ (34003780 <RCC_GetSysClockFreq+0xf8>)
340036e2:	e000      	b.n	340036e6 <RCC_GetSysClockFreq+0x5e>
340036e4:	4b27      	ldr	r3, [pc, #156]	@ (34003784 <RCC_GetSysClockFreq+0xfc>)
340036e6:	60fb      	str	r3, [r7, #12]
      break;
340036e8:	e041      	b.n	3400376e <RCC_GetSysClockFreq+0xe6>
      frequency = HSE_VALUE;
340036ea:	4b27      	ldr	r3, [pc, #156]	@ (34003788 <RCC_GetSysClockFreq+0x100>)
340036ec:	60fb      	str	r3, [r7, #12]
      break;
340036ee:	e03e      	b.n	3400376e <RCC_GetSysClockFreq+0xe6>
      switch (icx_source)
340036f0:	687b      	ldr	r3, [r7, #4]
340036f2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340036f6:	d02e      	beq.n	34003756 <RCC_GetSysClockFreq+0xce>
340036f8:	687b      	ldr	r3, [r7, #4]
340036fa:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340036fe:	d833      	bhi.n	34003768 <RCC_GetSysClockFreq+0xe0>
34003700:	687b      	ldr	r3, [r7, #4]
34003702:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34003706:	d01d      	beq.n	34003744 <RCC_GetSysClockFreq+0xbc>
34003708:	687b      	ldr	r3, [r7, #4]
3400370a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400370e:	d82b      	bhi.n	34003768 <RCC_GetSysClockFreq+0xe0>
34003710:	687b      	ldr	r3, [r7, #4]
34003712:	2b00      	cmp	r3, #0
34003714:	d004      	beq.n	34003720 <RCC_GetSysClockFreq+0x98>
34003716:	687b      	ldr	r3, [r7, #4]
34003718:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400371c:	d009      	beq.n	34003732 <RCC_GetSysClockFreq+0xaa>
          break;
3400371e:	e023      	b.n	34003768 <RCC_GetSysClockFreq+0xe0>
          frequency = HAL_RCCEx_GetPLL1CLKFreq();
34003720:	f004 faf0 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
34003724:	60f8      	str	r0, [r7, #12]
          frequency = frequency / icx_divider;
34003726:	68fa      	ldr	r2, [r7, #12]
34003728:	683b      	ldr	r3, [r7, #0]
3400372a:	fbb2 f3f3 	udiv	r3, r2, r3
3400372e:	60fb      	str	r3, [r7, #12]
          break;
34003730:	e01b      	b.n	3400376a <RCC_GetSysClockFreq+0xe2>
          frequency = HAL_RCCEx_GetPLL2CLKFreq();
34003732:	f004 fb2d 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
34003736:	60f8      	str	r0, [r7, #12]
          frequency = frequency / icx_divider;
34003738:	68fa      	ldr	r2, [r7, #12]
3400373a:	683b      	ldr	r3, [r7, #0]
3400373c:	fbb2 f3f3 	udiv	r3, r2, r3
34003740:	60fb      	str	r3, [r7, #12]
          break;
34003742:	e012      	b.n	3400376a <RCC_GetSysClockFreq+0xe2>
          frequency = HAL_RCCEx_GetPLL3CLKFreq();
34003744:	f004 fb6a 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
34003748:	60f8      	str	r0, [r7, #12]
          frequency = frequency / icx_divider;
3400374a:	68fa      	ldr	r2, [r7, #12]
3400374c:	683b      	ldr	r3, [r7, #0]
3400374e:	fbb2 f3f3 	udiv	r3, r2, r3
34003752:	60fb      	str	r3, [r7, #12]
          break;
34003754:	e009      	b.n	3400376a <RCC_GetSysClockFreq+0xe2>
          frequency = HAL_RCCEx_GetPLL4CLKFreq();
34003756:	f004 fba7 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
3400375a:	60f8      	str	r0, [r7, #12]
          frequency = frequency / icx_divider;
3400375c:	68fa      	ldr	r2, [r7, #12]
3400375e:	683b      	ldr	r3, [r7, #0]
34003760:	fbb2 f3f3 	udiv	r3, r2, r3
34003764:	60fb      	str	r3, [r7, #12]
          break;
34003766:	e000      	b.n	3400376a <RCC_GetSysClockFreq+0xe2>
          break;
34003768:	bf00      	nop
      break;
3400376a:	e000      	b.n	3400376e <RCC_GetSysClockFreq+0xe6>
      break;
3400376c:	bf00      	nop
  }

  return frequency;
3400376e:	68fb      	ldr	r3, [r7, #12]
}
34003770:	4618      	mov	r0, r3
34003772:	3710      	adds	r7, #16
34003774:	46bd      	mov	sp, r7
34003776:	bd80      	pop	{r7, pc}
34003778:	03d09000 	.word	0x03d09000
3400377c:	56028000 	.word	0x56028000
34003780:	00f42400 	.word	0x00f42400
34003784:	003d0900 	.word	0x003d0900
34003788:	016e3600 	.word	0x016e3600

3400378c <LL_RCC_HSE_SelectHSEAsDiv2Clock>:
{
3400378c:	b480      	push	{r7}
3400378e:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL);
34003790:	4b05      	ldr	r3, [pc, #20]	@ (340037a8 <LL_RCC_HSE_SelectHSEAsDiv2Clock+0x1c>)
34003792:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34003794:	4a04      	ldr	r2, [pc, #16]	@ (340037a8 <LL_RCC_HSE_SelectHSEAsDiv2Clock+0x1c>)
34003796:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
3400379a:	6553      	str	r3, [r2, #84]	@ 0x54
}
3400379c:	bf00      	nop
3400379e:	46bd      	mov	sp, r7
340037a0:	f85d 7b04 	ldr.w	r7, [sp], #4
340037a4:	4770      	bx	lr
340037a6:	bf00      	nop
340037a8:	56028000 	.word	0x56028000

340037ac <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>:
{
340037ac:	b480      	push	{r7}
340037ae:	af00      	add	r7, sp, #0
  SET_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL);
340037b0:	4b05      	ldr	r3, [pc, #20]	@ (340037c8 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock+0x1c>)
340037b2:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
340037b4:	4a04      	ldr	r2, [pc, #16]	@ (340037c8 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock+0x1c>)
340037b6:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
340037ba:	6553      	str	r3, [r2, #84]	@ 0x54
}
340037bc:	bf00      	nop
340037be:	46bd      	mov	sp, r7
340037c0:	f85d 7b04 	ldr.w	r7, [sp], #4
340037c4:	4770      	bx	lr
340037c6:	bf00      	nop
340037c8:	56028000 	.word	0x56028000

340037cc <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>:
{
340037cc:	b480      	push	{r7}
340037ce:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL) == RCC_HSECFGR_HSEDIV2SEL) ? 1UL : 0UL);
340037d0:	4b06      	ldr	r3, [pc, #24]	@ (340037ec <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock+0x20>)
340037d2:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
340037d4:	f003 0340 	and.w	r3, r3, #64	@ 0x40
340037d8:	2b40      	cmp	r3, #64	@ 0x40
340037da:	d101      	bne.n	340037e0 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock+0x14>
340037dc:	2301      	movs	r3, #1
340037de:	e000      	b.n	340037e2 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock+0x16>
340037e0:	2300      	movs	r3, #0
}
340037e2:	4618      	mov	r0, r3
340037e4:	46bd      	mov	sp, r7
340037e6:	f85d 7b04 	ldr.w	r7, [sp], #4
340037ea:	4770      	bx	lr
340037ec:	56028000 	.word	0x56028000

340037f0 <LL_RCC_HSE_IsReady>:
{
340037f0:	b480      	push	{r7}
340037f2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0UL) ? 1UL : 0UL);
340037f4:	4b06      	ldr	r3, [pc, #24]	@ (34003810 <LL_RCC_HSE_IsReady+0x20>)
340037f6:	685b      	ldr	r3, [r3, #4]
340037f8:	f003 0310 	and.w	r3, r3, #16
340037fc:	2b00      	cmp	r3, #0
340037fe:	d001      	beq.n	34003804 <LL_RCC_HSE_IsReady+0x14>
34003800:	2301      	movs	r3, #1
34003802:	e000      	b.n	34003806 <LL_RCC_HSE_IsReady+0x16>
34003804:	2300      	movs	r3, #0
}
34003806:	4618      	mov	r0, r3
34003808:	46bd      	mov	sp, r7
3400380a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400380e:	4770      	bx	lr
34003810:	56028000 	.word	0x56028000

34003814 <LL_RCC_HSI_IsReady>:
{
34003814:	b480      	push	{r7}
34003816:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSIRDY) != 0UL) ? 1UL : 0UL);
34003818:	4b06      	ldr	r3, [pc, #24]	@ (34003834 <LL_RCC_HSI_IsReady+0x20>)
3400381a:	685b      	ldr	r3, [r3, #4]
3400381c:	f003 0308 	and.w	r3, r3, #8
34003820:	2b00      	cmp	r3, #0
34003822:	d001      	beq.n	34003828 <LL_RCC_HSI_IsReady+0x14>
34003824:	2301      	movs	r3, #1
34003826:	e000      	b.n	3400382a <LL_RCC_HSI_IsReady+0x16>
34003828:	2300      	movs	r3, #0
}
3400382a:	4618      	mov	r0, r3
3400382c:	46bd      	mov	sp, r7
3400382e:	f85d 7b04 	ldr.w	r7, [sp], #4
34003832:	4770      	bx	lr
34003834:	56028000 	.word	0x56028000

34003838 <LL_RCC_HSI_GetDivider>:
{
34003838:	b480      	push	{r7}
3400383a:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400383c:	4b04      	ldr	r3, [pc, #16]	@ (34003850 <LL_RCC_HSI_GetDivider+0x18>)
3400383e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34003840:	f403 73c0 	and.w	r3, r3, #384	@ 0x180
}
34003844:	4618      	mov	r0, r3
34003846:	46bd      	mov	sp, r7
34003848:	f85d 7b04 	ldr.w	r7, [sp], #4
3400384c:	4770      	bx	lr
3400384e:	bf00      	nop
34003850:	56028000 	.word	0x56028000

34003854 <LL_RCC_MSI_IsReady>:
{
34003854:	b480      	push	{r7}
34003856:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_MSIRDY) != 0UL) ? 1UL : 0UL);
34003858:	4b06      	ldr	r3, [pc, #24]	@ (34003874 <LL_RCC_MSI_IsReady+0x20>)
3400385a:	685b      	ldr	r3, [r3, #4]
3400385c:	f003 0304 	and.w	r3, r3, #4
34003860:	2b00      	cmp	r3, #0
34003862:	d001      	beq.n	34003868 <LL_RCC_MSI_IsReady+0x14>
34003864:	2301      	movs	r3, #1
34003866:	e000      	b.n	3400386a <LL_RCC_MSI_IsReady+0x16>
34003868:	2300      	movs	r3, #0
}
3400386a:	4618      	mov	r0, r3
3400386c:	46bd      	mov	sp, r7
3400386e:	f85d 7b04 	ldr.w	r7, [sp], #4
34003872:	4770      	bx	lr
34003874:	56028000 	.word	0x56028000

34003878 <LL_RCC_MSI_GetFrequency>:
{
34003878:	b480      	push	{r7}
3400387a:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL));
3400387c:	4b04      	ldr	r3, [pc, #16]	@ (34003890 <LL_RCC_MSI_GetFrequency+0x18>)
3400387e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34003880:	f403 7300 	and.w	r3, r3, #512	@ 0x200
}
34003884:	4618      	mov	r0, r3
34003886:	46bd      	mov	sp, r7
34003888:	f85d 7b04 	ldr.w	r7, [sp], #4
3400388c:	4770      	bx	lr
3400388e:	bf00      	nop
34003890:	56028000 	.word	0x56028000

34003894 <LL_RCC_LSE_IsReady>:
{
34003894:	b480      	push	{r7}
34003896:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSERDY) != 0UL) ? 1UL : 0UL);
34003898:	4b06      	ldr	r3, [pc, #24]	@ (340038b4 <LL_RCC_LSE_IsReady+0x20>)
3400389a:	685b      	ldr	r3, [r3, #4]
3400389c:	f003 0302 	and.w	r3, r3, #2
340038a0:	2b00      	cmp	r3, #0
340038a2:	d001      	beq.n	340038a8 <LL_RCC_LSE_IsReady+0x14>
340038a4:	2301      	movs	r3, #1
340038a6:	e000      	b.n	340038aa <LL_RCC_LSE_IsReady+0x16>
340038a8:	2300      	movs	r3, #0
}
340038aa:	4618      	mov	r0, r3
340038ac:	46bd      	mov	sp, r7
340038ae:	f85d 7b04 	ldr.w	r7, [sp], #4
340038b2:	4770      	bx	lr
340038b4:	56028000 	.word	0x56028000

340038b8 <LL_RCC_LSI_IsReady>:
{
340038b8:	b480      	push	{r7}
340038ba:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
340038bc:	4b04      	ldr	r3, [pc, #16]	@ (340038d0 <LL_RCC_LSI_IsReady+0x18>)
340038be:	685b      	ldr	r3, [r3, #4]
340038c0:	f003 0301 	and.w	r3, r3, #1
}
340038c4:	4618      	mov	r0, r3
340038c6:	46bd      	mov	sp, r7
340038c8:	f85d 7b04 	ldr.w	r7, [sp], #4
340038cc:	4770      	bx	lr
340038ce:	bf00      	nop
340038d0:	56028000 	.word	0x56028000

340038d4 <LL_RCC_GetAHBPrescaler>:
{
340038d4:	b480      	push	{r7}
340038d6:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_HPRE));
340038d8:	4b04      	ldr	r3, [pc, #16]	@ (340038ec <LL_RCC_GetAHBPrescaler+0x18>)
340038da:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340038dc:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
}
340038e0:	4618      	mov	r0, r3
340038e2:	46bd      	mov	sp, r7
340038e4:	f85d 7b04 	ldr.w	r7, [sp], #4
340038e8:	4770      	bx	lr
340038ea:	bf00      	nop
340038ec:	56028000 	.word	0x56028000

340038f0 <LL_RCC_GetAPB1Prescaler>:
{
340038f0:	b480      	push	{r7}
340038f2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
340038f4:	4b04      	ldr	r3, [pc, #16]	@ (34003908 <LL_RCC_GetAPB1Prescaler+0x18>)
340038f6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340038f8:	f003 0307 	and.w	r3, r3, #7
}
340038fc:	4618      	mov	r0, r3
340038fe:	46bd      	mov	sp, r7
34003900:	f85d 7b04 	ldr.w	r7, [sp], #4
34003904:	4770      	bx	lr
34003906:	bf00      	nop
34003908:	56028000 	.word	0x56028000

3400390c <LL_RCC_GetAPB2Prescaler>:
{
3400390c:	b480      	push	{r7}
3400390e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE2));
34003910:	4b04      	ldr	r3, [pc, #16]	@ (34003924 <LL_RCC_GetAPB2Prescaler+0x18>)
34003912:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34003914:	f003 0370 	and.w	r3, r3, #112	@ 0x70
}
34003918:	4618      	mov	r0, r3
3400391a:	46bd      	mov	sp, r7
3400391c:	f85d 7b04 	ldr.w	r7, [sp], #4
34003920:	4770      	bx	lr
34003922:	bf00      	nop
34003924:	56028000 	.word	0x56028000

34003928 <LL_RCC_GetAPB4Prescaler>:
{
34003928:	b480      	push	{r7}
3400392a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE4));
3400392c:	4b04      	ldr	r3, [pc, #16]	@ (34003940 <LL_RCC_GetAPB4Prescaler+0x18>)
3400392e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34003930:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
}
34003934:	4618      	mov	r0, r3
34003936:	46bd      	mov	sp, r7
34003938:	f85d 7b04 	ldr.w	r7, [sp], #4
3400393c:	4770      	bx	lr
3400393e:	bf00      	nop
34003940:	56028000 	.word	0x56028000

34003944 <LL_RCC_GetAPB5Prescaler>:
{
34003944:	b480      	push	{r7}
34003946:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE5));
34003948:	4b04      	ldr	r3, [pc, #16]	@ (3400395c <LL_RCC_GetAPB5Prescaler+0x18>)
3400394a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400394c:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
}
34003950:	4618      	mov	r0, r3
34003952:	46bd      	mov	sp, r7
34003954:	f85d 7b04 	ldr.w	r7, [sp], #4
34003958:	4770      	bx	lr
3400395a:	bf00      	nop
3400395c:	56028000 	.word	0x56028000

34003960 <LL_RCC_SetClockSource>:
{
34003960:	b480      	push	{r7}
34003962:	b085      	sub	sp, #20
34003964:	af00      	add	r7, sp, #0
34003966:	6078      	str	r0, [r7, #4]
  volatile uint32_t *pReg = (uint32_t *)((uint32_t)&RCC->CCIPR1 + LL_CLKSOURCE_REG(ClkSource));
34003968:	687b      	ldr	r3, [r7, #4]
3400396a:	b2da      	uxtb	r2, r3
3400396c:	4b10      	ldr	r3, [pc, #64]	@ (340039b0 <LL_RCC_SetClockSource+0x50>)
3400396e:	4413      	add	r3, r2
34003970:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(*pReg, LL_CLKSOURCE_MASK(ClkSource), LL_CLKSOURCE_CONFIG(ClkSource));
34003972:	68fb      	ldr	r3, [r7, #12]
34003974:	681a      	ldr	r2, [r3, #0]
34003976:	687b      	ldr	r3, [r7, #4]
34003978:	0e19      	lsrs	r1, r3, #24
3400397a:	687b      	ldr	r3, [r7, #4]
3400397c:	0a1b      	lsrs	r3, r3, #8
3400397e:	f003 031f 	and.w	r3, r3, #31
34003982:	fa01 f303 	lsl.w	r3, r1, r3
34003986:	43db      	mvns	r3, r3
34003988:	401a      	ands	r2, r3
3400398a:	687b      	ldr	r3, [r7, #4]
3400398c:	0c1b      	lsrs	r3, r3, #16
3400398e:	b2d9      	uxtb	r1, r3
34003990:	687b      	ldr	r3, [r7, #4]
34003992:	0a1b      	lsrs	r3, r3, #8
34003994:	f003 031f 	and.w	r3, r3, #31
34003998:	fa01 f303 	lsl.w	r3, r1, r3
3400399c:	431a      	orrs	r2, r3
3400399e:	68fb      	ldr	r3, [r7, #12]
340039a0:	601a      	str	r2, [r3, #0]
}
340039a2:	bf00      	nop
340039a4:	3714      	adds	r7, #20
340039a6:	46bd      	mov	sp, r7
340039a8:	f85d 7b04 	ldr.w	r7, [sp], #4
340039ac:	4770      	bx	lr
340039ae:	bf00      	nop
340039b0:	56028144 	.word	0x56028144

340039b4 <LL_RCC_GetADCPrescaler>:
{
340039b4:	b480      	push	{r7}
340039b6:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADCPRE) >> RCC_CCIPR1_ADCPRE_Pos);
340039b8:	4b04      	ldr	r3, [pc, #16]	@ (340039cc <LL_RCC_GetADCPrescaler+0x18>)
340039ba:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
340039be:	0a1b      	lsrs	r3, r3, #8
340039c0:	b2db      	uxtb	r3, r3
}
340039c2:	4618      	mov	r0, r3
340039c4:	46bd      	mov	sp, r7
340039c6:	f85d 7b04 	ldr.w	r7, [sp], #4
340039ca:	4770      	bx	lr
340039cc:	56028000 	.word	0x56028000

340039d0 <LL_RCC_SetADFClockSource>:
{
340039d0:	b480      	push	{r7}
340039d2:	b083      	sub	sp, #12
340039d4:	af00      	add	r7, sp, #0
340039d6:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_ADF1SEL, ClkSource);
340039d8:	4b07      	ldr	r3, [pc, #28]	@ (340039f8 <LL_RCC_SetADFClockSource+0x28>)
340039da:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
340039de:	f023 0207 	bic.w	r2, r3, #7
340039e2:	4905      	ldr	r1, [pc, #20]	@ (340039f8 <LL_RCC_SetADFClockSource+0x28>)
340039e4:	687b      	ldr	r3, [r7, #4]
340039e6:	4313      	orrs	r3, r2
340039e8:	f8c1 3144 	str.w	r3, [r1, #324]	@ 0x144
}
340039ec:	bf00      	nop
340039ee:	370c      	adds	r7, #12
340039f0:	46bd      	mov	sp, r7
340039f2:	f85d 7b04 	ldr.w	r7, [sp], #4
340039f6:	4770      	bx	lr
340039f8:	56028000 	.word	0x56028000

340039fc <LL_RCC_SetCLKPClockSource>:
{
340039fc:	b480      	push	{r7}
340039fe:	b083      	sub	sp, #12
34003a00:	af00      	add	r7, sp, #0
34003a02:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_PERSEL, ClkSource);
34003a04:	4b07      	ldr	r3, [pc, #28]	@ (34003a24 <LL_RCC_SetCLKPClockSource+0x28>)
34003a06:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
34003a0a:	f023 0207 	bic.w	r2, r3, #7
34003a0e:	4905      	ldr	r1, [pc, #20]	@ (34003a24 <LL_RCC_SetCLKPClockSource+0x28>)
34003a10:	687b      	ldr	r3, [r7, #4]
34003a12:	4313      	orrs	r3, r2
34003a14:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
34003a18:	bf00      	nop
34003a1a:	370c      	adds	r7, #12
34003a1c:	46bd      	mov	sp, r7
34003a1e:	f85d 7b04 	ldr.w	r7, [sp], #4
34003a22:	4770      	bx	lr
34003a24:	56028000 	.word	0x56028000

34003a28 <LL_RCC_SetDCMIPPClockSource>:
{
34003a28:	b480      	push	{r7}
34003a2a:	b083      	sub	sp, #12
34003a2c:	af00      	add	r7, sp, #0
34003a2e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_DCMIPPSEL, ClkSource);
34003a30:	4b07      	ldr	r3, [pc, #28]	@ (34003a50 <LL_RCC_SetDCMIPPClockSource+0x28>)
34003a32:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
34003a36:	f423 1240 	bic.w	r2, r3, #3145728	@ 0x300000
34003a3a:	4905      	ldr	r1, [pc, #20]	@ (34003a50 <LL_RCC_SetDCMIPPClockSource+0x28>)
34003a3c:	687b      	ldr	r3, [r7, #4]
34003a3e:	4313      	orrs	r3, r2
34003a40:	f8c1 3144 	str.w	r3, [r1, #324]	@ 0x144
}
34003a44:	bf00      	nop
34003a46:	370c      	adds	r7, #12
34003a48:	46bd      	mov	sp, r7
34003a4a:	f85d 7b04 	ldr.w	r7, [sp], #4
34003a4e:	4770      	bx	lr
34003a50:	56028000 	.word	0x56028000

34003a54 <LL_RCC_SetETHClockSource>:
{
34003a54:	b480      	push	{r7}
34003a56:	b083      	sub	sp, #12
34003a58:	af00      	add	r7, sp, #0
34003a5a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1CLKSEL, ClkSource);
34003a5c:	4b07      	ldr	r3, [pc, #28]	@ (34003a7c <LL_RCC_SetETHClockSource+0x28>)
34003a5e:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34003a62:	f423 5240 	bic.w	r2, r3, #12288	@ 0x3000
34003a66:	4905      	ldr	r1, [pc, #20]	@ (34003a7c <LL_RCC_SetETHClockSource+0x28>)
34003a68:	687b      	ldr	r3, [r7, #4]
34003a6a:	4313      	orrs	r3, r2
34003a6c:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
34003a70:	bf00      	nop
34003a72:	370c      	adds	r7, #12
34003a74:	46bd      	mov	sp, r7
34003a76:	f85d 7b04 	ldr.w	r7, [sp], #4
34003a7a:	4770      	bx	lr
34003a7c:	56028000 	.word	0x56028000

34003a80 <LL_RCC_SetETHPHYInterface>:
{
34003a80:	b480      	push	{r7}
34003a82:	b083      	sub	sp, #12
34003a84:	af00      	add	r7, sp, #0
34003a86:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1SEL, Interface);
34003a88:	4b07      	ldr	r3, [pc, #28]	@ (34003aa8 <LL_RCC_SetETHPHYInterface+0x28>)
34003a8a:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34003a8e:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
34003a92:	4905      	ldr	r1, [pc, #20]	@ (34003aa8 <LL_RCC_SetETHPHYInterface+0x28>)
34003a94:	687b      	ldr	r3, [r7, #4]
34003a96:	4313      	orrs	r3, r2
34003a98:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
34003a9c:	bf00      	nop
34003a9e:	370c      	adds	r7, #12
34003aa0:	46bd      	mov	sp, r7
34003aa2:	f85d 7b04 	ldr.w	r7, [sp], #4
34003aa6:	4770      	bx	lr
34003aa8:	56028000 	.word	0x56028000

34003aac <LL_RCC_GetETH1PTPDivider>:
{
34003aac:	b480      	push	{r7}
34003aae:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1PTPDIV));
34003ab0:	4b04      	ldr	r3, [pc, #16]	@ (34003ac4 <LL_RCC_GetETH1PTPDivider+0x18>)
34003ab2:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34003ab6:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
}
34003aba:	4618      	mov	r0, r3
34003abc:	46bd      	mov	sp, r7
34003abe:	f85d 7b04 	ldr.w	r7, [sp], #4
34003ac2:	4770      	bx	lr
34003ac4:	56028000 	.word	0x56028000

34003ac8 <LL_RCC_SetETHREFRXClockSource>:
{
34003ac8:	b480      	push	{r7}
34003aca:	b083      	sub	sp, #12
34003acc:	af00      	add	r7, sp, #0
34003ace:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1REFCLKSEL, ClkSource);
34003ad0:	4b07      	ldr	r3, [pc, #28]	@ (34003af0 <LL_RCC_SetETHREFRXClockSource+0x28>)
34003ad2:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34003ad6:	f423 1280 	bic.w	r2, r3, #1048576	@ 0x100000
34003ada:	4905      	ldr	r1, [pc, #20]	@ (34003af0 <LL_RCC_SetETHREFRXClockSource+0x28>)
34003adc:	687b      	ldr	r3, [r7, #4]
34003ade:	4313      	orrs	r3, r2
34003ae0:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
34003ae4:	bf00      	nop
34003ae6:	370c      	adds	r7, #12
34003ae8:	46bd      	mov	sp, r7
34003aea:	f85d 7b04 	ldr.w	r7, [sp], #4
34003aee:	4770      	bx	lr
34003af0:	56028000 	.word	0x56028000

34003af4 <LL_RCC_SetETHREFTXClockSource>:
{
34003af4:	b480      	push	{r7}
34003af6:	b083      	sub	sp, #12
34003af8:	af00      	add	r7, sp, #0
34003afa:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1GTXCLKSEL, ClkSource);
34003afc:	4b07      	ldr	r3, [pc, #28]	@ (34003b1c <LL_RCC_SetETHREFTXClockSource+0x28>)
34003afe:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34003b02:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
34003b06:	4905      	ldr	r1, [pc, #20]	@ (34003b1c <LL_RCC_SetETHREFTXClockSource+0x28>)
34003b08:	687b      	ldr	r3, [r7, #4]
34003b0a:	4313      	orrs	r3, r2
34003b0c:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
34003b10:	bf00      	nop
34003b12:	370c      	adds	r7, #12
34003b14:	46bd      	mov	sp, r7
34003b16:	f85d 7b04 	ldr.w	r7, [sp], #4
34003b1a:	4770      	bx	lr
34003b1c:	56028000 	.word	0x56028000

34003b20 <LL_RCC_SetFDCANClockSource>:
{
34003b20:	b480      	push	{r7}
34003b22:	b083      	sub	sp, #12
34003b24:	af00      	add	r7, sp, #0
34003b26:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR3, RCC_CCIPR3_FDCANSEL, ClkSource);
34003b28:	4b07      	ldr	r3, [pc, #28]	@ (34003b48 <LL_RCC_SetFDCANClockSource+0x28>)
34003b2a:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34003b2e:	f023 0203 	bic.w	r2, r3, #3
34003b32:	4905      	ldr	r1, [pc, #20]	@ (34003b48 <LL_RCC_SetFDCANClockSource+0x28>)
34003b34:	687b      	ldr	r3, [r7, #4]
34003b36:	4313      	orrs	r3, r2
34003b38:	f8c1 314c 	str.w	r3, [r1, #332]	@ 0x14c
}
34003b3c:	bf00      	nop
34003b3e:	370c      	adds	r7, #12
34003b40:	46bd      	mov	sp, r7
34003b42:	f85d 7b04 	ldr.w	r7, [sp], #4
34003b46:	4770      	bx	lr
34003b48:	56028000 	.word	0x56028000

34003b4c <LL_RCC_SetFMCClockSource>:
{
34003b4c:	b480      	push	{r7}
34003b4e:	b083      	sub	sp, #12
34003b50:	af00      	add	r7, sp, #0
34003b52:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR3, RCC_CCIPR3_FMCSEL, ClkSource);
34003b54:	4b07      	ldr	r3, [pc, #28]	@ (34003b74 <LL_RCC_SetFMCClockSource+0x28>)
34003b56:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34003b5a:	f023 0230 	bic.w	r2, r3, #48	@ 0x30
34003b5e:	4905      	ldr	r1, [pc, #20]	@ (34003b74 <LL_RCC_SetFMCClockSource+0x28>)
34003b60:	687b      	ldr	r3, [r7, #4]
34003b62:	4313      	orrs	r3, r2
34003b64:	f8c1 314c 	str.w	r3, [r1, #332]	@ 0x14c
}
34003b68:	bf00      	nop
34003b6a:	370c      	adds	r7, #12
34003b6c:	46bd      	mov	sp, r7
34003b6e:	f85d 7b04 	ldr.w	r7, [sp], #4
34003b72:	4770      	bx	lr
34003b74:	56028000 	.word	0x56028000

34003b78 <LL_RCC_SetI2CClockSource>:
{
34003b78:	b580      	push	{r7, lr}
34003b7a:	b082      	sub	sp, #8
34003b7c:	af00      	add	r7, sp, #0
34003b7e:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34003b80:	6878      	ldr	r0, [r7, #4]
34003b82:	f7ff feed 	bl	34003960 <LL_RCC_SetClockSource>
}
34003b86:	bf00      	nop
34003b88:	3708      	adds	r7, #8
34003b8a:	46bd      	mov	sp, r7
34003b8c:	bd80      	pop	{r7, pc}

34003b8e <LL_RCC_SetI3CClockSource>:
{
34003b8e:	b580      	push	{r7, lr}
34003b90:	b082      	sub	sp, #8
34003b92:	af00      	add	r7, sp, #0
34003b94:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34003b96:	6878      	ldr	r0, [r7, #4]
34003b98:	f7ff fee2 	bl	34003960 <LL_RCC_SetClockSource>
}
34003b9c:	bf00      	nop
34003b9e:	3708      	adds	r7, #8
34003ba0:	46bd      	mov	sp, r7
34003ba2:	bd80      	pop	{r7, pc}

34003ba4 <LL_RCC_SetLPTIMClockSource>:
{
34003ba4:	b580      	push	{r7, lr}
34003ba6:	b082      	sub	sp, #8
34003ba8:	af00      	add	r7, sp, #0
34003baa:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34003bac:	6878      	ldr	r0, [r7, #4]
34003bae:	f7ff fed7 	bl	34003960 <LL_RCC_SetClockSource>
}
34003bb2:	bf00      	nop
34003bb4:	3708      	adds	r7, #8
34003bb6:	46bd      	mov	sp, r7
34003bb8:	bd80      	pop	{r7, pc}
	...

34003bbc <LL_RCC_SetLPUARTClockSource>:
{
34003bbc:	b480      	push	{r7}
34003bbe:	b083      	sub	sp, #12
34003bc0:	af00      	add	r7, sp, #0
34003bc2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR14, RCC_CCIPR14_LPUART1SEL, ClkSource);
34003bc4:	4b07      	ldr	r3, [pc, #28]	@ (34003be4 <LL_RCC_SetLPUARTClockSource+0x28>)
34003bc6:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
34003bca:	f423 62e0 	bic.w	r2, r3, #1792	@ 0x700
34003bce:	4905      	ldr	r1, [pc, #20]	@ (34003be4 <LL_RCC_SetLPUARTClockSource+0x28>)
34003bd0:	687b      	ldr	r3, [r7, #4]
34003bd2:	4313      	orrs	r3, r2
34003bd4:	f8c1 3178 	str.w	r3, [r1, #376]	@ 0x178
}
34003bd8:	bf00      	nop
34003bda:	370c      	adds	r7, #12
34003bdc:	46bd      	mov	sp, r7
34003bde:	f85d 7b04 	ldr.w	r7, [sp], #4
34003be2:	4770      	bx	lr
34003be4:	56028000 	.word	0x56028000

34003be8 <LL_RCC_SetLTDCClockSource>:
{
34003be8:	b480      	push	{r7}
34003bea:	b083      	sub	sp, #12
34003bec:	af00      	add	r7, sp, #0
34003bee:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR4, RCC_CCIPR4_LTDCSEL, ClkSource);
34003bf0:	4b07      	ldr	r3, [pc, #28]	@ (34003c10 <LL_RCC_SetLTDCClockSource+0x28>)
34003bf2:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
34003bf6:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
34003bfa:	4905      	ldr	r1, [pc, #20]	@ (34003c10 <LL_RCC_SetLTDCClockSource+0x28>)
34003bfc:	687b      	ldr	r3, [r7, #4]
34003bfe:	4313      	orrs	r3, r2
34003c00:	f8c1 3150 	str.w	r3, [r1, #336]	@ 0x150
}
34003c04:	bf00      	nop
34003c06:	370c      	adds	r7, #12
34003c08:	46bd      	mov	sp, r7
34003c0a:	f85d 7b04 	ldr.w	r7, [sp], #4
34003c0e:	4770      	bx	lr
34003c10:	56028000 	.word	0x56028000

34003c14 <LL_RCC_SetMDFClockSource>:
{
34003c14:	b480      	push	{r7}
34003c16:	b083      	sub	sp, #12
34003c18:	af00      	add	r7, sp, #0
34003c1a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR5, RCC_CCIPR5_MDF1SEL, ClkSource);
34003c1c:	4b07      	ldr	r3, [pc, #28]	@ (34003c3c <LL_RCC_SetMDFClockSource+0x28>)
34003c1e:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
34003c22:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
34003c26:	4905      	ldr	r1, [pc, #20]	@ (34003c3c <LL_RCC_SetMDFClockSource+0x28>)
34003c28:	687b      	ldr	r3, [r7, #4]
34003c2a:	4313      	orrs	r3, r2
34003c2c:	f8c1 3154 	str.w	r3, [r1, #340]	@ 0x154
}
34003c30:	bf00      	nop
34003c32:	370c      	adds	r7, #12
34003c34:	46bd      	mov	sp, r7
34003c36:	f85d 7b04 	ldr.w	r7, [sp], #4
34003c3a:	4770      	bx	lr
34003c3c:	56028000 	.word	0x56028000

34003c40 <LL_RCC_SetOTGPHYClockSource>:
{
34003c40:	b580      	push	{r7, lr}
34003c42:	b082      	sub	sp, #8
34003c44:	af00      	add	r7, sp, #0
34003c46:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34003c48:	6878      	ldr	r0, [r7, #4]
34003c4a:	f7ff fe89 	bl	34003960 <LL_RCC_SetClockSource>
}
34003c4e:	bf00      	nop
34003c50:	3708      	adds	r7, #8
34003c52:	46bd      	mov	sp, r7
34003c54:	bd80      	pop	{r7, pc}

34003c56 <LL_RCC_SetOTGPHYCKREFClockSource>:
{
34003c56:	b580      	push	{r7, lr}
34003c58:	b082      	sub	sp, #8
34003c5a:	af00      	add	r7, sp, #0
34003c5c:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34003c5e:	6878      	ldr	r0, [r7, #4]
34003c60:	f7ff fe7e 	bl	34003960 <LL_RCC_SetClockSource>
}
34003c64:	bf00      	nop
34003c66:	3708      	adds	r7, #8
34003c68:	46bd      	mov	sp, r7
34003c6a:	bd80      	pop	{r7, pc}

34003c6c <LL_RCC_SetPSSIClockSource>:
{
34003c6c:	b480      	push	{r7}
34003c6e:	b083      	sub	sp, #12
34003c70:	af00      	add	r7, sp, #0
34003c72:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_PSSISEL, ClkSource);
34003c74:	4b07      	ldr	r3, [pc, #28]	@ (34003c94 <LL_RCC_SetPSSIClockSource+0x28>)
34003c76:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
34003c7a:	f023 0230 	bic.w	r2, r3, #48	@ 0x30
34003c7e:	4905      	ldr	r1, [pc, #20]	@ (34003c94 <LL_RCC_SetPSSIClockSource+0x28>)
34003c80:	687b      	ldr	r3, [r7, #4]
34003c82:	4313      	orrs	r3, r2
34003c84:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
34003c88:	bf00      	nop
34003c8a:	370c      	adds	r7, #12
34003c8c:	46bd      	mov	sp, r7
34003c8e:	f85d 7b04 	ldr.w	r7, [sp], #4
34003c92:	4770      	bx	lr
34003c94:	56028000 	.word	0x56028000

34003c98 <LL_RCC_SetSAIClockSource>:
{
34003c98:	b580      	push	{r7, lr}
34003c9a:	b082      	sub	sp, #8
34003c9c:	af00      	add	r7, sp, #0
34003c9e:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34003ca0:	6878      	ldr	r0, [r7, #4]
34003ca2:	f7ff fe5d 	bl	34003960 <LL_RCC_SetClockSource>
}
34003ca6:	bf00      	nop
34003ca8:	3708      	adds	r7, #8
34003caa:	46bd      	mov	sp, r7
34003cac:	bd80      	pop	{r7, pc}

34003cae <LL_RCC_SetSDMMCClockSource>:
{
34003cae:	b580      	push	{r7, lr}
34003cb0:	b082      	sub	sp, #8
34003cb2:	af00      	add	r7, sp, #0
34003cb4:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34003cb6:	6878      	ldr	r0, [r7, #4]
34003cb8:	f7ff fe52 	bl	34003960 <LL_RCC_SetClockSource>
}
34003cbc:	bf00      	nop
34003cbe:	3708      	adds	r7, #8
34003cc0:	46bd      	mov	sp, r7
34003cc2:	bd80      	pop	{r7, pc}

34003cc4 <LL_RCC_SetSPDIFRXClockSource>:
{
34003cc4:	b480      	push	{r7}
34003cc6:	b083      	sub	sp, #12
34003cc8:	af00      	add	r7, sp, #0
34003cca:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR9, RCC_CCIPR9_SPDIFRX1SEL, ClkSource);
34003ccc:	4b07      	ldr	r3, [pc, #28]	@ (34003cec <LL_RCC_SetSPDIFRXClockSource+0x28>)
34003cce:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
34003cd2:	f023 0207 	bic.w	r2, r3, #7
34003cd6:	4905      	ldr	r1, [pc, #20]	@ (34003cec <LL_RCC_SetSPDIFRXClockSource+0x28>)
34003cd8:	687b      	ldr	r3, [r7, #4]
34003cda:	4313      	orrs	r3, r2
34003cdc:	f8c1 3164 	str.w	r3, [r1, #356]	@ 0x164
}
34003ce0:	bf00      	nop
34003ce2:	370c      	adds	r7, #12
34003ce4:	46bd      	mov	sp, r7
34003ce6:	f85d 7b04 	ldr.w	r7, [sp], #4
34003cea:	4770      	bx	lr
34003cec:	56028000 	.word	0x56028000

34003cf0 <LL_RCC_SetSPIClockSource>:
{
34003cf0:	b580      	push	{r7, lr}
34003cf2:	b082      	sub	sp, #8
34003cf4:	af00      	add	r7, sp, #0
34003cf6:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34003cf8:	6878      	ldr	r0, [r7, #4]
34003cfa:	f7ff fe31 	bl	34003960 <LL_RCC_SetClockSource>
}
34003cfe:	bf00      	nop
34003d00:	3708      	adds	r7, #8
34003d02:	46bd      	mov	sp, r7
34003d04:	bd80      	pop	{r7, pc}

34003d06 <LL_RCC_SetUSARTClockSource>:
{
34003d06:	b580      	push	{r7, lr}
34003d08:	b082      	sub	sp, #8
34003d0a:	af00      	add	r7, sp, #0
34003d0c:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34003d0e:	6878      	ldr	r0, [r7, #4]
34003d10:	f7ff fe26 	bl	34003960 <LL_RCC_SetClockSource>
}
34003d14:	bf00      	nop
34003d16:	3708      	adds	r7, #8
34003d18:	46bd      	mov	sp, r7
34003d1a:	bd80      	pop	{r7, pc}

34003d1c <LL_RCC_SetXSPIClockSource>:
{
34003d1c:	b580      	push	{r7, lr}
34003d1e:	b082      	sub	sp, #8
34003d20:	af00      	add	r7, sp, #0
34003d22:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34003d24:	6878      	ldr	r0, [r7, #4]
34003d26:	f7ff fe1b 	bl	34003960 <LL_RCC_SetClockSource>
}
34003d2a:	bf00      	nop
34003d2c:	3708      	adds	r7, #8
34003d2e:	46bd      	mov	sp, r7
34003d30:	bd80      	pop	{r7, pc}
	...

34003d34 <LL_RCC_GetClockSource>:
{
34003d34:	b480      	push	{r7}
34003d36:	b085      	sub	sp, #20
34003d38:	af00      	add	r7, sp, #0
34003d3a:	6078      	str	r0, [r7, #4]
  const volatile uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&RCC->CCIPR1) + LL_CLKSOURCE_REG(Periph)));
34003d3c:	687b      	ldr	r3, [r7, #4]
34003d3e:	b2da      	uxtb	r2, r3
34003d40:	4b0e      	ldr	r3, [pc, #56]	@ (34003d7c <LL_RCC_GetClockSource+0x48>)
34003d42:	4413      	add	r3, r2
34003d44:	60fb      	str	r3, [r7, #12]
  return (uint32_t)(Periph | (((READ_BIT(*pReg, LL_CLKSOURCE_MASK(Periph))) >> LL_CLKSOURCE_SHIFT(Periph)) << LL_RCC_CONFIG_SHIFT));
34003d46:	68fb      	ldr	r3, [r7, #12]
34003d48:	681a      	ldr	r2, [r3, #0]
34003d4a:	687b      	ldr	r3, [r7, #4]
34003d4c:	0e19      	lsrs	r1, r3, #24
34003d4e:	687b      	ldr	r3, [r7, #4]
34003d50:	0a1b      	lsrs	r3, r3, #8
34003d52:	f003 031f 	and.w	r3, r3, #31
34003d56:	fa01 f303 	lsl.w	r3, r1, r3
34003d5a:	401a      	ands	r2, r3
34003d5c:	687b      	ldr	r3, [r7, #4]
34003d5e:	0a1b      	lsrs	r3, r3, #8
34003d60:	f003 031f 	and.w	r3, r3, #31
34003d64:	fa22 f303 	lsr.w	r3, r2, r3
34003d68:	041a      	lsls	r2, r3, #16
34003d6a:	687b      	ldr	r3, [r7, #4]
34003d6c:	4313      	orrs	r3, r2
}
34003d6e:	4618      	mov	r0, r3
34003d70:	3714      	adds	r7, #20
34003d72:	46bd      	mov	sp, r7
34003d74:	f85d 7b04 	ldr.w	r7, [sp], #4
34003d78:	4770      	bx	lr
34003d7a:	bf00      	nop
34003d7c:	56028144 	.word	0x56028144

34003d80 <LL_RCC_GetADCClockSource>:
{
34003d80:	b480      	push	{r7}
34003d82:	b083      	sub	sp, #12
34003d84:	af00      	add	r7, sp, #0
34003d86:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADC12SEL));
34003d88:	4b05      	ldr	r3, [pc, #20]	@ (34003da0 <LL_RCC_GetADCClockSource+0x20>)
34003d8a:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
34003d8e:	f003 0370 	and.w	r3, r3, #112	@ 0x70
}
34003d92:	4618      	mov	r0, r3
34003d94:	370c      	adds	r7, #12
34003d96:	46bd      	mov	sp, r7
34003d98:	f85d 7b04 	ldr.w	r7, [sp], #4
34003d9c:	4770      	bx	lr
34003d9e:	bf00      	nop
34003da0:	56028000 	.word	0x56028000

34003da4 <LL_RCC_GetADFClockSource>:
{
34003da4:	b480      	push	{r7}
34003da6:	b083      	sub	sp, #12
34003da8:	af00      	add	r7, sp, #0
34003daa:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADF1SEL));
34003dac:	4b05      	ldr	r3, [pc, #20]	@ (34003dc4 <LL_RCC_GetADFClockSource+0x20>)
34003dae:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
34003db2:	f003 0307 	and.w	r3, r3, #7
}
34003db6:	4618      	mov	r0, r3
34003db8:	370c      	adds	r7, #12
34003dba:	46bd      	mov	sp, r7
34003dbc:	f85d 7b04 	ldr.w	r7, [sp], #4
34003dc0:	4770      	bx	lr
34003dc2:	bf00      	nop
34003dc4:	56028000 	.word	0x56028000

34003dc8 <LL_RCC_GetCLKPClockSource>:
{
34003dc8:	b480      	push	{r7}
34003dca:	b083      	sub	sp, #12
34003dcc:	af00      	add	r7, sp, #0
34003dce:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_PERSEL));
34003dd0:	4b05      	ldr	r3, [pc, #20]	@ (34003de8 <LL_RCC_GetCLKPClockSource+0x20>)
34003dd2:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
34003dd6:	f003 0307 	and.w	r3, r3, #7
}
34003dda:	4618      	mov	r0, r3
34003ddc:	370c      	adds	r7, #12
34003dde:	46bd      	mov	sp, r7
34003de0:	f85d 7b04 	ldr.w	r7, [sp], #4
34003de4:	4770      	bx	lr
34003de6:	bf00      	nop
34003de8:	56028000 	.word	0x56028000

34003dec <LL_RCC_GetDCMIPPClockSource>:
{
34003dec:	b480      	push	{r7}
34003dee:	b083      	sub	sp, #12
34003df0:	af00      	add	r7, sp, #0
34003df2:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_DCMIPPSEL));
34003df4:	4b05      	ldr	r3, [pc, #20]	@ (34003e0c <LL_RCC_GetDCMIPPClockSource+0x20>)
34003df6:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
34003dfa:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
}
34003dfe:	4618      	mov	r0, r3
34003e00:	370c      	adds	r7, #12
34003e02:	46bd      	mov	sp, r7
34003e04:	f85d 7b04 	ldr.w	r7, [sp], #4
34003e08:	4770      	bx	lr
34003e0a:	bf00      	nop
34003e0c:	56028000 	.word	0x56028000

34003e10 <LL_RCC_GetETHClockSource>:
{
34003e10:	b480      	push	{r7}
34003e12:	b083      	sub	sp, #12
34003e14:	af00      	add	r7, sp, #0
34003e16:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1CLKSEL));
34003e18:	4b05      	ldr	r3, [pc, #20]	@ (34003e30 <LL_RCC_GetETHClockSource+0x20>)
34003e1a:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34003e1e:	f403 5340 	and.w	r3, r3, #12288	@ 0x3000
}
34003e22:	4618      	mov	r0, r3
34003e24:	370c      	adds	r7, #12
34003e26:	46bd      	mov	sp, r7
34003e28:	f85d 7b04 	ldr.w	r7, [sp], #4
34003e2c:	4770      	bx	lr
34003e2e:	bf00      	nop
34003e30:	56028000 	.word	0x56028000

34003e34 <LL_RCC_GetETHPTPClockSource>:
{
34003e34:	b480      	push	{r7}
34003e36:	b083      	sub	sp, #12
34003e38:	af00      	add	r7, sp, #0
34003e3a:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1PTPSEL));
34003e3c:	4b05      	ldr	r3, [pc, #20]	@ (34003e54 <LL_RCC_GetETHPTPClockSource+0x20>)
34003e3e:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34003e42:	f003 0303 	and.w	r3, r3, #3
}
34003e46:	4618      	mov	r0, r3
34003e48:	370c      	adds	r7, #12
34003e4a:	46bd      	mov	sp, r7
34003e4c:	f85d 7b04 	ldr.w	r7, [sp], #4
34003e50:	4770      	bx	lr
34003e52:	bf00      	nop
34003e54:	56028000 	.word	0x56028000

34003e58 <LL_RCC_GetFDCANClockSource>:
{
34003e58:	b480      	push	{r7}
34003e5a:	b083      	sub	sp, #12
34003e5c:	af00      	add	r7, sp, #0
34003e5e:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR3, RCC_CCIPR3_FDCANSEL));
34003e60:	4b05      	ldr	r3, [pc, #20]	@ (34003e78 <LL_RCC_GetFDCANClockSource+0x20>)
34003e62:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34003e66:	f003 0303 	and.w	r3, r3, #3
}
34003e6a:	4618      	mov	r0, r3
34003e6c:	370c      	adds	r7, #12
34003e6e:	46bd      	mov	sp, r7
34003e70:	f85d 7b04 	ldr.w	r7, [sp], #4
34003e74:	4770      	bx	lr
34003e76:	bf00      	nop
34003e78:	56028000 	.word	0x56028000

34003e7c <LL_RCC_GetFMCClockSource>:
{
34003e7c:	b480      	push	{r7}
34003e7e:	b083      	sub	sp, #12
34003e80:	af00      	add	r7, sp, #0
34003e82:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR3, RCC_CCIPR3_FMCSEL));
34003e84:	4b05      	ldr	r3, [pc, #20]	@ (34003e9c <LL_RCC_GetFMCClockSource+0x20>)
34003e86:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34003e8a:	f003 0330 	and.w	r3, r3, #48	@ 0x30
}
34003e8e:	4618      	mov	r0, r3
34003e90:	370c      	adds	r7, #12
34003e92:	46bd      	mov	sp, r7
34003e94:	f85d 7b04 	ldr.w	r7, [sp], #4
34003e98:	4770      	bx	lr
34003e9a:	bf00      	nop
34003e9c:	56028000 	.word	0x56028000

34003ea0 <LL_RCC_GetI2CClockSource>:
{
34003ea0:	b580      	push	{r7, lr}
34003ea2:	b082      	sub	sp, #8
34003ea4:	af00      	add	r7, sp, #0
34003ea6:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
34003ea8:	6878      	ldr	r0, [r7, #4]
34003eaa:	f7ff ff43 	bl	34003d34 <LL_RCC_GetClockSource>
34003eae:	4603      	mov	r3, r0
}
34003eb0:	4618      	mov	r0, r3
34003eb2:	3708      	adds	r7, #8
34003eb4:	46bd      	mov	sp, r7
34003eb6:	bd80      	pop	{r7, pc}

34003eb8 <LL_RCC_GetI3CClockSource>:
{
34003eb8:	b580      	push	{r7, lr}
34003eba:	b082      	sub	sp, #8
34003ebc:	af00      	add	r7, sp, #0
34003ebe:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
34003ec0:	6878      	ldr	r0, [r7, #4]
34003ec2:	f7ff ff37 	bl	34003d34 <LL_RCC_GetClockSource>
34003ec6:	4603      	mov	r3, r0
}
34003ec8:	4618      	mov	r0, r3
34003eca:	3708      	adds	r7, #8
34003ecc:	46bd      	mov	sp, r7
34003ece:	bd80      	pop	{r7, pc}

34003ed0 <LL_RCC_GetLPTIMClockSource>:
{
34003ed0:	b580      	push	{r7, lr}
34003ed2:	b082      	sub	sp, #8
34003ed4:	af00      	add	r7, sp, #0
34003ed6:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
34003ed8:	6878      	ldr	r0, [r7, #4]
34003eda:	f7ff ff2b 	bl	34003d34 <LL_RCC_GetClockSource>
34003ede:	4603      	mov	r3, r0
}
34003ee0:	4618      	mov	r0, r3
34003ee2:	3708      	adds	r7, #8
34003ee4:	46bd      	mov	sp, r7
34003ee6:	bd80      	pop	{r7, pc}

34003ee8 <LL_RCC_GetLPUARTClockSource>:
{
34003ee8:	b480      	push	{r7}
34003eea:	b083      	sub	sp, #12
34003eec:	af00      	add	r7, sp, #0
34003eee:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR14, RCC_CCIPR14_LPUART1SEL));
34003ef0:	4b05      	ldr	r3, [pc, #20]	@ (34003f08 <LL_RCC_GetLPUARTClockSource+0x20>)
34003ef2:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
34003ef6:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
}
34003efa:	4618      	mov	r0, r3
34003efc:	370c      	adds	r7, #12
34003efe:	46bd      	mov	sp, r7
34003f00:	f85d 7b04 	ldr.w	r7, [sp], #4
34003f04:	4770      	bx	lr
34003f06:	bf00      	nop
34003f08:	56028000 	.word	0x56028000

34003f0c <LL_RCC_GetLTDCClockSource>:
{
34003f0c:	b480      	push	{r7}
34003f0e:	b083      	sub	sp, #12
34003f10:	af00      	add	r7, sp, #0
34003f12:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR4, RCC_CCIPR4_LTDCSEL));
34003f14:	4b05      	ldr	r3, [pc, #20]	@ (34003f2c <LL_RCC_GetLTDCClockSource+0x20>)
34003f16:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
34003f1a:	f003 7340 	and.w	r3, r3, #50331648	@ 0x3000000
}
34003f1e:	4618      	mov	r0, r3
34003f20:	370c      	adds	r7, #12
34003f22:	46bd      	mov	sp, r7
34003f24:	f85d 7b04 	ldr.w	r7, [sp], #4
34003f28:	4770      	bx	lr
34003f2a:	bf00      	nop
34003f2c:	56028000 	.word	0x56028000

34003f30 <LL_RCC_GetMDFClockSource>:
{
34003f30:	b480      	push	{r7}
34003f32:	b083      	sub	sp, #12
34003f34:	af00      	add	r7, sp, #0
34003f36:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR5, RCC_CCIPR5_MDF1SEL));
34003f38:	4b05      	ldr	r3, [pc, #20]	@ (34003f50 <LL_RCC_GetMDFClockSource+0x20>)
34003f3a:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
34003f3e:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
}
34003f42:	4618      	mov	r0, r3
34003f44:	370c      	adds	r7, #12
34003f46:	46bd      	mov	sp, r7
34003f48:	f85d 7b04 	ldr.w	r7, [sp], #4
34003f4c:	4770      	bx	lr
34003f4e:	bf00      	nop
34003f50:	56028000 	.word	0x56028000

34003f54 <LL_RCC_GetPSSIClockSource>:
{
34003f54:	b480      	push	{r7}
34003f56:	b083      	sub	sp, #12
34003f58:	af00      	add	r7, sp, #0
34003f5a:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_PSSISEL));
34003f5c:	4b05      	ldr	r3, [pc, #20]	@ (34003f74 <LL_RCC_GetPSSIClockSource+0x20>)
34003f5e:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
34003f62:	f003 0330 	and.w	r3, r3, #48	@ 0x30
}
34003f66:	4618      	mov	r0, r3
34003f68:	370c      	adds	r7, #12
34003f6a:	46bd      	mov	sp, r7
34003f6c:	f85d 7b04 	ldr.w	r7, [sp], #4
34003f70:	4770      	bx	lr
34003f72:	bf00      	nop
34003f74:	56028000 	.word	0x56028000

34003f78 <LL_RCC_GetSAIClockSource>:
{
34003f78:	b580      	push	{r7, lr}
34003f7a:	b082      	sub	sp, #8
34003f7c:	af00      	add	r7, sp, #0
34003f7e:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
34003f80:	6878      	ldr	r0, [r7, #4]
34003f82:	f7ff fed7 	bl	34003d34 <LL_RCC_GetClockSource>
34003f86:	4603      	mov	r3, r0
}
34003f88:	4618      	mov	r0, r3
34003f8a:	3708      	adds	r7, #8
34003f8c:	46bd      	mov	sp, r7
34003f8e:	bd80      	pop	{r7, pc}

34003f90 <LL_RCC_GetSDMMCClockSource>:
{
34003f90:	b580      	push	{r7, lr}
34003f92:	b082      	sub	sp, #8
34003f94:	af00      	add	r7, sp, #0
34003f96:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
34003f98:	6878      	ldr	r0, [r7, #4]
34003f9a:	f7ff fecb 	bl	34003d34 <LL_RCC_GetClockSource>
34003f9e:	4603      	mov	r3, r0
}
34003fa0:	4618      	mov	r0, r3
34003fa2:	3708      	adds	r7, #8
34003fa4:	46bd      	mov	sp, r7
34003fa6:	bd80      	pop	{r7, pc}

34003fa8 <LL_RCC_GetSPDIFRXClockSource>:
{
34003fa8:	b480      	push	{r7}
34003faa:	b083      	sub	sp, #12
34003fac:	af00      	add	r7, sp, #0
34003fae:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR9, RCC_CCIPR9_SPDIFRX1SEL));
34003fb0:	4b05      	ldr	r3, [pc, #20]	@ (34003fc8 <LL_RCC_GetSPDIFRXClockSource+0x20>)
34003fb2:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
34003fb6:	f003 0307 	and.w	r3, r3, #7
}
34003fba:	4618      	mov	r0, r3
34003fbc:	370c      	adds	r7, #12
34003fbe:	46bd      	mov	sp, r7
34003fc0:	f85d 7b04 	ldr.w	r7, [sp], #4
34003fc4:	4770      	bx	lr
34003fc6:	bf00      	nop
34003fc8:	56028000 	.word	0x56028000

34003fcc <LL_RCC_GetSPIClockSource>:
{
34003fcc:	b580      	push	{r7, lr}
34003fce:	b082      	sub	sp, #8
34003fd0:	af00      	add	r7, sp, #0
34003fd2:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
34003fd4:	6878      	ldr	r0, [r7, #4]
34003fd6:	f7ff fead 	bl	34003d34 <LL_RCC_GetClockSource>
34003fda:	4603      	mov	r3, r0
}
34003fdc:	4618      	mov	r0, r3
34003fde:	3708      	adds	r7, #8
34003fe0:	46bd      	mov	sp, r7
34003fe2:	bd80      	pop	{r7, pc}

34003fe4 <LL_RCC_GetUSARTClockSource>:
{
34003fe4:	b580      	push	{r7, lr}
34003fe6:	b082      	sub	sp, #8
34003fe8:	af00      	add	r7, sp, #0
34003fea:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
34003fec:	6878      	ldr	r0, [r7, #4]
34003fee:	f7ff fea1 	bl	34003d34 <LL_RCC_GetClockSource>
34003ff2:	4603      	mov	r3, r0
}
34003ff4:	4618      	mov	r0, r3
34003ff6:	3708      	adds	r7, #8
34003ff8:	46bd      	mov	sp, r7
34003ffa:	bd80      	pop	{r7, pc}

34003ffc <LL_RCC_GetUARTClockSource>:
{
34003ffc:	b580      	push	{r7, lr}
34003ffe:	b082      	sub	sp, #8
34004000:	af00      	add	r7, sp, #0
34004002:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
34004004:	6878      	ldr	r0, [r7, #4]
34004006:	f7ff fe95 	bl	34003d34 <LL_RCC_GetClockSource>
3400400a:	4603      	mov	r3, r0
}
3400400c:	4618      	mov	r0, r3
3400400e:	3708      	adds	r7, #8
34004010:	46bd      	mov	sp, r7
34004012:	bd80      	pop	{r7, pc}

34004014 <LL_RCC_GetUSBClockSource>:
{
34004014:	b580      	push	{r7, lr}
34004016:	b082      	sub	sp, #8
34004018:	af00      	add	r7, sp, #0
3400401a:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3400401c:	6878      	ldr	r0, [r7, #4]
3400401e:	f7ff fe89 	bl	34003d34 <LL_RCC_GetClockSource>
34004022:	4603      	mov	r3, r0
}
34004024:	4618      	mov	r0, r3
34004026:	3708      	adds	r7, #8
34004028:	46bd      	mov	sp, r7
3400402a:	bd80      	pop	{r7, pc}

3400402c <LL_RCC_GetXSPIClockSource>:
{
3400402c:	b580      	push	{r7, lr}
3400402e:	b082      	sub	sp, #8
34004030:	af00      	add	r7, sp, #0
34004032:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
34004034:	6878      	ldr	r0, [r7, #4]
34004036:	f7ff fe7d 	bl	34003d34 <LL_RCC_GetClockSource>
3400403a:	4603      	mov	r3, r0
}
3400403c:	4618      	mov	r0, r3
3400403e:	3708      	adds	r7, #8
34004040:	46bd      	mov	sp, r7
34004042:	bd80      	pop	{r7, pc}

34004044 <LL_RCC_SetRTCClockSource>:
{
34004044:	b480      	push	{r7}
34004046:	b083      	sub	sp, #12
34004048:	af00      	add	r7, sp, #0
3400404a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_RTCSEL, Source);
3400404c:	4b07      	ldr	r3, [pc, #28]	@ (3400406c <LL_RCC_SetRTCClockSource+0x28>)
3400404e:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
34004052:	f423 7240 	bic.w	r2, r3, #768	@ 0x300
34004056:	4905      	ldr	r1, [pc, #20]	@ (3400406c <LL_RCC_SetRTCClockSource+0x28>)
34004058:	687b      	ldr	r3, [r7, #4]
3400405a:	4313      	orrs	r3, r2
3400405c:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
34004060:	bf00      	nop
34004062:	370c      	adds	r7, #12
34004064:	46bd      	mov	sp, r7
34004066:	f85d 7b04 	ldr.w	r7, [sp], #4
3400406a:	4770      	bx	lr
3400406c:	56028000 	.word	0x56028000

34004070 <LL_RCC_GetRTCClockSource>:
{
34004070:	b480      	push	{r7}
34004072:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCSEL));
34004074:	4b04      	ldr	r3, [pc, #16]	@ (34004088 <LL_RCC_GetRTCClockSource+0x18>)
34004076:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3400407a:	f403 7340 	and.w	r3, r3, #768	@ 0x300
}
3400407e:	4618      	mov	r0, r3
34004080:	46bd      	mov	sp, r7
34004082:	f85d 7b04 	ldr.w	r7, [sp], #4
34004086:	4770      	bx	lr
34004088:	56028000 	.word	0x56028000

3400408c <LL_RCC_SetRTC_HSEPrescaler>:
{
3400408c:	b480      	push	{r7}
3400408e:	b083      	sub	sp, #12
34004090:	af00      	add	r7, sp, #0
34004092:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_RTCPRE, Prescaler);
34004094:	4b07      	ldr	r3, [pc, #28]	@ (340040b4 <LL_RCC_SetRTC_HSEPrescaler+0x28>)
34004096:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3400409a:	f423 327c 	bic.w	r2, r3, #258048	@ 0x3f000
3400409e:	4905      	ldr	r1, [pc, #20]	@ (340040b4 <LL_RCC_SetRTC_HSEPrescaler+0x28>)
340040a0:	687b      	ldr	r3, [r7, #4]
340040a2:	4313      	orrs	r3, r2
340040a4:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
340040a8:	bf00      	nop
340040aa:	370c      	adds	r7, #12
340040ac:	46bd      	mov	sp, r7
340040ae:	f85d 7b04 	ldr.w	r7, [sp], #4
340040b2:	4770      	bx	lr
340040b4:	56028000 	.word	0x56028000

340040b8 <LL_RCC_SetTIMPrescaler>:
{
340040b8:	b480      	push	{r7}
340040ba:	b083      	sub	sp, #12
340040bc:	af00      	add	r7, sp, #0
340040be:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR2, RCC_CFGR2_TIMPRE, Prescaler << RCC_CFGR2_TIMPRE_Pos);
340040c0:	4b07      	ldr	r3, [pc, #28]	@ (340040e0 <LL_RCC_SetTIMPrescaler+0x28>)
340040c2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340040c4:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
340040c8:	687b      	ldr	r3, [r7, #4]
340040ca:	061b      	lsls	r3, r3, #24
340040cc:	4904      	ldr	r1, [pc, #16]	@ (340040e0 <LL_RCC_SetTIMPrescaler+0x28>)
340040ce:	4313      	orrs	r3, r2
340040d0:	624b      	str	r3, [r1, #36]	@ 0x24
}
340040d2:	bf00      	nop
340040d4:	370c      	adds	r7, #12
340040d6:	46bd      	mov	sp, r7
340040d8:	f85d 7b04 	ldr.w	r7, [sp], #4
340040dc:	4770      	bx	lr
340040de:	bf00      	nop
340040e0:	56028000 	.word	0x56028000

340040e4 <LL_RCC_GetTIMPrescaler>:
{
340040e4:	b480      	push	{r7}
340040e6:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_TIMPRE) >> RCC_CFGR2_TIMPRE_Pos);
340040e8:	4b04      	ldr	r3, [pc, #16]	@ (340040fc <LL_RCC_GetTIMPrescaler+0x18>)
340040ea:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340040ec:	0e1b      	lsrs	r3, r3, #24
340040ee:	f003 0303 	and.w	r3, r3, #3
}
340040f2:	4618      	mov	r0, r3
340040f4:	46bd      	mov	sp, r7
340040f6:	f85d 7b04 	ldr.w	r7, [sp], #4
340040fa:	4770      	bx	lr
340040fc:	56028000 	.word	0x56028000

34004100 <LL_RCC_PLL1_GetSource>:
{
34004100:	b480      	push	{r7}
34004102:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1SEL));
34004104:	4b04      	ldr	r3, [pc, #16]	@ (34004118 <LL_RCC_PLL1_GetSource+0x18>)
34004106:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400410a:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3400410e:	4618      	mov	r0, r3
34004110:	46bd      	mov	sp, r7
34004112:	f85d 7b04 	ldr.w	r7, [sp], #4
34004116:	4770      	bx	lr
34004118:	56028000 	.word	0x56028000

3400411c <LL_RCC_PLL1_IsReady>:
{
3400411c:	b480      	push	{r7}
3400411e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL1RDY) == (RCC_SR_PLL1RDY)) ? 1UL : 0UL);
34004120:	4b07      	ldr	r3, [pc, #28]	@ (34004140 <LL_RCC_PLL1_IsReady+0x24>)
34004122:	685b      	ldr	r3, [r3, #4]
34004124:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34004128:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400412c:	d101      	bne.n	34004132 <LL_RCC_PLL1_IsReady+0x16>
3400412e:	2301      	movs	r3, #1
34004130:	e000      	b.n	34004134 <LL_RCC_PLL1_IsReady+0x18>
34004132:	2300      	movs	r3, #0
}
34004134:	4618      	mov	r0, r3
34004136:	46bd      	mov	sp, r7
34004138:	f85d 7b04 	ldr.w	r7, [sp], #4
3400413c:	4770      	bx	lr
3400413e:	bf00      	nop
34004140:	56028000 	.word	0x56028000

34004144 <LL_RCC_PLL1_IsEnabledBypass>:
{
34004144:	b480      	push	{r7}
34004146:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1BYP) == RCC_PLL1CFGR1_PLL1BYP) ? 1UL : 0UL);
34004148:	4b07      	ldr	r3, [pc, #28]	@ (34004168 <LL_RCC_PLL1_IsEnabledBypass+0x24>)
3400414a:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400414e:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34004152:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
34004156:	d101      	bne.n	3400415c <LL_RCC_PLL1_IsEnabledBypass+0x18>
34004158:	2301      	movs	r3, #1
3400415a:	e000      	b.n	3400415e <LL_RCC_PLL1_IsEnabledBypass+0x1a>
3400415c:	2300      	movs	r3, #0
}
3400415e:	4618      	mov	r0, r3
34004160:	46bd      	mov	sp, r7
34004162:	f85d 7b04 	ldr.w	r7, [sp], #4
34004166:	4770      	bx	lr
34004168:	56028000 	.word	0x56028000

3400416c <LL_RCC_PLL1_GetN>:
{
3400416c:	b480      	push	{r7}
3400416e:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1DIVN) >> RCC_PLL1CFGR1_PLL1DIVN_Pos));
34004170:	4b05      	ldr	r3, [pc, #20]	@ (34004188 <LL_RCC_PLL1_GetN+0x1c>)
34004172:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34004176:	0a1b      	lsrs	r3, r3, #8
34004178:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
3400417c:	4618      	mov	r0, r3
3400417e:	46bd      	mov	sp, r7
34004180:	f85d 7b04 	ldr.w	r7, [sp], #4
34004184:	4770      	bx	lr
34004186:	bf00      	nop
34004188:	56028000 	.word	0x56028000

3400418c <LL_RCC_PLL1_GetM>:
{
3400418c:	b480      	push	{r7}
3400418e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1DIVM) >> RCC_PLL1CFGR1_PLL1DIVM_Pos);
34004190:	4b05      	ldr	r3, [pc, #20]	@ (340041a8 <LL_RCC_PLL1_GetM+0x1c>)
34004192:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34004196:	0d1b      	lsrs	r3, r3, #20
34004198:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
3400419c:	4618      	mov	r0, r3
3400419e:	46bd      	mov	sp, r7
340041a0:	f85d 7b04 	ldr.w	r7, [sp], #4
340041a4:	4770      	bx	lr
340041a6:	bf00      	nop
340041a8:	56028000 	.word	0x56028000

340041ac <LL_RCC_PLL1_GetP1>:
{
340041ac:	b480      	push	{r7}
340041ae:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV1) >> RCC_PLL1CFGR3_PLL1PDIV1_Pos);
340041b0:	4b05      	ldr	r3, [pc, #20]	@ (340041c8 <LL_RCC_PLL1_GetP1+0x1c>)
340041b2:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
340041b6:	0edb      	lsrs	r3, r3, #27
340041b8:	f003 0307 	and.w	r3, r3, #7
}
340041bc:	4618      	mov	r0, r3
340041be:	46bd      	mov	sp, r7
340041c0:	f85d 7b04 	ldr.w	r7, [sp], #4
340041c4:	4770      	bx	lr
340041c6:	bf00      	nop
340041c8:	56028000 	.word	0x56028000

340041cc <LL_RCC_PLL1_GetP2>:
{
340041cc:	b480      	push	{r7}
340041ce:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV2) >> RCC_PLL1CFGR3_PLL1PDIV2_Pos);
340041d0:	4b05      	ldr	r3, [pc, #20]	@ (340041e8 <LL_RCC_PLL1_GetP2+0x1c>)
340041d2:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
340041d6:	0e1b      	lsrs	r3, r3, #24
340041d8:	f003 0307 	and.w	r3, r3, #7
}
340041dc:	4618      	mov	r0, r3
340041de:	46bd      	mov	sp, r7
340041e0:	f85d 7b04 	ldr.w	r7, [sp], #4
340041e4:	4770      	bx	lr
340041e6:	bf00      	nop
340041e8:	56028000 	.word	0x56028000

340041ec <LL_RCC_PLL1P_IsEnabled>:
{
340041ec:	b480      	push	{r7}
340041ee:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIVEN) == RCC_PLL1CFGR3_PLL1PDIVEN) ? 1UL : 0UL);
340041f0:	4b07      	ldr	r3, [pc, #28]	@ (34004210 <LL_RCC_PLL1P_IsEnabled+0x24>)
340041f2:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
340041f6:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
340041fa:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
340041fe:	d101      	bne.n	34004204 <LL_RCC_PLL1P_IsEnabled+0x18>
34004200:	2301      	movs	r3, #1
34004202:	e000      	b.n	34004206 <LL_RCC_PLL1P_IsEnabled+0x1a>
34004204:	2300      	movs	r3, #0
}
34004206:	4618      	mov	r0, r3
34004208:	46bd      	mov	sp, r7
3400420a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400420e:	4770      	bx	lr
34004210:	56028000 	.word	0x56028000

34004214 <LL_RCC_PLL1_GetFRACN>:
{
34004214:	b480      	push	{r7}
34004216:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >> RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos);
34004218:	4b04      	ldr	r3, [pc, #16]	@ (3400422c <LL_RCC_PLL1_GetFRACN+0x18>)
3400421a:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
3400421e:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
34004222:	4618      	mov	r0, r3
34004224:	46bd      	mov	sp, r7
34004226:	f85d 7b04 	ldr.w	r7, [sp], #4
3400422a:	4770      	bx	lr
3400422c:	56028000 	.word	0x56028000

34004230 <LL_RCC_PLL2_GetSource>:
{
34004230:	b480      	push	{r7}
34004232:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2SEL));
34004234:	4b04      	ldr	r3, [pc, #16]	@ (34004248 <LL_RCC_PLL2_GetSource+0x18>)
34004236:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3400423a:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3400423e:	4618      	mov	r0, r3
34004240:	46bd      	mov	sp, r7
34004242:	f85d 7b04 	ldr.w	r7, [sp], #4
34004246:	4770      	bx	lr
34004248:	56028000 	.word	0x56028000

3400424c <LL_RCC_PLL2_IsReady>:
{
3400424c:	b480      	push	{r7}
3400424e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL2RDY) == (RCC_SR_PLL2RDY)) ? 1UL : 0UL);
34004250:	4b07      	ldr	r3, [pc, #28]	@ (34004270 <LL_RCC_PLL2_IsReady+0x24>)
34004252:	685b      	ldr	r3, [r3, #4]
34004254:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34004258:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3400425c:	d101      	bne.n	34004262 <LL_RCC_PLL2_IsReady+0x16>
3400425e:	2301      	movs	r3, #1
34004260:	e000      	b.n	34004264 <LL_RCC_PLL2_IsReady+0x18>
34004262:	2300      	movs	r3, #0
}
34004264:	4618      	mov	r0, r3
34004266:	46bd      	mov	sp, r7
34004268:	f85d 7b04 	ldr.w	r7, [sp], #4
3400426c:	4770      	bx	lr
3400426e:	bf00      	nop
34004270:	56028000 	.word	0x56028000

34004274 <LL_RCC_PLL2_IsEnabledBypass>:
{
34004274:	b480      	push	{r7}
34004276:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2BYP) == RCC_PLL2CFGR1_PLL2BYP) ? 1UL : 0UL);
34004278:	4b07      	ldr	r3, [pc, #28]	@ (34004298 <LL_RCC_PLL2_IsEnabledBypass+0x24>)
3400427a:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3400427e:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34004282:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
34004286:	d101      	bne.n	3400428c <LL_RCC_PLL2_IsEnabledBypass+0x18>
34004288:	2301      	movs	r3, #1
3400428a:	e000      	b.n	3400428e <LL_RCC_PLL2_IsEnabledBypass+0x1a>
3400428c:	2300      	movs	r3, #0
}
3400428e:	4618      	mov	r0, r3
34004290:	46bd      	mov	sp, r7
34004292:	f85d 7b04 	ldr.w	r7, [sp], #4
34004296:	4770      	bx	lr
34004298:	56028000 	.word	0x56028000

3400429c <LL_RCC_PLL2_GetN>:
{
3400429c:	b480      	push	{r7}
3400429e:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2DIVN) >> RCC_PLL2CFGR1_PLL2DIVN_Pos));
340042a0:	4b05      	ldr	r3, [pc, #20]	@ (340042b8 <LL_RCC_PLL2_GetN+0x1c>)
340042a2:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
340042a6:	0a1b      	lsrs	r3, r3, #8
340042a8:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
340042ac:	4618      	mov	r0, r3
340042ae:	46bd      	mov	sp, r7
340042b0:	f85d 7b04 	ldr.w	r7, [sp], #4
340042b4:	4770      	bx	lr
340042b6:	bf00      	nop
340042b8:	56028000 	.word	0x56028000

340042bc <LL_RCC_PLL2_GetM>:
{
340042bc:	b480      	push	{r7}
340042be:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2DIVM) >> RCC_PLL2CFGR1_PLL2DIVM_Pos);
340042c0:	4b05      	ldr	r3, [pc, #20]	@ (340042d8 <LL_RCC_PLL2_GetM+0x1c>)
340042c2:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
340042c6:	0d1b      	lsrs	r3, r3, #20
340042c8:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
340042cc:	4618      	mov	r0, r3
340042ce:	46bd      	mov	sp, r7
340042d0:	f85d 7b04 	ldr.w	r7, [sp], #4
340042d4:	4770      	bx	lr
340042d6:	bf00      	nop
340042d8:	56028000 	.word	0x56028000

340042dc <LL_RCC_PLL2_GetP1>:
{
340042dc:	b480      	push	{r7}
340042de:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV1) >> RCC_PLL2CFGR3_PLL2PDIV1_Pos);
340042e0:	4b05      	ldr	r3, [pc, #20]	@ (340042f8 <LL_RCC_PLL2_GetP1+0x1c>)
340042e2:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
340042e6:	0edb      	lsrs	r3, r3, #27
340042e8:	f003 0307 	and.w	r3, r3, #7
}
340042ec:	4618      	mov	r0, r3
340042ee:	46bd      	mov	sp, r7
340042f0:	f85d 7b04 	ldr.w	r7, [sp], #4
340042f4:	4770      	bx	lr
340042f6:	bf00      	nop
340042f8:	56028000 	.word	0x56028000

340042fc <LL_RCC_PLL2_GetP2>:
{
340042fc:	b480      	push	{r7}
340042fe:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV2) >> RCC_PLL2CFGR3_PLL2PDIV2_Pos);
34004300:	4b05      	ldr	r3, [pc, #20]	@ (34004318 <LL_RCC_PLL2_GetP2+0x1c>)
34004302:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
34004306:	0e1b      	lsrs	r3, r3, #24
34004308:	f003 0307 	and.w	r3, r3, #7
}
3400430c:	4618      	mov	r0, r3
3400430e:	46bd      	mov	sp, r7
34004310:	f85d 7b04 	ldr.w	r7, [sp], #4
34004314:	4770      	bx	lr
34004316:	bf00      	nop
34004318:	56028000 	.word	0x56028000

3400431c <LL_RCC_PLL2P_IsEnabled>:
{
3400431c:	b480      	push	{r7}
3400431e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIVEN) == RCC_PLL2CFGR3_PLL2PDIVEN) ? 1UL : 0UL);
34004320:	4b07      	ldr	r3, [pc, #28]	@ (34004340 <LL_RCC_PLL2P_IsEnabled+0x24>)
34004322:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
34004326:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3400432a:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
3400432e:	d101      	bne.n	34004334 <LL_RCC_PLL2P_IsEnabled+0x18>
34004330:	2301      	movs	r3, #1
34004332:	e000      	b.n	34004336 <LL_RCC_PLL2P_IsEnabled+0x1a>
34004334:	2300      	movs	r3, #0
}
34004336:	4618      	mov	r0, r3
34004338:	46bd      	mov	sp, r7
3400433a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400433e:	4770      	bx	lr
34004340:	56028000 	.word	0x56028000

34004344 <LL_RCC_PLL2_GetFRACN>:
{
34004344:	b480      	push	{r7}
34004346:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >> RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos);
34004348:	4b04      	ldr	r3, [pc, #16]	@ (3400435c <LL_RCC_PLL2_GetFRACN+0x18>)
3400434a:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
3400434e:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
34004352:	4618      	mov	r0, r3
34004354:	46bd      	mov	sp, r7
34004356:	f85d 7b04 	ldr.w	r7, [sp], #4
3400435a:	4770      	bx	lr
3400435c:	56028000 	.word	0x56028000

34004360 <LL_RCC_PLL3_GetSource>:
{
34004360:	b480      	push	{r7}
34004362:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3SEL));
34004364:	4b04      	ldr	r3, [pc, #16]	@ (34004378 <LL_RCC_PLL3_GetSource+0x18>)
34004366:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3400436a:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3400436e:	4618      	mov	r0, r3
34004370:	46bd      	mov	sp, r7
34004372:	f85d 7b04 	ldr.w	r7, [sp], #4
34004376:	4770      	bx	lr
34004378:	56028000 	.word	0x56028000

3400437c <LL_RCC_PLL3_IsReady>:
{
3400437c:	b480      	push	{r7}
3400437e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL3RDY) == (RCC_SR_PLL3RDY)) ? 1UL : 0UL);
34004380:	4b07      	ldr	r3, [pc, #28]	@ (340043a0 <LL_RCC_PLL3_IsReady+0x24>)
34004382:	685b      	ldr	r3, [r3, #4]
34004384:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34004388:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
3400438c:	d101      	bne.n	34004392 <LL_RCC_PLL3_IsReady+0x16>
3400438e:	2301      	movs	r3, #1
34004390:	e000      	b.n	34004394 <LL_RCC_PLL3_IsReady+0x18>
34004392:	2300      	movs	r3, #0
}
34004394:	4618      	mov	r0, r3
34004396:	46bd      	mov	sp, r7
34004398:	f85d 7b04 	ldr.w	r7, [sp], #4
3400439c:	4770      	bx	lr
3400439e:	bf00      	nop
340043a0:	56028000 	.word	0x56028000

340043a4 <LL_RCC_PLL3_IsEnabledBypass>:
{
340043a4:	b480      	push	{r7}
340043a6:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3BYP) == RCC_PLL3CFGR1_PLL3BYP) ? 1UL : 0UL);
340043a8:	4b07      	ldr	r3, [pc, #28]	@ (340043c8 <LL_RCC_PLL3_IsEnabledBypass+0x24>)
340043aa:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
340043ae:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
340043b2:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
340043b6:	d101      	bne.n	340043bc <LL_RCC_PLL3_IsEnabledBypass+0x18>
340043b8:	2301      	movs	r3, #1
340043ba:	e000      	b.n	340043be <LL_RCC_PLL3_IsEnabledBypass+0x1a>
340043bc:	2300      	movs	r3, #0
}
340043be:	4618      	mov	r0, r3
340043c0:	46bd      	mov	sp, r7
340043c2:	f85d 7b04 	ldr.w	r7, [sp], #4
340043c6:	4770      	bx	lr
340043c8:	56028000 	.word	0x56028000

340043cc <LL_RCC_PLL3_GetN>:
{
340043cc:	b480      	push	{r7}
340043ce:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3DIVN) >> RCC_PLL3CFGR1_PLL3DIVN_Pos));
340043d0:	4b05      	ldr	r3, [pc, #20]	@ (340043e8 <LL_RCC_PLL3_GetN+0x1c>)
340043d2:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
340043d6:	0a1b      	lsrs	r3, r3, #8
340043d8:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
340043dc:	4618      	mov	r0, r3
340043de:	46bd      	mov	sp, r7
340043e0:	f85d 7b04 	ldr.w	r7, [sp], #4
340043e4:	4770      	bx	lr
340043e6:	bf00      	nop
340043e8:	56028000 	.word	0x56028000

340043ec <LL_RCC_PLL3_GetM>:
{
340043ec:	b480      	push	{r7}
340043ee:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3DIVM) >> RCC_PLL3CFGR1_PLL3DIVM_Pos);
340043f0:	4b05      	ldr	r3, [pc, #20]	@ (34004408 <LL_RCC_PLL3_GetM+0x1c>)
340043f2:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
340043f6:	0d1b      	lsrs	r3, r3, #20
340043f8:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
340043fc:	4618      	mov	r0, r3
340043fe:	46bd      	mov	sp, r7
34004400:	f85d 7b04 	ldr.w	r7, [sp], #4
34004404:	4770      	bx	lr
34004406:	bf00      	nop
34004408:	56028000 	.word	0x56028000

3400440c <LL_RCC_PLL3_GetP1>:
{
3400440c:	b480      	push	{r7}
3400440e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV1) >> RCC_PLL3CFGR3_PLL3PDIV1_Pos);
34004410:	4b05      	ldr	r3, [pc, #20]	@ (34004428 <LL_RCC_PLL3_GetP1+0x1c>)
34004412:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34004416:	0edb      	lsrs	r3, r3, #27
34004418:	f003 0307 	and.w	r3, r3, #7
}
3400441c:	4618      	mov	r0, r3
3400441e:	46bd      	mov	sp, r7
34004420:	f85d 7b04 	ldr.w	r7, [sp], #4
34004424:	4770      	bx	lr
34004426:	bf00      	nop
34004428:	56028000 	.word	0x56028000

3400442c <LL_RCC_PLL3_GetP2>:
{
3400442c:	b480      	push	{r7}
3400442e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV2) >> RCC_PLL3CFGR3_PLL3PDIV2_Pos);
34004430:	4b05      	ldr	r3, [pc, #20]	@ (34004448 <LL_RCC_PLL3_GetP2+0x1c>)
34004432:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34004436:	0e1b      	lsrs	r3, r3, #24
34004438:	f003 0307 	and.w	r3, r3, #7
}
3400443c:	4618      	mov	r0, r3
3400443e:	46bd      	mov	sp, r7
34004440:	f85d 7b04 	ldr.w	r7, [sp], #4
34004444:	4770      	bx	lr
34004446:	bf00      	nop
34004448:	56028000 	.word	0x56028000

3400444c <LL_RCC_PLL3P_IsEnabled>:
{
3400444c:	b480      	push	{r7}
3400444e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIVEN) == RCC_PLL3CFGR3_PLL3PDIVEN) ? 1UL : 0UL);
34004450:	4b07      	ldr	r3, [pc, #28]	@ (34004470 <LL_RCC_PLL3P_IsEnabled+0x24>)
34004452:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34004456:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3400445a:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
3400445e:	d101      	bne.n	34004464 <LL_RCC_PLL3P_IsEnabled+0x18>
34004460:	2301      	movs	r3, #1
34004462:	e000      	b.n	34004466 <LL_RCC_PLL3P_IsEnabled+0x1a>
34004464:	2300      	movs	r3, #0
}
34004466:	4618      	mov	r0, r3
34004468:	46bd      	mov	sp, r7
3400446a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400446e:	4770      	bx	lr
34004470:	56028000 	.word	0x56028000

34004474 <LL_RCC_PLL3_GetFRACN>:
{
34004474:	b480      	push	{r7}
34004476:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >> RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos);
34004478:	4b04      	ldr	r3, [pc, #16]	@ (3400448c <LL_RCC_PLL3_GetFRACN+0x18>)
3400447a:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
3400447e:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
34004482:	4618      	mov	r0, r3
34004484:	46bd      	mov	sp, r7
34004486:	f85d 7b04 	ldr.w	r7, [sp], #4
3400448a:	4770      	bx	lr
3400448c:	56028000 	.word	0x56028000

34004490 <LL_RCC_PLL4_GetSource>:
{
34004490:	b480      	push	{r7}
34004492:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4SEL));
34004494:	4b04      	ldr	r3, [pc, #16]	@ (340044a8 <LL_RCC_PLL4_GetSource+0x18>)
34004496:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3400449a:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3400449e:	4618      	mov	r0, r3
340044a0:	46bd      	mov	sp, r7
340044a2:	f85d 7b04 	ldr.w	r7, [sp], #4
340044a6:	4770      	bx	lr
340044a8:	56028000 	.word	0x56028000

340044ac <LL_RCC_PLL4_IsReady>:
{
340044ac:	b480      	push	{r7}
340044ae:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL4RDY) == (RCC_SR_PLL4RDY)) ? 1UL : 0UL);
340044b0:	4b07      	ldr	r3, [pc, #28]	@ (340044d0 <LL_RCC_PLL4_IsReady+0x24>)
340044b2:	685b      	ldr	r3, [r3, #4]
340044b4:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
340044b8:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
340044bc:	d101      	bne.n	340044c2 <LL_RCC_PLL4_IsReady+0x16>
340044be:	2301      	movs	r3, #1
340044c0:	e000      	b.n	340044c4 <LL_RCC_PLL4_IsReady+0x18>
340044c2:	2300      	movs	r3, #0
}
340044c4:	4618      	mov	r0, r3
340044c6:	46bd      	mov	sp, r7
340044c8:	f85d 7b04 	ldr.w	r7, [sp], #4
340044cc:	4770      	bx	lr
340044ce:	bf00      	nop
340044d0:	56028000 	.word	0x56028000

340044d4 <LL_RCC_PLL4_IsEnabledBypass>:
{
340044d4:	b480      	push	{r7}
340044d6:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4BYP) == RCC_PLL4CFGR1_PLL4BYP) ? 1UL : 0UL);
340044d8:	4b07      	ldr	r3, [pc, #28]	@ (340044f8 <LL_RCC_PLL4_IsEnabledBypass+0x24>)
340044da:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
340044de:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
340044e2:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
340044e6:	d101      	bne.n	340044ec <LL_RCC_PLL4_IsEnabledBypass+0x18>
340044e8:	2301      	movs	r3, #1
340044ea:	e000      	b.n	340044ee <LL_RCC_PLL4_IsEnabledBypass+0x1a>
340044ec:	2300      	movs	r3, #0
}
340044ee:	4618      	mov	r0, r3
340044f0:	46bd      	mov	sp, r7
340044f2:	f85d 7b04 	ldr.w	r7, [sp], #4
340044f6:	4770      	bx	lr
340044f8:	56028000 	.word	0x56028000

340044fc <LL_RCC_PLL4_GetN>:
{
340044fc:	b480      	push	{r7}
340044fe:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4DIVN) >> RCC_PLL4CFGR1_PLL4DIVN_Pos));
34004500:	4b05      	ldr	r3, [pc, #20]	@ (34004518 <LL_RCC_PLL4_GetN+0x1c>)
34004502:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34004506:	0a1b      	lsrs	r3, r3, #8
34004508:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
3400450c:	4618      	mov	r0, r3
3400450e:	46bd      	mov	sp, r7
34004510:	f85d 7b04 	ldr.w	r7, [sp], #4
34004514:	4770      	bx	lr
34004516:	bf00      	nop
34004518:	56028000 	.word	0x56028000

3400451c <LL_RCC_PLL4_GetM>:
{
3400451c:	b480      	push	{r7}
3400451e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4DIVM) >> RCC_PLL4CFGR1_PLL4DIVM_Pos);
34004520:	4b05      	ldr	r3, [pc, #20]	@ (34004538 <LL_RCC_PLL4_GetM+0x1c>)
34004522:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34004526:	0d1b      	lsrs	r3, r3, #20
34004528:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
3400452c:	4618      	mov	r0, r3
3400452e:	46bd      	mov	sp, r7
34004530:	f85d 7b04 	ldr.w	r7, [sp], #4
34004534:	4770      	bx	lr
34004536:	bf00      	nop
34004538:	56028000 	.word	0x56028000

3400453c <LL_RCC_PLL4_GetP1>:
{
3400453c:	b480      	push	{r7}
3400453e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV1) >> RCC_PLL4CFGR3_PLL4PDIV1_Pos);
34004540:	4b05      	ldr	r3, [pc, #20]	@ (34004558 <LL_RCC_PLL4_GetP1+0x1c>)
34004542:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34004546:	0edb      	lsrs	r3, r3, #27
34004548:	f003 0307 	and.w	r3, r3, #7
}
3400454c:	4618      	mov	r0, r3
3400454e:	46bd      	mov	sp, r7
34004550:	f85d 7b04 	ldr.w	r7, [sp], #4
34004554:	4770      	bx	lr
34004556:	bf00      	nop
34004558:	56028000 	.word	0x56028000

3400455c <LL_RCC_PLL4_GetP2>:
{
3400455c:	b480      	push	{r7}
3400455e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV2) >> RCC_PLL4CFGR3_PLL4PDIV2_Pos);
34004560:	4b05      	ldr	r3, [pc, #20]	@ (34004578 <LL_RCC_PLL4_GetP2+0x1c>)
34004562:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34004566:	0e1b      	lsrs	r3, r3, #24
34004568:	f003 0307 	and.w	r3, r3, #7
}
3400456c:	4618      	mov	r0, r3
3400456e:	46bd      	mov	sp, r7
34004570:	f85d 7b04 	ldr.w	r7, [sp], #4
34004574:	4770      	bx	lr
34004576:	bf00      	nop
34004578:	56028000 	.word	0x56028000

3400457c <LL_RCC_PLL4P_IsEnabled>:
{
3400457c:	b480      	push	{r7}
3400457e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIVEN) == RCC_PLL4CFGR3_PLL4PDIVEN) ? 1UL : 0UL);
34004580:	4b07      	ldr	r3, [pc, #28]	@ (340045a0 <LL_RCC_PLL4P_IsEnabled+0x24>)
34004582:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34004586:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3400458a:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
3400458e:	d101      	bne.n	34004594 <LL_RCC_PLL4P_IsEnabled+0x18>
34004590:	2301      	movs	r3, #1
34004592:	e000      	b.n	34004596 <LL_RCC_PLL4P_IsEnabled+0x1a>
34004594:	2300      	movs	r3, #0
}
34004596:	4618      	mov	r0, r3
34004598:	46bd      	mov	sp, r7
3400459a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400459e:	4770      	bx	lr
340045a0:	56028000 	.word	0x56028000

340045a4 <LL_RCC_PLL4_GetFRACN>:
{
340045a4:	b480      	push	{r7}
340045a6:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >> RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos);
340045a8:	4b04      	ldr	r3, [pc, #16]	@ (340045bc <LL_RCC_PLL4_GetFRACN+0x18>)
340045aa:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
340045ae:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
340045b2:	4618      	mov	r0, r3
340045b4:	46bd      	mov	sp, r7
340045b6:	f85d 7b04 	ldr.w	r7, [sp], #4
340045ba:	4770      	bx	lr
340045bc:	56028000 	.word	0x56028000

340045c0 <LL_RCC_IC3_Enable>:
  * @brief  Enable IC3
  * @rmtoll DIVENSR       IC3ENS        LL_RCC_IC3_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC3_Enable(void)
{
340045c0:	b480      	push	{r7}
340045c2:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC3ENS);
340045c4:	4b04      	ldr	r3, [pc, #16]	@ (340045d8 <LL_RCC_IC3_Enable+0x18>)
340045c6:	2204      	movs	r2, #4
340045c8:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
340045cc:	bf00      	nop
340045ce:	46bd      	mov	sp, r7
340045d0:	f85d 7b04 	ldr.w	r7, [sp], #4
340045d4:	4770      	bx	lr
340045d6:	bf00      	nop
340045d8:	56028000 	.word	0x56028000

340045dc <LL_RCC_IC3_IsEnabled>:
  * @brief  Check if IC3 is enabled
  * @rmtoll DIVENR       IC3EN         LL_RCC_IC3_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC3_IsEnabled(void)
{
340045dc:	b480      	push	{r7}
340045de:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC3EN) == RCC_DIVENR_IC3EN) ? 1UL : 0UL);
340045e0:	4b07      	ldr	r3, [pc, #28]	@ (34004600 <LL_RCC_IC3_IsEnabled+0x24>)
340045e2:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
340045e6:	f003 0304 	and.w	r3, r3, #4
340045ea:	2b04      	cmp	r3, #4
340045ec:	d101      	bne.n	340045f2 <LL_RCC_IC3_IsEnabled+0x16>
340045ee:	2301      	movs	r3, #1
340045f0:	e000      	b.n	340045f4 <LL_RCC_IC3_IsEnabled+0x18>
340045f2:	2300      	movs	r3, #0
}
340045f4:	4618      	mov	r0, r3
340045f6:	46bd      	mov	sp, r7
340045f8:	f85d 7b04 	ldr.w	r7, [sp], #4
340045fc:	4770      	bx	lr
340045fe:	bf00      	nop
34004600:	56028000 	.word	0x56028000

34004604 <LL_RCC_IC3_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC3_GetSource(void)
{
34004604:	b480      	push	{r7}
34004606:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL));
34004608:	4b04      	ldr	r3, [pc, #16]	@ (3400461c <LL_RCC_IC3_GetSource+0x18>)
3400460a:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3400460e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34004612:	4618      	mov	r0, r3
34004614:	46bd      	mov	sp, r7
34004616:	f85d 7b04 	ldr.w	r7, [sp], #4
3400461a:	4770      	bx	lr
3400461c:	56028000 	.word	0x56028000

34004620 <LL_RCC_IC3_GetDivider>:
  * @brief  Get IC3 divider
  * @rmtoll IC3CFGR      IC3INT        LL_RCC_IC3_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC3_GetDivider(void)
{
34004620:	b480      	push	{r7}
34004622:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3INT) >> RCC_IC3CFGR_IC3INT_Pos) + 1UL);
34004624:	4b05      	ldr	r3, [pc, #20]	@ (3400463c <LL_RCC_IC3_GetDivider+0x1c>)
34004626:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3400462a:	0c1b      	lsrs	r3, r3, #16
3400462c:	b2db      	uxtb	r3, r3
3400462e:	3301      	adds	r3, #1
}
34004630:	4618      	mov	r0, r3
34004632:	46bd      	mov	sp, r7
34004634:	f85d 7b04 	ldr.w	r7, [sp], #4
34004638:	4770      	bx	lr
3400463a:	bf00      	nop
3400463c:	56028000 	.word	0x56028000

34004640 <LL_RCC_IC4_Enable>:
  * @brief  Enable IC4
  * @rmtoll DIVENSR       IC4ENS        LL_RCC_IC4_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC4_Enable(void)
{
34004640:	b480      	push	{r7}
34004642:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
34004644:	4b04      	ldr	r3, [pc, #16]	@ (34004658 <LL_RCC_IC4_Enable+0x18>)
34004646:	2208      	movs	r2, #8
34004648:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3400464c:	bf00      	nop
3400464e:	46bd      	mov	sp, r7
34004650:	f85d 7b04 	ldr.w	r7, [sp], #4
34004654:	4770      	bx	lr
34004656:	bf00      	nop
34004658:	56028000 	.word	0x56028000

3400465c <LL_RCC_IC4_IsEnabled>:
  * @brief  Check if IC4 is enabled
  * @rmtoll DIVENR       IC4EN         LL_RCC_IC4_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC4_IsEnabled(void)
{
3400465c:	b480      	push	{r7}
3400465e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC4EN) == RCC_DIVENR_IC4EN) ? 1UL : 0UL);
34004660:	4b07      	ldr	r3, [pc, #28]	@ (34004680 <LL_RCC_IC4_IsEnabled+0x24>)
34004662:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
34004666:	f003 0308 	and.w	r3, r3, #8
3400466a:	2b08      	cmp	r3, #8
3400466c:	d101      	bne.n	34004672 <LL_RCC_IC4_IsEnabled+0x16>
3400466e:	2301      	movs	r3, #1
34004670:	e000      	b.n	34004674 <LL_RCC_IC4_IsEnabled+0x18>
34004672:	2300      	movs	r3, #0
}
34004674:	4618      	mov	r0, r3
34004676:	46bd      	mov	sp, r7
34004678:	f85d 7b04 	ldr.w	r7, [sp], #4
3400467c:	4770      	bx	lr
3400467e:	bf00      	nop
34004680:	56028000 	.word	0x56028000

34004684 <LL_RCC_IC4_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC4_GetSource(void)
{
34004684:	b480      	push	{r7}
34004686:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
34004688:	4b04      	ldr	r3, [pc, #16]	@ (3400469c <LL_RCC_IC4_GetSource+0x18>)
3400468a:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3400468e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34004692:	4618      	mov	r0, r3
34004694:	46bd      	mov	sp, r7
34004696:	f85d 7b04 	ldr.w	r7, [sp], #4
3400469a:	4770      	bx	lr
3400469c:	56028000 	.word	0x56028000

340046a0 <LL_RCC_IC4_GetDivider>:
  * @brief  Get IC4 divider
  * @rmtoll IC4CFGR      IC4INT        LL_RCC_IC4_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC4_GetDivider(void)
{
340046a0:	b480      	push	{r7}
340046a2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
340046a4:	4b05      	ldr	r3, [pc, #20]	@ (340046bc <LL_RCC_IC4_GetDivider+0x1c>)
340046a6:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
340046aa:	0c1b      	lsrs	r3, r3, #16
340046ac:	b2db      	uxtb	r3, r3
340046ae:	3301      	adds	r3, #1
}
340046b0:	4618      	mov	r0, r3
340046b2:	46bd      	mov	sp, r7
340046b4:	f85d 7b04 	ldr.w	r7, [sp], #4
340046b8:	4770      	bx	lr
340046ba:	bf00      	nop
340046bc:	56028000 	.word	0x56028000

340046c0 <LL_RCC_IC5_Enable>:
  * @brief  Enable IC5
  * @rmtoll DIVENSR       IC5ENS        LL_RCC_IC5_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC5_Enable(void)
{
340046c0:	b480      	push	{r7}
340046c2:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
340046c4:	4b04      	ldr	r3, [pc, #16]	@ (340046d8 <LL_RCC_IC5_Enable+0x18>)
340046c6:	2210      	movs	r2, #16
340046c8:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
340046cc:	bf00      	nop
340046ce:	46bd      	mov	sp, r7
340046d0:	f85d 7b04 	ldr.w	r7, [sp], #4
340046d4:	4770      	bx	lr
340046d6:	bf00      	nop
340046d8:	56028000 	.word	0x56028000

340046dc <LL_RCC_IC5_IsEnabled>:
  * @brief  Check if IC5 is enabled
  * @rmtoll DIVENR       IC5EN         LL_RCC_IC5_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC5_IsEnabled(void)
{
340046dc:	b480      	push	{r7}
340046de:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC5EN) == RCC_DIVENR_IC5EN) ? 1UL : 0UL);
340046e0:	4b07      	ldr	r3, [pc, #28]	@ (34004700 <LL_RCC_IC5_IsEnabled+0x24>)
340046e2:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
340046e6:	f003 0310 	and.w	r3, r3, #16
340046ea:	2b10      	cmp	r3, #16
340046ec:	d101      	bne.n	340046f2 <LL_RCC_IC5_IsEnabled+0x16>
340046ee:	2301      	movs	r3, #1
340046f0:	e000      	b.n	340046f4 <LL_RCC_IC5_IsEnabled+0x18>
340046f2:	2300      	movs	r3, #0
}
340046f4:	4618      	mov	r0, r3
340046f6:	46bd      	mov	sp, r7
340046f8:	f85d 7b04 	ldr.w	r7, [sp], #4
340046fc:	4770      	bx	lr
340046fe:	bf00      	nop
34004700:	56028000 	.word	0x56028000

34004704 <LL_RCC_IC5_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC5_GetSource(void)
{
34004704:	b480      	push	{r7}
34004706:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL));
34004708:	4b04      	ldr	r3, [pc, #16]	@ (3400471c <LL_RCC_IC5_GetSource+0x18>)
3400470a:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
3400470e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34004712:	4618      	mov	r0, r3
34004714:	46bd      	mov	sp, r7
34004716:	f85d 7b04 	ldr.w	r7, [sp], #4
3400471a:	4770      	bx	lr
3400471c:	56028000 	.word	0x56028000

34004720 <LL_RCC_IC5_GetDivider>:
  * @brief  Get IC5 divider
  * @rmtoll IC5CFGR      IC5INT        LL_RCC_IC5_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC5_GetDivider(void)
{
34004720:	b480      	push	{r7}
34004722:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5INT) >> RCC_IC5CFGR_IC5INT_Pos) + 1UL);
34004724:	4b05      	ldr	r3, [pc, #20]	@ (3400473c <LL_RCC_IC5_GetDivider+0x1c>)
34004726:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
3400472a:	0c1b      	lsrs	r3, r3, #16
3400472c:	b2db      	uxtb	r3, r3
3400472e:	3301      	adds	r3, #1
}
34004730:	4618      	mov	r0, r3
34004732:	46bd      	mov	sp, r7
34004734:	f85d 7b04 	ldr.w	r7, [sp], #4
34004738:	4770      	bx	lr
3400473a:	bf00      	nop
3400473c:	56028000 	.word	0x56028000

34004740 <LL_RCC_IC7_Enable>:
  * @brief  Enable IC7
  * @rmtoll DIVENSR       IC7ENS        LL_RCC_IC7_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC7_Enable(void)
{
34004740:	b480      	push	{r7}
34004742:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
34004744:	4b04      	ldr	r3, [pc, #16]	@ (34004758 <LL_RCC_IC7_Enable+0x18>)
34004746:	2240      	movs	r2, #64	@ 0x40
34004748:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3400474c:	bf00      	nop
3400474e:	46bd      	mov	sp, r7
34004750:	f85d 7b04 	ldr.w	r7, [sp], #4
34004754:	4770      	bx	lr
34004756:	bf00      	nop
34004758:	56028000 	.word	0x56028000

3400475c <LL_RCC_IC7_IsEnabled>:
  * @brief  Check if IC7 is enabled
  * @rmtoll DIVENR       IC7EN         LL_RCC_IC7_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC7_IsEnabled(void)
{
3400475c:	b480      	push	{r7}
3400475e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC7EN) == RCC_DIVENR_IC7EN) ? 1UL : 0UL);
34004760:	4b07      	ldr	r3, [pc, #28]	@ (34004780 <LL_RCC_IC7_IsEnabled+0x24>)
34004762:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
34004766:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3400476a:	2b40      	cmp	r3, #64	@ 0x40
3400476c:	d101      	bne.n	34004772 <LL_RCC_IC7_IsEnabled+0x16>
3400476e:	2301      	movs	r3, #1
34004770:	e000      	b.n	34004774 <LL_RCC_IC7_IsEnabled+0x18>
34004772:	2300      	movs	r3, #0
}
34004774:	4618      	mov	r0, r3
34004776:	46bd      	mov	sp, r7
34004778:	f85d 7b04 	ldr.w	r7, [sp], #4
3400477c:	4770      	bx	lr
3400477e:	bf00      	nop
34004780:	56028000 	.word	0x56028000

34004784 <LL_RCC_IC7_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC7_GetSource(void)
{
34004784:	b480      	push	{r7}
34004786:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL));
34004788:	4b04      	ldr	r3, [pc, #16]	@ (3400479c <LL_RCC_IC7_GetSource+0x18>)
3400478a:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3400478e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34004792:	4618      	mov	r0, r3
34004794:	46bd      	mov	sp, r7
34004796:	f85d 7b04 	ldr.w	r7, [sp], #4
3400479a:	4770      	bx	lr
3400479c:	56028000 	.word	0x56028000

340047a0 <LL_RCC_IC7_GetDivider>:
  * @brief  Get IC7 divider
  * @rmtoll IC7CFGR      IC7INT        LL_RCC_IC7_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC7_GetDivider(void)
{
340047a0:	b480      	push	{r7}
340047a2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7INT) >> RCC_IC7CFGR_IC7INT_Pos) + 1UL);
340047a4:	4b05      	ldr	r3, [pc, #20]	@ (340047bc <LL_RCC_IC7_GetDivider+0x1c>)
340047a6:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
340047aa:	0c1b      	lsrs	r3, r3, #16
340047ac:	b2db      	uxtb	r3, r3
340047ae:	3301      	adds	r3, #1
}
340047b0:	4618      	mov	r0, r3
340047b2:	46bd      	mov	sp, r7
340047b4:	f85d 7b04 	ldr.w	r7, [sp], #4
340047b8:	4770      	bx	lr
340047ba:	bf00      	nop
340047bc:	56028000 	.word	0x56028000

340047c0 <LL_RCC_IC8_Enable>:
  * @brief  Enable IC8
  * @rmtoll DIVENSR       IC8ENS        LL_RCC_IC8_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC8_Enable(void)
{
340047c0:	b480      	push	{r7}
340047c2:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
340047c4:	4b04      	ldr	r3, [pc, #16]	@ (340047d8 <LL_RCC_IC8_Enable+0x18>)
340047c6:	2280      	movs	r2, #128	@ 0x80
340047c8:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
340047cc:	bf00      	nop
340047ce:	46bd      	mov	sp, r7
340047d0:	f85d 7b04 	ldr.w	r7, [sp], #4
340047d4:	4770      	bx	lr
340047d6:	bf00      	nop
340047d8:	56028000 	.word	0x56028000

340047dc <LL_RCC_IC8_IsEnabled>:
  * @brief  Check if IC8 is enabled
  * @rmtoll DIVENR       IC8EN         LL_RCC_IC8_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC8_IsEnabled(void)
{
340047dc:	b480      	push	{r7}
340047de:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC8EN) == RCC_DIVENR_IC8EN) ? 1UL : 0UL);
340047e0:	4b07      	ldr	r3, [pc, #28]	@ (34004800 <LL_RCC_IC8_IsEnabled+0x24>)
340047e2:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
340047e6:	f003 0380 	and.w	r3, r3, #128	@ 0x80
340047ea:	2b80      	cmp	r3, #128	@ 0x80
340047ec:	d101      	bne.n	340047f2 <LL_RCC_IC8_IsEnabled+0x16>
340047ee:	2301      	movs	r3, #1
340047f0:	e000      	b.n	340047f4 <LL_RCC_IC8_IsEnabled+0x18>
340047f2:	2300      	movs	r3, #0
}
340047f4:	4618      	mov	r0, r3
340047f6:	46bd      	mov	sp, r7
340047f8:	f85d 7b04 	ldr.w	r7, [sp], #4
340047fc:	4770      	bx	lr
340047fe:	bf00      	nop
34004800:	56028000 	.word	0x56028000

34004804 <LL_RCC_IC8_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC8_GetSource(void)
{
34004804:	b480      	push	{r7}
34004806:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
34004808:	4b04      	ldr	r3, [pc, #16]	@ (3400481c <LL_RCC_IC8_GetSource+0x18>)
3400480a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3400480e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34004812:	4618      	mov	r0, r3
34004814:	46bd      	mov	sp, r7
34004816:	f85d 7b04 	ldr.w	r7, [sp], #4
3400481a:	4770      	bx	lr
3400481c:	56028000 	.word	0x56028000

34004820 <LL_RCC_IC8_GetDivider>:
  * @brief  Get IC8 divider
  * @rmtoll IC8CFGR      IC8INT        LL_RCC_IC8_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC8_GetDivider(void)
{
34004820:	b480      	push	{r7}
34004822:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8INT) >> RCC_IC8CFGR_IC8INT_Pos) + 1UL);
34004824:	4b05      	ldr	r3, [pc, #20]	@ (3400483c <LL_RCC_IC8_GetDivider+0x1c>)
34004826:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3400482a:	0c1b      	lsrs	r3, r3, #16
3400482c:	b2db      	uxtb	r3, r3
3400482e:	3301      	adds	r3, #1
}
34004830:	4618      	mov	r0, r3
34004832:	46bd      	mov	sp, r7
34004834:	f85d 7b04 	ldr.w	r7, [sp], #4
34004838:	4770      	bx	lr
3400483a:	bf00      	nop
3400483c:	56028000 	.word	0x56028000

34004840 <LL_RCC_IC9_Enable>:
  * @brief  Enable IC9
  * @rmtoll DIVENSR       IC9ENS        LL_RCC_IC9_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC9_Enable(void)
{
34004840:	b480      	push	{r7}
34004842:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
34004844:	4b04      	ldr	r3, [pc, #16]	@ (34004858 <LL_RCC_IC9_Enable+0x18>)
34004846:	f44f 7280 	mov.w	r2, #256	@ 0x100
3400484a:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3400484e:	bf00      	nop
34004850:	46bd      	mov	sp, r7
34004852:	f85d 7b04 	ldr.w	r7, [sp], #4
34004856:	4770      	bx	lr
34004858:	56028000 	.word	0x56028000

3400485c <LL_RCC_IC9_IsEnabled>:
  * @brief  Check if IC9 is enabled
  * @rmtoll DIVENR       IC9EN         LL_RCC_IC9_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC9_IsEnabled(void)
{
3400485c:	b480      	push	{r7}
3400485e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC9EN) == RCC_DIVENR_IC9EN) ? 1UL : 0UL);
34004860:	4b07      	ldr	r3, [pc, #28]	@ (34004880 <LL_RCC_IC9_IsEnabled+0x24>)
34004862:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
34004866:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3400486a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400486e:	d101      	bne.n	34004874 <LL_RCC_IC9_IsEnabled+0x18>
34004870:	2301      	movs	r3, #1
34004872:	e000      	b.n	34004876 <LL_RCC_IC9_IsEnabled+0x1a>
34004874:	2300      	movs	r3, #0
}
34004876:	4618      	mov	r0, r3
34004878:	46bd      	mov	sp, r7
3400487a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400487e:	4770      	bx	lr
34004880:	56028000 	.word	0x56028000

34004884 <LL_RCC_IC9_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC9_GetSource(void)
{
34004884:	b480      	push	{r7}
34004886:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL));
34004888:	4b04      	ldr	r3, [pc, #16]	@ (3400489c <LL_RCC_IC9_GetSource+0x18>)
3400488a:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400488e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34004892:	4618      	mov	r0, r3
34004894:	46bd      	mov	sp, r7
34004896:	f85d 7b04 	ldr.w	r7, [sp], #4
3400489a:	4770      	bx	lr
3400489c:	56028000 	.word	0x56028000

340048a0 <LL_RCC_IC9_GetDivider>:
  * @brief  Get IC9 divider
  * @rmtoll IC9CFGR      IC9INT        LL_RCC_IC9_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC9_GetDivider(void)
{
340048a0:	b480      	push	{r7}
340048a2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9INT) >> RCC_IC9CFGR_IC9INT_Pos) + 1UL);
340048a4:	4b05      	ldr	r3, [pc, #20]	@ (340048bc <LL_RCC_IC9_GetDivider+0x1c>)
340048a6:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
340048aa:	0c1b      	lsrs	r3, r3, #16
340048ac:	b2db      	uxtb	r3, r3
340048ae:	3301      	adds	r3, #1
}
340048b0:	4618      	mov	r0, r3
340048b2:	46bd      	mov	sp, r7
340048b4:	f85d 7b04 	ldr.w	r7, [sp], #4
340048b8:	4770      	bx	lr
340048ba:	bf00      	nop
340048bc:	56028000 	.word	0x56028000

340048c0 <LL_RCC_IC10_Enable>:
  * @brief  Enable IC10
  * @rmtoll DIVENSR       IC10ENS        LL_RCC_IC10_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC10_Enable(void)
{
340048c0:	b480      	push	{r7}
340048c2:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
340048c4:	4b04      	ldr	r3, [pc, #16]	@ (340048d8 <LL_RCC_IC10_Enable+0x18>)
340048c6:	f44f 7200 	mov.w	r2, #512	@ 0x200
340048ca:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
340048ce:	bf00      	nop
340048d0:	46bd      	mov	sp, r7
340048d2:	f85d 7b04 	ldr.w	r7, [sp], #4
340048d6:	4770      	bx	lr
340048d8:	56028000 	.word	0x56028000

340048dc <LL_RCC_IC10_IsEnabled>:
  * @brief  Check if IC10 is enabled
  * @rmtoll DIVENR       IC10EN         LL_RCC_IC10_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC10_IsEnabled(void)
{
340048dc:	b480      	push	{r7}
340048de:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC10EN) == RCC_DIVENR_IC10EN) ? 1UL : 0UL);
340048e0:	4b07      	ldr	r3, [pc, #28]	@ (34004900 <LL_RCC_IC10_IsEnabled+0x24>)
340048e2:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
340048e6:	f403 7300 	and.w	r3, r3, #512	@ 0x200
340048ea:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
340048ee:	d101      	bne.n	340048f4 <LL_RCC_IC10_IsEnabled+0x18>
340048f0:	2301      	movs	r3, #1
340048f2:	e000      	b.n	340048f6 <LL_RCC_IC10_IsEnabled+0x1a>
340048f4:	2300      	movs	r3, #0
}
340048f6:	4618      	mov	r0, r3
340048f8:	46bd      	mov	sp, r7
340048fa:	f85d 7b04 	ldr.w	r7, [sp], #4
340048fe:	4770      	bx	lr
34004900:	56028000 	.word	0x56028000

34004904 <LL_RCC_IC10_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC10_GetSource(void)
{
34004904:	b480      	push	{r7}
34004906:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL));
34004908:	4b04      	ldr	r3, [pc, #16]	@ (3400491c <LL_RCC_IC10_GetSource+0x18>)
3400490a:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3400490e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34004912:	4618      	mov	r0, r3
34004914:	46bd      	mov	sp, r7
34004916:	f85d 7b04 	ldr.w	r7, [sp], #4
3400491a:	4770      	bx	lr
3400491c:	56028000 	.word	0x56028000

34004920 <LL_RCC_IC10_GetDivider>:
  * @brief  Get IC10 divider
  * @rmtoll IC10CFGR      IC10INT        LL_RCC_IC10_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC10_GetDivider(void)
{
34004920:	b480      	push	{r7}
34004922:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
34004924:	4b05      	ldr	r3, [pc, #20]	@ (3400493c <LL_RCC_IC10_GetDivider+0x1c>)
34004926:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3400492a:	0c1b      	lsrs	r3, r3, #16
3400492c:	b2db      	uxtb	r3, r3
3400492e:	3301      	adds	r3, #1
}
34004930:	4618      	mov	r0, r3
34004932:	46bd      	mov	sp, r7
34004934:	f85d 7b04 	ldr.w	r7, [sp], #4
34004938:	4770      	bx	lr
3400493a:	bf00      	nop
3400493c:	56028000 	.word	0x56028000

34004940 <LL_RCC_IC12_Enable>:
  * @brief  Enable IC12
  * @rmtoll DIVENSR       IC12ENS        LL_RCC_IC12_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC12_Enable(void)
{
34004940:	b480      	push	{r7}
34004942:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC12ENS);
34004944:	4b04      	ldr	r3, [pc, #16]	@ (34004958 <LL_RCC_IC12_Enable+0x18>)
34004946:	f44f 6200 	mov.w	r2, #2048	@ 0x800
3400494a:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3400494e:	bf00      	nop
34004950:	46bd      	mov	sp, r7
34004952:	f85d 7b04 	ldr.w	r7, [sp], #4
34004956:	4770      	bx	lr
34004958:	56028000 	.word	0x56028000

3400495c <LL_RCC_IC12_IsEnabled>:
  * @brief  Check if IC12 is enabled
  * @rmtoll DIVENR       IC12EN         LL_RCC_IC12_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC12_IsEnabled(void)
{
3400495c:	b480      	push	{r7}
3400495e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC12EN) == RCC_DIVENR_IC12EN) ? 1UL : 0UL);
34004960:	4b07      	ldr	r3, [pc, #28]	@ (34004980 <LL_RCC_IC12_IsEnabled+0x24>)
34004962:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
34004966:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3400496a:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
3400496e:	d101      	bne.n	34004974 <LL_RCC_IC12_IsEnabled+0x18>
34004970:	2301      	movs	r3, #1
34004972:	e000      	b.n	34004976 <LL_RCC_IC12_IsEnabled+0x1a>
34004974:	2300      	movs	r3, #0
}
34004976:	4618      	mov	r0, r3
34004978:	46bd      	mov	sp, r7
3400497a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400497e:	4770      	bx	lr
34004980:	56028000 	.word	0x56028000

34004984 <LL_RCC_IC12_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC12_GetSource(void)
{
34004984:	b480      	push	{r7}
34004986:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC12CFGR, RCC_IC12CFGR_IC12SEL));
34004988:	4b04      	ldr	r3, [pc, #16]	@ (3400499c <LL_RCC_IC12_GetSource+0x18>)
3400498a:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
3400498e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34004992:	4618      	mov	r0, r3
34004994:	46bd      	mov	sp, r7
34004996:	f85d 7b04 	ldr.w	r7, [sp], #4
3400499a:	4770      	bx	lr
3400499c:	56028000 	.word	0x56028000

340049a0 <LL_RCC_IC12_GetDivider>:
  * @brief  Get IC12 divider
  * @rmtoll IC12CFGR      IC12INT        LL_RCC_IC12_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC12_GetDivider(void)
{
340049a0:	b480      	push	{r7}
340049a2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC12CFGR, RCC_IC12CFGR_IC12INT) >> RCC_IC12CFGR_IC12INT_Pos) + 1UL);
340049a4:	4b05      	ldr	r3, [pc, #20]	@ (340049bc <LL_RCC_IC12_GetDivider+0x1c>)
340049a6:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
340049aa:	0c1b      	lsrs	r3, r3, #16
340049ac:	b2db      	uxtb	r3, r3
340049ae:	3301      	adds	r3, #1
}
340049b0:	4618      	mov	r0, r3
340049b2:	46bd      	mov	sp, r7
340049b4:	f85d 7b04 	ldr.w	r7, [sp], #4
340049b8:	4770      	bx	lr
340049ba:	bf00      	nop
340049bc:	56028000 	.word	0x56028000

340049c0 <LL_RCC_IC13_Enable>:
  * @brief  Enable IC13
  * @rmtoll DIVENSR       IC13ENS        LL_RCC_IC13_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC13_Enable(void)
{
340049c0:	b480      	push	{r7}
340049c2:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC13ENS);
340049c4:	4b04      	ldr	r3, [pc, #16]	@ (340049d8 <LL_RCC_IC13_Enable+0x18>)
340049c6:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
340049ca:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
340049ce:	bf00      	nop
340049d0:	46bd      	mov	sp, r7
340049d2:	f85d 7b04 	ldr.w	r7, [sp], #4
340049d6:	4770      	bx	lr
340049d8:	56028000 	.word	0x56028000

340049dc <LL_RCC_IC13_IsEnabled>:
  * @brief  Check if IC13 is enabled
  * @rmtoll DIVENR       IC13EN         LL_RCC_IC13_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC13_IsEnabled(void)
{
340049dc:	b480      	push	{r7}
340049de:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC13EN) == RCC_DIVENR_IC13EN) ? 1UL : 0UL);
340049e0:	4b07      	ldr	r3, [pc, #28]	@ (34004a00 <LL_RCC_IC13_IsEnabled+0x24>)
340049e2:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
340049e6:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
340049ea:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
340049ee:	d101      	bne.n	340049f4 <LL_RCC_IC13_IsEnabled+0x18>
340049f0:	2301      	movs	r3, #1
340049f2:	e000      	b.n	340049f6 <LL_RCC_IC13_IsEnabled+0x1a>
340049f4:	2300      	movs	r3, #0
}
340049f6:	4618      	mov	r0, r3
340049f8:	46bd      	mov	sp, r7
340049fa:	f85d 7b04 	ldr.w	r7, [sp], #4
340049fe:	4770      	bx	lr
34004a00:	56028000 	.word	0x56028000

34004a04 <LL_RCC_IC13_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC13_GetSource(void)
{
34004a04:	b480      	push	{r7}
34004a06:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13SEL));
34004a08:	4b04      	ldr	r3, [pc, #16]	@ (34004a1c <LL_RCC_IC13_GetSource+0x18>)
34004a0a:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
34004a0e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34004a12:	4618      	mov	r0, r3
34004a14:	46bd      	mov	sp, r7
34004a16:	f85d 7b04 	ldr.w	r7, [sp], #4
34004a1a:	4770      	bx	lr
34004a1c:	56028000 	.word	0x56028000

34004a20 <LL_RCC_IC13_GetDivider>:
  * @brief  Get IC13 divider
  * @rmtoll IC13CFGR      IC13INT        LL_RCC_IC13_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC13_GetDivider(void)
{
34004a20:	b480      	push	{r7}
34004a22:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13INT) >> RCC_IC13CFGR_IC13INT_Pos) + 1UL);
34004a24:	4b05      	ldr	r3, [pc, #20]	@ (34004a3c <LL_RCC_IC13_GetDivider+0x1c>)
34004a26:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
34004a2a:	0c1b      	lsrs	r3, r3, #16
34004a2c:	b2db      	uxtb	r3, r3
34004a2e:	3301      	adds	r3, #1
}
34004a30:	4618      	mov	r0, r3
34004a32:	46bd      	mov	sp, r7
34004a34:	f85d 7b04 	ldr.w	r7, [sp], #4
34004a38:	4770      	bx	lr
34004a3a:	bf00      	nop
34004a3c:	56028000 	.word	0x56028000

34004a40 <LL_RCC_IC14_Enable>:
  * @brief  Enable IC14
  * @rmtoll DIVENSR       IC14ENS        LL_RCC_IC14_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC14_Enable(void)
{
34004a40:	b480      	push	{r7}
34004a42:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
34004a44:	4b04      	ldr	r3, [pc, #16]	@ (34004a58 <LL_RCC_IC14_Enable+0x18>)
34004a46:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
34004a4a:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34004a4e:	bf00      	nop
34004a50:	46bd      	mov	sp, r7
34004a52:	f85d 7b04 	ldr.w	r7, [sp], #4
34004a56:	4770      	bx	lr
34004a58:	56028000 	.word	0x56028000

34004a5c <LL_RCC_IC14_IsEnabled>:
  * @brief  Check if IC14 is enabled
  * @rmtoll DIVENR       IC14EN         LL_RCC_IC14_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC14_IsEnabled(void)
{
34004a5c:	b480      	push	{r7}
34004a5e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC14EN) == RCC_DIVENR_IC14EN) ? 1UL : 0UL);
34004a60:	4b07      	ldr	r3, [pc, #28]	@ (34004a80 <LL_RCC_IC14_IsEnabled+0x24>)
34004a62:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
34004a66:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
34004a6a:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
34004a6e:	d101      	bne.n	34004a74 <LL_RCC_IC14_IsEnabled+0x18>
34004a70:	2301      	movs	r3, #1
34004a72:	e000      	b.n	34004a76 <LL_RCC_IC14_IsEnabled+0x1a>
34004a74:	2300      	movs	r3, #0
}
34004a76:	4618      	mov	r0, r3
34004a78:	46bd      	mov	sp, r7
34004a7a:	f85d 7b04 	ldr.w	r7, [sp], #4
34004a7e:	4770      	bx	lr
34004a80:	56028000 	.word	0x56028000

34004a84 <LL_RCC_IC14_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC14_GetSource(void)
{
34004a84:	b480      	push	{r7}
34004a86:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL));
34004a88:	4b04      	ldr	r3, [pc, #16]	@ (34004a9c <LL_RCC_IC14_GetSource+0x18>)
34004a8a:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34004a8e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34004a92:	4618      	mov	r0, r3
34004a94:	46bd      	mov	sp, r7
34004a96:	f85d 7b04 	ldr.w	r7, [sp], #4
34004a9a:	4770      	bx	lr
34004a9c:	56028000 	.word	0x56028000

34004aa0 <LL_RCC_IC14_GetDivider>:
  * @brief  Get IC14 divider
  * @rmtoll IC14CFGR      IC14INT        LL_RCC_IC14_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC14_GetDivider(void)
{
34004aa0:	b480      	push	{r7}
34004aa2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14INT) >> RCC_IC14CFGR_IC14INT_Pos) + 1UL);
34004aa4:	4b05      	ldr	r3, [pc, #20]	@ (34004abc <LL_RCC_IC14_GetDivider+0x1c>)
34004aa6:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34004aaa:	0c1b      	lsrs	r3, r3, #16
34004aac:	b2db      	uxtb	r3, r3
34004aae:	3301      	adds	r3, #1
}
34004ab0:	4618      	mov	r0, r3
34004ab2:	46bd      	mov	sp, r7
34004ab4:	f85d 7b04 	ldr.w	r7, [sp], #4
34004ab8:	4770      	bx	lr
34004aba:	bf00      	nop
34004abc:	56028000 	.word	0x56028000

34004ac0 <LL_RCC_IC15_Enable>:
  * @brief  Enable IC15
  * @rmtoll DIVENSR       IC15ENS        LL_RCC_IC15_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC15_Enable(void)
{
34004ac0:	b480      	push	{r7}
34004ac2:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
34004ac4:	4b04      	ldr	r3, [pc, #16]	@ (34004ad8 <LL_RCC_IC15_Enable+0x18>)
34004ac6:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
34004aca:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34004ace:	bf00      	nop
34004ad0:	46bd      	mov	sp, r7
34004ad2:	f85d 7b04 	ldr.w	r7, [sp], #4
34004ad6:	4770      	bx	lr
34004ad8:	56028000 	.word	0x56028000

34004adc <LL_RCC_IC15_IsEnabled>:
  * @brief  Check if IC15 is enabled
  * @rmtoll DIVENR       IC15EN         LL_RCC_IC15_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC15_IsEnabled(void)
{
34004adc:	b480      	push	{r7}
34004ade:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC15EN) == RCC_DIVENR_IC15EN) ? 1UL : 0UL);
34004ae0:	4b07      	ldr	r3, [pc, #28]	@ (34004b00 <LL_RCC_IC15_IsEnabled+0x24>)
34004ae2:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
34004ae6:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34004aea:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
34004aee:	d101      	bne.n	34004af4 <LL_RCC_IC15_IsEnabled+0x18>
34004af0:	2301      	movs	r3, #1
34004af2:	e000      	b.n	34004af6 <LL_RCC_IC15_IsEnabled+0x1a>
34004af4:	2300      	movs	r3, #0
}
34004af6:	4618      	mov	r0, r3
34004af8:	46bd      	mov	sp, r7
34004afa:	f85d 7b04 	ldr.w	r7, [sp], #4
34004afe:	4770      	bx	lr
34004b00:	56028000 	.word	0x56028000

34004b04 <LL_RCC_IC15_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC15_GetSource(void)
{
34004b04:	b480      	push	{r7}
34004b06:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
34004b08:	4b04      	ldr	r3, [pc, #16]	@ (34004b1c <LL_RCC_IC15_GetSource+0x18>)
34004b0a:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34004b0e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34004b12:	4618      	mov	r0, r3
34004b14:	46bd      	mov	sp, r7
34004b16:	f85d 7b04 	ldr.w	r7, [sp], #4
34004b1a:	4770      	bx	lr
34004b1c:	56028000 	.word	0x56028000

34004b20 <LL_RCC_IC15_GetDivider>:
  * @brief  Get IC15 divider
  * @rmtoll IC15CFGR      IC15INT        LL_RCC_IC15_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC15_GetDivider(void)
{
34004b20:	b480      	push	{r7}
34004b22:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15INT) >> RCC_IC15CFGR_IC15INT_Pos) + 1UL);
34004b24:	4b05      	ldr	r3, [pc, #20]	@ (34004b3c <LL_RCC_IC15_GetDivider+0x1c>)
34004b26:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34004b2a:	0c1b      	lsrs	r3, r3, #16
34004b2c:	b2db      	uxtb	r3, r3
34004b2e:	3301      	adds	r3, #1
}
34004b30:	4618      	mov	r0, r3
34004b32:	46bd      	mov	sp, r7
34004b34:	f85d 7b04 	ldr.w	r7, [sp], #4
34004b38:	4770      	bx	lr
34004b3a:	bf00      	nop
34004b3c:	56028000 	.word	0x56028000

34004b40 <LL_RCC_IC16_Enable>:
  * @brief  Enable IC16
  * @rmtoll DIVENSR       IC16ENS        LL_RCC_IC16_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC16_Enable(void)
{
34004b40:	b480      	push	{r7}
34004b42:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC16ENS);
34004b44:	4b04      	ldr	r3, [pc, #16]	@ (34004b58 <LL_RCC_IC16_Enable+0x18>)
34004b46:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
34004b4a:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34004b4e:	bf00      	nop
34004b50:	46bd      	mov	sp, r7
34004b52:	f85d 7b04 	ldr.w	r7, [sp], #4
34004b56:	4770      	bx	lr
34004b58:	56028000 	.word	0x56028000

34004b5c <LL_RCC_IC16_IsEnabled>:
  * @brief  Check if IC16 is enabled
  * @rmtoll DIVENR       IC16EN         LL_RCC_IC16_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC16_IsEnabled(void)
{
34004b5c:	b480      	push	{r7}
34004b5e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC16EN) == RCC_DIVENR_IC16EN) ? 1UL : 0UL);
34004b60:	4b07      	ldr	r3, [pc, #28]	@ (34004b80 <LL_RCC_IC16_IsEnabled+0x24>)
34004b62:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
34004b66:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
34004b6a:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
34004b6e:	d101      	bne.n	34004b74 <LL_RCC_IC16_IsEnabled+0x18>
34004b70:	2301      	movs	r3, #1
34004b72:	e000      	b.n	34004b76 <LL_RCC_IC16_IsEnabled+0x1a>
34004b74:	2300      	movs	r3, #0
}
34004b76:	4618      	mov	r0, r3
34004b78:	46bd      	mov	sp, r7
34004b7a:	f85d 7b04 	ldr.w	r7, [sp], #4
34004b7e:	4770      	bx	lr
34004b80:	56028000 	.word	0x56028000

34004b84 <LL_RCC_IC16_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC16_GetSource(void)
{
34004b84:	b480      	push	{r7}
34004b86:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC16CFGR, RCC_IC16CFGR_IC16SEL));
34004b88:	4b04      	ldr	r3, [pc, #16]	@ (34004b9c <LL_RCC_IC16_GetSource+0x18>)
34004b8a:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
34004b8e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34004b92:	4618      	mov	r0, r3
34004b94:	46bd      	mov	sp, r7
34004b96:	f85d 7b04 	ldr.w	r7, [sp], #4
34004b9a:	4770      	bx	lr
34004b9c:	56028000 	.word	0x56028000

34004ba0 <LL_RCC_IC16_GetDivider>:
  * @brief  Get IC16 divider
  * @rmtoll IC16CFGR      IC16INT        LL_RCC_IC16_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC16_GetDivider(void)
{
34004ba0:	b480      	push	{r7}
34004ba2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC16CFGR, RCC_IC16CFGR_IC16INT) >> RCC_IC16CFGR_IC16INT_Pos) + 1UL);
34004ba4:	4b05      	ldr	r3, [pc, #20]	@ (34004bbc <LL_RCC_IC16_GetDivider+0x1c>)
34004ba6:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
34004baa:	0c1b      	lsrs	r3, r3, #16
34004bac:	b2db      	uxtb	r3, r3
34004bae:	3301      	adds	r3, #1
}
34004bb0:	4618      	mov	r0, r3
34004bb2:	46bd      	mov	sp, r7
34004bb4:	f85d 7b04 	ldr.w	r7, [sp], #4
34004bb8:	4770      	bx	lr
34004bba:	bf00      	nop
34004bbc:	56028000 	.word	0x56028000

34004bc0 <LL_RCC_IC17_Enable>:
  * @brief  Enable IC17
  * @rmtoll DIVENSR       IC17ENS        LL_RCC_IC17_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC17_Enable(void)
{
34004bc0:	b480      	push	{r7}
34004bc2:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC17ENS);
34004bc4:	4b04      	ldr	r3, [pc, #16]	@ (34004bd8 <LL_RCC_IC17_Enable+0x18>)
34004bc6:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
34004bca:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34004bce:	bf00      	nop
34004bd0:	46bd      	mov	sp, r7
34004bd2:	f85d 7b04 	ldr.w	r7, [sp], #4
34004bd6:	4770      	bx	lr
34004bd8:	56028000 	.word	0x56028000

34004bdc <LL_RCC_IC17_IsEnabled>:
  * @brief  Check if IC17 is enabled
  * @rmtoll DIVENR       IC17EN         LL_RCC_IC17_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC17_IsEnabled(void)
{
34004bdc:	b480      	push	{r7}
34004bde:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC17EN) == RCC_DIVENR_IC17EN) ? 1UL : 0UL);
34004be0:	4b07      	ldr	r3, [pc, #28]	@ (34004c00 <LL_RCC_IC17_IsEnabled+0x24>)
34004be2:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
34004be6:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34004bea:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34004bee:	d101      	bne.n	34004bf4 <LL_RCC_IC17_IsEnabled+0x18>
34004bf0:	2301      	movs	r3, #1
34004bf2:	e000      	b.n	34004bf6 <LL_RCC_IC17_IsEnabled+0x1a>
34004bf4:	2300      	movs	r3, #0
}
34004bf6:	4618      	mov	r0, r3
34004bf8:	46bd      	mov	sp, r7
34004bfa:	f85d 7b04 	ldr.w	r7, [sp], #4
34004bfe:	4770      	bx	lr
34004c00:	56028000 	.word	0x56028000

34004c04 <LL_RCC_IC17_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC17_GetSource(void)
{
34004c04:	b480      	push	{r7}
34004c06:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC17CFGR, RCC_IC17CFGR_IC17SEL));
34004c08:	4b04      	ldr	r3, [pc, #16]	@ (34004c1c <LL_RCC_IC17_GetSource+0x18>)
34004c0a:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
34004c0e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34004c12:	4618      	mov	r0, r3
34004c14:	46bd      	mov	sp, r7
34004c16:	f85d 7b04 	ldr.w	r7, [sp], #4
34004c1a:	4770      	bx	lr
34004c1c:	56028000 	.word	0x56028000

34004c20 <LL_RCC_IC17_GetDivider>:
  * @brief  Get IC17 divider
  * @rmtoll IC17CFGR      IC17INT        LL_RCC_IC17_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC17_GetDivider(void)
{
34004c20:	b480      	push	{r7}
34004c22:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC17CFGR, RCC_IC17CFGR_IC17INT) >> RCC_IC17CFGR_IC17INT_Pos) + 1UL);
34004c24:	4b05      	ldr	r3, [pc, #20]	@ (34004c3c <LL_RCC_IC17_GetDivider+0x1c>)
34004c26:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
34004c2a:	0c1b      	lsrs	r3, r3, #16
34004c2c:	b2db      	uxtb	r3, r3
34004c2e:	3301      	adds	r3, #1
}
34004c30:	4618      	mov	r0, r3
34004c32:	46bd      	mov	sp, r7
34004c34:	f85d 7b04 	ldr.w	r7, [sp], #4
34004c38:	4770      	bx	lr
34004c3a:	bf00      	nop
34004c3c:	56028000 	.word	0x56028000

34004c40 <LL_RCC_IC18_Enable>:
  * @brief  Enable IC18
  * @rmtoll DIVENSR       IC18ENS        LL_RCC_IC18_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC18_Enable(void)
{
34004c40:	b480      	push	{r7}
34004c42:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC18ENS);
34004c44:	4b04      	ldr	r3, [pc, #16]	@ (34004c58 <LL_RCC_IC18_Enable+0x18>)
34004c46:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
34004c4a:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34004c4e:	bf00      	nop
34004c50:	46bd      	mov	sp, r7
34004c52:	f85d 7b04 	ldr.w	r7, [sp], #4
34004c56:	4770      	bx	lr
34004c58:	56028000 	.word	0x56028000

34004c5c <LL_RCC_IC18_IsEnabled>:
  * @brief  Check if IC18 is enabled
  * @rmtoll DIVENR       IC18EN         LL_RCC_IC18_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC18_IsEnabled(void)
{
34004c5c:	b480      	push	{r7}
34004c5e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC18EN) == RCC_DIVENR_IC18EN) ? 1UL : 0UL);
34004c60:	4b07      	ldr	r3, [pc, #28]	@ (34004c80 <LL_RCC_IC18_IsEnabled+0x24>)
34004c62:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
34004c66:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34004c6a:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34004c6e:	d101      	bne.n	34004c74 <LL_RCC_IC18_IsEnabled+0x18>
34004c70:	2301      	movs	r3, #1
34004c72:	e000      	b.n	34004c76 <LL_RCC_IC18_IsEnabled+0x1a>
34004c74:	2300      	movs	r3, #0
}
34004c76:	4618      	mov	r0, r3
34004c78:	46bd      	mov	sp, r7
34004c7a:	f85d 7b04 	ldr.w	r7, [sp], #4
34004c7e:	4770      	bx	lr
34004c80:	56028000 	.word	0x56028000

34004c84 <LL_RCC_IC18_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC18_GetSource(void)
{
34004c84:	b480      	push	{r7}
34004c86:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC18CFGR, RCC_IC18CFGR_IC18SEL));
34004c88:	4b04      	ldr	r3, [pc, #16]	@ (34004c9c <LL_RCC_IC18_GetSource+0x18>)
34004c8a:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
34004c8e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34004c92:	4618      	mov	r0, r3
34004c94:	46bd      	mov	sp, r7
34004c96:	f85d 7b04 	ldr.w	r7, [sp], #4
34004c9a:	4770      	bx	lr
34004c9c:	56028000 	.word	0x56028000

34004ca0 <LL_RCC_IC18_GetDivider>:
  * @brief  Get IC18 divider
  * @rmtoll IC18CFGR      IC18INT        LL_RCC_IC18_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC18_GetDivider(void)
{
34004ca0:	b480      	push	{r7}
34004ca2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC18CFGR, RCC_IC18CFGR_IC18INT) >> RCC_IC18CFGR_IC18INT_Pos) + 1UL);
34004ca4:	4b05      	ldr	r3, [pc, #20]	@ (34004cbc <LL_RCC_IC18_GetDivider+0x1c>)
34004ca6:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
34004caa:	0c1b      	lsrs	r3, r3, #16
34004cac:	b2db      	uxtb	r3, r3
34004cae:	3301      	adds	r3, #1
}
34004cb0:	4618      	mov	r0, r3
34004cb2:	46bd      	mov	sp, r7
34004cb4:	f85d 7b04 	ldr.w	r7, [sp], #4
34004cb8:	4770      	bx	lr
34004cba:	bf00      	nop
34004cbc:	56028000 	.word	0x56028000

34004cc0 <LL_RCC_IC19_Enable>:
  * @brief  Enable IC19
  * @rmtoll DIVENSR       IC19ENS        LL_RCC_IC19_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC19_Enable(void)
{
34004cc0:	b480      	push	{r7}
34004cc2:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC19ENS);
34004cc4:	4b04      	ldr	r3, [pc, #16]	@ (34004cd8 <LL_RCC_IC19_Enable+0x18>)
34004cc6:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
34004cca:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34004cce:	bf00      	nop
34004cd0:	46bd      	mov	sp, r7
34004cd2:	f85d 7b04 	ldr.w	r7, [sp], #4
34004cd6:	4770      	bx	lr
34004cd8:	56028000 	.word	0x56028000

34004cdc <LL_RCC_IC19_IsEnabled>:
  * @brief  Check if IC19 is enabled
  * @rmtoll DIVENR       IC19EN         LL_RCC_IC19_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC19_IsEnabled(void)
{
34004cdc:	b480      	push	{r7}
34004cde:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC19EN) == RCC_DIVENR_IC19EN) ? 1UL : 0UL);
34004ce0:	4b07      	ldr	r3, [pc, #28]	@ (34004d00 <LL_RCC_IC19_IsEnabled+0x24>)
34004ce2:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
34004ce6:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
34004cea:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
34004cee:	d101      	bne.n	34004cf4 <LL_RCC_IC19_IsEnabled+0x18>
34004cf0:	2301      	movs	r3, #1
34004cf2:	e000      	b.n	34004cf6 <LL_RCC_IC19_IsEnabled+0x1a>
34004cf4:	2300      	movs	r3, #0
}
34004cf6:	4618      	mov	r0, r3
34004cf8:	46bd      	mov	sp, r7
34004cfa:	f85d 7b04 	ldr.w	r7, [sp], #4
34004cfe:	4770      	bx	lr
34004d00:	56028000 	.word	0x56028000

34004d04 <LL_RCC_IC19_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC19_GetSource(void)
{
34004d04:	b480      	push	{r7}
34004d06:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL));
34004d08:	4b04      	ldr	r3, [pc, #16]	@ (34004d1c <LL_RCC_IC19_GetSource+0x18>)
34004d0a:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
34004d0e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34004d12:	4618      	mov	r0, r3
34004d14:	46bd      	mov	sp, r7
34004d16:	f85d 7b04 	ldr.w	r7, [sp], #4
34004d1a:	4770      	bx	lr
34004d1c:	56028000 	.word	0x56028000

34004d20 <LL_RCC_IC19_GetDivider>:
  * @brief  Get IC19 divider
  * @rmtoll IC19CFGR      IC19INT        LL_RCC_IC19_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC19_GetDivider(void)
{
34004d20:	b480      	push	{r7}
34004d22:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19INT) >> RCC_IC19CFGR_IC19INT_Pos) + 1UL);
34004d24:	4b05      	ldr	r3, [pc, #20]	@ (34004d3c <LL_RCC_IC19_GetDivider+0x1c>)
34004d26:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
34004d2a:	0c1b      	lsrs	r3, r3, #16
34004d2c:	b2db      	uxtb	r3, r3
34004d2e:	3301      	adds	r3, #1
}
34004d30:	4618      	mov	r0, r3
34004d32:	46bd      	mov	sp, r7
34004d34:	f85d 7b04 	ldr.w	r7, [sp], #4
34004d38:	4770      	bx	lr
34004d3a:	bf00      	nop
34004d3c:	56028000 	.word	0x56028000

34004d40 <LL_RCC_IC20_Enable>:
  * @brief  Enable IC20
  * @rmtoll DIVENSR       IC20ENS        LL_RCC_IC20_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC20_Enable(void)
{
34004d40:	b480      	push	{r7}
34004d42:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC20ENS);
34004d44:	4b04      	ldr	r3, [pc, #16]	@ (34004d58 <LL_RCC_IC20_Enable+0x18>)
34004d46:	f44f 2200 	mov.w	r2, #524288	@ 0x80000
34004d4a:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34004d4e:	bf00      	nop
34004d50:	46bd      	mov	sp, r7
34004d52:	f85d 7b04 	ldr.w	r7, [sp], #4
34004d56:	4770      	bx	lr
34004d58:	56028000 	.word	0x56028000

34004d5c <LL_RCC_IC20_IsEnabled>:
  * @brief  Check if IC20 is enabled
  * @rmtoll DIVENR       IC20EN         LL_RCC_IC20_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC20_IsEnabled(void)
{
34004d5c:	b480      	push	{r7}
34004d5e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC20EN) == RCC_DIVENR_IC20EN) ? 1UL : 0UL);
34004d60:	4b07      	ldr	r3, [pc, #28]	@ (34004d80 <LL_RCC_IC20_IsEnabled+0x24>)
34004d62:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
34004d66:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
34004d6a:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
34004d6e:	d101      	bne.n	34004d74 <LL_RCC_IC20_IsEnabled+0x18>
34004d70:	2301      	movs	r3, #1
34004d72:	e000      	b.n	34004d76 <LL_RCC_IC20_IsEnabled+0x1a>
34004d74:	2300      	movs	r3, #0
}
34004d76:	4618      	mov	r0, r3
34004d78:	46bd      	mov	sp, r7
34004d7a:	f85d 7b04 	ldr.w	r7, [sp], #4
34004d7e:	4770      	bx	lr
34004d80:	56028000 	.word	0x56028000

34004d84 <LL_RCC_IC20_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC20_GetSource(void)
{
34004d84:	b480      	push	{r7}
34004d86:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
34004d88:	4b04      	ldr	r3, [pc, #16]	@ (34004d9c <LL_RCC_IC20_GetSource+0x18>)
34004d8a:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
34004d8e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
34004d92:	4618      	mov	r0, r3
34004d94:	46bd      	mov	sp, r7
34004d96:	f85d 7b04 	ldr.w	r7, [sp], #4
34004d9a:	4770      	bx	lr
34004d9c:	56028000 	.word	0x56028000

34004da0 <LL_RCC_IC20_GetDivider>:
  * @brief  Get IC20 divider
  * @rmtoll IC20CFGR      IC20INT        LL_RCC_IC20_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC20_GetDivider(void)
{
34004da0:	b480      	push	{r7}
34004da2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20INT) >> RCC_IC20CFGR_IC20INT_Pos) + 1UL);
34004da4:	4b05      	ldr	r3, [pc, #20]	@ (34004dbc <LL_RCC_IC20_GetDivider+0x1c>)
34004da6:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
34004daa:	0c1b      	lsrs	r3, r3, #16
34004dac:	b2db      	uxtb	r3, r3
34004dae:	3301      	adds	r3, #1
}
34004db0:	4618      	mov	r0, r3
34004db2:	46bd      	mov	sp, r7
34004db4:	f85d 7b04 	ldr.w	r7, [sp], #4
34004db8:	4770      	bx	lr
34004dba:	bf00      	nop
34004dbc:	56028000 	.word	0x56028000

34004dc0 <LL_RCC_CLKP_Enable>:
  * @brief  Enable CLKP
  * @rmtoll MISCENSR      PERENS        LL_RCC_CLKP_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_CLKP_Enable(void)
{
34004dc0:	b480      	push	{r7}
34004dc2:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
34004dc4:	4b04      	ldr	r3, [pc, #16]	@ (34004dd8 <LL_RCC_CLKP_Enable+0x18>)
34004dc6:	2240      	movs	r2, #64	@ 0x40
34004dc8:	f8c3 2a48 	str.w	r2, [r3, #2632]	@ 0xa48
}
34004dcc:	bf00      	nop
34004dce:	46bd      	mov	sp, r7
34004dd0:	f85d 7b04 	ldr.w	r7, [sp], #4
34004dd4:	4770      	bx	lr
34004dd6:	bf00      	nop
34004dd8:	56028000 	.word	0x56028000

34004ddc <LL_RCC_CLKP_IsEnabled>:
  * @brief  Check if CLKP is enabled
  * @rmtoll MISCENR       PEREN         LL_RCC_CLKP_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_CLKP_IsEnabled(void)
{
34004ddc:	b480      	push	{r7}
34004dde:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->MISCENR, RCC_MISCENR_PEREN) == RCC_MISCENR_PEREN) ? 1UL : 0UL);
34004de0:	4b07      	ldr	r3, [pc, #28]	@ (34004e00 <LL_RCC_CLKP_IsEnabled+0x24>)
34004de2:	f8d3 3248 	ldr.w	r3, [r3, #584]	@ 0x248
34004de6:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34004dea:	2b40      	cmp	r3, #64	@ 0x40
34004dec:	d101      	bne.n	34004df2 <LL_RCC_CLKP_IsEnabled+0x16>
34004dee:	2301      	movs	r3, #1
34004df0:	e000      	b.n	34004df4 <LL_RCC_CLKP_IsEnabled+0x18>
34004df2:	2300      	movs	r3, #0
}
34004df4:	4618      	mov	r0, r3
34004df6:	46bd      	mov	sp, r7
34004df8:	f85d 7b04 	ldr.w	r7, [sp], #4
34004dfc:	4770      	bx	lr
34004dfe:	bf00      	nop
34004e00:	56028000 	.word	0x56028000

34004e04 <HAL_RCCEx_PeriphCLKConfig>:
  *         modification indeed impacts all peripherals using this ICx as clock source.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(const RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
34004e04:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
34004e08:	b0f2      	sub	sp, #456	@ 0x1c8
34004e0a:	af00      	add	r7, sp, #0
34004e0c:	f8c7 01b4 	str.w	r0, [r7, #436]	@ 0x1b4
  uint32_t tmpreg;
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
34004e10:	2300      	movs	r3, #0
34004e12:	f887 31c7 	strb.w	r3, [r7, #455]	@ 0x1c7
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
34004e16:	2300      	movs	r3, #0
34004e18:	f887 31c6 	strb.w	r3, [r7, #454]	@ 0x1c6

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*---------------------------- RTC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
34004e1c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34004e20:	e9d3 2300 	ldrd	r2, r3, [r3]
34004e24:	f002 6400 	and.w	r4, r2, #134217728	@ 0x8000000
34004e28:	2500      	movs	r5, #0
34004e2a:	ea54 0305 	orrs.w	r3, r4, r5
34004e2e:	d06c      	beq.n	34004f0a <HAL_RCCEx_PeriphCLKConfig+0x106>
    /* check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* As the RTC clock source selection can be changed only if the Backup Domain is reset */
    /* reset the Backup domain only if the RTC Clock source selection is modified from default reset value */
    tmpreg = LL_RCC_GetRTCClockSource();
34004e30:	f7ff f91e 	bl	34004070 <LL_RCC_GetRTCClockSource>
34004e34:	f8c7 01c0 	str.w	r0, [r7, #448]	@ 0x1c0

    if ((tmpreg != RCC_RTCCLKSOURCE_DISABLE) && (tmpreg != (PeriphClkInit->RTCClockSelection & RCC_CCIPR7_RTCSEL)))
34004e38:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
34004e3c:	2b00      	cmp	r3, #0
34004e3e:	d018      	beq.n	34004e72 <HAL_RCCEx_PeriphCLKConfig+0x6e>
34004e40:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34004e44:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
34004e48:	f403 7240 	and.w	r2, r3, #768	@ 0x300
34004e4c:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
34004e50:	4293      	cmp	r3, r2
34004e52:	d00e      	beq.n	34004e72 <HAL_RCCEx_PeriphCLKConfig+0x6e>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->DBPCR, PWR_DBPCR_DBP);
34004e54:	4bc3      	ldr	r3, [pc, #780]	@ (34005164 <HAL_RCCEx_PeriphCLKConfig+0x360>)
34004e56:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34004e58:	4ac2      	ldr	r2, [pc, #776]	@ (34005164 <HAL_RCCEx_PeriphCLKConfig+0x360>)
34004e5a:	f043 0301 	orr.w	r3, r3, #1
34004e5e:	62d3      	str	r3, [r2, #44]	@ 0x2c

      /* Read back to check Backup domain enabled */
      if (READ_BIT(PWR->DBPCR, PWR_DBPCR_DBP) == 0U)
34004e60:	4bc0      	ldr	r3, [pc, #768]	@ (34005164 <HAL_RCCEx_PeriphCLKConfig+0x360>)
34004e62:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34004e64:	f003 0301 	and.w	r3, r3, #1
34004e68:	2b00      	cmp	r3, #0
34004e6a:	d102      	bne.n	34004e72 <HAL_RCCEx_PeriphCLKConfig+0x6e>
      {
        ret = HAL_ERROR;
34004e6c:	2301      	movs	r3, #1
34004e6e:	f887 31c7 	strb.w	r3, [r7, #455]	@ 0x1c7
        WRITE_REG(RCC->BDCR, tmpreg);
#endif /* #if 0  TO DO */
      }
    }

    if (ret == HAL_OK)
34004e72:	f897 31c7 	ldrb.w	r3, [r7, #455]	@ 0x1c7
34004e76:	2b00      	cmp	r3, #0
34004e78:	d143      	bne.n	34004f02 <HAL_RCCEx_PeriphCLKConfig+0xfe>
    {
      /* If LSE is selected as RTC clock source (and enabled prior to Backup Domain reset), wait for LSE reactivation */
      if (PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
34004e7a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34004e7e:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
34004e82:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34004e86:	d117      	bne.n	34004eb8 <HAL_RCCEx_PeriphCLKConfig+0xb4>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
34004e88:	f7fc fd72 	bl	34001970 <HAL_GetTick>
34004e8c:	f8c7 01bc 	str.w	r0, [r7, #444]	@ 0x1bc

        /* Wait till LSE is ready */
        while (LL_RCC_LSE_IsReady() == 0U)
34004e90:	e00d      	b.n	34004eae <HAL_RCCEx_PeriphCLKConfig+0xaa>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
34004e92:	f7fc fd6d 	bl	34001970 <HAL_GetTick>
34004e96:	4602      	mov	r2, r0
34004e98:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
34004e9c:	1ad2      	subs	r2, r2, r3
34004e9e:	f241 3388 	movw	r3, #5000	@ 0x1388
34004ea2:	429a      	cmp	r2, r3
34004ea4:	d903      	bls.n	34004eae <HAL_RCCEx_PeriphCLKConfig+0xaa>
          {
            ret = HAL_TIMEOUT;
34004ea6:	2303      	movs	r3, #3
34004ea8:	f887 31c7 	strb.w	r3, [r7, #455]	@ 0x1c7
            break;
34004eac:	e004      	b.n	34004eb8 <HAL_RCCEx_PeriphCLKConfig+0xb4>
        while (LL_RCC_LSE_IsReady() == 0U)
34004eae:	f7fe fcf1 	bl	34003894 <LL_RCC_LSE_IsReady>
34004eb2:	4603      	mov	r3, r0
34004eb4:	2b00      	cmp	r3, #0
34004eb6:	d0ec      	beq.n	34004e92 <HAL_RCCEx_PeriphCLKConfig+0x8e>
          }
        }
      }

      if (ret == HAL_OK)
34004eb8:	f897 31c7 	ldrb.w	r3, [r7, #455]	@ 0x1c7
34004ebc:	2b00      	cmp	r3, #0
34004ebe:	d11b      	bne.n	34004ef8 <HAL_RCCEx_PeriphCLKConfig+0xf4>
      {
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
34004ec0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34004ec4:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
34004ec8:	f403 7340 	and.w	r3, r3, #768	@ 0x300
34004ecc:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
34004ed0:	d108      	bne.n	34004ee4 <HAL_RCCEx_PeriphCLKConfig+0xe0>
34004ed2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34004ed6:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
34004eda:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
34004ede:	4618      	mov	r0, r3
34004ee0:	f7ff f8d4 	bl	3400408c <LL_RCC_SetRTC_HSEPrescaler>
34004ee4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34004ee8:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
34004eec:	f403 7340 	and.w	r3, r3, #768	@ 0x300
34004ef0:	4618      	mov	r0, r3
34004ef2:	f7ff f8a7 	bl	34004044 <LL_RCC_SetRTCClockSource>
34004ef6:	e008      	b.n	34004f0a <HAL_RCCEx_PeriphCLKConfig+0x106>
      }
      else
      {
        /* set overall return value */
        status = ret;
34004ef8:	f897 31c7 	ldrb.w	r3, [r7, #455]	@ 0x1c7
34004efc:	f887 31c6 	strb.w	r3, [r7, #454]	@ 0x1c6
34004f00:	e003      	b.n	34004f0a <HAL_RCCEx_PeriphCLKConfig+0x106>
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
34004f02:	f897 31c7 	ldrb.w	r3, [r7, #455]	@ 0x1c7
34004f06:	f887 31c6 	strb.w	r3, [r7, #454]	@ 0x1c6
    }
  }

  /*------------------------------------ CKPER configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
34004f0a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34004f0e:	e9d3 2300 	ldrd	r2, r3, [r3]
34004f12:	f002 0804 	and.w	r8, r2, #4
34004f16:	f04f 0900 	mov.w	r9, #0
34004f1a:	ea58 0309 	orrs.w	r3, r8, r9
34004f1e:	f000 809b 	beq.w	34005058 <HAL_RCCEx_PeriphCLKConfig+0x254>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CKPERCLKSOURCE(PeriphClkInit->CkperClockSelection));

    if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC5)
34004f22:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34004f26:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34004f2a:	2b04      	cmp	r3, #4
34004f2c:	d116      	bne.n	34004f5c <HAL_RCCEx_PeriphCLKConfig+0x158>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));

      /* Set IC5 configuration */
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
34004f2e:	4b8e      	ldr	r3, [pc, #568]	@ (34005168 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34004f30:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
34004f34:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34004f38:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34004f3c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34004f40:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
34004f42:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34004f46:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34004f48:	3b01      	subs	r3, #1
34004f4a:	041b      	lsls	r3, r3, #16
34004f4c:	4313      	orrs	r3, r2
34004f4e:	4a86      	ldr	r2, [pc, #536]	@ (34005168 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34004f50:	430b      	orrs	r3, r1
34004f52:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
                 PeriphClkInit->ICSelection[RCC_IC5].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC5].ClockDivider - 1U) << RCC_IC5CFGR_IC5INT_Pos));

      LL_RCC_IC5_Enable();
34004f56:	f7ff fbb3 	bl	340046c0 <LL_RCC_IC5_Enable>
34004f5a:	e076      	b.n	3400504a <HAL_RCCEx_PeriphCLKConfig+0x246>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC10)
34004f5c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34004f60:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34004f64:	2b05      	cmp	r3, #5
34004f66:	d116      	bne.n	34004f96 <HAL_RCCEx_PeriphCLKConfig+0x192>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34004f68:	4b7f      	ldr	r3, [pc, #508]	@ (34005168 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34004f6a:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
34004f6e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34004f72:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34004f76:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34004f7a:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
34004f7c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34004f80:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34004f82:	3b01      	subs	r3, #1
34004f84:	041b      	lsls	r3, r3, #16
34004f86:	4313      	orrs	r3, r2
34004f88:	4a77      	ldr	r2, [pc, #476]	@ (34005168 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34004f8a:	430b      	orrs	r3, r1
34004f8c:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
34004f90:	f7ff fc96 	bl	340048c0 <LL_RCC_IC10_Enable>
34004f94:	e059      	b.n	3400504a <HAL_RCCEx_PeriphCLKConfig+0x246>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC15)
34004f96:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34004f9a:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34004f9e:	2b06      	cmp	r3, #6
34004fa0:	d116      	bne.n	34004fd0 <HAL_RCCEx_PeriphCLKConfig+0x1cc>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34004fa2:	4b71      	ldr	r3, [pc, #452]	@ (34005168 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34004fa4:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34004fa8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34004fac:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34004fb0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34004fb4:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34004fb6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34004fba:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34004fbc:	3b01      	subs	r3, #1
34004fbe:	041b      	lsls	r3, r3, #16
34004fc0:	4313      	orrs	r3, r2
34004fc2:	4a69      	ldr	r2, [pc, #420]	@ (34005168 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34004fc4:	430b      	orrs	r3, r1
34004fc6:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34004fca:	f7ff fd79 	bl	34004ac0 <LL_RCC_IC15_Enable>
34004fce:	e03c      	b.n	3400504a <HAL_RCCEx_PeriphCLKConfig+0x246>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC19)
34004fd0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34004fd4:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34004fd8:	2b03      	cmp	r3, #3
34004fda:	d118      	bne.n	3400500e <HAL_RCCEx_PeriphCLKConfig+0x20a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC19].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC19].ClockDivider));

      /* Set IC19 configuration */
      MODIFY_REG(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL | RCC_IC19CFGR_IC19INT,
34004fdc:	4b62      	ldr	r3, [pc, #392]	@ (34005168 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34004fde:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
34004fe2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34004fe6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34004fea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34004fee:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
34004ff2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34004ff6:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
34004ffa:	3b01      	subs	r3, #1
34004ffc:	041b      	lsls	r3, r3, #16
34004ffe:	4313      	orrs	r3, r2
34005000:	4a59      	ldr	r2, [pc, #356]	@ (34005168 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34005002:	430b      	orrs	r3, r1
34005004:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
                 PeriphClkInit->ICSelection[RCC_IC19].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC19].ClockDivider - 1U) << RCC_IC19CFGR_IC19INT_Pos));

      LL_RCC_IC19_Enable();
34005008:	f7ff fe5a 	bl	34004cc0 <LL_RCC_IC19_Enable>
3400500c:	e01d      	b.n	3400504a <HAL_RCCEx_PeriphCLKConfig+0x246>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC20)
3400500e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005012:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34005016:	2b07      	cmp	r3, #7
34005018:	d117      	bne.n	3400504a <HAL_RCCEx_PeriphCLKConfig+0x246>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC20].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC20].ClockDivider));

      /* Set IC20 configuration */
      MODIFY_REG(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL | RCC_IC20CFGR_IC20INT,
3400501a:	4b53      	ldr	r3, [pc, #332]	@ (34005168 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3400501c:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
34005020:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34005024:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34005028:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400502c:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
34005030:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005034:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
34005038:	3b01      	subs	r3, #1
3400503a:	041b      	lsls	r3, r3, #16
3400503c:	4313      	orrs	r3, r2
3400503e:	4a4a      	ldr	r2, [pc, #296]	@ (34005168 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34005040:	430b      	orrs	r3, r1
34005042:	f8c2 3110 	str.w	r3, [r2, #272]	@ 0x110
                 PeriphClkInit->ICSelection[RCC_IC20].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC20].ClockDivider - 1U) << RCC_IC20CFGR_IC20INT_Pos));

      LL_RCC_IC20_Enable();
34005046:	f7ff fe7b 	bl	34004d40 <LL_RCC_IC20_Enable>
    {
      /* No ICx selected as source */
    }

    /* Configure the CKPER clock source */
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
3400504a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400504e:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34005052:	4618      	mov	r0, r3
34005054:	f7fe fcd2 	bl	340039fc <LL_RCC_SetCLKPClockSource>
  }

  /*-------------------------- XSPI1 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI1) == RCC_PERIPHCLK_XSPI1)
34005058:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400505c:	e9d3 2300 	ldrd	r2, r3, [r3]
34005060:	f04f 0a00 	mov.w	sl, #0
34005064:	f403 0b80 	and.w	fp, r3, #4194304	@ 0x400000
34005068:	ea5a 030b 	orrs.w	r3, sl, fp
3400506c:	d04b      	beq.n	34005106 <HAL_RCCEx_PeriphCLKConfig+0x302>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI1CLKSOURCE(PeriphClkInit->Xspi1ClockSelection));

    if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_IC3)
3400506e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005072:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
34005076:	4b3d      	ldr	r3, [pc, #244]	@ (3400516c <HAL_RCCEx_PeriphCLKConfig+0x368>)
34005078:	429a      	cmp	r2, r3
3400507a:	d116      	bne.n	340050aa <HAL_RCCEx_PeriphCLKConfig+0x2a6>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
3400507c:	4b3a      	ldr	r3, [pc, #232]	@ (34005168 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3400507e:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
34005082:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34005086:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400508a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400508e:	699a      	ldr	r2, [r3, #24]
34005090:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005094:	69db      	ldr	r3, [r3, #28]
34005096:	3b01      	subs	r3, #1
34005098:	041b      	lsls	r3, r3, #16
3400509a:	4313      	orrs	r3, r2
3400509c:	4a32      	ldr	r2, [pc, #200]	@ (34005168 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3400509e:	430b      	orrs	r3, r1
340050a0:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
340050a4:	f7ff fa8c 	bl	340045c0 <LL_RCC_IC3_Enable>
340050a8:	e026      	b.n	340050f8 <HAL_RCCEx_PeriphCLKConfig+0x2f4>
    }
    else if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_IC4)
340050aa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340050ae:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
340050b2:	4b2f      	ldr	r3, [pc, #188]	@ (34005170 <HAL_RCCEx_PeriphCLKConfig+0x36c>)
340050b4:	429a      	cmp	r2, r3
340050b6:	d116      	bne.n	340050e6 <HAL_RCCEx_PeriphCLKConfig+0x2e2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
340050b8:	4b2b      	ldr	r3, [pc, #172]	@ (34005168 <HAL_RCCEx_PeriphCLKConfig+0x364>)
340050ba:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
340050be:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340050c2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340050c6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340050ca:	6a1a      	ldr	r2, [r3, #32]
340050cc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340050d0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340050d2:	3b01      	subs	r3, #1
340050d4:	041b      	lsls	r3, r3, #16
340050d6:	4313      	orrs	r3, r2
340050d8:	4a23      	ldr	r2, [pc, #140]	@ (34005168 <HAL_RCCEx_PeriphCLKConfig+0x364>)
340050da:	430b      	orrs	r3, r1
340050dc:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
340050e0:	f7ff faae 	bl	34004640 <LL_RCC_IC4_Enable>
340050e4:	e008      	b.n	340050f8 <HAL_RCCEx_PeriphCLKConfig+0x2f4>
    }
    else if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_CLKP)
340050e6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340050ea:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
340050ee:	4b21      	ldr	r3, [pc, #132]	@ (34005174 <HAL_RCCEx_PeriphCLKConfig+0x370>)
340050f0:	429a      	cmp	r2, r3
340050f2:	d101      	bne.n	340050f8 <HAL_RCCEx_PeriphCLKConfig+0x2f4>
    {
      LL_RCC_CLKP_Enable();
340050f4:	f7ff fe64 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the XSPI1 clock source */
    __HAL_RCC_XSPI1_CONFIG(PeriphClkInit->Xspi1ClockSelection);
340050f8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340050fc:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
34005100:	4618      	mov	r0, r3
34005102:	f7fe fe0b 	bl	34003d1c <LL_RCC_SetXSPIClockSource>
  }

  /*-------------------------- XSPI2 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI2) == RCC_PERIPHCLK_XSPI2)
34005106:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400510a:	e9d3 2300 	ldrd	r2, r3, [r3]
3400510e:	2100      	movs	r1, #0
34005110:	f8c7 11a8 	str.w	r1, [r7, #424]	@ 0x1a8
34005114:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
34005118:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
3400511c:	e9d7 016a 	ldrd	r0, r1, [r7, #424]	@ 0x1a8
34005120:	4603      	mov	r3, r0
34005122:	460a      	mov	r2, r1
34005124:	4313      	orrs	r3, r2
34005126:	d057      	beq.n	340051d8 <HAL_RCCEx_PeriphCLKConfig+0x3d4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI2CLKSOURCE(PeriphClkInit->Xspi2ClockSelection));

    if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_IC3)
34005128:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400512c:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
34005130:	4b11      	ldr	r3, [pc, #68]	@ (34005178 <HAL_RCCEx_PeriphCLKConfig+0x374>)
34005132:	429a      	cmp	r2, r3
34005134:	d122      	bne.n	3400517c <HAL_RCCEx_PeriphCLKConfig+0x378>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
34005136:	4b0c      	ldr	r3, [pc, #48]	@ (34005168 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34005138:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3400513c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34005140:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34005144:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005148:	699a      	ldr	r2, [r3, #24]
3400514a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400514e:	69db      	ldr	r3, [r3, #28]
34005150:	3b01      	subs	r3, #1
34005152:	041b      	lsls	r3, r3, #16
34005154:	4313      	orrs	r3, r2
34005156:	4a04      	ldr	r2, [pc, #16]	@ (34005168 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34005158:	430b      	orrs	r3, r1
3400515a:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
3400515e:	f7ff fa2f 	bl	340045c0 <LL_RCC_IC3_Enable>
34005162:	e032      	b.n	340051ca <HAL_RCCEx_PeriphCLKConfig+0x3c6>
34005164:	56024800 	.word	0x56024800
34005168:	56028000 	.word	0x56028000
3400516c:	03020014 	.word	0x03020014
34005170:	03030014 	.word	0x03030014
34005174:	03010014 	.word	0x03010014
34005178:	03020414 	.word	0x03020414
    }
    else if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_IC4)
3400517c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005180:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
34005184:	4bc5      	ldr	r3, [pc, #788]	@ (3400549c <HAL_RCCEx_PeriphCLKConfig+0x698>)
34005186:	429a      	cmp	r2, r3
34005188:	d116      	bne.n	340051b8 <HAL_RCCEx_PeriphCLKConfig+0x3b4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
3400518a:	4bc5      	ldr	r3, [pc, #788]	@ (340054a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3400518c:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34005190:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34005194:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34005198:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400519c:	6a1a      	ldr	r2, [r3, #32]
3400519e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340051a2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340051a4:	3b01      	subs	r3, #1
340051a6:	041b      	lsls	r3, r3, #16
340051a8:	4313      	orrs	r3, r2
340051aa:	4abd      	ldr	r2, [pc, #756]	@ (340054a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
340051ac:	430b      	orrs	r3, r1
340051ae:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
340051b2:	f7ff fa45 	bl	34004640 <LL_RCC_IC4_Enable>
340051b6:	e008      	b.n	340051ca <HAL_RCCEx_PeriphCLKConfig+0x3c6>
    }
    else if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_CLKP)
340051b8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340051bc:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
340051c0:	4bb8      	ldr	r3, [pc, #736]	@ (340054a4 <HAL_RCCEx_PeriphCLKConfig+0x6a0>)
340051c2:	429a      	cmp	r2, r3
340051c4:	d101      	bne.n	340051ca <HAL_RCCEx_PeriphCLKConfig+0x3c6>
    {
      LL_RCC_CLKP_Enable();
340051c6:	f7ff fdfb 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the XSPI2 clock source */
    __HAL_RCC_XSPI2_CONFIG(PeriphClkInit->Xspi2ClockSelection);
340051ca:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340051ce:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
340051d2:	4618      	mov	r0, r3
340051d4:	f7fe fda2 	bl	34003d1c <LL_RCC_SetXSPIClockSource>
  }

  /*-------------------------- XSPI3 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI3) == RCC_PERIPHCLK_XSPI3)
340051d8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340051dc:	e9d3 2300 	ldrd	r2, r3, [r3]
340051e0:	2100      	movs	r1, #0
340051e2:	f8c7 11a0 	str.w	r1, [r7, #416]	@ 0x1a0
340051e6:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
340051ea:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
340051ee:	e9d7 0168 	ldrd	r0, r1, [r7, #416]	@ 0x1a0
340051f2:	4603      	mov	r3, r0
340051f4:	460a      	mov	r2, r1
340051f6:	4313      	orrs	r3, r2
340051f8:	d04b      	beq.n	34005292 <HAL_RCCEx_PeriphCLKConfig+0x48e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI3CLKSOURCE(PeriphClkInit->Xspi3ClockSelection));

    if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_IC3)
340051fa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340051fe:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
34005202:	4ba9      	ldr	r3, [pc, #676]	@ (340054a8 <HAL_RCCEx_PeriphCLKConfig+0x6a4>)
34005204:	429a      	cmp	r2, r3
34005206:	d116      	bne.n	34005236 <HAL_RCCEx_PeriphCLKConfig+0x432>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
34005208:	4ba5      	ldr	r3, [pc, #660]	@ (340054a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3400520a:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3400520e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34005212:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34005216:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400521a:	699a      	ldr	r2, [r3, #24]
3400521c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005220:	69db      	ldr	r3, [r3, #28]
34005222:	3b01      	subs	r3, #1
34005224:	041b      	lsls	r3, r3, #16
34005226:	4313      	orrs	r3, r2
34005228:	4a9d      	ldr	r2, [pc, #628]	@ (340054a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3400522a:	430b      	orrs	r3, r1
3400522c:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
34005230:	f7ff f9c6 	bl	340045c0 <LL_RCC_IC3_Enable>
34005234:	e026      	b.n	34005284 <HAL_RCCEx_PeriphCLKConfig+0x480>
    }
    else if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_IC4)
34005236:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400523a:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
3400523e:	4b9b      	ldr	r3, [pc, #620]	@ (340054ac <HAL_RCCEx_PeriphCLKConfig+0x6a8>)
34005240:	429a      	cmp	r2, r3
34005242:	d116      	bne.n	34005272 <HAL_RCCEx_PeriphCLKConfig+0x46e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
34005244:	4b96      	ldr	r3, [pc, #600]	@ (340054a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34005246:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3400524a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400524e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34005252:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005256:	6a1a      	ldr	r2, [r3, #32]
34005258:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400525c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400525e:	3b01      	subs	r3, #1
34005260:	041b      	lsls	r3, r3, #16
34005262:	4313      	orrs	r3, r2
34005264:	4a8e      	ldr	r2, [pc, #568]	@ (340054a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34005266:	430b      	orrs	r3, r1
34005268:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
3400526c:	f7ff f9e8 	bl	34004640 <LL_RCC_IC4_Enable>
34005270:	e008      	b.n	34005284 <HAL_RCCEx_PeriphCLKConfig+0x480>
    }
    else if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_CLKP)
34005272:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005276:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
3400527a:	4b8d      	ldr	r3, [pc, #564]	@ (340054b0 <HAL_RCCEx_PeriphCLKConfig+0x6ac>)
3400527c:	429a      	cmp	r2, r3
3400527e:	d101      	bne.n	34005284 <HAL_RCCEx_PeriphCLKConfig+0x480>
    {
      LL_RCC_CLKP_Enable();
34005280:	f7ff fd9e 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the XSPI3 clock source */
    __HAL_RCC_XSPI3_CONFIG(PeriphClkInit->Xspi3ClockSelection);
34005284:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005288:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
3400528c:	4618      	mov	r0, r3
3400528e:	f7fe fd45 	bl	34003d1c <LL_RCC_SetXSPIClockSource>
  }

  /*---------------------------- FMC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
34005292:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005296:	e9d3 2300 	ldrd	r2, r3, [r3]
3400529a:	f402 6300 	and.w	r3, r2, #2048	@ 0x800
3400529e:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
340052a2:	2300      	movs	r3, #0
340052a4:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
340052a8:	e9d7 0166 	ldrd	r0, r1, [r7, #408]	@ 0x198
340052ac:	4603      	mov	r3, r0
340052ae:	460a      	mov	r2, r1
340052b0:	4313      	orrs	r3, r2
340052b2:	d048      	beq.n	34005346 <HAL_RCCEx_PeriphCLKConfig+0x542>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FMCCLKSOURCE(PeriphClkInit->FmcClockSelection));

    if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_IC3)
340052b4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340052b8:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
340052bc:	2b20      	cmp	r3, #32
340052be:	d116      	bne.n	340052ee <HAL_RCCEx_PeriphCLKConfig+0x4ea>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
340052c0:	4b77      	ldr	r3, [pc, #476]	@ (340054a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
340052c2:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
340052c6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340052ca:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340052ce:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340052d2:	699a      	ldr	r2, [r3, #24]
340052d4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340052d8:	69db      	ldr	r3, [r3, #28]
340052da:	3b01      	subs	r3, #1
340052dc:	041b      	lsls	r3, r3, #16
340052de:	4313      	orrs	r3, r2
340052e0:	4a6f      	ldr	r2, [pc, #444]	@ (340054a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
340052e2:	430b      	orrs	r3, r1
340052e4:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
340052e8:	f7ff f96a 	bl	340045c0 <LL_RCC_IC3_Enable>
340052ec:	e024      	b.n	34005338 <HAL_RCCEx_PeriphCLKConfig+0x534>
    }
    else if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_IC4)
340052ee:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340052f2:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
340052f6:	2b30      	cmp	r3, #48	@ 0x30
340052f8:	d116      	bne.n	34005328 <HAL_RCCEx_PeriphCLKConfig+0x524>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
340052fa:	4b69      	ldr	r3, [pc, #420]	@ (340054a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
340052fc:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34005300:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34005304:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34005308:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400530c:	6a1a      	ldr	r2, [r3, #32]
3400530e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005312:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34005314:	3b01      	subs	r3, #1
34005316:	041b      	lsls	r3, r3, #16
34005318:	4313      	orrs	r3, r2
3400531a:	4a61      	ldr	r2, [pc, #388]	@ (340054a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3400531c:	430b      	orrs	r3, r1
3400531e:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
34005322:	f7ff f98d 	bl	34004640 <LL_RCC_IC4_Enable>
34005326:	e007      	b.n	34005338 <HAL_RCCEx_PeriphCLKConfig+0x534>
    }
    else if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_CLKP)
34005328:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400532c:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34005330:	2b10      	cmp	r3, #16
34005332:	d101      	bne.n	34005338 <HAL_RCCEx_PeriphCLKConfig+0x534>
    {
      LL_RCC_CLKP_Enable();
34005334:	f7ff fd44 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of FMC kernel clock*/
    __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
34005338:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400533c:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34005340:	4618      	mov	r0, r3
34005342:	f7fe fc03 	bl	34003b4c <LL_RCC_SetFMCClockSource>
  }

  /*------------------------------------- SDMMC1 Configuration ------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
34005346:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400534a:	e9d3 2300 	ldrd	r2, r3, [r3]
3400534e:	f002 4380 	and.w	r3, r2, #1073741824	@ 0x40000000
34005352:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
34005356:	2300      	movs	r3, #0
34005358:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194
3400535c:	e9d7 0164 	ldrd	r0, r1, [r7, #400]	@ 0x190
34005360:	4603      	mov	r3, r0
34005362:	460a      	mov	r2, r1
34005364:	4313      	orrs	r3, r2
34005366:	d04b      	beq.n	34005400 <HAL_RCCEx_PeriphCLKConfig+0x5fc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));

    if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_IC4)
34005368:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400536c:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
34005370:	4b50      	ldr	r3, [pc, #320]	@ (340054b4 <HAL_RCCEx_PeriphCLKConfig+0x6b0>)
34005372:	429a      	cmp	r2, r3
34005374:	d116      	bne.n	340053a4 <HAL_RCCEx_PeriphCLKConfig+0x5a0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
34005376:	4b4a      	ldr	r3, [pc, #296]	@ (340054a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34005378:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3400537c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34005380:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34005384:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005388:	6a1a      	ldr	r2, [r3, #32]
3400538a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400538e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34005390:	3b01      	subs	r3, #1
34005392:	041b      	lsls	r3, r3, #16
34005394:	4313      	orrs	r3, r2
34005396:	4a42      	ldr	r2, [pc, #264]	@ (340054a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34005398:	430b      	orrs	r3, r1
3400539a:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
3400539e:	f7ff f94f 	bl	34004640 <LL_RCC_IC4_Enable>
340053a2:	e026      	b.n	340053f2 <HAL_RCCEx_PeriphCLKConfig+0x5ee>
    }
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_IC5)
340053a4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340053a8:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
340053ac:	4b42      	ldr	r3, [pc, #264]	@ (340054b8 <HAL_RCCEx_PeriphCLKConfig+0x6b4>)
340053ae:	429a      	cmp	r2, r3
340053b0:	d116      	bne.n	340053e0 <HAL_RCCEx_PeriphCLKConfig+0x5dc>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));

      /* Set IC5 configuration */
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
340053b2:	4b3b      	ldr	r3, [pc, #236]	@ (340054a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
340053b4:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
340053b8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340053bc:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340053c0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340053c4:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
340053c6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340053ca:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
340053cc:	3b01      	subs	r3, #1
340053ce:	041b      	lsls	r3, r3, #16
340053d0:	4313      	orrs	r3, r2
340053d2:	4a33      	ldr	r2, [pc, #204]	@ (340054a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
340053d4:	430b      	orrs	r3, r1
340053d6:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
                 PeriphClkInit->ICSelection[RCC_IC5].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC5].ClockDivider - 1U) << RCC_IC5CFGR_IC5INT_Pos));

      LL_RCC_IC5_Enable();
340053da:	f7ff f971 	bl	340046c0 <LL_RCC_IC5_Enable>
340053de:	e008      	b.n	340053f2 <HAL_RCCEx_PeriphCLKConfig+0x5ee>
    }
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_CLKP)
340053e0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340053e4:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
340053e8:	4b34      	ldr	r3, [pc, #208]	@ (340054bc <HAL_RCCEx_PeriphCLKConfig+0x6b8>)
340053ea:	429a      	cmp	r2, r3
340053ec:	d101      	bne.n	340053f2 <HAL_RCCEx_PeriphCLKConfig+0x5ee>
    {
      LL_RCC_CLKP_Enable();
340053ee:	f7ff fce7 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SDMMC1 clock*/
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
340053f2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340053f6:	f8d3 312c 	ldr.w	r3, [r3, #300]	@ 0x12c
340053fa:	4618      	mov	r0, r3
340053fc:	f7fe fc57 	bl	34003cae <LL_RCC_SetSDMMCClockSource>
  }

  /*------------------------------------- SDMMC2 Configuration ------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SDMMC2) == RCC_PERIPHCLK_SDMMC2)
34005400:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005404:	e9d3 2300 	ldrd	r2, r3, [r3]
34005408:	f002 4300 	and.w	r3, r2, #2147483648	@ 0x80000000
3400540c:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188
34005410:	2300      	movs	r3, #0
34005412:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
34005416:	e9d7 0162 	ldrd	r0, r1, [r7, #392]	@ 0x188
3400541a:	4603      	mov	r3, r0
3400541c:	460a      	mov	r2, r1
3400541e:	4313      	orrs	r3, r2
34005420:	d062      	beq.n	340054e8 <HAL_RCCEx_PeriphCLKConfig+0x6e4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC2CLKSOURCE(PeriphClkInit->Sdmmc2ClockSelection));

    if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_IC4)
34005422:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005426:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
3400542a:	4b25      	ldr	r3, [pc, #148]	@ (340054c0 <HAL_RCCEx_PeriphCLKConfig+0x6bc>)
3400542c:	429a      	cmp	r2, r3
3400542e:	d116      	bne.n	3400545e <HAL_RCCEx_PeriphCLKConfig+0x65a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
34005430:	4b1b      	ldr	r3, [pc, #108]	@ (340054a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34005432:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34005436:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400543a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400543e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005442:	6a1a      	ldr	r2, [r3, #32]
34005444:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005448:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400544a:	3b01      	subs	r3, #1
3400544c:	041b      	lsls	r3, r3, #16
3400544e:	4313      	orrs	r3, r2
34005450:	4a13      	ldr	r2, [pc, #76]	@ (340054a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34005452:	430b      	orrs	r3, r1
34005454:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
34005458:	f7ff f8f2 	bl	34004640 <LL_RCC_IC4_Enable>
3400545c:	e03d      	b.n	340054da <HAL_RCCEx_PeriphCLKConfig+0x6d6>
    }
    else if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_IC5)
3400545e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005462:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
34005466:	4b17      	ldr	r3, [pc, #92]	@ (340054c4 <HAL_RCCEx_PeriphCLKConfig+0x6c0>)
34005468:	429a      	cmp	r2, r3
3400546a:	d12d      	bne.n	340054c8 <HAL_RCCEx_PeriphCLKConfig+0x6c4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));

      /* Set IC5 configuration */
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
3400546c:	4b0c      	ldr	r3, [pc, #48]	@ (340054a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3400546e:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
34005472:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34005476:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400547a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400547e:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
34005480:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005484:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34005486:	3b01      	subs	r3, #1
34005488:	041b      	lsls	r3, r3, #16
3400548a:	4313      	orrs	r3, r2
3400548c:	4a04      	ldr	r2, [pc, #16]	@ (340054a0 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
3400548e:	430b      	orrs	r3, r1
34005490:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
                 PeriphClkInit->ICSelection[RCC_IC5].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC5].ClockDivider - 1U) << RCC_IC5CFGR_IC5INT_Pos));

      LL_RCC_IC5_Enable();
34005494:	f7ff f914 	bl	340046c0 <LL_RCC_IC5_Enable>
34005498:	e01f      	b.n	340054da <HAL_RCCEx_PeriphCLKConfig+0x6d6>
3400549a:	bf00      	nop
3400549c:	03030414 	.word	0x03030414
340054a0:	56028000 	.word	0x56028000
340054a4:	03010414 	.word	0x03010414
340054a8:	03020814 	.word	0x03020814
340054ac:	03030814 	.word	0x03030814
340054b0:	03010814 	.word	0x03010814
340054b4:	0302001c 	.word	0x0302001c
340054b8:	0303001c 	.word	0x0303001c
340054bc:	0301001c 	.word	0x0301001c
340054c0:	0302041c 	.word	0x0302041c
340054c4:	0303041c 	.word	0x0303041c
    }
    else if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_CLKP)
340054c8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340054cc:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
340054d0:	4bb3      	ldr	r3, [pc, #716]	@ (340057a0 <HAL_RCCEx_PeriphCLKConfig+0x99c>)
340054d2:	429a      	cmp	r2, r3
340054d4:	d101      	bne.n	340054da <HAL_RCCEx_PeriphCLKConfig+0x6d6>
    {
      LL_RCC_CLKP_Enable();
340054d6:	f7ff fc73 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SDMMC2 clock*/
    __HAL_RCC_SDMMC2_CONFIG(PeriphClkInit->Sdmmc2ClockSelection);
340054da:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340054de:	f8d3 3130 	ldr.w	r3, [r3, #304]	@ 0x130
340054e2:	4618      	mov	r0, r3
340054e4:	f7fe fbe3 	bl	34003cae <LL_RCC_SetSDMMCClockSource>
  }

  /*---------------------------- ADC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
340054e8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340054ec:	e9d3 2300 	ldrd	r2, r3, [r3]
340054f0:	f002 0301 	and.w	r3, r2, #1
340054f4:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
340054f8:	2300      	movs	r3, #0
340054fa:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
340054fe:	e9d7 0160 	ldrd	r0, r1, [r7, #384]	@ 0x180
34005502:	4603      	mov	r3, r0
34005504:	460a      	mov	r2, r1
34005506:	4313      	orrs	r3, r2
34005508:	d057      	beq.n	340055ba <HAL_RCCEx_PeriphCLKConfig+0x7b6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));
    assert_param(IS_RCC_ADCDIVIDER(PeriphClkInit->AdcDivider));

    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_IC7)
3400550a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400550e:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
34005512:	2b20      	cmp	r3, #32
34005514:	d116      	bne.n	34005544 <HAL_RCCEx_PeriphCLKConfig+0x740>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34005516:	4ba3      	ldr	r3, [pc, #652]	@ (340057a4 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34005518:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3400551c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34005520:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34005524:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005528:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
3400552a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400552e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34005530:	3b01      	subs	r3, #1
34005532:	041b      	lsls	r3, r3, #16
34005534:	4313      	orrs	r3, r2
34005536:	4a9b      	ldr	r2, [pc, #620]	@ (340057a4 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34005538:	430b      	orrs	r3, r1
3400553a:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
3400553e:	f7ff f8ff 	bl	34004740 <LL_RCC_IC7_Enable>
34005542:	e024      	b.n	3400558e <HAL_RCCEx_PeriphCLKConfig+0x78a>
    }
    else if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_IC8)
34005544:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005548:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
3400554c:	2b30      	cmp	r3, #48	@ 0x30
3400554e:	d116      	bne.n	3400557e <HAL_RCCEx_PeriphCLKConfig+0x77a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34005550:	4b94      	ldr	r3, [pc, #592]	@ (340057a4 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34005552:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34005556:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400555a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400555e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005562:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34005564:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005568:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400556a:	3b01      	subs	r3, #1
3400556c:	041b      	lsls	r3, r3, #16
3400556e:	4313      	orrs	r3, r2
34005570:	4a8c      	ldr	r2, [pc, #560]	@ (340057a4 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34005572:	430b      	orrs	r3, r1
34005574:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34005578:	f7ff f922 	bl	340047c0 <LL_RCC_IC8_Enable>
3400557c:	e007      	b.n	3400558e <HAL_RCCEx_PeriphCLKConfig+0x78a>
    }
    else if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_CLKP)
3400557e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005582:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
34005586:	2b10      	cmp	r3, #16
34005588:	d101      	bne.n	3400558e <HAL_RCCEx_PeriphCLKConfig+0x78a>
    {
      LL_RCC_CLKP_Enable();
3400558a:	f7ff fc19 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the ADC clock source and divider */
    MODIFY_REG(RCC->CCIPR1, (RCC_CCIPR1_ADCPRE | RCC_CCIPR1_ADC12SEL), \
3400558e:	4b85      	ldr	r3, [pc, #532]	@ (340057a4 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34005590:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
34005594:	f423 417f 	bic.w	r1, r3, #65280	@ 0xff00
34005598:	f021 0170 	bic.w	r1, r1, #112	@ 0x70
3400559c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340055a0:	f8d3 30c0 	ldr.w	r3, [r3, #192]	@ 0xc0
340055a4:	3b01      	subs	r3, #1
340055a6:	021a      	lsls	r2, r3, #8
340055a8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340055ac:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
340055b0:	4313      	orrs	r3, r2
340055b2:	4a7c      	ldr	r2, [pc, #496]	@ (340057a4 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
340055b4:	430b      	orrs	r3, r1
340055b6:	f8c2 3144 	str.w	r3, [r2, #324]	@ 0x144
               (((PeriphClkInit->AdcDivider - 1U) << RCC_CCIPR1_ADCPRE_Pos) | (PeriphClkInit->AdcClockSelection)));
  }

  /*---------------------------- ADF1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADF1) == RCC_PERIPHCLK_ADF1)
340055ba:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340055be:	e9d3 2300 	ldrd	r2, r3, [r3]
340055c2:	f002 0302 	and.w	r3, r2, #2
340055c6:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
340055ca:	2300      	movs	r3, #0
340055cc:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
340055d0:	e9d7 015e 	ldrd	r0, r1, [r7, #376]	@ 0x178
340055d4:	4603      	mov	r3, r0
340055d6:	460a      	mov	r2, r1
340055d8:	4313      	orrs	r3, r2
340055da:	d048      	beq.n	3400566e <HAL_RCCEx_PeriphCLKConfig+0x86a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADF1CLKSOURCE(PeriphClkInit->Adf1ClockSelection));

    if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_IC7)
340055dc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340055e0:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
340055e4:	2b02      	cmp	r3, #2
340055e6:	d116      	bne.n	34005616 <HAL_RCCEx_PeriphCLKConfig+0x812>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
340055e8:	4b6e      	ldr	r3, [pc, #440]	@ (340057a4 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
340055ea:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
340055ee:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340055f2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340055f6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340055fa:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
340055fc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005600:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34005602:	3b01      	subs	r3, #1
34005604:	041b      	lsls	r3, r3, #16
34005606:	4313      	orrs	r3, r2
34005608:	4a66      	ldr	r2, [pc, #408]	@ (340057a4 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
3400560a:	430b      	orrs	r3, r1
3400560c:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34005610:	f7ff f896 	bl	34004740 <LL_RCC_IC7_Enable>
34005614:	e024      	b.n	34005660 <HAL_RCCEx_PeriphCLKConfig+0x85c>
    }
    else if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_IC8)
34005616:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400561a:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3400561e:	2b03      	cmp	r3, #3
34005620:	d116      	bne.n	34005650 <HAL_RCCEx_PeriphCLKConfig+0x84c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34005622:	4b60      	ldr	r3, [pc, #384]	@ (340057a4 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34005624:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34005628:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400562c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34005630:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005634:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34005636:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400563a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400563c:	3b01      	subs	r3, #1
3400563e:	041b      	lsls	r3, r3, #16
34005640:	4313      	orrs	r3, r2
34005642:	4a58      	ldr	r2, [pc, #352]	@ (340057a4 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34005644:	430b      	orrs	r3, r1
34005646:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3400564a:	f7ff f8b9 	bl	340047c0 <LL_RCC_IC8_Enable>
3400564e:	e007      	b.n	34005660 <HAL_RCCEx_PeriphCLKConfig+0x85c>
    }
    else if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_CLKP)
34005650:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005654:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34005658:	2b01      	cmp	r3, #1
3400565a:	d101      	bne.n	34005660 <HAL_RCCEx_PeriphCLKConfig+0x85c>
    {
      LL_RCC_CLKP_Enable();
3400565c:	f7ff fbb0 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of ADF1 clock*/
    __HAL_RCC_ADF1_CONFIG(PeriphClkInit->Adf1ClockSelection);
34005660:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005664:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34005668:	4618      	mov	r0, r3
3400566a:	f7fe f9b1 	bl	340039d0 <LL_RCC_SetADFClockSource>
  }

  /*------------------------------------ CSI configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CSI) == RCC_PERIPHCLK_CSI)
3400566e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005672:	e9d3 2300 	ldrd	r2, r3, [r3]
34005676:	f002 0308 	and.w	r3, r2, #8
3400567a:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
3400567e:	2300      	movs	r3, #0
34005680:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
34005684:	e9d7 015c 	ldrd	r0, r1, [r7, #368]	@ 0x170
34005688:	4603      	mov	r3, r0
3400568a:	460a      	mov	r2, r1
3400568c:	4313      	orrs	r3, r2
3400568e:	d017      	beq.n	340056c0 <HAL_RCCEx_PeriphCLKConfig+0x8bc>
    /* Check the parameters */
    assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC18].ClockSelection));
    assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC18].ClockDivider));

    /* Set IC18 configuration */
    MODIFY_REG(RCC->IC18CFGR, RCC_IC18CFGR_IC18SEL | RCC_IC18CFGR_IC18INT,
34005690:	4b44      	ldr	r3, [pc, #272]	@ (340057a4 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34005692:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
34005696:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400569a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400569e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340056a2:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
340056a6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340056aa:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
340056ae:	3b01      	subs	r3, #1
340056b0:	041b      	lsls	r3, r3, #16
340056b2:	4313      	orrs	r3, r2
340056b4:	4a3b      	ldr	r2, [pc, #236]	@ (340057a4 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
340056b6:	430b      	orrs	r3, r1
340056b8:	f8c2 3108 	str.w	r3, [r2, #264]	@ 0x108
               PeriphClkInit->ICSelection[RCC_IC18].ClockSelection | \
               ((PeriphClkInit->ICSelection[RCC_IC18].ClockDivider - 1U) << RCC_IC18CFGR_IC18INT_Pos));

    LL_RCC_IC18_Enable();
340056bc:	f7ff fac0 	bl	34004c40 <LL_RCC_IC18_Enable>
  }

  /*---------------------- DCMIPP configuration ------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_DCMIPP) == RCC_PERIPHCLK_DCMIPP)
340056c0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340056c4:	e9d3 2300 	ldrd	r2, r3, [r3]
340056c8:	f002 0310 	and.w	r3, r2, #16
340056cc:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
340056d0:	2300      	movs	r3, #0
340056d2:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
340056d6:	e9d7 015a 	ldrd	r0, r1, [r7, #360]	@ 0x168
340056da:	4603      	mov	r3, r0
340056dc:	460a      	mov	r2, r1
340056de:	4313      	orrs	r3, r2
340056e0:	d02f      	beq.n	34005742 <HAL_RCCEx_PeriphCLKConfig+0x93e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DCMIPPCLKSOURCE(PeriphClkInit->DcmippClockSelection));

    if (PeriphClkInit->DcmippClockSelection == RCC_DCMIPPCLKSOURCE_IC17)
340056e2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340056e6:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
340056ea:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
340056ee:	d118      	bne.n	34005722 <HAL_RCCEx_PeriphCLKConfig+0x91e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC17].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC17].ClockDivider));

      /* Set IC17 configuration */
      MODIFY_REG(RCC->IC17CFGR, RCC_IC17CFGR_IC17SEL | RCC_IC17CFGR_IC17INT,
340056f0:	4b2c      	ldr	r3, [pc, #176]	@ (340057a4 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
340056f2:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
340056f6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340056fa:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340056fe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005702:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
34005706:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400570a:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
3400570e:	3b01      	subs	r3, #1
34005710:	041b      	lsls	r3, r3, #16
34005712:	4313      	orrs	r3, r2
34005714:	4a23      	ldr	r2, [pc, #140]	@ (340057a4 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34005716:	430b      	orrs	r3, r1
34005718:	f8c2 3104 	str.w	r3, [r2, #260]	@ 0x104
                 PeriphClkInit->ICSelection[RCC_IC17].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC17].ClockDivider - 1U) << RCC_IC17CFGR_IC17INT_Pos));

      LL_RCC_IC17_Enable();
3400571c:	f7ff fa50 	bl	34004bc0 <LL_RCC_IC17_Enable>
34005720:	e008      	b.n	34005734 <HAL_RCCEx_PeriphCLKConfig+0x930>
    }
    else if (PeriphClkInit->DcmippClockSelection == RCC_DCMIPPCLKSOURCE_CLKP)
34005722:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005726:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
3400572a:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3400572e:	d101      	bne.n	34005734 <HAL_RCCEx_PeriphCLKConfig+0x930>
    {
      LL_RCC_CLKP_Enable();
34005730:	f7ff fb46 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the CEC clock source */
    __HAL_RCC_DCMIPP_CONFIG(PeriphClkInit->DcmippClockSelection);
34005734:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005738:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
3400573c:	4618      	mov	r0, r3
3400573e:	f7fe f973 	bl	34003a28 <LL_RCC_SetDCMIPPClockSource>
  }

  /*---------------------- ETH1 configuration --------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1) == RCC_PERIPHCLK_ETH1)
34005742:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005746:	e9d3 2300 	ldrd	r2, r3, [r3]
3400574a:	f002 0320 	and.w	r3, r2, #32
3400574e:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
34005752:	2300      	movs	r3, #0
34005754:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
34005758:	e9d7 0158 	ldrd	r0, r1, [r7, #352]	@ 0x160
3400575c:	4603      	mov	r3, r0
3400575e:	460a      	mov	r2, r1
34005760:	4313      	orrs	r3, r2
34005762:	d031      	beq.n	340057c8 <HAL_RCCEx_PeriphCLKConfig+0x9c4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1CLKSOURCE(PeriphClkInit->Eth1ClockSelection));

    if (PeriphClkInit->Eth1ClockSelection == RCC_ETH1CLKSOURCE_IC12)
34005764:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005768:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3400576c:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
34005770:	d11a      	bne.n	340057a8 <HAL_RCCEx_PeriphCLKConfig+0x9a4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC12].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC12].ClockDivider));

      /* Set IC12 configuration */
      MODIFY_REG(RCC->IC12CFGR, RCC_IC12CFGR_IC12SEL | RCC_IC12CFGR_IC12INT,
34005772:	4b0c      	ldr	r3, [pc, #48]	@ (340057a4 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34005774:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
34005778:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400577c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34005780:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005784:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
34005786:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400578a:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
3400578c:	3b01      	subs	r3, #1
3400578e:	041b      	lsls	r3, r3, #16
34005790:	4313      	orrs	r3, r2
34005792:	4a04      	ldr	r2, [pc, #16]	@ (340057a4 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34005794:	430b      	orrs	r3, r1
34005796:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
                 PeriphClkInit->ICSelection[RCC_IC12].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC12].ClockDivider - 1U) << RCC_IC12CFGR_IC12INT_Pos));

      LL_RCC_IC12_Enable();
3400579a:	f7ff f8d1 	bl	34004940 <LL_RCC_IC12_Enable>
3400579e:	e00c      	b.n	340057ba <HAL_RCCEx_PeriphCLKConfig+0x9b6>
340057a0:	0301041c 	.word	0x0301041c
340057a4:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Eth1ClockSelection == RCC_ETH1CLKSOURCE_CLKP)
340057a8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340057ac:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
340057b0:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
340057b4:	d101      	bne.n	340057ba <HAL_RCCEx_PeriphCLKConfig+0x9b6>
    {
      LL_RCC_CLKP_Enable();
340057b6:	f7ff fb03 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the ETH1 clock source */
    __HAL_RCC_ETH1_CONFIG(PeriphClkInit->Eth1ClockSelection);
340057ba:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340057be:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
340057c2:	4618      	mov	r0, r3
340057c4:	f7fe f946 	bl	34003a54 <LL_RCC_SetETHClockSource>
  }

  /*---------------------- ETH1PHY configuration -----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1PHY) == RCC_PERIPHCLK_ETH1PHY)
340057c8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340057cc:	e9d3 2300 	ldrd	r2, r3, [r3]
340057d0:	f002 0340 	and.w	r3, r2, #64	@ 0x40
340057d4:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
340057d8:	2300      	movs	r3, #0
340057da:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
340057de:	e9d7 0156 	ldrd	r0, r1, [r7, #344]	@ 0x158
340057e2:	4603      	mov	r3, r0
340057e4:	460a      	mov	r2, r1
340057e6:	4313      	orrs	r3, r2
340057e8:	d006      	beq.n	340057f8 <HAL_RCCEx_PeriphCLKConfig+0x9f4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1PHYIF(PeriphClkInit->Eth1PhyInterfaceSelection));

    /* Configure the source of ETH1 PHY interface */
    __HAL_RCC_ETH1PHY_CONFIG(PeriphClkInit->Eth1PhyInterfaceSelection);
340057ea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340057ee:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
340057f2:	4618      	mov	r0, r3
340057f4:	f7fe f944 	bl	34003a80 <LL_RCC_SetETHPHYInterface>
  }

  /*---------------------- ETH1 RX configuration -----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1RX) == RCC_PERIPHCLK_ETH1RX)
340057f8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340057fc:	e9d3 2300 	ldrd	r2, r3, [r3]
34005800:	f002 0380 	and.w	r3, r2, #128	@ 0x80
34005804:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
34005808:	2300      	movs	r3, #0
3400580a:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
3400580e:	e9d7 0154 	ldrd	r0, r1, [r7, #336]	@ 0x150
34005812:	4603      	mov	r3, r0
34005814:	460a      	mov	r2, r1
34005816:	4313      	orrs	r3, r2
34005818:	d006      	beq.n	34005828 <HAL_RCCEx_PeriphCLKConfig+0xa24>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1RXCLKSOURCE(PeriphClkInit->Eth1RxClockSelection));

    /* Configure the ETH1 RX clock source */
    __HAL_RCC_ETH1RX_CONFIG(PeriphClkInit->Eth1RxClockSelection);
3400581a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400581e:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
34005822:	4618      	mov	r0, r3
34005824:	f7fe f950 	bl	34003ac8 <LL_RCC_SetETHREFRXClockSource>
  }

  /*---------------------- ETH1 TX configuration -----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1TX) == RCC_PERIPHCLK_ETH1TX)
34005828:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400582c:	e9d3 2300 	ldrd	r2, r3, [r3]
34005830:	f402 7380 	and.w	r3, r2, #256	@ 0x100
34005834:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
34005838:	2300      	movs	r3, #0
3400583a:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
3400583e:	e9d7 0152 	ldrd	r0, r1, [r7, #328]	@ 0x148
34005842:	4603      	mov	r3, r0
34005844:	460a      	mov	r2, r1
34005846:	4313      	orrs	r3, r2
34005848:	d006      	beq.n	34005858 <HAL_RCCEx_PeriphCLKConfig+0xa54>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1TXCLKSOURCE(PeriphClkInit->Eth1TxClockSelection));

    /* Configure the ETH1 TX clock source */
    __HAL_RCC_ETH1TX_CONFIG(PeriphClkInit->Eth1TxClockSelection);
3400584a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400584e:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
34005852:	4618      	mov	r0, r3
34005854:	f7fe f94e 	bl	34003af4 <LL_RCC_SetETHREFTXClockSource>
  }

  /*---------------------- ETH1 PTP configuration ----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1PTP) == RCC_PERIPHCLK_ETH1PTP)
34005858:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400585c:	e9d3 2300 	ldrd	r2, r3, [r3]
34005860:	f402 7300 	and.w	r3, r2, #512	@ 0x200
34005864:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
34005868:	2300      	movs	r3, #0
3400586a:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
3400586e:	e9d7 0150 	ldrd	r0, r1, [r7, #320]	@ 0x140
34005872:	4603      	mov	r3, r0
34005874:	460a      	mov	r2, r1
34005876:	4313      	orrs	r3, r2
34005878:	d038      	beq.n	340058ec <HAL_RCCEx_PeriphCLKConfig+0xae8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1PTPCLKSOURCE(PeriphClkInit->Eth1PtpClockSelection));
    assert_param(IS_RCC_ETH1PTPDIVIDER(PeriphClkInit->Eth1PtpDivider));

    if (PeriphClkInit->Eth1PtpClockSelection == RCC_ETH1PTPCLKSOURCE_IC13)
3400587a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400587e:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34005882:	2b02      	cmp	r3, #2
34005884:	d116      	bne.n	340058b4 <HAL_RCCEx_PeriphCLKConfig+0xab0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC13].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC13].ClockDivider));

      /* Set IC13 configuration */
      MODIFY_REG(RCC->IC13CFGR, RCC_IC13CFGR_IC13SEL | RCC_IC13CFGR_IC13INT,
34005886:	4bbc      	ldr	r3, [pc, #752]	@ (34005b78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34005888:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
3400588c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34005890:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34005894:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005898:	6e9a      	ldr	r2, [r3, #104]	@ 0x68
3400589a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400589e:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
340058a0:	3b01      	subs	r3, #1
340058a2:	041b      	lsls	r3, r3, #16
340058a4:	4313      	orrs	r3, r2
340058a6:	4ab4      	ldr	r2, [pc, #720]	@ (34005b78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
340058a8:	430b      	orrs	r3, r1
340058aa:	f8c2 30f4 	str.w	r3, [r2, #244]	@ 0xf4
                 PeriphClkInit->ICSelection[RCC_IC13].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC13].ClockDivider - 1U) << RCC_IC13CFGR_IC13INT_Pos));

      LL_RCC_IC13_Enable();
340058ae:	f7ff f887 	bl	340049c0 <LL_RCC_IC13_Enable>
340058b2:	e007      	b.n	340058c4 <HAL_RCCEx_PeriphCLKConfig+0xac0>
    }
    else if (PeriphClkInit->Eth1PtpClockSelection == RCC_ETH1PTPCLKSOURCE_CLKP)
340058b4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340058b8:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
340058bc:	2b01      	cmp	r3, #1
340058be:	d101      	bne.n	340058c4 <HAL_RCCEx_PeriphCLKConfig+0xac0>
    {
      LL_RCC_CLKP_Enable();
340058c0:	f7ff fa7e 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the ETH1 PTP clock source and divider */
    MODIFY_REG(RCC->CCIPR2, (RCC_CCIPR2_ETH1PTPDIV | RCC_CCIPR2_ETH1PTPSEL), \
340058c4:	4bac      	ldr	r3, [pc, #688]	@ (34005b78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
340058c6:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
340058ca:	f023 01f3 	bic.w	r1, r3, #243	@ 0xf3
340058ce:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340058d2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
340058d6:	3b01      	subs	r3, #1
340058d8:	011a      	lsls	r2, r3, #4
340058da:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340058de:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
340058e2:	4313      	orrs	r3, r2
340058e4:	4aa4      	ldr	r2, [pc, #656]	@ (34005b78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
340058e6:	430b      	orrs	r3, r1
340058e8:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
               (((PeriphClkInit->Eth1PtpDivider - 1U) << RCC_CCIPR2_ETH1PTPDIV_Pos) | \
                PeriphClkInit->Eth1PtpClockSelection));
  }

  /*---------------------- FDCAN configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
340058ec:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340058f0:	e9d3 2300 	ldrd	r2, r3, [r3]
340058f4:	f402 6380 	and.w	r3, r2, #1024	@ 0x400
340058f8:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
340058fc:	2300      	movs	r3, #0
340058fe:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
34005902:	e9d7 014e 	ldrd	r0, r1, [r7, #312]	@ 0x138
34005906:	4603      	mov	r3, r0
34005908:	460a      	mov	r2, r1
3400590a:	4313      	orrs	r3, r2
3400590c:	d02d      	beq.n	3400596a <HAL_RCCEx_PeriphCLKConfig+0xb66>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FDCANCLKSOURCE(PeriphClkInit->FdcanClockSelection));

    if (PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_IC19)
3400590e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005912:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34005916:	2b02      	cmp	r3, #2
34005918:	d118      	bne.n	3400594c <HAL_RCCEx_PeriphCLKConfig+0xb48>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC19].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC19].ClockDivider));

      /* Set IC19 configuration */
      MODIFY_REG(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL | RCC_IC19CFGR_IC19INT,
3400591a:	4b97      	ldr	r3, [pc, #604]	@ (34005b78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3400591c:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
34005920:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34005924:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34005928:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400592c:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
34005930:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005934:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
34005938:	3b01      	subs	r3, #1
3400593a:	041b      	lsls	r3, r3, #16
3400593c:	4313      	orrs	r3, r2
3400593e:	4a8e      	ldr	r2, [pc, #568]	@ (34005b78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34005940:	430b      	orrs	r3, r1
34005942:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
                 PeriphClkInit->ICSelection[RCC_IC19].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC19].ClockDivider - 1U) << RCC_IC19CFGR_IC19INT_Pos));

      LL_RCC_IC19_Enable();
34005946:	f7ff f9bb 	bl	34004cc0 <LL_RCC_IC19_Enable>
3400594a:	e007      	b.n	3400595c <HAL_RCCEx_PeriphCLKConfig+0xb58>
    }
    else if (PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_CLKP)
3400594c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005950:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34005954:	2b01      	cmp	r3, #1
34005956:	d101      	bne.n	3400595c <HAL_RCCEx_PeriphCLKConfig+0xb58>
    {
      LL_RCC_CLKP_Enable();
34005958:	f7ff fa32 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of FDCAN clock*/
    __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
3400595c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005960:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34005964:	4618      	mov	r0, r3
34005966:	f7fe f8db 	bl	34003b20 <LL_RCC_SetFDCANClockSource>
  }

  /*------------------------------ I2C1 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
3400596a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400596e:	e9d3 2300 	ldrd	r2, r3, [r3]
34005972:	f402 5380 	and.w	r3, r2, #4096	@ 0x1000
34005976:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
3400597a:	2300      	movs	r3, #0
3400597c:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
34005980:	e9d7 014c 	ldrd	r0, r1, [r7, #304]	@ 0x130
34005984:	4603      	mov	r3, r0
34005986:	460a      	mov	r2, r1
34005988:	4313      	orrs	r3, r2
3400598a:	d04b      	beq.n	34005a24 <HAL_RCCEx_PeriphCLKConfig+0xc20>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_IC10)
3400598c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005990:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
34005994:	4b79      	ldr	r3, [pc, #484]	@ (34005b7c <HAL_RCCEx_PeriphCLKConfig+0xd78>)
34005996:	429a      	cmp	r2, r3
34005998:	d116      	bne.n	340059c8 <HAL_RCCEx_PeriphCLKConfig+0xbc4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400599a:	4b77      	ldr	r3, [pc, #476]	@ (34005b78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3400599c:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
340059a0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340059a4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340059a8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340059ac:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
340059ae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340059b2:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
340059b4:	3b01      	subs	r3, #1
340059b6:	041b      	lsls	r3, r3, #16
340059b8:	4313      	orrs	r3, r2
340059ba:	4a6f      	ldr	r2, [pc, #444]	@ (34005b78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
340059bc:	430b      	orrs	r3, r1
340059be:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
340059c2:	f7fe ff7d 	bl	340048c0 <LL_RCC_IC10_Enable>
340059c6:	e026      	b.n	34005a16 <HAL_RCCEx_PeriphCLKConfig+0xc12>
    }
    else if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_IC15)
340059c8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340059cc:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
340059d0:	4b6b      	ldr	r3, [pc, #428]	@ (34005b80 <HAL_RCCEx_PeriphCLKConfig+0xd7c>)
340059d2:	429a      	cmp	r2, r3
340059d4:	d116      	bne.n	34005a04 <HAL_RCCEx_PeriphCLKConfig+0xc00>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
340059d6:	4b68      	ldr	r3, [pc, #416]	@ (34005b78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
340059d8:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
340059dc:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340059e0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340059e4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340059e8:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
340059ea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340059ee:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
340059f0:	3b01      	subs	r3, #1
340059f2:	041b      	lsls	r3, r3, #16
340059f4:	4313      	orrs	r3, r2
340059f6:	4a60      	ldr	r2, [pc, #384]	@ (34005b78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
340059f8:	430b      	orrs	r3, r1
340059fa:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
340059fe:	f7ff f85f 	bl	34004ac0 <LL_RCC_IC15_Enable>
34005a02:	e008      	b.n	34005a16 <HAL_RCCEx_PeriphCLKConfig+0xc12>
    }
    else if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_CLKP)
34005a04:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005a08:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
34005a0c:	4b5d      	ldr	r3, [pc, #372]	@ (34005b84 <HAL_RCCEx_PeriphCLKConfig+0xd80>)
34005a0e:	429a      	cmp	r2, r3
34005a10:	d101      	bne.n	34005a16 <HAL_RCCEx_PeriphCLKConfig+0xc12>
    {
      LL_RCC_CLKP_Enable();
34005a12:	f7ff f9d5 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C1 clock*/
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
34005a16:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005a1a:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
34005a1e:	4618      	mov	r0, r3
34005a20:	f7fe f8aa 	bl	34003b78 <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I2C2 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
34005a24:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005a28:	e9d3 2300 	ldrd	r2, r3, [r3]
34005a2c:	f402 5300 	and.w	r3, r2, #8192	@ 0x2000
34005a30:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
34005a34:	2300      	movs	r3, #0
34005a36:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
34005a3a:	e9d7 014a 	ldrd	r0, r1, [r7, #296]	@ 0x128
34005a3e:	4603      	mov	r3, r0
34005a40:	460a      	mov	r2, r1
34005a42:	4313      	orrs	r3, r2
34005a44:	d04b      	beq.n	34005ade <HAL_RCCEx_PeriphCLKConfig+0xcda>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_IC10)
34005a46:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005a4a:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
34005a4e:	4b4e      	ldr	r3, [pc, #312]	@ (34005b88 <HAL_RCCEx_PeriphCLKConfig+0xd84>)
34005a50:	429a      	cmp	r2, r3
34005a52:	d116      	bne.n	34005a82 <HAL_RCCEx_PeriphCLKConfig+0xc7e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34005a54:	4b48      	ldr	r3, [pc, #288]	@ (34005b78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34005a56:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
34005a5a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34005a5e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34005a62:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005a66:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
34005a68:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005a6c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34005a6e:	3b01      	subs	r3, #1
34005a70:	041b      	lsls	r3, r3, #16
34005a72:	4313      	orrs	r3, r2
34005a74:	4a40      	ldr	r2, [pc, #256]	@ (34005b78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34005a76:	430b      	orrs	r3, r1
34005a78:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
34005a7c:	f7fe ff20 	bl	340048c0 <LL_RCC_IC10_Enable>
34005a80:	e026      	b.n	34005ad0 <HAL_RCCEx_PeriphCLKConfig+0xccc>
    }
    else if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_IC15)
34005a82:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005a86:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
34005a8a:	4b40      	ldr	r3, [pc, #256]	@ (34005b8c <HAL_RCCEx_PeriphCLKConfig+0xd88>)
34005a8c:	429a      	cmp	r2, r3
34005a8e:	d116      	bne.n	34005abe <HAL_RCCEx_PeriphCLKConfig+0xcba>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34005a90:	4b39      	ldr	r3, [pc, #228]	@ (34005b78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34005a92:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34005a96:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34005a9a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34005a9e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005aa2:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34005aa4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005aa8:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34005aaa:	3b01      	subs	r3, #1
34005aac:	041b      	lsls	r3, r3, #16
34005aae:	4313      	orrs	r3, r2
34005ab0:	4a31      	ldr	r2, [pc, #196]	@ (34005b78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34005ab2:	430b      	orrs	r3, r1
34005ab4:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34005ab8:	f7ff f802 	bl	34004ac0 <LL_RCC_IC15_Enable>
34005abc:	e008      	b.n	34005ad0 <HAL_RCCEx_PeriphCLKConfig+0xccc>
    }
    else if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_CLKP)
34005abe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005ac2:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
34005ac6:	4b32      	ldr	r3, [pc, #200]	@ (34005b90 <HAL_RCCEx_PeriphCLKConfig+0xd8c>)
34005ac8:	429a      	cmp	r2, r3
34005aca:	d101      	bne.n	34005ad0 <HAL_RCCEx_PeriphCLKConfig+0xccc>
    {
      LL_RCC_CLKP_Enable();
34005acc:	f7ff f978 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C2 clock*/
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
34005ad0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005ad4:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
34005ad8:	4618      	mov	r0, r3
34005ada:	f7fe f84d 	bl	34003b78 <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I2C3 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
34005ade:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005ae2:	e9d3 2300 	ldrd	r2, r3, [r3]
34005ae6:	f402 4380 	and.w	r3, r2, #16384	@ 0x4000
34005aea:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
34005aee:	2300      	movs	r3, #0
34005af0:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
34005af4:	e9d7 0148 	ldrd	r0, r1, [r7, #288]	@ 0x120
34005af8:	4603      	mov	r3, r0
34005afa:	460a      	mov	r2, r1
34005afc:	4313      	orrs	r3, r2
34005afe:	d05d      	beq.n	34005bbc <HAL_RCCEx_PeriphCLKConfig+0xdb8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_IC10)
34005b00:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005b04:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
34005b08:	4b22      	ldr	r3, [pc, #136]	@ (34005b94 <HAL_RCCEx_PeriphCLKConfig+0xd90>)
34005b0a:	429a      	cmp	r2, r3
34005b0c:	d116      	bne.n	34005b3c <HAL_RCCEx_PeriphCLKConfig+0xd38>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34005b0e:	4b1a      	ldr	r3, [pc, #104]	@ (34005b78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34005b10:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
34005b14:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34005b18:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34005b1c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005b20:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
34005b22:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005b26:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34005b28:	3b01      	subs	r3, #1
34005b2a:	041b      	lsls	r3, r3, #16
34005b2c:	4313      	orrs	r3, r2
34005b2e:	4a12      	ldr	r2, [pc, #72]	@ (34005b78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34005b30:	430b      	orrs	r3, r1
34005b32:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
34005b36:	f7fe fec3 	bl	340048c0 <LL_RCC_IC10_Enable>
34005b3a:	e038      	b.n	34005bae <HAL_RCCEx_PeriphCLKConfig+0xdaa>
    }
    else if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_IC15)
34005b3c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005b40:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
34005b44:	4b14      	ldr	r3, [pc, #80]	@ (34005b98 <HAL_RCCEx_PeriphCLKConfig+0xd94>)
34005b46:	429a      	cmp	r2, r3
34005b48:	d128      	bne.n	34005b9c <HAL_RCCEx_PeriphCLKConfig+0xd98>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34005b4a:	4b0b      	ldr	r3, [pc, #44]	@ (34005b78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34005b4c:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34005b50:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34005b54:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34005b58:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005b5c:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34005b5e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005b62:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34005b64:	3b01      	subs	r3, #1
34005b66:	041b      	lsls	r3, r3, #16
34005b68:	4313      	orrs	r3, r2
34005b6a:	4a03      	ldr	r2, [pc, #12]	@ (34005b78 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34005b6c:	430b      	orrs	r3, r1
34005b6e:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34005b72:	f7fe ffa5 	bl	34004ac0 <LL_RCC_IC15_Enable>
34005b76:	e01a      	b.n	34005bae <HAL_RCCEx_PeriphCLKConfig+0xdaa>
34005b78:	56028000 	.word	0x56028000
34005b7c:	0702000c 	.word	0x0702000c
34005b80:	0703000c 	.word	0x0703000c
34005b84:	0701000c 	.word	0x0701000c
34005b88:	0702040c 	.word	0x0702040c
34005b8c:	0703040c 	.word	0x0703040c
34005b90:	0701040c 	.word	0x0701040c
34005b94:	0702080c 	.word	0x0702080c
34005b98:	0703080c 	.word	0x0703080c
    }
    else if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_CLKP)
34005b9c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005ba0:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
34005ba4:	4bc8      	ldr	r3, [pc, #800]	@ (34005ec8 <HAL_RCCEx_PeriphCLKConfig+0x10c4>)
34005ba6:	429a      	cmp	r2, r3
34005ba8:	d101      	bne.n	34005bae <HAL_RCCEx_PeriphCLKConfig+0xdaa>
    {
      LL_RCC_CLKP_Enable();
34005baa:	f7ff f909 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C3 clock*/
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
34005bae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005bb2:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
34005bb6:	4618      	mov	r0, r3
34005bb8:	f7fd ffde 	bl	34003b78 <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I2C4 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
34005bbc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005bc0:	e9d3 2300 	ldrd	r2, r3, [r3]
34005bc4:	f402 4300 	and.w	r3, r2, #32768	@ 0x8000
34005bc8:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
34005bcc:	2300      	movs	r3, #0
34005bce:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
34005bd2:	e9d7 0146 	ldrd	r0, r1, [r7, #280]	@ 0x118
34005bd6:	4603      	mov	r3, r0
34005bd8:	460a      	mov	r2, r1
34005bda:	4313      	orrs	r3, r2
34005bdc:	d04b      	beq.n	34005c76 <HAL_RCCEx_PeriphCLKConfig+0xe72>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_IC10)
34005bde:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005be2:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
34005be6:	4bb9      	ldr	r3, [pc, #740]	@ (34005ecc <HAL_RCCEx_PeriphCLKConfig+0x10c8>)
34005be8:	429a      	cmp	r2, r3
34005bea:	d116      	bne.n	34005c1a <HAL_RCCEx_PeriphCLKConfig+0xe16>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34005bec:	4bb8      	ldr	r3, [pc, #736]	@ (34005ed0 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34005bee:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
34005bf2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34005bf6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34005bfa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005bfe:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
34005c00:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005c04:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34005c06:	3b01      	subs	r3, #1
34005c08:	041b      	lsls	r3, r3, #16
34005c0a:	4313      	orrs	r3, r2
34005c0c:	4ab0      	ldr	r2, [pc, #704]	@ (34005ed0 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34005c0e:	430b      	orrs	r3, r1
34005c10:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
34005c14:	f7fe fe54 	bl	340048c0 <LL_RCC_IC10_Enable>
34005c18:	e026      	b.n	34005c68 <HAL_RCCEx_PeriphCLKConfig+0xe64>
    }
    else if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_IC15)
34005c1a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005c1e:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
34005c22:	4bac      	ldr	r3, [pc, #688]	@ (34005ed4 <HAL_RCCEx_PeriphCLKConfig+0x10d0>)
34005c24:	429a      	cmp	r2, r3
34005c26:	d116      	bne.n	34005c56 <HAL_RCCEx_PeriphCLKConfig+0xe52>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34005c28:	4ba9      	ldr	r3, [pc, #676]	@ (34005ed0 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34005c2a:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34005c2e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34005c32:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34005c36:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005c3a:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34005c3c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005c40:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34005c42:	3b01      	subs	r3, #1
34005c44:	041b      	lsls	r3, r3, #16
34005c46:	4313      	orrs	r3, r2
34005c48:	4aa1      	ldr	r2, [pc, #644]	@ (34005ed0 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34005c4a:	430b      	orrs	r3, r1
34005c4c:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34005c50:	f7fe ff36 	bl	34004ac0 <LL_RCC_IC15_Enable>
34005c54:	e008      	b.n	34005c68 <HAL_RCCEx_PeriphCLKConfig+0xe64>
    }
    else if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_CLKP)
34005c56:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005c5a:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
34005c5e:	4b9e      	ldr	r3, [pc, #632]	@ (34005ed8 <HAL_RCCEx_PeriphCLKConfig+0x10d4>)
34005c60:	429a      	cmp	r2, r3
34005c62:	d101      	bne.n	34005c68 <HAL_RCCEx_PeriphCLKConfig+0xe64>
    {
      LL_RCC_CLKP_Enable();
34005c64:	f7ff f8ac 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C4 clock*/
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
34005c68:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005c6c:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
34005c70:	4618      	mov	r0, r3
34005c72:	f7fd ff81 	bl	34003b78 <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I3C1 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I3C1) == RCC_PERIPHCLK_I3C1)
34005c76:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005c7a:	e9d3 2300 	ldrd	r2, r3, [r3]
34005c7e:	f402 3380 	and.w	r3, r2, #65536	@ 0x10000
34005c82:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
34005c86:	2300      	movs	r3, #0
34005c88:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
34005c8c:	e9d7 0144 	ldrd	r0, r1, [r7, #272]	@ 0x110
34005c90:	4603      	mov	r3, r0
34005c92:	460a      	mov	r2, r1
34005c94:	4313      	orrs	r3, r2
34005c96:	d04b      	beq.n	34005d30 <HAL_RCCEx_PeriphCLKConfig+0xf2c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I3C1CLKSOURCE(PeriphClkInit->I3c1ClockSelection));

    if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_IC10)
34005c98:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005c9c:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
34005ca0:	4b8e      	ldr	r3, [pc, #568]	@ (34005edc <HAL_RCCEx_PeriphCLKConfig+0x10d8>)
34005ca2:	429a      	cmp	r2, r3
34005ca4:	d116      	bne.n	34005cd4 <HAL_RCCEx_PeriphCLKConfig+0xed0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34005ca6:	4b8a      	ldr	r3, [pc, #552]	@ (34005ed0 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34005ca8:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
34005cac:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34005cb0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34005cb4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005cb8:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
34005cba:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005cbe:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34005cc0:	3b01      	subs	r3, #1
34005cc2:	041b      	lsls	r3, r3, #16
34005cc4:	4313      	orrs	r3, r2
34005cc6:	4a82      	ldr	r2, [pc, #520]	@ (34005ed0 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34005cc8:	430b      	orrs	r3, r1
34005cca:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
34005cce:	f7fe fdf7 	bl	340048c0 <LL_RCC_IC10_Enable>
34005cd2:	e026      	b.n	34005d22 <HAL_RCCEx_PeriphCLKConfig+0xf1e>
    }
    else if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_IC15)
34005cd4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005cd8:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
34005cdc:	4b80      	ldr	r3, [pc, #512]	@ (34005ee0 <HAL_RCCEx_PeriphCLKConfig+0x10dc>)
34005cde:	429a      	cmp	r2, r3
34005ce0:	d116      	bne.n	34005d10 <HAL_RCCEx_PeriphCLKConfig+0xf0c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34005ce2:	4b7b      	ldr	r3, [pc, #492]	@ (34005ed0 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34005ce4:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34005ce8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34005cec:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34005cf0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005cf4:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34005cf6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005cfa:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34005cfc:	3b01      	subs	r3, #1
34005cfe:	041b      	lsls	r3, r3, #16
34005d00:	4313      	orrs	r3, r2
34005d02:	4a73      	ldr	r2, [pc, #460]	@ (34005ed0 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34005d04:	430b      	orrs	r3, r1
34005d06:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34005d0a:	f7fe fed9 	bl	34004ac0 <LL_RCC_IC15_Enable>
34005d0e:	e008      	b.n	34005d22 <HAL_RCCEx_PeriphCLKConfig+0xf1e>
    }
    else if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_CLKP)
34005d10:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005d14:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
34005d18:	4b72      	ldr	r3, [pc, #456]	@ (34005ee4 <HAL_RCCEx_PeriphCLKConfig+0x10e0>)
34005d1a:	429a      	cmp	r2, r3
34005d1c:	d101      	bne.n	34005d22 <HAL_RCCEx_PeriphCLKConfig+0xf1e>
    {
      LL_RCC_CLKP_Enable();
34005d1e:	f7ff f84f 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I3C1 clock*/
    __HAL_RCC_I3C1_CONFIG(PeriphClkInit->I3c1ClockSelection);
34005d22:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005d26:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34005d2a:	4618      	mov	r0, r3
34005d2c:	f7fd ff2f 	bl	34003b8e <LL_RCC_SetI3CClockSource>
  }

  /*------------------------------ I3C2 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I3C2) == RCC_PERIPHCLK_I3C2)
34005d30:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005d34:	e9d3 2300 	ldrd	r2, r3, [r3]
34005d38:	f402 3300 	and.w	r3, r2, #131072	@ 0x20000
34005d3c:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
34005d40:	2300      	movs	r3, #0
34005d42:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
34005d46:	e9d7 0142 	ldrd	r0, r1, [r7, #264]	@ 0x108
34005d4a:	4603      	mov	r3, r0
34005d4c:	460a      	mov	r2, r1
34005d4e:	4313      	orrs	r3, r2
34005d50:	d04b      	beq.n	34005dea <HAL_RCCEx_PeriphCLKConfig+0xfe6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I3C2CLKSOURCE(PeriphClkInit->I3c2ClockSelection));

    if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_IC10)
34005d52:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005d56:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
34005d5a:	4b63      	ldr	r3, [pc, #396]	@ (34005ee8 <HAL_RCCEx_PeriphCLKConfig+0x10e4>)
34005d5c:	429a      	cmp	r2, r3
34005d5e:	d116      	bne.n	34005d8e <HAL_RCCEx_PeriphCLKConfig+0xf8a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34005d60:	4b5b      	ldr	r3, [pc, #364]	@ (34005ed0 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34005d62:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
34005d66:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34005d6a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34005d6e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005d72:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
34005d74:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005d78:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34005d7a:	3b01      	subs	r3, #1
34005d7c:	041b      	lsls	r3, r3, #16
34005d7e:	4313      	orrs	r3, r2
34005d80:	4a53      	ldr	r2, [pc, #332]	@ (34005ed0 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34005d82:	430b      	orrs	r3, r1
34005d84:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
34005d88:	f7fe fd9a 	bl	340048c0 <LL_RCC_IC10_Enable>
34005d8c:	e026      	b.n	34005ddc <HAL_RCCEx_PeriphCLKConfig+0xfd8>
    }
    else if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_IC15)
34005d8e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005d92:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
34005d96:	4b55      	ldr	r3, [pc, #340]	@ (34005eec <HAL_RCCEx_PeriphCLKConfig+0x10e8>)
34005d98:	429a      	cmp	r2, r3
34005d9a:	d116      	bne.n	34005dca <HAL_RCCEx_PeriphCLKConfig+0xfc6>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34005d9c:	4b4c      	ldr	r3, [pc, #304]	@ (34005ed0 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34005d9e:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34005da2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34005da6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34005daa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005dae:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34005db0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005db4:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34005db6:	3b01      	subs	r3, #1
34005db8:	041b      	lsls	r3, r3, #16
34005dba:	4313      	orrs	r3, r2
34005dbc:	4a44      	ldr	r2, [pc, #272]	@ (34005ed0 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34005dbe:	430b      	orrs	r3, r1
34005dc0:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34005dc4:	f7fe fe7c 	bl	34004ac0 <LL_RCC_IC15_Enable>
34005dc8:	e008      	b.n	34005ddc <HAL_RCCEx_PeriphCLKConfig+0xfd8>
    }
    else if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_CLKP)
34005dca:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005dce:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
34005dd2:	4b47      	ldr	r3, [pc, #284]	@ (34005ef0 <HAL_RCCEx_PeriphCLKConfig+0x10ec>)
34005dd4:	429a      	cmp	r2, r3
34005dd6:	d101      	bne.n	34005ddc <HAL_RCCEx_PeriphCLKConfig+0xfd8>
    {
      LL_RCC_CLKP_Enable();
34005dd8:	f7fe fff2 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I3C2 clock*/
    __HAL_RCC_I3C2_CONFIG(PeriphClkInit->I3c2ClockSelection);
34005ddc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005de0:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34005de4:	4618      	mov	r0, r3
34005de6:	f7fd fed2 	bl	34003b8e <LL_RCC_SetI3CClockSource>
  }

  /*---------------------------- LPTIM1 configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
34005dea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005dee:	e9d3 2300 	ldrd	r2, r3, [r3]
34005df2:	f402 2380 	and.w	r3, r2, #262144	@ 0x40000
34005df6:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
34005dfa:	2300      	movs	r3, #0
34005dfc:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
34005e00:	e9d7 0140 	ldrd	r0, r1, [r7, #256]	@ 0x100
34005e04:	4603      	mov	r3, r0
34005e06:	460a      	mov	r2, r1
34005e08:	4313      	orrs	r3, r2
34005e0a:	d02d      	beq.n	34005e68 <HAL_RCCEx_PeriphCLKConfig+0x1064>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));

    if (PeriphClkInit->Lptim1ClockSelection == RCC_LPTIM1CLKSOURCE_IC15)
34005e0c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005e10:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
34005e14:	4b37      	ldr	r3, [pc, #220]	@ (34005ef4 <HAL_RCCEx_PeriphCLKConfig+0x10f0>)
34005e16:	429a      	cmp	r2, r3
34005e18:	d116      	bne.n	34005e48 <HAL_RCCEx_PeriphCLKConfig+0x1044>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34005e1a:	4b2d      	ldr	r3, [pc, #180]	@ (34005ed0 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34005e1c:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34005e20:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34005e24:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34005e28:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005e2c:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34005e2e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005e32:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34005e34:	3b01      	subs	r3, #1
34005e36:	041b      	lsls	r3, r3, #16
34005e38:	4313      	orrs	r3, r2
34005e3a:	4a25      	ldr	r2, [pc, #148]	@ (34005ed0 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34005e3c:	430b      	orrs	r3, r1
34005e3e:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34005e42:	f7fe fe3d 	bl	34004ac0 <LL_RCC_IC15_Enable>
34005e46:	e008      	b.n	34005e5a <HAL_RCCEx_PeriphCLKConfig+0x1056>
    }
    else if (PeriphClkInit->Lptim1ClockSelection == RCC_LPTIM1CLKSOURCE_CLKP)
34005e48:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005e4c:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
34005e50:	4b29      	ldr	r3, [pc, #164]	@ (34005ef8 <HAL_RCCEx_PeriphCLKConfig+0x10f4>)
34005e52:	429a      	cmp	r2, r3
34005e54:	d101      	bne.n	34005e5a <HAL_RCCEx_PeriphCLKConfig+0x1056>
    {
      LL_RCC_CLKP_Enable();
34005e56:	f7fe ffb3 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM1 clock*/
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
34005e5a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005e5e:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
34005e62:	4618      	mov	r0, r3
34005e64:	f7fd fe9e 	bl	34003ba4 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM2 configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
34005e68:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005e6c:	e9d3 2300 	ldrd	r2, r3, [r3]
34005e70:	f402 2300 	and.w	r3, r2, #524288	@ 0x80000
34005e74:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
34005e78:	2300      	movs	r3, #0
34005e7a:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
34005e7e:	e9d7 013e 	ldrd	r0, r1, [r7, #248]	@ 0xf8
34005e82:	4603      	mov	r3, r0
34005e84:	460a      	mov	r2, r1
34005e86:	4313      	orrs	r3, r2
34005e88:	d04a      	beq.n	34005f20 <HAL_RCCEx_PeriphCLKConfig+0x111c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM2CLKSOURCE(PeriphClkInit->Lptim2ClockSelection));

    if (PeriphClkInit->Lptim2ClockSelection == RCC_LPTIM2CLKSOURCE_IC15)
34005e8a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005e8e:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
34005e92:	4b1a      	ldr	r3, [pc, #104]	@ (34005efc <HAL_RCCEx_PeriphCLKConfig+0x10f8>)
34005e94:	429a      	cmp	r2, r3
34005e96:	d133      	bne.n	34005f00 <HAL_RCCEx_PeriphCLKConfig+0x10fc>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34005e98:	4b0d      	ldr	r3, [pc, #52]	@ (34005ed0 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34005e9a:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34005e9e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34005ea2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34005ea6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005eaa:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34005eac:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005eb0:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34005eb2:	3b01      	subs	r3, #1
34005eb4:	041b      	lsls	r3, r3, #16
34005eb6:	4313      	orrs	r3, r2
34005eb8:	4a05      	ldr	r2, [pc, #20]	@ (34005ed0 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34005eba:	430b      	orrs	r3, r1
34005ebc:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34005ec0:	f7fe fdfe 	bl	34004ac0 <LL_RCC_IC15_Enable>
34005ec4:	e025      	b.n	34005f12 <HAL_RCCEx_PeriphCLKConfig+0x110e>
34005ec6:	bf00      	nop
34005ec8:	0701080c 	.word	0x0701080c
34005ecc:	07020c0c 	.word	0x07020c0c
34005ed0:	56028000 	.word	0x56028000
34005ed4:	07030c0c 	.word	0x07030c0c
34005ed8:	07010c0c 	.word	0x07010c0c
34005edc:	0702100c 	.word	0x0702100c
34005ee0:	0703100c 	.word	0x0703100c
34005ee4:	0701100c 	.word	0x0701100c
34005ee8:	0702140c 	.word	0x0702140c
34005eec:	0703140c 	.word	0x0703140c
34005ef0:	0701140c 	.word	0x0701140c
34005ef4:	0702082c 	.word	0x0702082c
34005ef8:	0701082c 	.word	0x0701082c
34005efc:	07020c2c 	.word	0x07020c2c
    }
    else if (PeriphClkInit->Lptim2ClockSelection == RCC_LPTIM2CLKSOURCE_CLKP)
34005f00:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005f04:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
34005f08:	4bca      	ldr	r3, [pc, #808]	@ (34006234 <HAL_RCCEx_PeriphCLKConfig+0x1430>)
34005f0a:	429a      	cmp	r2, r3
34005f0c:	d101      	bne.n	34005f12 <HAL_RCCEx_PeriphCLKConfig+0x110e>
    {
      LL_RCC_CLKP_Enable();
34005f0e:	f7fe ff57 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM2 clock*/
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
34005f12:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005f16:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
34005f1a:	4618      	mov	r0, r3
34005f1c:	f7fd fe42 	bl	34003ba4 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM3 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM3) == RCC_PERIPHCLK_LPTIM3)
34005f20:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005f24:	e9d3 2300 	ldrd	r2, r3, [r3]
34005f28:	f402 1380 	and.w	r3, r2, #1048576	@ 0x100000
34005f2c:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
34005f30:	2300      	movs	r3, #0
34005f32:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
34005f36:	e9d7 013c 	ldrd	r0, r1, [r7, #240]	@ 0xf0
34005f3a:	4603      	mov	r3, r0
34005f3c:	460a      	mov	r2, r1
34005f3e:	4313      	orrs	r3, r2
34005f40:	d02d      	beq.n	34005f9e <HAL_RCCEx_PeriphCLKConfig+0x119a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM3CLKSOURCE(PeriphClkInit->Lptim3ClockSelection));

    if (PeriphClkInit->Lptim3ClockSelection == RCC_LPTIM3CLKSOURCE_IC15)
34005f42:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005f46:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
34005f4a:	4bbb      	ldr	r3, [pc, #748]	@ (34006238 <HAL_RCCEx_PeriphCLKConfig+0x1434>)
34005f4c:	429a      	cmp	r2, r3
34005f4e:	d116      	bne.n	34005f7e <HAL_RCCEx_PeriphCLKConfig+0x117a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34005f50:	4bba      	ldr	r3, [pc, #744]	@ (3400623c <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34005f52:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34005f56:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34005f5a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34005f5e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005f62:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34005f64:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005f68:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34005f6a:	3b01      	subs	r3, #1
34005f6c:	041b      	lsls	r3, r3, #16
34005f6e:	4313      	orrs	r3, r2
34005f70:	4ab2      	ldr	r2, [pc, #712]	@ (3400623c <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34005f72:	430b      	orrs	r3, r1
34005f74:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34005f78:	f7fe fda2 	bl	34004ac0 <LL_RCC_IC15_Enable>
34005f7c:	e008      	b.n	34005f90 <HAL_RCCEx_PeriphCLKConfig+0x118c>
    }
    else if (PeriphClkInit->Lptim3ClockSelection == RCC_LPTIM3CLKSOURCE_CLKP)
34005f7e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005f82:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
34005f86:	4bae      	ldr	r3, [pc, #696]	@ (34006240 <HAL_RCCEx_PeriphCLKConfig+0x143c>)
34005f88:	429a      	cmp	r2, r3
34005f8a:	d101      	bne.n	34005f90 <HAL_RCCEx_PeriphCLKConfig+0x118c>
    {
      LL_RCC_CLKP_Enable();
34005f8c:	f7fe ff18 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM3 clock */
    __HAL_RCC_LPTIM3_CONFIG(PeriphClkInit->Lptim3ClockSelection);
34005f90:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005f94:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
34005f98:	4618      	mov	r0, r3
34005f9a:	f7fd fe03 	bl	34003ba4 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM4 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM4) == RCC_PERIPHCLK_LPTIM4)
34005f9e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005fa2:	e9d3 2300 	ldrd	r2, r3, [r3]
34005fa6:	f402 1300 	and.w	r3, r2, #2097152	@ 0x200000
34005faa:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
34005fae:	2300      	movs	r3, #0
34005fb0:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
34005fb4:	e9d7 013a 	ldrd	r0, r1, [r7, #232]	@ 0xe8
34005fb8:	4603      	mov	r3, r0
34005fba:	460a      	mov	r2, r1
34005fbc:	4313      	orrs	r3, r2
34005fbe:	d02d      	beq.n	3400601c <HAL_RCCEx_PeriphCLKConfig+0x1218>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM4CLKSOURCE(PeriphClkInit->Lptim4ClockSelection));

    if (PeriphClkInit->Lptim4ClockSelection == RCC_LPTIM4CLKSOURCE_IC15)
34005fc0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005fc4:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
34005fc8:	4b9e      	ldr	r3, [pc, #632]	@ (34006244 <HAL_RCCEx_PeriphCLKConfig+0x1440>)
34005fca:	429a      	cmp	r2, r3
34005fcc:	d116      	bne.n	34005ffc <HAL_RCCEx_PeriphCLKConfig+0x11f8>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34005fce:	4b9b      	ldr	r3, [pc, #620]	@ (3400623c <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34005fd0:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34005fd4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34005fd8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34005fdc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005fe0:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34005fe2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34005fe6:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34005fe8:	3b01      	subs	r3, #1
34005fea:	041b      	lsls	r3, r3, #16
34005fec:	4313      	orrs	r3, r2
34005fee:	4a93      	ldr	r2, [pc, #588]	@ (3400623c <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34005ff0:	430b      	orrs	r3, r1
34005ff2:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34005ff6:	f7fe fd63 	bl	34004ac0 <LL_RCC_IC15_Enable>
34005ffa:	e008      	b.n	3400600e <HAL_RCCEx_PeriphCLKConfig+0x120a>
    }
    else if (PeriphClkInit->Lptim4ClockSelection == RCC_LPTIM4CLKSOURCE_CLKP)
34005ffc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006000:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
34006004:	4b90      	ldr	r3, [pc, #576]	@ (34006248 <HAL_RCCEx_PeriphCLKConfig+0x1444>)
34006006:	429a      	cmp	r2, r3
34006008:	d101      	bne.n	3400600e <HAL_RCCEx_PeriphCLKConfig+0x120a>
    {
      LL_RCC_CLKP_Enable();
3400600a:	f7fe fed9 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM4 clock */
    __HAL_RCC_LPTIM4_CONFIG(PeriphClkInit->Lptim4ClockSelection);
3400600e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006012:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
34006016:	4618      	mov	r0, r3
34006018:	f7fd fdc4 	bl	34003ba4 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM5 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM5) == RCC_PERIPHCLK_LPTIM5)
3400601c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006020:	e9d3 2300 	ldrd	r2, r3, [r3]
34006024:	f402 0380 	and.w	r3, r2, #4194304	@ 0x400000
34006028:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
3400602c:	2300      	movs	r3, #0
3400602e:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
34006032:	e9d7 0138 	ldrd	r0, r1, [r7, #224]	@ 0xe0
34006036:	4603      	mov	r3, r0
34006038:	460a      	mov	r2, r1
3400603a:	4313      	orrs	r3, r2
3400603c:	d02d      	beq.n	3400609a <HAL_RCCEx_PeriphCLKConfig+0x1296>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM5CLKSOURCE(PeriphClkInit->Lptim5ClockSelection));

    if (PeriphClkInit->Lptim5ClockSelection == RCC_LPTIM5CLKSOURCE_IC15)
3400603e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006042:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
34006046:	4b81      	ldr	r3, [pc, #516]	@ (3400624c <HAL_RCCEx_PeriphCLKConfig+0x1448>)
34006048:	429a      	cmp	r2, r3
3400604a:	d116      	bne.n	3400607a <HAL_RCCEx_PeriphCLKConfig+0x1276>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400604c:	4b7b      	ldr	r3, [pc, #492]	@ (3400623c <HAL_RCCEx_PeriphCLKConfig+0x1438>)
3400604e:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34006052:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006056:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400605a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400605e:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34006060:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006064:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34006066:	3b01      	subs	r3, #1
34006068:	041b      	lsls	r3, r3, #16
3400606a:	4313      	orrs	r3, r2
3400606c:	4a73      	ldr	r2, [pc, #460]	@ (3400623c <HAL_RCCEx_PeriphCLKConfig+0x1438>)
3400606e:	430b      	orrs	r3, r1
34006070:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34006074:	f7fe fd24 	bl	34004ac0 <LL_RCC_IC15_Enable>
34006078:	e008      	b.n	3400608c <HAL_RCCEx_PeriphCLKConfig+0x1288>
    }
    else if (PeriphClkInit->Lptim5ClockSelection == RCC_LPTIM5CLKSOURCE_CLKP)
3400607a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400607e:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
34006082:	4b73      	ldr	r3, [pc, #460]	@ (34006250 <HAL_RCCEx_PeriphCLKConfig+0x144c>)
34006084:	429a      	cmp	r2, r3
34006086:	d101      	bne.n	3400608c <HAL_RCCEx_PeriphCLKConfig+0x1288>
    {
      LL_RCC_CLKP_Enable();
34006088:	f7fe fe9a 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM5 clock */
    __HAL_RCC_LPTIM5_CONFIG(PeriphClkInit->Lptim5ClockSelection);
3400608c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006090:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
34006094:	4618      	mov	r0, r3
34006096:	f7fd fd85 	bl	34003ba4 <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------------- LPUART1 Configuration -------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
3400609a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400609e:	e9d3 2300 	ldrd	r2, r3, [r3]
340060a2:	f402 0300 	and.w	r3, r2, #8388608	@ 0x800000
340060a6:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
340060aa:	2300      	movs	r3, #0
340060ac:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
340060b0:	e9d7 0136 	ldrd	r0, r1, [r7, #216]	@ 0xd8
340060b4:	4603      	mov	r3, r0
340060b6:	460a      	mov	r2, r1
340060b8:	4313      	orrs	r3, r2
340060ba:	d04b      	beq.n	34006154 <HAL_RCCEx_PeriphCLKConfig+0x1350>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_IC9)
340060bc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340060c0:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
340060c4:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
340060c8:	d116      	bne.n	340060f8 <HAL_RCCEx_PeriphCLKConfig+0x12f4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
340060ca:	4b5c      	ldr	r3, [pc, #368]	@ (3400623c <HAL_RCCEx_PeriphCLKConfig+0x1438>)
340060cc:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
340060d0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340060d4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340060d8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340060dc:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
340060de:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340060e2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
340060e4:	3b01      	subs	r3, #1
340060e6:	041b      	lsls	r3, r3, #16
340060e8:	4313      	orrs	r3, r2
340060ea:	4a54      	ldr	r2, [pc, #336]	@ (3400623c <HAL_RCCEx_PeriphCLKConfig+0x1438>)
340060ec:	430b      	orrs	r3, r1
340060ee:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
340060f2:	f7fe fba5 	bl	34004840 <LL_RCC_IC9_Enable>
340060f6:	e026      	b.n	34006146 <HAL_RCCEx_PeriphCLKConfig+0x1342>
    }
    else if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_IC14)
340060f8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340060fc:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
34006100:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
34006104:	d116      	bne.n	34006134 <HAL_RCCEx_PeriphCLKConfig+0x1330>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34006106:	4b4d      	ldr	r3, [pc, #308]	@ (3400623c <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34006108:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400610c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006110:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006114:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006118:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3400611a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400611e:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34006120:	3b01      	subs	r3, #1
34006122:	041b      	lsls	r3, r3, #16
34006124:	4313      	orrs	r3, r2
34006126:	4a45      	ldr	r2, [pc, #276]	@ (3400623c <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34006128:	430b      	orrs	r3, r1
3400612a:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3400612e:	f7fe fc87 	bl	34004a40 <LL_RCC_IC14_Enable>
34006132:	e008      	b.n	34006146 <HAL_RCCEx_PeriphCLKConfig+0x1342>
    }
    else if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_CLKP)
34006134:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006138:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
3400613c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34006140:	d101      	bne.n	34006146 <HAL_RCCEx_PeriphCLKConfig+0x1342>
    {
      LL_RCC_CLKP_Enable();
34006142:	f7fe fe3d 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPUART1 clock */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
34006146:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400614a:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
3400614e:	4618      	mov	r0, r3
34006150:	f7fd fd34 	bl	34003bbc <LL_RCC_SetLPUARTClockSource>
  }

  /*-------------------------- LTDC Configuration ----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
34006154:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006158:	e9d3 2300 	ldrd	r2, r3, [r3]
3400615c:	f002 7380 	and.w	r3, r2, #16777216	@ 0x1000000
34006160:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
34006164:	2300      	movs	r3, #0
34006166:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
3400616a:	e9d7 0134 	ldrd	r0, r1, [r7, #208]	@ 0xd0
3400616e:	4603      	mov	r3, r0
34006170:	460a      	mov	r2, r1
34006172:	4313      	orrs	r3, r2
34006174:	d02f      	beq.n	340061d6 <HAL_RCCEx_PeriphCLKConfig+0x13d2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LTDCCLKSOURCE(PeriphClkInit->LtdcClockSelection));

    if (PeriphClkInit->LtdcClockSelection == RCC_LTDCCLKSOURCE_IC16)
34006176:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400617a:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
3400617e:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34006182:	d118      	bne.n	340061b6 <HAL_RCCEx_PeriphCLKConfig+0x13b2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC16].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC16].ClockDivider));

      /* Set IC16 configuration */
      MODIFY_REG(RCC->IC16CFGR, RCC_IC16CFGR_IC16SEL | RCC_IC16CFGR_IC16INT,
34006184:	4b2d      	ldr	r3, [pc, #180]	@ (3400623c <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34006186:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
3400618a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400618e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006192:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006196:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
3400619a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400619e:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
340061a2:	3b01      	subs	r3, #1
340061a4:	041b      	lsls	r3, r3, #16
340061a6:	4313      	orrs	r3, r2
340061a8:	4a24      	ldr	r2, [pc, #144]	@ (3400623c <HAL_RCCEx_PeriphCLKConfig+0x1438>)
340061aa:	430b      	orrs	r3, r1
340061ac:	f8c2 3100 	str.w	r3, [r2, #256]	@ 0x100
                 PeriphClkInit->ICSelection[RCC_IC16].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC16].ClockDivider - 1U) << RCC_IC16CFGR_IC16INT_Pos));

      LL_RCC_IC16_Enable();
340061b0:	f7fe fcc6 	bl	34004b40 <LL_RCC_IC16_Enable>
340061b4:	e008      	b.n	340061c8 <HAL_RCCEx_PeriphCLKConfig+0x13c4>
    }
    else if (PeriphClkInit->LtdcClockSelection == RCC_LTDCCLKSOURCE_CLKP)
340061b6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340061ba:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
340061be:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
340061c2:	d101      	bne.n	340061c8 <HAL_RCCEx_PeriphCLKConfig+0x13c4>
    {
      LL_RCC_CLKP_Enable();
340061c4:	f7fe fdfc 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LTDC clock */
    __HAL_RCC_LTDC_CONFIG(PeriphClkInit->LtdcClockSelection);
340061c8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340061cc:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
340061d0:	4618      	mov	r0, r3
340061d2:	f7fd fd09 	bl	34003be8 <LL_RCC_SetLTDCClockSource>
  }

  /*---------------------------- MDF1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_MDF1) == RCC_PERIPHCLK_MDF1)
340061d6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340061da:	e9d3 2300 	ldrd	r2, r3, [r3]
340061de:	f002 7300 	and.w	r3, r2, #33554432	@ 0x2000000
340061e2:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
340061e6:	2300      	movs	r3, #0
340061e8:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
340061ec:	e9d7 0132 	ldrd	r0, r1, [r7, #200]	@ 0xc8
340061f0:	4603      	mov	r3, r0
340061f2:	460a      	mov	r2, r1
340061f4:	4313      	orrs	r3, r2
340061f6:	d05b      	beq.n	340062b0 <HAL_RCCEx_PeriphCLKConfig+0x14ac>
  {
    /* Check the parameters */
    assert_param(IS_RCC_MDF1CLKSOURCE(PeriphClkInit->Mdf1ClockSelection));

    if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_IC7)
340061f8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340061fc:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
34006200:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34006204:	d126      	bne.n	34006254 <HAL_RCCEx_PeriphCLKConfig+0x1450>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34006206:	4b0d      	ldr	r3, [pc, #52]	@ (3400623c <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34006208:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3400620c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006210:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006214:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006218:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
3400621a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400621e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34006220:	3b01      	subs	r3, #1
34006222:	041b      	lsls	r3, r3, #16
34006224:	4313      	orrs	r3, r2
34006226:	4a05      	ldr	r2, [pc, #20]	@ (3400623c <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34006228:	430b      	orrs	r3, r1
3400622a:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
3400622e:	f7fe fa87 	bl	34004740 <LL_RCC_IC7_Enable>
34006232:	e036      	b.n	340062a2 <HAL_RCCEx_PeriphCLKConfig+0x149e>
34006234:	07010c2c 	.word	0x07010c2c
34006238:	0702102c 	.word	0x0702102c
3400623c:	56028000 	.word	0x56028000
34006240:	0701102c 	.word	0x0701102c
34006244:	0702142c 	.word	0x0702142c
34006248:	0701142c 	.word	0x0701142c
3400624c:	0702182c 	.word	0x0702182c
34006250:	0701182c 	.word	0x0701182c
    }
    else if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_IC8)
34006254:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006258:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
3400625c:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34006260:	d116      	bne.n	34006290 <HAL_RCCEx_PeriphCLKConfig+0x148c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34006262:	4bb5      	ldr	r3, [pc, #724]	@ (34006538 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34006264:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34006268:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400626c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006270:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006274:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34006276:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400627a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400627c:	3b01      	subs	r3, #1
3400627e:	041b      	lsls	r3, r3, #16
34006280:	4313      	orrs	r3, r2
34006282:	4aad      	ldr	r2, [pc, #692]	@ (34006538 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34006284:	430b      	orrs	r3, r1
34006286:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3400628a:	f7fe fa99 	bl	340047c0 <LL_RCC_IC8_Enable>
3400628e:	e008      	b.n	340062a2 <HAL_RCCEx_PeriphCLKConfig+0x149e>
    }
    else if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_CLKP)
34006290:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006294:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
34006298:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
3400629c:	d101      	bne.n	340062a2 <HAL_RCCEx_PeriphCLKConfig+0x149e>
    {
      LL_RCC_CLKP_Enable();
3400629e:	f7fe fd8f 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of MDF1 clock*/
    __HAL_RCC_MDF1_CONFIG(PeriphClkInit->Mdf1ClockSelection);
340062a2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340062a6:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
340062aa:	4618      	mov	r0, r3
340062ac:	f7fd fcb2 	bl	34003c14 <LL_RCC_SetMDFClockSource>
  }

  /*---------------------------- PSSI configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PSSI) == RCC_PERIPHCLK_PSSI)
340062b0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340062b4:	e9d3 2300 	ldrd	r2, r3, [r3]
340062b8:	f002 6380 	and.w	r3, r2, #67108864	@ 0x4000000
340062bc:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
340062c0:	2300      	movs	r3, #0
340062c2:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
340062c6:	e9d7 0130 	ldrd	r0, r1, [r7, #192]	@ 0xc0
340062ca:	4603      	mov	r3, r0
340062cc:	460a      	mov	r2, r1
340062ce:	4313      	orrs	r3, r2
340062d0:	d02d      	beq.n	3400632e <HAL_RCCEx_PeriphCLKConfig+0x152a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_PSSICLKSOURCE(PeriphClkInit->PssiClockSelection));

    if (PeriphClkInit->PssiClockSelection == RCC_PSSICLKSOURCE_IC20)
340062d2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340062d6:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
340062da:	2b20      	cmp	r3, #32
340062dc:	d118      	bne.n	34006310 <HAL_RCCEx_PeriphCLKConfig+0x150c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC20].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC20].ClockDivider));

      /* Set IC20 configuration */
      MODIFY_REG(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL | RCC_IC20CFGR_IC20INT,
340062de:	4b96      	ldr	r3, [pc, #600]	@ (34006538 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
340062e0:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
340062e4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340062e8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340062ec:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340062f0:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
340062f4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340062f8:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
340062fc:	3b01      	subs	r3, #1
340062fe:	041b      	lsls	r3, r3, #16
34006300:	4313      	orrs	r3, r2
34006302:	4a8d      	ldr	r2, [pc, #564]	@ (34006538 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34006304:	430b      	orrs	r3, r1
34006306:	f8c2 3110 	str.w	r3, [r2, #272]	@ 0x110
                 PeriphClkInit->ICSelection[RCC_IC20].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC20].ClockDivider - 1U) << RCC_IC20CFGR_IC20INT_Pos));

      LL_RCC_IC20_Enable();
3400630a:	f7fe fd19 	bl	34004d40 <LL_RCC_IC20_Enable>
3400630e:	e007      	b.n	34006320 <HAL_RCCEx_PeriphCLKConfig+0x151c>
    }
    else if (PeriphClkInit->PssiClockSelection == RCC_PSSICLKSOURCE_CLKP)
34006310:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006314:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
34006318:	2b10      	cmp	r3, #16
3400631a:	d101      	bne.n	34006320 <HAL_RCCEx_PeriphCLKConfig+0x151c>
    {
      LL_RCC_CLKP_Enable();
3400631c:	f7fe fd50 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of PSSI clock*/
    __HAL_RCC_PSSI_CONFIG(PeriphClkInit->PssiClockSelection);
34006320:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006324:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
34006328:	4618      	mov	r0, r3
3400632a:	f7fd fc9f 	bl	34003c6c <LL_RCC_SetPSSIClockSource>
  }

  /*---------------------------- SAI1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
3400632e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006332:	e9d3 2300 	ldrd	r2, r3, [r3]
34006336:	f002 5380 	and.w	r3, r2, #268435456	@ 0x10000000
3400633a:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
3400633e:	2300      	movs	r3, #0
34006340:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
34006344:	e9d7 012e 	ldrd	r0, r1, [r7, #184]	@ 0xb8
34006348:	4603      	mov	r3, r0
3400634a:	460a      	mov	r2, r1
3400634c:	4313      	orrs	r3, r2
3400634e:	d04b      	beq.n	340063e8 <HAL_RCCEx_PeriphCLKConfig+0x15e4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_IC7)
34006350:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006354:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
34006358:	4b78      	ldr	r3, [pc, #480]	@ (3400653c <HAL_RCCEx_PeriphCLKConfig+0x1738>)
3400635a:	429a      	cmp	r2, r3
3400635c:	d116      	bne.n	3400638c <HAL_RCCEx_PeriphCLKConfig+0x1588>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3400635e:	4b76      	ldr	r3, [pc, #472]	@ (34006538 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34006360:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34006364:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006368:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400636c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006370:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34006372:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006376:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34006378:	3b01      	subs	r3, #1
3400637a:	041b      	lsls	r3, r3, #16
3400637c:	4313      	orrs	r3, r2
3400637e:	4a6e      	ldr	r2, [pc, #440]	@ (34006538 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34006380:	430b      	orrs	r3, r1
34006382:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34006386:	f7fe f9db 	bl	34004740 <LL_RCC_IC7_Enable>
3400638a:	e026      	b.n	340063da <HAL_RCCEx_PeriphCLKConfig+0x15d6>
    }
    else if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_IC8)
3400638c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006390:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
34006394:	4b6a      	ldr	r3, [pc, #424]	@ (34006540 <HAL_RCCEx_PeriphCLKConfig+0x173c>)
34006396:	429a      	cmp	r2, r3
34006398:	d116      	bne.n	340063c8 <HAL_RCCEx_PeriphCLKConfig+0x15c4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400639a:	4b67      	ldr	r3, [pc, #412]	@ (34006538 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
3400639c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
340063a0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340063a4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340063a8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340063ac:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
340063ae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340063b2:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340063b4:	3b01      	subs	r3, #1
340063b6:	041b      	lsls	r3, r3, #16
340063b8:	4313      	orrs	r3, r2
340063ba:	4a5f      	ldr	r2, [pc, #380]	@ (34006538 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
340063bc:	430b      	orrs	r3, r1
340063be:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
340063c2:	f7fe f9fd 	bl	340047c0 <LL_RCC_IC8_Enable>
340063c6:	e008      	b.n	340063da <HAL_RCCEx_PeriphCLKConfig+0x15d6>
    }
    else if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_CLKP)
340063c8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340063cc:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
340063d0:	4b5c      	ldr	r3, [pc, #368]	@ (34006544 <HAL_RCCEx_PeriphCLKConfig+0x1740>)
340063d2:	429a      	cmp	r2, r3
340063d4:	d101      	bne.n	340063da <HAL_RCCEx_PeriphCLKConfig+0x15d6>
    {
      LL_RCC_CLKP_Enable();
340063d6:	f7fe fcf3 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SAI1 clock*/
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
340063da:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340063de:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
340063e2:	4618      	mov	r0, r3
340063e4:	f7fd fc58 	bl	34003c98 <LL_RCC_SetSAIClockSource>
  }

  /*---------------------------- SAI2 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2)
340063e8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340063ec:	e9d3 2300 	ldrd	r2, r3, [r3]
340063f0:	f002 5300 	and.w	r3, r2, #536870912	@ 0x20000000
340063f4:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
340063f8:	2300      	movs	r3, #0
340063fa:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
340063fe:	e9d7 012c 	ldrd	r0, r1, [r7, #176]	@ 0xb0
34006402:	4603      	mov	r3, r0
34006404:	460a      	mov	r2, r1
34006406:	4313      	orrs	r3, r2
34006408:	d04b      	beq.n	340064a2 <HAL_RCCEx_PeriphCLKConfig+0x169e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));

    if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_IC7)
3400640a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400640e:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
34006412:	4b4d      	ldr	r3, [pc, #308]	@ (34006548 <HAL_RCCEx_PeriphCLKConfig+0x1744>)
34006414:	429a      	cmp	r2, r3
34006416:	d116      	bne.n	34006446 <HAL_RCCEx_PeriphCLKConfig+0x1642>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34006418:	4b47      	ldr	r3, [pc, #284]	@ (34006538 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
3400641a:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3400641e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006422:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006426:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400642a:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
3400642c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006430:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34006432:	3b01      	subs	r3, #1
34006434:	041b      	lsls	r3, r3, #16
34006436:	4313      	orrs	r3, r2
34006438:	4a3f      	ldr	r2, [pc, #252]	@ (34006538 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
3400643a:	430b      	orrs	r3, r1
3400643c:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34006440:	f7fe f97e 	bl	34004740 <LL_RCC_IC7_Enable>
34006444:	e026      	b.n	34006494 <HAL_RCCEx_PeriphCLKConfig+0x1690>
    }
    else if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_IC8)
34006446:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400644a:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
3400644e:	4b3f      	ldr	r3, [pc, #252]	@ (3400654c <HAL_RCCEx_PeriphCLKConfig+0x1748>)
34006450:	429a      	cmp	r2, r3
34006452:	d116      	bne.n	34006482 <HAL_RCCEx_PeriphCLKConfig+0x167e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34006454:	4b38      	ldr	r3, [pc, #224]	@ (34006538 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34006456:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3400645a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400645e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006462:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006466:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34006468:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400646c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400646e:	3b01      	subs	r3, #1
34006470:	041b      	lsls	r3, r3, #16
34006472:	4313      	orrs	r3, r2
34006474:	4a30      	ldr	r2, [pc, #192]	@ (34006538 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34006476:	430b      	orrs	r3, r1
34006478:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3400647c:	f7fe f9a0 	bl	340047c0 <LL_RCC_IC8_Enable>
34006480:	e008      	b.n	34006494 <HAL_RCCEx_PeriphCLKConfig+0x1690>
    }
    else if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_CLKP)
34006482:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006486:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
3400648a:	4b31      	ldr	r3, [pc, #196]	@ (34006550 <HAL_RCCEx_PeriphCLKConfig+0x174c>)
3400648c:	429a      	cmp	r2, r3
3400648e:	d101      	bne.n	34006494 <HAL_RCCEx_PeriphCLKConfig+0x1690>
    {
      LL_RCC_CLKP_Enable();
34006490:	f7fe fc96 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SAI2 clock*/
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
34006494:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006498:	f8d3 3128 	ldr.w	r3, [r3, #296]	@ 0x128
3400649c:	4618      	mov	r0, r3
3400649e:	f7fd fbfb 	bl	34003c98 <LL_RCC_SetSAIClockSource>
  }

  /*---------------------------- SPDIFRX1 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPDIFRX1) == RCC_PERIPHCLK_SPDIFRX1)
340064a2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340064a6:	e9d3 2300 	ldrd	r2, r3, [r3]
340064aa:	2100      	movs	r1, #0
340064ac:	f8c7 10a8 	str.w	r1, [r7, #168]	@ 0xa8
340064b0:	f003 0301 	and.w	r3, r3, #1
340064b4:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
340064b8:	e9d7 012a 	ldrd	r0, r1, [r7, #168]	@ 0xa8
340064bc:	4603      	mov	r3, r0
340064be:	460a      	mov	r2, r1
340064c0:	4313      	orrs	r3, r2
340064c2:	d056      	beq.n	34006572 <HAL_RCCEx_PeriphCLKConfig+0x176e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPDIFRX1CLKSOURCE(PeriphClkInit->Spdifrx1ClockSelection));

    if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_IC7)
340064c4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340064c8:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
340064cc:	2b02      	cmp	r3, #2
340064ce:	d116      	bne.n	340064fe <HAL_RCCEx_PeriphCLKConfig+0x16fa>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
340064d0:	4b19      	ldr	r3, [pc, #100]	@ (34006538 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
340064d2:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
340064d6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340064da:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340064de:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340064e2:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
340064e4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340064e8:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
340064ea:	3b01      	subs	r3, #1
340064ec:	041b      	lsls	r3, r3, #16
340064ee:	4313      	orrs	r3, r2
340064f0:	4a11      	ldr	r2, [pc, #68]	@ (34006538 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
340064f2:	430b      	orrs	r3, r1
340064f4:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
340064f8:	f7fe f922 	bl	34004740 <LL_RCC_IC7_Enable>
340064fc:	e032      	b.n	34006564 <HAL_RCCEx_PeriphCLKConfig+0x1760>
    }
    else if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_IC8)
340064fe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006502:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34006506:	2b03      	cmp	r3, #3
34006508:	d124      	bne.n	34006554 <HAL_RCCEx_PeriphCLKConfig+0x1750>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400650a:	4b0b      	ldr	r3, [pc, #44]	@ (34006538 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
3400650c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34006510:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006514:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006518:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400651c:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3400651e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006522:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34006524:	3b01      	subs	r3, #1
34006526:	041b      	lsls	r3, r3, #16
34006528:	4313      	orrs	r3, r2
3400652a:	4a03      	ldr	r2, [pc, #12]	@ (34006538 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
3400652c:	430b      	orrs	r3, r1
3400652e:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34006532:	f7fe f945 	bl	340047c0 <LL_RCC_IC8_Enable>
34006536:	e015      	b.n	34006564 <HAL_RCCEx_PeriphCLKConfig+0x1760>
34006538:	56028000 	.word	0x56028000
3400653c:	07021418 	.word	0x07021418
34006540:	07031418 	.word	0x07031418
34006544:	07011418 	.word	0x07011418
34006548:	07021818 	.word	0x07021818
3400654c:	07031818 	.word	0x07031818
34006550:	07011818 	.word	0x07011818
    }
    else if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_CLKP)
34006554:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006558:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3400655c:	2b01      	cmp	r3, #1
3400655e:	d101      	bne.n	34006564 <HAL_RCCEx_PeriphCLKConfig+0x1760>
    {
      LL_RCC_CLKP_Enable();
34006560:	f7fe fc2e 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPDIFRX1 clock */
    __HAL_RCC_SPDIFRX1_CONFIG(PeriphClkInit->Spdifrx1ClockSelection);
34006564:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006568:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3400656c:	4618      	mov	r0, r3
3400656e:	f7fd fba9 	bl	34003cc4 <LL_RCC_SetSPDIFRXClockSource>
  }

  /*---------------------------- SPI1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI1) == RCC_PERIPHCLK_SPI1)
34006572:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006576:	e9d3 2300 	ldrd	r2, r3, [r3]
3400657a:	2100      	movs	r1, #0
3400657c:	f8c7 10a0 	str.w	r1, [r7, #160]	@ 0xa0
34006580:	f003 0302 	and.w	r3, r3, #2
34006584:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
34006588:	e9d7 0128 	ldrd	r0, r1, [r7, #160]	@ 0xa0
3400658c:	4603      	mov	r3, r0
3400658e:	460a      	mov	r2, r1
34006590:	4313      	orrs	r3, r2
34006592:	d04b      	beq.n	3400662c <HAL_RCCEx_PeriphCLKConfig+0x1828>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI1CLKSOURCE(PeriphClkInit->Spi1ClockSelection));

    if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_IC8)
34006594:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006598:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
3400659c:	4bc6      	ldr	r3, [pc, #792]	@ (340068b8 <HAL_RCCEx_PeriphCLKConfig+0x1ab4>)
3400659e:	429a      	cmp	r2, r3
340065a0:	d116      	bne.n	340065d0 <HAL_RCCEx_PeriphCLKConfig+0x17cc>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
340065a2:	4bc6      	ldr	r3, [pc, #792]	@ (340068bc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
340065a4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
340065a8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340065ac:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340065b0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340065b4:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
340065b6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340065ba:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340065bc:	3b01      	subs	r3, #1
340065be:	041b      	lsls	r3, r3, #16
340065c0:	4313      	orrs	r3, r2
340065c2:	4abe      	ldr	r2, [pc, #760]	@ (340068bc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
340065c4:	430b      	orrs	r3, r1
340065c6:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
340065ca:	f7fe f8f9 	bl	340047c0 <LL_RCC_IC8_Enable>
340065ce:	e026      	b.n	3400661e <HAL_RCCEx_PeriphCLKConfig+0x181a>
    }
    else if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_IC9)
340065d0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340065d4:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
340065d8:	4bb9      	ldr	r3, [pc, #740]	@ (340068c0 <HAL_RCCEx_PeriphCLKConfig+0x1abc>)
340065da:	429a      	cmp	r2, r3
340065dc:	d116      	bne.n	3400660c <HAL_RCCEx_PeriphCLKConfig+0x1808>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
340065de:	4bb7      	ldr	r3, [pc, #732]	@ (340068bc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
340065e0:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
340065e4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340065e8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340065ec:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340065f0:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
340065f2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340065f6:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
340065f8:	3b01      	subs	r3, #1
340065fa:	041b      	lsls	r3, r3, #16
340065fc:	4313      	orrs	r3, r2
340065fe:	4aaf      	ldr	r2, [pc, #700]	@ (340068bc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34006600:	430b      	orrs	r3, r1
34006602:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34006606:	f7fe f91b 	bl	34004840 <LL_RCC_IC9_Enable>
3400660a:	e008      	b.n	3400661e <HAL_RCCEx_PeriphCLKConfig+0x181a>
    }
    else if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_CLKP)
3400660c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006610:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
34006614:	4bab      	ldr	r3, [pc, #684]	@ (340068c4 <HAL_RCCEx_PeriphCLKConfig+0x1ac0>)
34006616:	429a      	cmp	r2, r3
34006618:	d101      	bne.n	3400661e <HAL_RCCEx_PeriphCLKConfig+0x181a>
    {
      LL_RCC_CLKP_Enable();
3400661a:	f7fe fbd1 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI1 clock*/
    __HAL_RCC_SPI1_CONFIG(PeriphClkInit->Spi1ClockSelection);
3400661e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006622:	f8d3 3134 	ldr.w	r3, [r3, #308]	@ 0x134
34006626:	4618      	mov	r0, r3
34006628:	f7fd fb62 	bl	34003cf0 <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI2 configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI2) == RCC_PERIPHCLK_SPI2)
3400662c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006630:	e9d3 2300 	ldrd	r2, r3, [r3]
34006634:	2100      	movs	r1, #0
34006636:	f8c7 1098 	str.w	r1, [r7, #152]	@ 0x98
3400663a:	f003 0304 	and.w	r3, r3, #4
3400663e:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
34006642:	e9d7 0126 	ldrd	r0, r1, [r7, #152]	@ 0x98
34006646:	4603      	mov	r3, r0
34006648:	460a      	mov	r2, r1
3400664a:	4313      	orrs	r3, r2
3400664c:	d04b      	beq.n	340066e6 <HAL_RCCEx_PeriphCLKConfig+0x18e2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI2CLKSOURCE(PeriphClkInit->Spi2ClockSelection));

    if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_IC8)
3400664e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006652:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
34006656:	4b9c      	ldr	r3, [pc, #624]	@ (340068c8 <HAL_RCCEx_PeriphCLKConfig+0x1ac4>)
34006658:	429a      	cmp	r2, r3
3400665a:	d116      	bne.n	3400668a <HAL_RCCEx_PeriphCLKConfig+0x1886>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400665c:	4b97      	ldr	r3, [pc, #604]	@ (340068bc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3400665e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34006662:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006666:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400666a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400666e:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34006670:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006674:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34006676:	3b01      	subs	r3, #1
34006678:	041b      	lsls	r3, r3, #16
3400667a:	4313      	orrs	r3, r2
3400667c:	4a8f      	ldr	r2, [pc, #572]	@ (340068bc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3400667e:	430b      	orrs	r3, r1
34006680:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34006684:	f7fe f89c 	bl	340047c0 <LL_RCC_IC8_Enable>
34006688:	e026      	b.n	340066d8 <HAL_RCCEx_PeriphCLKConfig+0x18d4>
    }
    else if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_IC9)
3400668a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400668e:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
34006692:	4b8e      	ldr	r3, [pc, #568]	@ (340068cc <HAL_RCCEx_PeriphCLKConfig+0x1ac8>)
34006694:	429a      	cmp	r2, r3
34006696:	d116      	bne.n	340066c6 <HAL_RCCEx_PeriphCLKConfig+0x18c2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34006698:	4b88      	ldr	r3, [pc, #544]	@ (340068bc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3400669a:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400669e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340066a2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340066a6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340066aa:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
340066ac:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340066b0:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
340066b2:	3b01      	subs	r3, #1
340066b4:	041b      	lsls	r3, r3, #16
340066b6:	4313      	orrs	r3, r2
340066b8:	4a80      	ldr	r2, [pc, #512]	@ (340068bc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
340066ba:	430b      	orrs	r3, r1
340066bc:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
340066c0:	f7fe f8be 	bl	34004840 <LL_RCC_IC9_Enable>
340066c4:	e008      	b.n	340066d8 <HAL_RCCEx_PeriphCLKConfig+0x18d4>
    }
    else if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_CLKP)
340066c6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340066ca:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
340066ce:	4b80      	ldr	r3, [pc, #512]	@ (340068d0 <HAL_RCCEx_PeriphCLKConfig+0x1acc>)
340066d0:	429a      	cmp	r2, r3
340066d2:	d101      	bne.n	340066d8 <HAL_RCCEx_PeriphCLKConfig+0x18d4>
    {
      LL_RCC_CLKP_Enable();
340066d4:	f7fe fb74 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI2 clock*/
    __HAL_RCC_SPI2_CONFIG(PeriphClkInit->Spi2ClockSelection);
340066d8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340066dc:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
340066e0:	4618      	mov	r0, r3
340066e2:	f7fd fb05 	bl	34003cf0 <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI3 configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI3) == RCC_PERIPHCLK_SPI3)
340066e6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340066ea:	e9d3 2300 	ldrd	r2, r3, [r3]
340066ee:	2100      	movs	r1, #0
340066f0:	f8c7 1090 	str.w	r1, [r7, #144]	@ 0x90
340066f4:	f003 0308 	and.w	r3, r3, #8
340066f8:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
340066fc:	e9d7 0124 	ldrd	r0, r1, [r7, #144]	@ 0x90
34006700:	4603      	mov	r3, r0
34006702:	460a      	mov	r2, r1
34006704:	4313      	orrs	r3, r2
34006706:	d04b      	beq.n	340067a0 <HAL_RCCEx_PeriphCLKConfig+0x199c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI3CLKSOURCE(PeriphClkInit->Spi3ClockSelection));

    if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_IC8)
34006708:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400670c:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
34006710:	4b70      	ldr	r3, [pc, #448]	@ (340068d4 <HAL_RCCEx_PeriphCLKConfig+0x1ad0>)
34006712:	429a      	cmp	r2, r3
34006714:	d116      	bne.n	34006744 <HAL_RCCEx_PeriphCLKConfig+0x1940>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34006716:	4b69      	ldr	r3, [pc, #420]	@ (340068bc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34006718:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3400671c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006720:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006724:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006728:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3400672a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400672e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34006730:	3b01      	subs	r3, #1
34006732:	041b      	lsls	r3, r3, #16
34006734:	4313      	orrs	r3, r2
34006736:	4a61      	ldr	r2, [pc, #388]	@ (340068bc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34006738:	430b      	orrs	r3, r1
3400673a:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3400673e:	f7fe f83f 	bl	340047c0 <LL_RCC_IC8_Enable>
34006742:	e026      	b.n	34006792 <HAL_RCCEx_PeriphCLKConfig+0x198e>
    }
    else if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_IC9)
34006744:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006748:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
3400674c:	4b62      	ldr	r3, [pc, #392]	@ (340068d8 <HAL_RCCEx_PeriphCLKConfig+0x1ad4>)
3400674e:	429a      	cmp	r2, r3
34006750:	d116      	bne.n	34006780 <HAL_RCCEx_PeriphCLKConfig+0x197c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34006752:	4b5a      	ldr	r3, [pc, #360]	@ (340068bc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34006754:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34006758:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400675c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006760:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006764:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34006766:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400676a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400676c:	3b01      	subs	r3, #1
3400676e:	041b      	lsls	r3, r3, #16
34006770:	4313      	orrs	r3, r2
34006772:	4a52      	ldr	r2, [pc, #328]	@ (340068bc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34006774:	430b      	orrs	r3, r1
34006776:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400677a:	f7fe f861 	bl	34004840 <LL_RCC_IC9_Enable>
3400677e:	e008      	b.n	34006792 <HAL_RCCEx_PeriphCLKConfig+0x198e>
    }
    else if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_CLKP)
34006780:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006784:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
34006788:	4b54      	ldr	r3, [pc, #336]	@ (340068dc <HAL_RCCEx_PeriphCLKConfig+0x1ad8>)
3400678a:	429a      	cmp	r2, r3
3400678c:	d101      	bne.n	34006792 <HAL_RCCEx_PeriphCLKConfig+0x198e>
    {
      LL_RCC_CLKP_Enable();
3400678e:	f7fe fb17 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI3 clock*/
    __HAL_RCC_SPI3_CONFIG(PeriphClkInit->Spi3ClockSelection);
34006792:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006796:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
3400679a:	4618      	mov	r0, r3
3400679c:	f7fd faa8 	bl	34003cf0 <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI4 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI4) == RCC_PERIPHCLK_SPI4)
340067a0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340067a4:	e9d3 2300 	ldrd	r2, r3, [r3]
340067a8:	2100      	movs	r1, #0
340067aa:	f8c7 1088 	str.w	r1, [r7, #136]	@ 0x88
340067ae:	f003 0310 	and.w	r3, r3, #16
340067b2:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
340067b6:	e9d7 0122 	ldrd	r0, r1, [r7, #136]	@ 0x88
340067ba:	4603      	mov	r3, r0
340067bc:	460a      	mov	r2, r1
340067be:	4313      	orrs	r3, r2
340067c0:	d04b      	beq.n	3400685a <HAL_RCCEx_PeriphCLKConfig+0x1a56>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI4CLKSOURCE(PeriphClkInit->Spi4ClockSelection));

    if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_IC9)
340067c2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340067c6:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
340067ca:	4b45      	ldr	r3, [pc, #276]	@ (340068e0 <HAL_RCCEx_PeriphCLKConfig+0x1adc>)
340067cc:	429a      	cmp	r2, r3
340067ce:	d116      	bne.n	340067fe <HAL_RCCEx_PeriphCLKConfig+0x19fa>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
340067d0:	4b3a      	ldr	r3, [pc, #232]	@ (340068bc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
340067d2:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
340067d6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340067da:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340067de:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340067e2:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
340067e4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340067e8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
340067ea:	3b01      	subs	r3, #1
340067ec:	041b      	lsls	r3, r3, #16
340067ee:	4313      	orrs	r3, r2
340067f0:	4a32      	ldr	r2, [pc, #200]	@ (340068bc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
340067f2:	430b      	orrs	r3, r1
340067f4:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
340067f8:	f7fe f822 	bl	34004840 <LL_RCC_IC9_Enable>
340067fc:	e026      	b.n	3400684c <HAL_RCCEx_PeriphCLKConfig+0x1a48>
    }
    else if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_IC14)
340067fe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006802:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
34006806:	4b37      	ldr	r3, [pc, #220]	@ (340068e4 <HAL_RCCEx_PeriphCLKConfig+0x1ae0>)
34006808:	429a      	cmp	r2, r3
3400680a:	d116      	bne.n	3400683a <HAL_RCCEx_PeriphCLKConfig+0x1a36>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400680c:	4b2b      	ldr	r3, [pc, #172]	@ (340068bc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3400680e:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34006812:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006816:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400681a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400681e:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34006820:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006824:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34006826:	3b01      	subs	r3, #1
34006828:	041b      	lsls	r3, r3, #16
3400682a:	4313      	orrs	r3, r2
3400682c:	4a23      	ldr	r2, [pc, #140]	@ (340068bc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3400682e:	430b      	orrs	r3, r1
34006830:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34006834:	f7fe f904 	bl	34004a40 <LL_RCC_IC14_Enable>
34006838:	e008      	b.n	3400684c <HAL_RCCEx_PeriphCLKConfig+0x1a48>
    }
    else if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_CLKP)
3400683a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400683e:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
34006842:	4b29      	ldr	r3, [pc, #164]	@ (340068e8 <HAL_RCCEx_PeriphCLKConfig+0x1ae4>)
34006844:	429a      	cmp	r2, r3
34006846:	d101      	bne.n	3400684c <HAL_RCCEx_PeriphCLKConfig+0x1a48>
    {
      LL_RCC_CLKP_Enable();
34006848:	f7fe faba 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI4 clock */
    __HAL_RCC_SPI4_CONFIG(PeriphClkInit->Spi4ClockSelection);
3400684c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006850:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
34006854:	4618      	mov	r0, r3
34006856:	f7fd fa4b 	bl	34003cf0 <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI5 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI5) == RCC_PERIPHCLK_SPI5)
3400685a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400685e:	e9d3 2300 	ldrd	r2, r3, [r3]
34006862:	2100      	movs	r1, #0
34006864:	f8c7 1080 	str.w	r1, [r7, #128]	@ 0x80
34006868:	f003 0320 	and.w	r3, r3, #32
3400686c:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
34006870:	e9d7 0120 	ldrd	r0, r1, [r7, #128]	@ 0x80
34006874:	4603      	mov	r3, r0
34006876:	460a      	mov	r2, r1
34006878:	4313      	orrs	r3, r2
3400687a:	d067      	beq.n	3400694c <HAL_RCCEx_PeriphCLKConfig+0x1b48>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI5CLKSOURCE(PeriphClkInit->Spi5ClockSelection));

    if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_IC9)
3400687c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006880:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
34006884:	4b19      	ldr	r3, [pc, #100]	@ (340068ec <HAL_RCCEx_PeriphCLKConfig+0x1ae8>)
34006886:	429a      	cmp	r2, r3
34006888:	d132      	bne.n	340068f0 <HAL_RCCEx_PeriphCLKConfig+0x1aec>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400688a:	4b0c      	ldr	r3, [pc, #48]	@ (340068bc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3400688c:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34006890:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006894:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006898:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400689c:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400689e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340068a2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
340068a4:	3b01      	subs	r3, #1
340068a6:	041b      	lsls	r3, r3, #16
340068a8:	4313      	orrs	r3, r2
340068aa:	4a04      	ldr	r2, [pc, #16]	@ (340068bc <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
340068ac:	430b      	orrs	r3, r1
340068ae:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
340068b2:	f7fd ffc5 	bl	34004840 <LL_RCC_IC9_Enable>
340068b6:	e042      	b.n	3400693e <HAL_RCCEx_PeriphCLKConfig+0x1b3a>
340068b8:	07020420 	.word	0x07020420
340068bc:	56028000 	.word	0x56028000
340068c0:	07030420 	.word	0x07030420
340068c4:	07010420 	.word	0x07010420
340068c8:	07020820 	.word	0x07020820
340068cc:	07030820 	.word	0x07030820
340068d0:	07010820 	.word	0x07010820
340068d4:	07020c20 	.word	0x07020c20
340068d8:	07030c20 	.word	0x07030c20
340068dc:	07010c20 	.word	0x07010c20
340068e0:	07021020 	.word	0x07021020
340068e4:	07031020 	.word	0x07031020
340068e8:	07011020 	.word	0x07011020
340068ec:	07021420 	.word	0x07021420
    }
    else if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_IC14)
340068f0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340068f4:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
340068f8:	4bc2      	ldr	r3, [pc, #776]	@ (34006c04 <HAL_RCCEx_PeriphCLKConfig+0x1e00>)
340068fa:	429a      	cmp	r2, r3
340068fc:	d116      	bne.n	3400692c <HAL_RCCEx_PeriphCLKConfig+0x1b28>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
340068fe:	4bc2      	ldr	r3, [pc, #776]	@ (34006c08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34006900:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34006904:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006908:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400690c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006910:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34006912:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006916:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34006918:	3b01      	subs	r3, #1
3400691a:	041b      	lsls	r3, r3, #16
3400691c:	4313      	orrs	r3, r2
3400691e:	4aba      	ldr	r2, [pc, #744]	@ (34006c08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34006920:	430b      	orrs	r3, r1
34006922:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34006926:	f7fe f88b 	bl	34004a40 <LL_RCC_IC14_Enable>
3400692a:	e008      	b.n	3400693e <HAL_RCCEx_PeriphCLKConfig+0x1b3a>
    }
    else if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_CLKP)
3400692c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006930:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
34006934:	4bb5      	ldr	r3, [pc, #724]	@ (34006c0c <HAL_RCCEx_PeriphCLKConfig+0x1e08>)
34006936:	429a      	cmp	r2, r3
34006938:	d101      	bne.n	3400693e <HAL_RCCEx_PeriphCLKConfig+0x1b3a>
    {
      LL_RCC_CLKP_Enable();
3400693a:	f7fe fa41 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI5 clock */
    __HAL_RCC_SPI5_CONFIG(PeriphClkInit->Spi5ClockSelection);
3400693e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006942:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
34006946:	4618      	mov	r0, r3
34006948:	f7fd f9d2 	bl	34003cf0 <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI6 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
3400694c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006950:	e9d3 2300 	ldrd	r2, r3, [r3]
34006954:	2100      	movs	r1, #0
34006956:	67b9      	str	r1, [r7, #120]	@ 0x78
34006958:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3400695c:	67fb      	str	r3, [r7, #124]	@ 0x7c
3400695e:	e9d7 011e 	ldrd	r0, r1, [r7, #120]	@ 0x78
34006962:	4603      	mov	r3, r0
34006964:	460a      	mov	r2, r1
34006966:	4313      	orrs	r3, r2
34006968:	d04b      	beq.n	34006a02 <HAL_RCCEx_PeriphCLKConfig+0x1bfe>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI6CLKSOURCE(PeriphClkInit->Spi6ClockSelection));

    if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_IC8)
3400696a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400696e:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
34006972:	4ba7      	ldr	r3, [pc, #668]	@ (34006c10 <HAL_RCCEx_PeriphCLKConfig+0x1e0c>)
34006974:	429a      	cmp	r2, r3
34006976:	d116      	bne.n	340069a6 <HAL_RCCEx_PeriphCLKConfig+0x1ba2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34006978:	4ba3      	ldr	r3, [pc, #652]	@ (34006c08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3400697a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3400697e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006982:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006986:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400698a:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3400698c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006990:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34006992:	3b01      	subs	r3, #1
34006994:	041b      	lsls	r3, r3, #16
34006996:	4313      	orrs	r3, r2
34006998:	4a9b      	ldr	r2, [pc, #620]	@ (34006c08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3400699a:	430b      	orrs	r3, r1
3400699c:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
340069a0:	f7fd ff0e 	bl	340047c0 <LL_RCC_IC8_Enable>
340069a4:	e026      	b.n	340069f4 <HAL_RCCEx_PeriphCLKConfig+0x1bf0>
    }
    else if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_IC9)
340069a6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340069aa:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
340069ae:	4b99      	ldr	r3, [pc, #612]	@ (34006c14 <HAL_RCCEx_PeriphCLKConfig+0x1e10>)
340069b0:	429a      	cmp	r2, r3
340069b2:	d116      	bne.n	340069e2 <HAL_RCCEx_PeriphCLKConfig+0x1bde>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
340069b4:	4b94      	ldr	r3, [pc, #592]	@ (34006c08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
340069b6:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
340069ba:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340069be:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340069c2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340069c6:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
340069c8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340069cc:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
340069ce:	3b01      	subs	r3, #1
340069d0:	041b      	lsls	r3, r3, #16
340069d2:	4313      	orrs	r3, r2
340069d4:	4a8c      	ldr	r2, [pc, #560]	@ (34006c08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
340069d6:	430b      	orrs	r3, r1
340069d8:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
340069dc:	f7fd ff30 	bl	34004840 <LL_RCC_IC9_Enable>
340069e0:	e008      	b.n	340069f4 <HAL_RCCEx_PeriphCLKConfig+0x1bf0>
    }
    else if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_CLKP)
340069e2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340069e6:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
340069ea:	4b8b      	ldr	r3, [pc, #556]	@ (34006c18 <HAL_RCCEx_PeriphCLKConfig+0x1e14>)
340069ec:	429a      	cmp	r2, r3
340069ee:	d101      	bne.n	340069f4 <HAL_RCCEx_PeriphCLKConfig+0x1bf0>
    {
      LL_RCC_CLKP_Enable();
340069f0:	f7fe f9e6 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI6 clock*/
    __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
340069f4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340069f8:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
340069fc:	4618      	mov	r0, r3
340069fe:	f7fd f977 	bl	34003cf0 <LL_RCC_SetSPIClockSource>
  }

  /*-------------------------- USART1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
34006a02:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006a06:	e9d3 2300 	ldrd	r2, r3, [r3]
34006a0a:	2100      	movs	r1, #0
34006a0c:	6739      	str	r1, [r7, #112]	@ 0x70
34006a0e:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34006a12:	677b      	str	r3, [r7, #116]	@ 0x74
34006a14:	e9d7 011c 	ldrd	r0, r1, [r7, #112]	@ 0x70
34006a18:	4603      	mov	r3, r0
34006a1a:	460a      	mov	r2, r1
34006a1c:	4313      	orrs	r3, r2
34006a1e:	d04b      	beq.n	34006ab8 <HAL_RCCEx_PeriphCLKConfig+0x1cb4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_IC9)
34006a20:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006a24:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
34006a28:	4b7c      	ldr	r3, [pc, #496]	@ (34006c1c <HAL_RCCEx_PeriphCLKConfig+0x1e18>)
34006a2a:	429a      	cmp	r2, r3
34006a2c:	d116      	bne.n	34006a5c <HAL_RCCEx_PeriphCLKConfig+0x1c58>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34006a2e:	4b76      	ldr	r3, [pc, #472]	@ (34006c08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34006a30:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34006a34:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006a38:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006a3c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006a40:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34006a42:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006a46:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34006a48:	3b01      	subs	r3, #1
34006a4a:	041b      	lsls	r3, r3, #16
34006a4c:	4313      	orrs	r3, r2
34006a4e:	4a6e      	ldr	r2, [pc, #440]	@ (34006c08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34006a50:	430b      	orrs	r3, r1
34006a52:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34006a56:	f7fd fef3 	bl	34004840 <LL_RCC_IC9_Enable>
34006a5a:	e026      	b.n	34006aaa <HAL_RCCEx_PeriphCLKConfig+0x1ca6>
    }
    else if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_IC14)
34006a5c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006a60:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
34006a64:	4b6e      	ldr	r3, [pc, #440]	@ (34006c20 <HAL_RCCEx_PeriphCLKConfig+0x1e1c>)
34006a66:	429a      	cmp	r2, r3
34006a68:	d116      	bne.n	34006a98 <HAL_RCCEx_PeriphCLKConfig+0x1c94>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34006a6a:	4b67      	ldr	r3, [pc, #412]	@ (34006c08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34006a6c:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34006a70:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006a74:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006a78:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006a7c:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34006a7e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006a82:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34006a84:	3b01      	subs	r3, #1
34006a86:	041b      	lsls	r3, r3, #16
34006a88:	4313      	orrs	r3, r2
34006a8a:	4a5f      	ldr	r2, [pc, #380]	@ (34006c08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34006a8c:	430b      	orrs	r3, r1
34006a8e:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34006a92:	f7fd ffd5 	bl	34004a40 <LL_RCC_IC14_Enable>
34006a96:	e008      	b.n	34006aaa <HAL_RCCEx_PeriphCLKConfig+0x1ca6>
    }
    else if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_CLKP)
34006a98:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006a9c:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
34006aa0:	4b60      	ldr	r3, [pc, #384]	@ (34006c24 <HAL_RCCEx_PeriphCLKConfig+0x1e20>)
34006aa2:	429a      	cmp	r2, r3
34006aa4:	d101      	bne.n	34006aaa <HAL_RCCEx_PeriphCLKConfig+0x1ca6>
    {
      LL_RCC_CLKP_Enable();
34006aa6:	f7fe f98b 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART1 clock */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
34006aaa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006aae:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
34006ab2:	4618      	mov	r0, r3
34006ab4:	f7fd f927 	bl	34003d06 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART2 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
34006ab8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006abc:	e9d3 2300 	ldrd	r2, r3, [r3]
34006ac0:	2100      	movs	r1, #0
34006ac2:	66b9      	str	r1, [r7, #104]	@ 0x68
34006ac4:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34006ac8:	66fb      	str	r3, [r7, #108]	@ 0x6c
34006aca:	e9d7 011a 	ldrd	r0, r1, [r7, #104]	@ 0x68
34006ace:	4603      	mov	r3, r0
34006ad0:	460a      	mov	r2, r1
34006ad2:	4313      	orrs	r3, r2
34006ad4:	d04b      	beq.n	34006b6e <HAL_RCCEx_PeriphCLKConfig+0x1d6a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_IC9)
34006ad6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006ada:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
34006ade:	4b52      	ldr	r3, [pc, #328]	@ (34006c28 <HAL_RCCEx_PeriphCLKConfig+0x1e24>)
34006ae0:	429a      	cmp	r2, r3
34006ae2:	d116      	bne.n	34006b12 <HAL_RCCEx_PeriphCLKConfig+0x1d0e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34006ae4:	4b48      	ldr	r3, [pc, #288]	@ (34006c08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34006ae6:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34006aea:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006aee:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006af2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006af6:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34006af8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006afc:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34006afe:	3b01      	subs	r3, #1
34006b00:	041b      	lsls	r3, r3, #16
34006b02:	4313      	orrs	r3, r2
34006b04:	4a40      	ldr	r2, [pc, #256]	@ (34006c08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34006b06:	430b      	orrs	r3, r1
34006b08:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34006b0c:	f7fd fe98 	bl	34004840 <LL_RCC_IC9_Enable>
34006b10:	e026      	b.n	34006b60 <HAL_RCCEx_PeriphCLKConfig+0x1d5c>
    }
    else if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_IC14)
34006b12:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006b16:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
34006b1a:	4b44      	ldr	r3, [pc, #272]	@ (34006c2c <HAL_RCCEx_PeriphCLKConfig+0x1e28>)
34006b1c:	429a      	cmp	r2, r3
34006b1e:	d116      	bne.n	34006b4e <HAL_RCCEx_PeriphCLKConfig+0x1d4a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34006b20:	4b39      	ldr	r3, [pc, #228]	@ (34006c08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34006b22:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34006b26:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006b2a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006b2e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006b32:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34006b34:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006b38:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34006b3a:	3b01      	subs	r3, #1
34006b3c:	041b      	lsls	r3, r3, #16
34006b3e:	4313      	orrs	r3, r2
34006b40:	4a31      	ldr	r2, [pc, #196]	@ (34006c08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34006b42:	430b      	orrs	r3, r1
34006b44:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34006b48:	f7fd ff7a 	bl	34004a40 <LL_RCC_IC14_Enable>
34006b4c:	e008      	b.n	34006b60 <HAL_RCCEx_PeriphCLKConfig+0x1d5c>
    }
    else if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_CLKP)
34006b4e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006b52:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
34006b56:	4b36      	ldr	r3, [pc, #216]	@ (34006c30 <HAL_RCCEx_PeriphCLKConfig+0x1e2c>)
34006b58:	429a      	cmp	r2, r3
34006b5a:	d101      	bne.n	34006b60 <HAL_RCCEx_PeriphCLKConfig+0x1d5c>
    {
      LL_RCC_CLKP_Enable();
34006b5c:	f7fe f930 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART2 clock */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
34006b60:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006b64:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
34006b68:	4618      	mov	r0, r3
34006b6a:	f7fd f8cc 	bl	34003d06 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART3 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
34006b6e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006b72:	e9d3 2300 	ldrd	r2, r3, [r3]
34006b76:	2100      	movs	r1, #0
34006b78:	6639      	str	r1, [r7, #96]	@ 0x60
34006b7a:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34006b7e:	667b      	str	r3, [r7, #100]	@ 0x64
34006b80:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	@ 0x60
34006b84:	4603      	mov	r3, r0
34006b86:	460a      	mov	r2, r1
34006b88:	4313      	orrs	r3, r2
34006b8a:	d067      	beq.n	34006c5c <HAL_RCCEx_PeriphCLKConfig+0x1e58>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_IC9)
34006b8c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006b90:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
34006b94:	4b27      	ldr	r3, [pc, #156]	@ (34006c34 <HAL_RCCEx_PeriphCLKConfig+0x1e30>)
34006b96:	429a      	cmp	r2, r3
34006b98:	d116      	bne.n	34006bc8 <HAL_RCCEx_PeriphCLKConfig+0x1dc4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34006b9a:	4b1b      	ldr	r3, [pc, #108]	@ (34006c08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34006b9c:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34006ba0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006ba4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006ba8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006bac:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34006bae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006bb2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34006bb4:	3b01      	subs	r3, #1
34006bb6:	041b      	lsls	r3, r3, #16
34006bb8:	4313      	orrs	r3, r2
34006bba:	4a13      	ldr	r2, [pc, #76]	@ (34006c08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34006bbc:	430b      	orrs	r3, r1
34006bbe:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34006bc2:	f7fd fe3d 	bl	34004840 <LL_RCC_IC9_Enable>
34006bc6:	e042      	b.n	34006c4e <HAL_RCCEx_PeriphCLKConfig+0x1e4a>
    }
    else if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_IC14)
34006bc8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006bcc:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
34006bd0:	4b19      	ldr	r3, [pc, #100]	@ (34006c38 <HAL_RCCEx_PeriphCLKConfig+0x1e34>)
34006bd2:	429a      	cmp	r2, r3
34006bd4:	d132      	bne.n	34006c3c <HAL_RCCEx_PeriphCLKConfig+0x1e38>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34006bd6:	4b0c      	ldr	r3, [pc, #48]	@ (34006c08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34006bd8:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34006bdc:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006be0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006be4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006be8:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34006bea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006bee:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34006bf0:	3b01      	subs	r3, #1
34006bf2:	041b      	lsls	r3, r3, #16
34006bf4:	4313      	orrs	r3, r2
34006bf6:	4a04      	ldr	r2, [pc, #16]	@ (34006c08 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34006bf8:	430b      	orrs	r3, r1
34006bfa:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34006bfe:	f7fd ff1f 	bl	34004a40 <LL_RCC_IC14_Enable>
34006c02:	e024      	b.n	34006c4e <HAL_RCCEx_PeriphCLKConfig+0x1e4a>
34006c04:	07031420 	.word	0x07031420
34006c08:	56028000 	.word	0x56028000
34006c0c:	07011420 	.word	0x07011420
34006c10:	07021820 	.word	0x07021820
34006c14:	07031820 	.word	0x07031820
34006c18:	07011820 	.word	0x07011820
34006c1c:	07020030 	.word	0x07020030
34006c20:	07030030 	.word	0x07030030
34006c24:	07010030 	.word	0x07010030
34006c28:	07020430 	.word	0x07020430
34006c2c:	07030430 	.word	0x07030430
34006c30:	07010430 	.word	0x07010430
34006c34:	07020830 	.word	0x07020830
34006c38:	07030830 	.word	0x07030830
    }
    else if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_CLKP)
34006c3c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006c40:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
34006c44:	4bb3      	ldr	r3, [pc, #716]	@ (34006f14 <HAL_RCCEx_PeriphCLKConfig+0x2110>)
34006c46:	429a      	cmp	r2, r3
34006c48:	d101      	bne.n	34006c4e <HAL_RCCEx_PeriphCLKConfig+0x1e4a>
    {
      LL_RCC_CLKP_Enable();
34006c4a:	f7fe f8b9 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART3 clock */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
34006c4e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006c52:	f8d3 3158 	ldr.w	r3, [r3, #344]	@ 0x158
34006c56:	4618      	mov	r0, r3
34006c58:	f7fd f855 	bl	34003d06 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART4 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
34006c5c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006c60:	e9d3 2300 	ldrd	r2, r3, [r3]
34006c64:	2100      	movs	r1, #0
34006c66:	65b9      	str	r1, [r7, #88]	@ 0x58
34006c68:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34006c6c:	65fb      	str	r3, [r7, #92]	@ 0x5c
34006c6e:	e9d7 0116 	ldrd	r0, r1, [r7, #88]	@ 0x58
34006c72:	4603      	mov	r3, r0
34006c74:	460a      	mov	r2, r1
34006c76:	4313      	orrs	r3, r2
34006c78:	d04b      	beq.n	34006d12 <HAL_RCCEx_PeriphCLKConfig+0x1f0e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_IC9)
34006c7a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006c7e:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
34006c82:	4ba5      	ldr	r3, [pc, #660]	@ (34006f18 <HAL_RCCEx_PeriphCLKConfig+0x2114>)
34006c84:	429a      	cmp	r2, r3
34006c86:	d116      	bne.n	34006cb6 <HAL_RCCEx_PeriphCLKConfig+0x1eb2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34006c88:	4ba4      	ldr	r3, [pc, #656]	@ (34006f1c <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34006c8a:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34006c8e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006c92:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006c96:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006c9a:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34006c9c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006ca0:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34006ca2:	3b01      	subs	r3, #1
34006ca4:	041b      	lsls	r3, r3, #16
34006ca6:	4313      	orrs	r3, r2
34006ca8:	4a9c      	ldr	r2, [pc, #624]	@ (34006f1c <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34006caa:	430b      	orrs	r3, r1
34006cac:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34006cb0:	f7fd fdc6 	bl	34004840 <LL_RCC_IC9_Enable>
34006cb4:	e026      	b.n	34006d04 <HAL_RCCEx_PeriphCLKConfig+0x1f00>
    }
    else if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_IC14)
34006cb6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006cba:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
34006cbe:	4b98      	ldr	r3, [pc, #608]	@ (34006f20 <HAL_RCCEx_PeriphCLKConfig+0x211c>)
34006cc0:	429a      	cmp	r2, r3
34006cc2:	d116      	bne.n	34006cf2 <HAL_RCCEx_PeriphCLKConfig+0x1eee>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34006cc4:	4b95      	ldr	r3, [pc, #596]	@ (34006f1c <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34006cc6:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34006cca:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006cce:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006cd2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006cd6:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34006cd8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006cdc:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34006cde:	3b01      	subs	r3, #1
34006ce0:	041b      	lsls	r3, r3, #16
34006ce2:	4313      	orrs	r3, r2
34006ce4:	4a8d      	ldr	r2, [pc, #564]	@ (34006f1c <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34006ce6:	430b      	orrs	r3, r1
34006ce8:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34006cec:	f7fd fea8 	bl	34004a40 <LL_RCC_IC14_Enable>
34006cf0:	e008      	b.n	34006d04 <HAL_RCCEx_PeriphCLKConfig+0x1f00>
    }
    else if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_CLKP)
34006cf2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006cf6:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
34006cfa:	4b8a      	ldr	r3, [pc, #552]	@ (34006f24 <HAL_RCCEx_PeriphCLKConfig+0x2120>)
34006cfc:	429a      	cmp	r2, r3
34006cfe:	d101      	bne.n	34006d04 <HAL_RCCEx_PeriphCLKConfig+0x1f00>
    {
      LL_RCC_CLKP_Enable();
34006d00:	f7fe f85e 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART4 clock */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
34006d04:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006d08:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
34006d0c:	4618      	mov	r0, r3
34006d0e:	f7fc fffa 	bl	34003d06 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART5 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
34006d12:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006d16:	e9d3 2300 	ldrd	r2, r3, [r3]
34006d1a:	2100      	movs	r1, #0
34006d1c:	6539      	str	r1, [r7, #80]	@ 0x50
34006d1e:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
34006d22:	657b      	str	r3, [r7, #84]	@ 0x54
34006d24:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	@ 0x50
34006d28:	4603      	mov	r3, r0
34006d2a:	460a      	mov	r2, r1
34006d2c:	4313      	orrs	r3, r2
34006d2e:	d04b      	beq.n	34006dc8 <HAL_RCCEx_PeriphCLKConfig+0x1fc4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_IC9)
34006d30:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006d34:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
34006d38:	4b7b      	ldr	r3, [pc, #492]	@ (34006f28 <HAL_RCCEx_PeriphCLKConfig+0x2124>)
34006d3a:	429a      	cmp	r2, r3
34006d3c:	d116      	bne.n	34006d6c <HAL_RCCEx_PeriphCLKConfig+0x1f68>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34006d3e:	4b77      	ldr	r3, [pc, #476]	@ (34006f1c <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34006d40:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34006d44:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006d48:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006d4c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006d50:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34006d52:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006d56:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34006d58:	3b01      	subs	r3, #1
34006d5a:	041b      	lsls	r3, r3, #16
34006d5c:	4313      	orrs	r3, r2
34006d5e:	4a6f      	ldr	r2, [pc, #444]	@ (34006f1c <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34006d60:	430b      	orrs	r3, r1
34006d62:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34006d66:	f7fd fd6b 	bl	34004840 <LL_RCC_IC9_Enable>
34006d6a:	e026      	b.n	34006dba <HAL_RCCEx_PeriphCLKConfig+0x1fb6>
    }
    else if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_IC14)
34006d6c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006d70:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
34006d74:	4b6d      	ldr	r3, [pc, #436]	@ (34006f2c <HAL_RCCEx_PeriphCLKConfig+0x2128>)
34006d76:	429a      	cmp	r2, r3
34006d78:	d116      	bne.n	34006da8 <HAL_RCCEx_PeriphCLKConfig+0x1fa4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34006d7a:	4b68      	ldr	r3, [pc, #416]	@ (34006f1c <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34006d7c:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34006d80:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006d84:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006d88:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006d8c:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34006d8e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006d92:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34006d94:	3b01      	subs	r3, #1
34006d96:	041b      	lsls	r3, r3, #16
34006d98:	4313      	orrs	r3, r2
34006d9a:	4a60      	ldr	r2, [pc, #384]	@ (34006f1c <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34006d9c:	430b      	orrs	r3, r1
34006d9e:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34006da2:	f7fd fe4d 	bl	34004a40 <LL_RCC_IC14_Enable>
34006da6:	e008      	b.n	34006dba <HAL_RCCEx_PeriphCLKConfig+0x1fb6>
    }
    else if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_CLKP)
34006da8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006dac:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
34006db0:	4b5f      	ldr	r3, [pc, #380]	@ (34006f30 <HAL_RCCEx_PeriphCLKConfig+0x212c>)
34006db2:	429a      	cmp	r2, r3
34006db4:	d101      	bne.n	34006dba <HAL_RCCEx_PeriphCLKConfig+0x1fb6>
    {
      LL_RCC_CLKP_Enable();
34006db6:	f7fe f803 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART5 clock */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
34006dba:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006dbe:	f8d3 3160 	ldr.w	r3, [r3, #352]	@ 0x160
34006dc2:	4618      	mov	r0, r3
34006dc4:	f7fc ff9f 	bl	34003d06 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART6 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
34006dc8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006dcc:	e9d3 2300 	ldrd	r2, r3, [r3]
34006dd0:	2100      	movs	r1, #0
34006dd2:	64b9      	str	r1, [r7, #72]	@ 0x48
34006dd4:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
34006dd8:	64fb      	str	r3, [r7, #76]	@ 0x4c
34006dda:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	@ 0x48
34006dde:	4603      	mov	r3, r0
34006de0:	460a      	mov	r2, r1
34006de2:	4313      	orrs	r3, r2
34006de4:	d04b      	beq.n	34006e7e <HAL_RCCEx_PeriphCLKConfig+0x207a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));

    if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_IC9)
34006de6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006dea:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
34006dee:	4b51      	ldr	r3, [pc, #324]	@ (34006f34 <HAL_RCCEx_PeriphCLKConfig+0x2130>)
34006df0:	429a      	cmp	r2, r3
34006df2:	d116      	bne.n	34006e22 <HAL_RCCEx_PeriphCLKConfig+0x201e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34006df4:	4b49      	ldr	r3, [pc, #292]	@ (34006f1c <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34006df6:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34006dfa:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006dfe:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006e02:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006e06:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34006e08:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006e0c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34006e0e:	3b01      	subs	r3, #1
34006e10:	041b      	lsls	r3, r3, #16
34006e12:	4313      	orrs	r3, r2
34006e14:	4a41      	ldr	r2, [pc, #260]	@ (34006f1c <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34006e16:	430b      	orrs	r3, r1
34006e18:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34006e1c:	f7fd fd10 	bl	34004840 <LL_RCC_IC9_Enable>
34006e20:	e026      	b.n	34006e70 <HAL_RCCEx_PeriphCLKConfig+0x206c>
    }
    else if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_IC14)
34006e22:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006e26:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
34006e2a:	4b43      	ldr	r3, [pc, #268]	@ (34006f38 <HAL_RCCEx_PeriphCLKConfig+0x2134>)
34006e2c:	429a      	cmp	r2, r3
34006e2e:	d116      	bne.n	34006e5e <HAL_RCCEx_PeriphCLKConfig+0x205a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34006e30:	4b3a      	ldr	r3, [pc, #232]	@ (34006f1c <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34006e32:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34006e36:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006e3a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006e3e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006e42:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34006e44:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006e48:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34006e4a:	3b01      	subs	r3, #1
34006e4c:	041b      	lsls	r3, r3, #16
34006e4e:	4313      	orrs	r3, r2
34006e50:	4a32      	ldr	r2, [pc, #200]	@ (34006f1c <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34006e52:	430b      	orrs	r3, r1
34006e54:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34006e58:	f7fd fdf2 	bl	34004a40 <LL_RCC_IC14_Enable>
34006e5c:	e008      	b.n	34006e70 <HAL_RCCEx_PeriphCLKConfig+0x206c>
    }
    else if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_CLKP)
34006e5e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006e62:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
34006e66:	4b35      	ldr	r3, [pc, #212]	@ (34006f3c <HAL_RCCEx_PeriphCLKConfig+0x2138>)
34006e68:	429a      	cmp	r2, r3
34006e6a:	d101      	bne.n	34006e70 <HAL_RCCEx_PeriphCLKConfig+0x206c>
    {
      LL_RCC_CLKP_Enable();
34006e6c:	f7fd ffa8 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART6 clock */
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
34006e70:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006e74:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
34006e78:	4618      	mov	r0, r3
34006e7a:	f7fc ff44 	bl	34003d06 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART7 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
34006e7e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006e82:	e9d3 2300 	ldrd	r2, r3, [r3]
34006e86:	2100      	movs	r1, #0
34006e88:	6439      	str	r1, [r7, #64]	@ 0x40
34006e8a:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34006e8e:	647b      	str	r3, [r7, #68]	@ 0x44
34006e90:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	@ 0x40
34006e94:	4603      	mov	r3, r0
34006e96:	460a      	mov	r2, r1
34006e98:	4313      	orrs	r3, r2
34006e9a:	d065      	beq.n	34006f68 <HAL_RCCEx_PeriphCLKConfig+0x2164>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));

    if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_IC9)
34006e9c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006ea0:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
34006ea4:	4b26      	ldr	r3, [pc, #152]	@ (34006f40 <HAL_RCCEx_PeriphCLKConfig+0x213c>)
34006ea6:	429a      	cmp	r2, r3
34006ea8:	d116      	bne.n	34006ed8 <HAL_RCCEx_PeriphCLKConfig+0x20d4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34006eaa:	4b1c      	ldr	r3, [pc, #112]	@ (34006f1c <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34006eac:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34006eb0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006eb4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006eb8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006ebc:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34006ebe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006ec2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34006ec4:	3b01      	subs	r3, #1
34006ec6:	041b      	lsls	r3, r3, #16
34006ec8:	4313      	orrs	r3, r2
34006eca:	4a14      	ldr	r2, [pc, #80]	@ (34006f1c <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34006ecc:	430b      	orrs	r3, r1
34006ece:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34006ed2:	f7fd fcb5 	bl	34004840 <LL_RCC_IC9_Enable>
34006ed6:	e040      	b.n	34006f5a <HAL_RCCEx_PeriphCLKConfig+0x2156>
    }
    else if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_IC14)
34006ed8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006edc:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
34006ee0:	4b18      	ldr	r3, [pc, #96]	@ (34006f44 <HAL_RCCEx_PeriphCLKConfig+0x2140>)
34006ee2:	429a      	cmp	r2, r3
34006ee4:	d130      	bne.n	34006f48 <HAL_RCCEx_PeriphCLKConfig+0x2144>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34006ee6:	4b0d      	ldr	r3, [pc, #52]	@ (34006f1c <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34006ee8:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34006eec:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006ef0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006ef4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006ef8:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34006efa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006efe:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34006f00:	3b01      	subs	r3, #1
34006f02:	041b      	lsls	r3, r3, #16
34006f04:	4313      	orrs	r3, r2
34006f06:	4a05      	ldr	r2, [pc, #20]	@ (34006f1c <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34006f08:	430b      	orrs	r3, r1
34006f0a:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34006f0e:	f7fd fd97 	bl	34004a40 <LL_RCC_IC14_Enable>
34006f12:	e022      	b.n	34006f5a <HAL_RCCEx_PeriphCLKConfig+0x2156>
34006f14:	07010830 	.word	0x07010830
34006f18:	07020c30 	.word	0x07020c30
34006f1c:	56028000 	.word	0x56028000
34006f20:	07030c30 	.word	0x07030c30
34006f24:	07010c30 	.word	0x07010c30
34006f28:	07021030 	.word	0x07021030
34006f2c:	07031030 	.word	0x07031030
34006f30:	07011030 	.word	0x07011030
34006f34:	07021430 	.word	0x07021430
34006f38:	07031430 	.word	0x07031430
34006f3c:	07011430 	.word	0x07011430
34006f40:	07021830 	.word	0x07021830
34006f44:	07031830 	.word	0x07031830
    }
    else if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_CLKP)
34006f48:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006f4c:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
34006f50:	4bca      	ldr	r3, [pc, #808]	@ (3400727c <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34006f52:	429a      	cmp	r2, r3
34006f54:	d101      	bne.n	34006f5a <HAL_RCCEx_PeriphCLKConfig+0x2156>
    {
      LL_RCC_CLKP_Enable();
34006f56:	f7fd ff33 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART7 clock */
    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);
34006f5a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006f5e:	f8d3 3168 	ldr.w	r3, [r3, #360]	@ 0x168
34006f62:	4618      	mov	r0, r3
34006f64:	f7fc fecf 	bl	34003d06 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART8 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
34006f68:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006f6c:	e9d3 2300 	ldrd	r2, r3, [r3]
34006f70:	2100      	movs	r1, #0
34006f72:	63b9      	str	r1, [r7, #56]	@ 0x38
34006f74:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
34006f78:	63fb      	str	r3, [r7, #60]	@ 0x3c
34006f7a:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	@ 0x38
34006f7e:	4603      	mov	r3, r0
34006f80:	460a      	mov	r2, r1
34006f82:	4313      	orrs	r3, r2
34006f84:	d04b      	beq.n	3400701e <HAL_RCCEx_PeriphCLKConfig+0x221a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));

    if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_IC9)
34006f86:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006f8a:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
34006f8e:	4bbc      	ldr	r3, [pc, #752]	@ (34007280 <HAL_RCCEx_PeriphCLKConfig+0x247c>)
34006f90:	429a      	cmp	r2, r3
34006f92:	d116      	bne.n	34006fc2 <HAL_RCCEx_PeriphCLKConfig+0x21be>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34006f94:	4bbb      	ldr	r3, [pc, #748]	@ (34007284 <HAL_RCCEx_PeriphCLKConfig+0x2480>)
34006f96:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34006f9a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006f9e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006fa2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006fa6:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34006fa8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006fac:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34006fae:	3b01      	subs	r3, #1
34006fb0:	041b      	lsls	r3, r3, #16
34006fb2:	4313      	orrs	r3, r2
34006fb4:	4ab3      	ldr	r2, [pc, #716]	@ (34007284 <HAL_RCCEx_PeriphCLKConfig+0x2480>)
34006fb6:	430b      	orrs	r3, r1
34006fb8:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34006fbc:	f7fd fc40 	bl	34004840 <LL_RCC_IC9_Enable>
34006fc0:	e026      	b.n	34007010 <HAL_RCCEx_PeriphCLKConfig+0x220c>
    }
    else if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_IC14)
34006fc2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006fc6:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
34006fca:	4baf      	ldr	r3, [pc, #700]	@ (34007288 <HAL_RCCEx_PeriphCLKConfig+0x2484>)
34006fcc:	429a      	cmp	r2, r3
34006fce:	d116      	bne.n	34006ffe <HAL_RCCEx_PeriphCLKConfig+0x21fa>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34006fd0:	4bac      	ldr	r3, [pc, #688]	@ (34007284 <HAL_RCCEx_PeriphCLKConfig+0x2480>)
34006fd2:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34006fd6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34006fda:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34006fde:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006fe2:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34006fe4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34006fe8:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34006fea:	3b01      	subs	r3, #1
34006fec:	041b      	lsls	r3, r3, #16
34006fee:	4313      	orrs	r3, r2
34006ff0:	4aa4      	ldr	r2, [pc, #656]	@ (34007284 <HAL_RCCEx_PeriphCLKConfig+0x2480>)
34006ff2:	430b      	orrs	r3, r1
34006ff4:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34006ff8:	f7fd fd22 	bl	34004a40 <LL_RCC_IC14_Enable>
34006ffc:	e008      	b.n	34007010 <HAL_RCCEx_PeriphCLKConfig+0x220c>
    }
    else if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_CLKP)
34006ffe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007002:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
34007006:	4ba1      	ldr	r3, [pc, #644]	@ (3400728c <HAL_RCCEx_PeriphCLKConfig+0x2488>)
34007008:	429a      	cmp	r2, r3
3400700a:	d101      	bne.n	34007010 <HAL_RCCEx_PeriphCLKConfig+0x220c>
    {
      LL_RCC_CLKP_Enable();
3400700c:	f7fd fed8 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART8 clock */
    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);
34007010:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007014:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
34007018:	4618      	mov	r0, r3
3400701a:	f7fc fe74 	bl	34003d06 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART9 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART9) == RCC_PERIPHCLK_UART9)
3400701e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007022:	e9d3 2300 	ldrd	r2, r3, [r3]
34007026:	2100      	movs	r1, #0
34007028:	6339      	str	r1, [r7, #48]	@ 0x30
3400702a:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
3400702e:	637b      	str	r3, [r7, #52]	@ 0x34
34007030:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	@ 0x30
34007034:	4603      	mov	r3, r0
34007036:	460a      	mov	r2, r1
34007038:	4313      	orrs	r3, r2
3400703a:	d04b      	beq.n	340070d4 <HAL_RCCEx_PeriphCLKConfig+0x22d0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART9CLKSOURCE(PeriphClkInit->Uart9ClockSelection));

    if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_IC9)
3400703c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007040:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
34007044:	4a92      	ldr	r2, [pc, #584]	@ (34007290 <HAL_RCCEx_PeriphCLKConfig+0x248c>)
34007046:	4293      	cmp	r3, r2
34007048:	d116      	bne.n	34007078 <HAL_RCCEx_PeriphCLKConfig+0x2274>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400704a:	4b8e      	ldr	r3, [pc, #568]	@ (34007284 <HAL_RCCEx_PeriphCLKConfig+0x2480>)
3400704c:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34007050:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34007054:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34007058:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400705c:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400705e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007062:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34007064:	3b01      	subs	r3, #1
34007066:	041b      	lsls	r3, r3, #16
34007068:	4313      	orrs	r3, r2
3400706a:	4a86      	ldr	r2, [pc, #536]	@ (34007284 <HAL_RCCEx_PeriphCLKConfig+0x2480>)
3400706c:	430b      	orrs	r3, r1
3400706e:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34007072:	f7fd fbe5 	bl	34004840 <LL_RCC_IC9_Enable>
34007076:	e026      	b.n	340070c6 <HAL_RCCEx_PeriphCLKConfig+0x22c2>
    }
    else if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_IC14)
34007078:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400707c:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
34007080:	4a84      	ldr	r2, [pc, #528]	@ (34007294 <HAL_RCCEx_PeriphCLKConfig+0x2490>)
34007082:	4293      	cmp	r3, r2
34007084:	d116      	bne.n	340070b4 <HAL_RCCEx_PeriphCLKConfig+0x22b0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34007086:	4b7f      	ldr	r3, [pc, #508]	@ (34007284 <HAL_RCCEx_PeriphCLKConfig+0x2480>)
34007088:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400708c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34007090:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34007094:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007098:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3400709a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400709e:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
340070a0:	3b01      	subs	r3, #1
340070a2:	041b      	lsls	r3, r3, #16
340070a4:	4313      	orrs	r3, r2
340070a6:	4a77      	ldr	r2, [pc, #476]	@ (34007284 <HAL_RCCEx_PeriphCLKConfig+0x2480>)
340070a8:	430b      	orrs	r3, r1
340070aa:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
340070ae:	f7fd fcc7 	bl	34004a40 <LL_RCC_IC14_Enable>
340070b2:	e008      	b.n	340070c6 <HAL_RCCEx_PeriphCLKConfig+0x22c2>
    }
    else if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_CLKP)
340070b4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340070b8:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
340070bc:	4a76      	ldr	r2, [pc, #472]	@ (34007298 <HAL_RCCEx_PeriphCLKConfig+0x2494>)
340070be:	4293      	cmp	r3, r2
340070c0:	d101      	bne.n	340070c6 <HAL_RCCEx_PeriphCLKConfig+0x22c2>
    {
      LL_RCC_CLKP_Enable();
340070c2:	f7fd fe7d 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART9 clock */
    __HAL_RCC_UART9_CONFIG(PeriphClkInit->Uart9ClockSelection);
340070c6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340070ca:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
340070ce:	4618      	mov	r0, r3
340070d0:	f7fc fe19 	bl	34003d06 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART10 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART10) == RCC_PERIPHCLK_USART10)
340070d4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340070d8:	e9d3 2300 	ldrd	r2, r3, [r3]
340070dc:	2100      	movs	r1, #0
340070de:	62b9      	str	r1, [r7, #40]	@ 0x28
340070e0:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
340070e4:	62fb      	str	r3, [r7, #44]	@ 0x2c
340070e6:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	@ 0x28
340070ea:	4603      	mov	r3, r0
340070ec:	460a      	mov	r2, r1
340070ee:	4313      	orrs	r3, r2
340070f0:	d04b      	beq.n	3400718a <HAL_RCCEx_PeriphCLKConfig+0x2386>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART10CLKSOURCE(PeriphClkInit->Usart10ClockSelection));

    if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_IC9)
340070f2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340070f6:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
340070fa:	4a68      	ldr	r2, [pc, #416]	@ (3400729c <HAL_RCCEx_PeriphCLKConfig+0x2498>)
340070fc:	4293      	cmp	r3, r2
340070fe:	d116      	bne.n	3400712e <HAL_RCCEx_PeriphCLKConfig+0x232a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34007100:	4b60      	ldr	r3, [pc, #384]	@ (34007284 <HAL_RCCEx_PeriphCLKConfig+0x2480>)
34007102:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34007106:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400710a:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400710e:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34007112:	6c91      	ldr	r1, [r2, #72]	@ 0x48
34007114:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34007118:	6cd2      	ldr	r2, [r2, #76]	@ 0x4c
3400711a:	3a01      	subs	r2, #1
3400711c:	0412      	lsls	r2, r2, #16
3400711e:	430a      	orrs	r2, r1
34007120:	4958      	ldr	r1, [pc, #352]	@ (34007284 <HAL_RCCEx_PeriphCLKConfig+0x2480>)
34007122:	4313      	orrs	r3, r2
34007124:	f8c1 30e4 	str.w	r3, [r1, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34007128:	f7fd fb8a 	bl	34004840 <LL_RCC_IC9_Enable>
3400712c:	e026      	b.n	3400717c <HAL_RCCEx_PeriphCLKConfig+0x2378>
    }
    else if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_IC14)
3400712e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007132:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34007136:	4a5a      	ldr	r2, [pc, #360]	@ (340072a0 <HAL_RCCEx_PeriphCLKConfig+0x249c>)
34007138:	4293      	cmp	r3, r2
3400713a:	d116      	bne.n	3400716a <HAL_RCCEx_PeriphCLKConfig+0x2366>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400713c:	4b51      	ldr	r3, [pc, #324]	@ (34007284 <HAL_RCCEx_PeriphCLKConfig+0x2480>)
3400713e:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34007142:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34007146:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400714a:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
3400714e:	6f11      	ldr	r1, [r2, #112]	@ 0x70
34007150:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34007154:	6f52      	ldr	r2, [r2, #116]	@ 0x74
34007156:	3a01      	subs	r2, #1
34007158:	0412      	lsls	r2, r2, #16
3400715a:	430a      	orrs	r2, r1
3400715c:	4949      	ldr	r1, [pc, #292]	@ (34007284 <HAL_RCCEx_PeriphCLKConfig+0x2480>)
3400715e:	4313      	orrs	r3, r2
34007160:	f8c1 30f8 	str.w	r3, [r1, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34007164:	f7fd fc6c 	bl	34004a40 <LL_RCC_IC14_Enable>
34007168:	e008      	b.n	3400717c <HAL_RCCEx_PeriphCLKConfig+0x2378>
    }
    else if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_CLKP)
3400716a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400716e:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34007172:	4a4c      	ldr	r2, [pc, #304]	@ (340072a4 <HAL_RCCEx_PeriphCLKConfig+0x24a0>)
34007174:	4293      	cmp	r3, r2
34007176:	d101      	bne.n	3400717c <HAL_RCCEx_PeriphCLKConfig+0x2378>
    {
      LL_RCC_CLKP_Enable();
34007178:	f7fd fe22 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART10 clock */
    __HAL_RCC_USART10_CONFIG(PeriphClkInit->Usart10ClockSelection);
3400717c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007180:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34007184:	4618      	mov	r0, r3
34007186:	f7fc fdbe 	bl	34003d06 <LL_RCC_SetUSARTClockSource>
  }

  /*------------------------------ USBPHY1 Configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBPHY1) == RCC_PERIPHCLK_USBPHY1)
3400718a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400718e:	e9d3 2300 	ldrd	r2, r3, [r3]
34007192:	2100      	movs	r1, #0
34007194:	6239      	str	r1, [r7, #32]
34007196:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
3400719a:	627b      	str	r3, [r7, #36]	@ 0x24
3400719c:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
340071a0:	4603      	mov	r3, r0
340071a2:	460a      	mov	r2, r1
340071a4:	4313      	orrs	r3, r2
340071a6:	d03b      	beq.n	34007220 <HAL_RCCEx_PeriphCLKConfig+0x241c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBPHY1CLKSOURCE(PeriphClkInit->UsbPhy1ClockSelection));

    if (PeriphClkInit->UsbPhy1ClockSelection == RCC_USBPHY1CLKSOURCE_IC15)
340071a8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340071ac:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
340071b0:	4a3d      	ldr	r2, [pc, #244]	@ (340072a8 <HAL_RCCEx_PeriphCLKConfig+0x24a4>)
340071b2:	4293      	cmp	r3, r2
340071b4:	d116      	bne.n	340071e4 <HAL_RCCEx_PeriphCLKConfig+0x23e0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
340071b6:	4b33      	ldr	r3, [pc, #204]	@ (34007284 <HAL_RCCEx_PeriphCLKConfig+0x2480>)
340071b8:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
340071bc:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
340071c0:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
340071c4:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
340071c8:	6f91      	ldr	r1, [r2, #120]	@ 0x78
340071ca:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
340071ce:	6fd2      	ldr	r2, [r2, #124]	@ 0x7c
340071d0:	3a01      	subs	r2, #1
340071d2:	0412      	lsls	r2, r2, #16
340071d4:	430a      	orrs	r2, r1
340071d6:	492b      	ldr	r1, [pc, #172]	@ (34007284 <HAL_RCCEx_PeriphCLKConfig+0x2480>)
340071d8:	4313      	orrs	r3, r2
340071da:	f8c1 30fc 	str.w	r3, [r1, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
340071de:	f7fd fc6f 	bl	34004ac0 <LL_RCC_IC15_Enable>
340071e2:	e008      	b.n	340071f6 <HAL_RCCEx_PeriphCLKConfig+0x23f2>
    }
    else if (PeriphClkInit->UsbPhy1ClockSelection == RCC_USBPHY1CLKSOURCE_CLKP)
340071e4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340071e8:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
340071ec:	4a2f      	ldr	r2, [pc, #188]	@ (340072ac <HAL_RCCEx_PeriphCLKConfig+0x24a8>)
340071ee:	4293      	cmp	r3, r2
340071f0:	d101      	bne.n	340071f6 <HAL_RCCEx_PeriphCLKConfig+0x23f2>
    {
      LL_RCC_CLKP_Enable();
340071f2:	f7fd fde5 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USBPHY1 clock*/
    __HAL_RCC_USBPHY1_CONFIG(PeriphClkInit->UsbPhy1ClockSelection);
340071f6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340071fa:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
340071fe:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
34007202:	4618      	mov	r0, r3
34007204:	f7fc fd1c 	bl	34003c40 <LL_RCC_SetOTGPHYClockSource>
34007208:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400720c:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
34007210:	0fdb      	lsrs	r3, r3, #31
34007212:	2b01      	cmp	r3, #1
34007214:	d102      	bne.n	3400721c <HAL_RCCEx_PeriphCLKConfig+0x2418>
34007216:	f7fc fac9 	bl	340037ac <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
3400721a:	e001      	b.n	34007220 <HAL_RCCEx_PeriphCLKConfig+0x241c>
3400721c:	f7fc fab6 	bl	3400378c <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------ USBPHY2 Configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBPHY2) == RCC_PERIPHCLK_USBPHY2)
34007220:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007224:	e9d3 2300 	ldrd	r2, r3, [r3]
34007228:	2100      	movs	r1, #0
3400722a:	61b9      	str	r1, [r7, #24]
3400722c:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
34007230:	61fb      	str	r3, [r7, #28]
34007232:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
34007236:	4603      	mov	r3, r0
34007238:	460a      	mov	r2, r1
3400723a:	4313      	orrs	r3, r2
3400723c:	d058      	beq.n	340072f0 <HAL_RCCEx_PeriphCLKConfig+0x24ec>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBPHY2CLKSOURCE(PeriphClkInit->UsbPhy2ClockSelection));

    if (PeriphClkInit->UsbPhy2ClockSelection == RCC_USBPHY2CLKSOURCE_IC15)
3400723e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007242:	f8d3 3180 	ldr.w	r3, [r3, #384]	@ 0x180
34007246:	4a1a      	ldr	r2, [pc, #104]	@ (340072b0 <HAL_RCCEx_PeriphCLKConfig+0x24ac>)
34007248:	4293      	cmp	r3, r2
3400724a:	d133      	bne.n	340072b4 <HAL_RCCEx_PeriphCLKConfig+0x24b0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400724c:	4b0d      	ldr	r3, [pc, #52]	@ (34007284 <HAL_RCCEx_PeriphCLKConfig+0x2480>)
3400724e:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34007252:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34007256:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400725a:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
3400725e:	6f91      	ldr	r1, [r2, #120]	@ 0x78
34007260:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34007264:	6fd2      	ldr	r2, [r2, #124]	@ 0x7c
34007266:	3a01      	subs	r2, #1
34007268:	0412      	lsls	r2, r2, #16
3400726a:	430a      	orrs	r2, r1
3400726c:	4905      	ldr	r1, [pc, #20]	@ (34007284 <HAL_RCCEx_PeriphCLKConfig+0x2480>)
3400726e:	4313      	orrs	r3, r2
34007270:	f8c1 30fc 	str.w	r3, [r1, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34007274:	f7fd fc24 	bl	34004ac0 <LL_RCC_IC15_Enable>
34007278:	e025      	b.n	340072c6 <HAL_RCCEx_PeriphCLKConfig+0x24c2>
3400727a:	bf00      	nop
3400727c:	07011830 	.word	0x07011830
34007280:	07021c30 	.word	0x07021c30
34007284:	56028000 	.word	0x56028000
34007288:	07031c30 	.word	0x07031c30
3400728c:	07011c30 	.word	0x07011c30
34007290:	07020034 	.word	0x07020034
34007294:	07030034 	.word	0x07030034
34007298:	07010034 	.word	0x07010034
3400729c:	07020434 	.word	0x07020434
340072a0:	07030434 	.word	0x07030434
340072a4:	07010434 	.word	0x07010434
340072a8:	03020c14 	.word	0x03020c14
340072ac:	03010c14 	.word	0x03010c14
340072b0:	03021414 	.word	0x03021414
    }
    else if (PeriphClkInit->UsbPhy2ClockSelection == RCC_USBPHY2CLKSOURCE_CLKP)
340072b4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340072b8:	f8d3 3180 	ldr.w	r3, [r3, #384]	@ 0x180
340072bc:	4a42      	ldr	r2, [pc, #264]	@ (340073c8 <HAL_RCCEx_PeriphCLKConfig+0x25c4>)
340072be:	4293      	cmp	r3, r2
340072c0:	d101      	bne.n	340072c6 <HAL_RCCEx_PeriphCLKConfig+0x24c2>
    {
      LL_RCC_CLKP_Enable();
340072c2:	f7fd fd7d 	bl	34004dc0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USBPHY2 clock*/
    __HAL_RCC_USBPHY2_CONFIG(PeriphClkInit->UsbPhy2ClockSelection);
340072c6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340072ca:	f8d3 3180 	ldr.w	r3, [r3, #384]	@ 0x180
340072ce:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
340072d2:	4618      	mov	r0, r3
340072d4:	f7fc fcb4 	bl	34003c40 <LL_RCC_SetOTGPHYClockSource>
340072d8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340072dc:	f8d3 3180 	ldr.w	r3, [r3, #384]	@ 0x180
340072e0:	0fdb      	lsrs	r3, r3, #31
340072e2:	2b01      	cmp	r3, #1
340072e4:	d102      	bne.n	340072ec <HAL_RCCEx_PeriphCLKConfig+0x24e8>
340072e6:	f7fc fa61 	bl	340037ac <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
340072ea:	e001      	b.n	340072f0 <HAL_RCCEx_PeriphCLKConfig+0x24ec>
340072ec:	f7fc fa4e 	bl	3400378c <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------ USBOTGHS1 Configuration -------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBOTGHS1) == RCC_PERIPHCLK_USBOTGHS1)
340072f0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340072f4:	e9d3 2300 	ldrd	r2, r3, [r3]
340072f8:	2100      	movs	r1, #0
340072fa:	6139      	str	r1, [r7, #16]
340072fc:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
34007300:	617b      	str	r3, [r7, #20]
34007302:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
34007306:	4603      	mov	r3, r0
34007308:	460a      	mov	r2, r1
3400730a:	4313      	orrs	r3, r2
3400730c:	d014      	beq.n	34007338 <HAL_RCCEx_PeriphCLKConfig+0x2534>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBOTGHS1CLKSOURCE(PeriphClkInit->UsbOtgHs1ClockSelection));

    /* Set the source of USBOTGHS1 clock */
    __HAL_RCC_USBOTGHS1_CONFIG(PeriphClkInit->UsbOtgHs1ClockSelection);
3400730e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007312:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
34007316:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
3400731a:	4618      	mov	r0, r3
3400731c:	f7fc fc9b 	bl	34003c56 <LL_RCC_SetOTGPHYCKREFClockSource>
34007320:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007324:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
34007328:	0fdb      	lsrs	r3, r3, #31
3400732a:	2b01      	cmp	r3, #1
3400732c:	d102      	bne.n	34007334 <HAL_RCCEx_PeriphCLKConfig+0x2530>
3400732e:	f7fc fa3d 	bl	340037ac <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
34007332:	e001      	b.n	34007338 <HAL_RCCEx_PeriphCLKConfig+0x2534>
34007334:	f7fc fa2a 	bl	3400378c <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------ USBOTGHS2 Configuration -------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBOTGHS2) == RCC_PERIPHCLK_USBOTGHS2)
34007338:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400733c:	e9d3 2300 	ldrd	r2, r3, [r3]
34007340:	2100      	movs	r1, #0
34007342:	60b9      	str	r1, [r7, #8]
34007344:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
34007348:	60fb      	str	r3, [r7, #12]
3400734a:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
3400734e:	4603      	mov	r3, r0
34007350:	460a      	mov	r2, r1
34007352:	4313      	orrs	r3, r2
34007354:	d014      	beq.n	34007380 <HAL_RCCEx_PeriphCLKConfig+0x257c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBOTGHS2CLKSOURCE(PeriphClkInit->UsbOtgHs2ClockSelection));

    /* Set the source of USBOTGHS2 clock */
    __HAL_RCC_USBOTGHS2_CONFIG(PeriphClkInit->UsbOtgHs2ClockSelection);
34007356:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400735a:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
3400735e:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
34007362:	4618      	mov	r0, r3
34007364:	f7fc fc77 	bl	34003c56 <LL_RCC_SetOTGPHYCKREFClockSource>
34007368:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400736c:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
34007370:	0fdb      	lsrs	r3, r3, #31
34007372:	2b01      	cmp	r3, #1
34007374:	d102      	bne.n	3400737c <HAL_RCCEx_PeriphCLKConfig+0x2578>
34007376:	f7fc fa19 	bl	340037ac <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
3400737a:	e001      	b.n	34007380 <HAL_RCCEx_PeriphCLKConfig+0x257c>
3400737c:	f7fc fa06 	bl	3400378c <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------------ TIM configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
34007380:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34007384:	e9d3 2300 	ldrd	r2, r3, [r3]
34007388:	2100      	movs	r1, #0
3400738a:	6039      	str	r1, [r7, #0]
3400738c:	f003 0380 	and.w	r3, r3, #128	@ 0x80
34007390:	607b      	str	r3, [r7, #4]
34007392:	e9d7 0100 	ldrd	r0, r1, [r7]
34007396:	4603      	mov	r3, r0
34007398:	460a      	mov	r2, r1
3400739a:	4313      	orrs	r3, r2
3400739c:	d006      	beq.n	340073ac <HAL_RCCEx_PeriphCLKConfig+0x25a8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER_CONFIG(PeriphClkInit->TIMPresSelection);
3400739e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340073a2:	f8d3 318c 	ldr.w	r3, [r3, #396]	@ 0x18c
340073a6:	4618      	mov	r0, r3
340073a8:	f7fc fe86 	bl	340040b8 <LL_RCC_SetTIMPrescaler>
  }

  if (status == HAL_OK)
340073ac:	f897 31c6 	ldrb.w	r3, [r7, #454]	@ 0x1c6
340073b0:	2b00      	cmp	r3, #0
340073b2:	d101      	bne.n	340073b8 <HAL_RCCEx_PeriphCLKConfig+0x25b4>
  {
    return HAL_OK;
340073b4:	2300      	movs	r3, #0
340073b6:	e000      	b.n	340073ba <HAL_RCCEx_PeriphCLKConfig+0x25b6>
  }
  return HAL_ERROR;
340073b8:	2301      	movs	r3, #1
}
340073ba:	4618      	mov	r0, r3
340073bc:	f507 77e4 	add.w	r7, r7, #456	@ 0x1c8
340073c0:	46bd      	mov	sp, r7
340073c2:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
340073c6:	bf00      	nop
340073c8:	03011414 	.word	0x03011414

340073cc <HAL_RCCEx_GetPeriphCLKFreq>:
  *            @arg RCC_PERIPHCLK_XSPI2    : XSPI2 peripheral clock
  *            @arg RCC_PERIPHCLK_XSPI3    : XSPI3 peripheral clock
  * @retval Frequency in Hz
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint64_t PeriphClk)
{
340073cc:	b590      	push	{r4, r7, lr}
340073ce:	b085      	sub	sp, #20
340073d0:	af00      	add	r7, sp, #0
340073d2:	e9c7 0100 	strd	r0, r1, [r7]
  uint32_t frequency = 0;   /* Set to 0 for returned value if no source clock */
340073d6:	2100      	movs	r1, #0
340073d8:	60f9      	str	r1, [r7, #12]

  switch (PeriphClk)
340073da:	e9d7 0100 	ldrd	r0, r1, [r7]
340073de:	f101 447f 	add.w	r4, r1, #4278190080	@ 0xff000000
340073e2:	ea50 0104 	orrs.w	r1, r0, r4
340073e6:	f000 8436 	beq.w	34007c56 <HAL_RCCEx_GetPeriphCLKFreq+0x88a>
340073ea:	e9d7 0100 	ldrd	r0, r1, [r7]
340073ee:	2801      	cmp	r0, #1
340073f0:	f171 7180 	sbcs.w	r1, r1, #16777216	@ 0x1000000
340073f4:	f080 8434 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340073f8:	e9d7 0100 	ldrd	r0, r1, [r7]
340073fc:	f5a1 0400 	sub.w	r4, r1, #8388608	@ 0x800000
34007400:	ea50 0104 	orrs.w	r1, r0, r4
34007404:	f000 8422 	beq.w	34007c4c <HAL_RCCEx_GetPeriphCLKFreq+0x880>
34007408:	e9d7 0100 	ldrd	r0, r1, [r7]
3400740c:	2801      	cmp	r0, #1
3400740e:	f571 0100 	sbcs.w	r1, r1, #8388608	@ 0x800000
34007412:	f080 8425 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34007416:	e9d7 0100 	ldrd	r0, r1, [r7]
3400741a:	f5a1 0480 	sub.w	r4, r1, #4194304	@ 0x400000
3400741e:	ea50 0104 	orrs.w	r1, r0, r4
34007422:	f000 840e 	beq.w	34007c42 <HAL_RCCEx_GetPeriphCLKFreq+0x876>
34007426:	e9d7 0100 	ldrd	r0, r1, [r7]
3400742a:	2801      	cmp	r0, #1
3400742c:	f571 0180 	sbcs.w	r1, r1, #4194304	@ 0x400000
34007430:	f080 8416 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34007434:	e9d7 0100 	ldrd	r0, r1, [r7]
34007438:	f5a1 1400 	sub.w	r4, r1, #2097152	@ 0x200000
3400743c:	ea50 0104 	orrs.w	r1, r0, r4
34007440:	f000 83fa 	beq.w	34007c38 <HAL_RCCEx_GetPeriphCLKFreq+0x86c>
34007444:	e9d7 0100 	ldrd	r0, r1, [r7]
34007448:	2801      	cmp	r0, #1
3400744a:	f571 1100 	sbcs.w	r1, r1, #2097152	@ 0x200000
3400744e:	f080 8407 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34007452:	e9d7 0100 	ldrd	r0, r1, [r7]
34007456:	f5a1 1480 	sub.w	r4, r1, #1048576	@ 0x100000
3400745a:	ea50 0104 	orrs.w	r1, r0, r4
3400745e:	f000 83e6 	beq.w	34007c2e <HAL_RCCEx_GetPeriphCLKFreq+0x862>
34007462:	e9d7 0100 	ldrd	r0, r1, [r7]
34007466:	2801      	cmp	r0, #1
34007468:	f571 1180 	sbcs.w	r1, r1, #1048576	@ 0x100000
3400746c:	f080 83f8 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34007470:	e9d7 0100 	ldrd	r0, r1, [r7]
34007474:	f5a1 2400 	sub.w	r4, r1, #524288	@ 0x80000
34007478:	ea50 0104 	orrs.w	r1, r0, r4
3400747c:	f000 83d2 	beq.w	34007c24 <HAL_RCCEx_GetPeriphCLKFreq+0x858>
34007480:	e9d7 0100 	ldrd	r0, r1, [r7]
34007484:	2801      	cmp	r0, #1
34007486:	f571 2100 	sbcs.w	r1, r1, #524288	@ 0x80000
3400748a:	f080 83e9 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3400748e:	e9d7 0100 	ldrd	r0, r1, [r7]
34007492:	f5a1 2480 	sub.w	r4, r1, #262144	@ 0x40000
34007496:	ea50 0104 	orrs.w	r1, r0, r4
3400749a:	f000 83be 	beq.w	34007c1a <HAL_RCCEx_GetPeriphCLKFreq+0x84e>
3400749e:	e9d7 0100 	ldrd	r0, r1, [r7]
340074a2:	2801      	cmp	r0, #1
340074a4:	f571 2180 	sbcs.w	r1, r1, #262144	@ 0x40000
340074a8:	f080 83da 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340074ac:	e9d7 0100 	ldrd	r0, r1, [r7]
340074b0:	f5a1 3400 	sub.w	r4, r1, #131072	@ 0x20000
340074b4:	ea50 0104 	orrs.w	r1, r0, r4
340074b8:	f000 83aa 	beq.w	34007c10 <HAL_RCCEx_GetPeriphCLKFreq+0x844>
340074bc:	e9d7 0100 	ldrd	r0, r1, [r7]
340074c0:	2801      	cmp	r0, #1
340074c2:	f571 3100 	sbcs.w	r1, r1, #131072	@ 0x20000
340074c6:	f080 83cb 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340074ca:	e9d7 0100 	ldrd	r0, r1, [r7]
340074ce:	f5a1 3480 	sub.w	r4, r1, #65536	@ 0x10000
340074d2:	ea50 0104 	orrs.w	r1, r0, r4
340074d6:	f000 8396 	beq.w	34007c06 <HAL_RCCEx_GetPeriphCLKFreq+0x83a>
340074da:	e9d7 0100 	ldrd	r0, r1, [r7]
340074de:	2801      	cmp	r0, #1
340074e0:	f571 3180 	sbcs.w	r1, r1, #65536	@ 0x10000
340074e4:	f080 83bc 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340074e8:	e9d7 0100 	ldrd	r0, r1, [r7]
340074ec:	f5a1 4400 	sub.w	r4, r1, #32768	@ 0x8000
340074f0:	ea50 0104 	orrs.w	r1, r0, r4
340074f4:	f000 8382 	beq.w	34007bfc <HAL_RCCEx_GetPeriphCLKFreq+0x830>
340074f8:	e9d7 0100 	ldrd	r0, r1, [r7]
340074fc:	2801      	cmp	r0, #1
340074fe:	f571 4100 	sbcs.w	r1, r1, #32768	@ 0x8000
34007502:	f080 83ad 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34007506:	e9d7 0100 	ldrd	r0, r1, [r7]
3400750a:	f5a1 4480 	sub.w	r4, r1, #16384	@ 0x4000
3400750e:	ea50 0104 	orrs.w	r1, r0, r4
34007512:	f000 836e 	beq.w	34007bf2 <HAL_RCCEx_GetPeriphCLKFreq+0x826>
34007516:	e9d7 0100 	ldrd	r0, r1, [r7]
3400751a:	2801      	cmp	r0, #1
3400751c:	f571 4180 	sbcs.w	r1, r1, #16384	@ 0x4000
34007520:	f080 839e 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34007524:	e9d7 0100 	ldrd	r0, r1, [r7]
34007528:	f5a1 5400 	sub.w	r4, r1, #8192	@ 0x2000
3400752c:	ea50 0104 	orrs.w	r1, r0, r4
34007530:	f000 835a 	beq.w	34007be8 <HAL_RCCEx_GetPeriphCLKFreq+0x81c>
34007534:	e9d7 0100 	ldrd	r0, r1, [r7]
34007538:	2801      	cmp	r0, #1
3400753a:	f571 5100 	sbcs.w	r1, r1, #8192	@ 0x2000
3400753e:	f080 838f 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34007542:	e9d7 0100 	ldrd	r0, r1, [r7]
34007546:	f5a1 5480 	sub.w	r4, r1, #4096	@ 0x1000
3400754a:	ea50 0104 	orrs.w	r1, r0, r4
3400754e:	f000 8346 	beq.w	34007bde <HAL_RCCEx_GetPeriphCLKFreq+0x812>
34007552:	e9d7 0100 	ldrd	r0, r1, [r7]
34007556:	2801      	cmp	r0, #1
34007558:	f571 5180 	sbcs.w	r1, r1, #4096	@ 0x1000
3400755c:	f080 8380 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34007560:	e9d7 0100 	ldrd	r0, r1, [r7]
34007564:	f5a1 6400 	sub.w	r4, r1, #2048	@ 0x800
34007568:	ea50 0104 	orrs.w	r1, r0, r4
3400756c:	f000 8332 	beq.w	34007bd4 <HAL_RCCEx_GetPeriphCLKFreq+0x808>
34007570:	e9d7 0100 	ldrd	r0, r1, [r7]
34007574:	2801      	cmp	r0, #1
34007576:	f571 6100 	sbcs.w	r1, r1, #2048	@ 0x800
3400757a:	f080 8371 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3400757e:	e9d7 0100 	ldrd	r0, r1, [r7]
34007582:	f5a1 6480 	sub.w	r4, r1, #1024	@ 0x400
34007586:	ea50 0104 	orrs.w	r1, r0, r4
3400758a:	f000 831e 	beq.w	34007bca <HAL_RCCEx_GetPeriphCLKFreq+0x7fe>
3400758e:	e9d7 0100 	ldrd	r0, r1, [r7]
34007592:	2801      	cmp	r0, #1
34007594:	f571 6180 	sbcs.w	r1, r1, #1024	@ 0x400
34007598:	f080 8362 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3400759c:	e9d7 0100 	ldrd	r0, r1, [r7]
340075a0:	f5a1 7400 	sub.w	r4, r1, #512	@ 0x200
340075a4:	ea50 0104 	orrs.w	r1, r0, r4
340075a8:	f000 830a 	beq.w	34007bc0 <HAL_RCCEx_GetPeriphCLKFreq+0x7f4>
340075ac:	e9d7 0100 	ldrd	r0, r1, [r7]
340075b0:	2801      	cmp	r0, #1
340075b2:	f571 7100 	sbcs.w	r1, r1, #512	@ 0x200
340075b6:	f080 8353 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340075ba:	e9d7 0100 	ldrd	r0, r1, [r7]
340075be:	f5a1 7480 	sub.w	r4, r1, #256	@ 0x100
340075c2:	ea50 0104 	orrs.w	r1, r0, r4
340075c6:	f000 82f6 	beq.w	34007bb6 <HAL_RCCEx_GetPeriphCLKFreq+0x7ea>
340075ca:	e9d7 0100 	ldrd	r0, r1, [r7]
340075ce:	2801      	cmp	r0, #1
340075d0:	f571 7180 	sbcs.w	r1, r1, #256	@ 0x100
340075d4:	f080 8344 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340075d8:	e9d7 0100 	ldrd	r0, r1, [r7]
340075dc:	f1a1 0440 	sub.w	r4, r1, #64	@ 0x40
340075e0:	ea50 0104 	orrs.w	r1, r0, r4
340075e4:	f000 82e2 	beq.w	34007bac <HAL_RCCEx_GetPeriphCLKFreq+0x7e0>
340075e8:	e9d7 0100 	ldrd	r0, r1, [r7]
340075ec:	2801      	cmp	r0, #1
340075ee:	f171 0140 	sbcs.w	r1, r1, #64	@ 0x40
340075f2:	f080 8335 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340075f6:	e9d7 0100 	ldrd	r0, r1, [r7]
340075fa:	f1a1 0420 	sub.w	r4, r1, #32
340075fe:	ea50 0104 	orrs.w	r1, r0, r4
34007602:	f000 82ce 	beq.w	34007ba2 <HAL_RCCEx_GetPeriphCLKFreq+0x7d6>
34007606:	e9d7 0100 	ldrd	r0, r1, [r7]
3400760a:	2801      	cmp	r0, #1
3400760c:	f171 0120 	sbcs.w	r1, r1, #32
34007610:	f080 8326 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34007614:	e9d7 0100 	ldrd	r0, r1, [r7]
34007618:	f1a1 0410 	sub.w	r4, r1, #16
3400761c:	ea50 0104 	orrs.w	r1, r0, r4
34007620:	f000 82ba 	beq.w	34007b98 <HAL_RCCEx_GetPeriphCLKFreq+0x7cc>
34007624:	e9d7 0100 	ldrd	r0, r1, [r7]
34007628:	2801      	cmp	r0, #1
3400762a:	f171 0110 	sbcs.w	r1, r1, #16
3400762e:	f080 8317 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34007632:	e9d7 0100 	ldrd	r0, r1, [r7]
34007636:	f1a1 0408 	sub.w	r4, r1, #8
3400763a:	ea50 0104 	orrs.w	r1, r0, r4
3400763e:	f000 82a6 	beq.w	34007b8e <HAL_RCCEx_GetPeriphCLKFreq+0x7c2>
34007642:	e9d7 0100 	ldrd	r0, r1, [r7]
34007646:	2801      	cmp	r0, #1
34007648:	f171 0108 	sbcs.w	r1, r1, #8
3400764c:	f080 8308 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34007650:	e9d7 0100 	ldrd	r0, r1, [r7]
34007654:	1f0c      	subs	r4, r1, #4
34007656:	ea50 0104 	orrs.w	r1, r0, r4
3400765a:	f000 8293 	beq.w	34007b84 <HAL_RCCEx_GetPeriphCLKFreq+0x7b8>
3400765e:	e9d7 0100 	ldrd	r0, r1, [r7]
34007662:	2801      	cmp	r0, #1
34007664:	f171 0104 	sbcs.w	r1, r1, #4
34007668:	f080 82fa 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3400766c:	e9d7 0100 	ldrd	r0, r1, [r7]
34007670:	1e8c      	subs	r4, r1, #2
34007672:	ea50 0104 	orrs.w	r1, r0, r4
34007676:	f000 8280 	beq.w	34007b7a <HAL_RCCEx_GetPeriphCLKFreq+0x7ae>
3400767a:	e9d7 0100 	ldrd	r0, r1, [r7]
3400767e:	2801      	cmp	r0, #1
34007680:	f171 0102 	sbcs.w	r1, r1, #2
34007684:	f080 82ec 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34007688:	e9d7 0100 	ldrd	r0, r1, [r7]
3400768c:	1e4c      	subs	r4, r1, #1
3400768e:	ea50 0104 	orrs.w	r1, r0, r4
34007692:	f000 826d 	beq.w	34007b70 <HAL_RCCEx_GetPeriphCLKFreq+0x7a4>
34007696:	e9d7 0100 	ldrd	r0, r1, [r7]
3400769a:	2801      	cmp	r0, #1
3400769c:	f171 0101 	sbcs.w	r1, r1, #1
340076a0:	f080 82de 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340076a4:	e9d7 0100 	ldrd	r0, r1, [r7]
340076a8:	f100 4400 	add.w	r4, r0, #2147483648	@ 0x80000000
340076ac:	4321      	orrs	r1, r4
340076ae:	f000 825a 	beq.w	34007b66 <HAL_RCCEx_GetPeriphCLKFreq+0x79a>
340076b2:	e9d7 0100 	ldrd	r0, r1, [r7]
340076b6:	4cda      	ldr	r4, [pc, #872]	@ (34007a20 <HAL_RCCEx_GetPeriphCLKFreq+0x654>)
340076b8:	42a0      	cmp	r0, r4
340076ba:	f171 0100 	sbcs.w	r1, r1, #0
340076be:	f080 82cf 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340076c2:	e9d7 0100 	ldrd	r0, r1, [r7]
340076c6:	f100 4440 	add.w	r4, r0, #3221225472	@ 0xc0000000
340076ca:	4321      	orrs	r1, r4
340076cc:	f000 8246 	beq.w	34007b5c <HAL_RCCEx_GetPeriphCLKFreq+0x790>
340076d0:	e9d7 0100 	ldrd	r0, r1, [r7]
340076d4:	4cd3      	ldr	r4, [pc, #844]	@ (34007a24 <HAL_RCCEx_GetPeriphCLKFreq+0x658>)
340076d6:	42a0      	cmp	r0, r4
340076d8:	f171 0100 	sbcs.w	r1, r1, #0
340076dc:	f080 82c0 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340076e0:	e9d7 0100 	ldrd	r0, r1, [r7]
340076e4:	f100 4460 	add.w	r4, r0, #3758096384	@ 0xe0000000
340076e8:	4321      	orrs	r1, r4
340076ea:	f000 8232 	beq.w	34007b52 <HAL_RCCEx_GetPeriphCLKFreq+0x786>
340076ee:	e9d7 0100 	ldrd	r0, r1, [r7]
340076f2:	4ccd      	ldr	r4, [pc, #820]	@ (34007a28 <HAL_RCCEx_GetPeriphCLKFreq+0x65c>)
340076f4:	42a0      	cmp	r0, r4
340076f6:	f171 0100 	sbcs.w	r1, r1, #0
340076fa:	f080 82b1 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340076fe:	e9d7 0100 	ldrd	r0, r1, [r7]
34007702:	f100 4470 	add.w	r4, r0, #4026531840	@ 0xf0000000
34007706:	4321      	orrs	r1, r4
34007708:	f000 821e 	beq.w	34007b48 <HAL_RCCEx_GetPeriphCLKFreq+0x77c>
3400770c:	e9d7 0100 	ldrd	r0, r1, [r7]
34007710:	4cc6      	ldr	r4, [pc, #792]	@ (34007a2c <HAL_RCCEx_GetPeriphCLKFreq+0x660>)
34007712:	42a0      	cmp	r0, r4
34007714:	f171 0100 	sbcs.w	r1, r1, #0
34007718:	f080 82a2 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3400771c:	e9d7 0100 	ldrd	r0, r1, [r7]
34007720:	f100 4478 	add.w	r4, r0, #4160749568	@ 0xf8000000
34007724:	4321      	orrs	r1, r4
34007726:	f000 820b 	beq.w	34007b40 <HAL_RCCEx_GetPeriphCLKFreq+0x774>
3400772a:	e9d7 0100 	ldrd	r0, r1, [r7]
3400772e:	4cc0      	ldr	r4, [pc, #768]	@ (34007a30 <HAL_RCCEx_GetPeriphCLKFreq+0x664>)
34007730:	42a0      	cmp	r0, r4
34007732:	f171 0100 	sbcs.w	r1, r1, #0
34007736:	f080 8293 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3400773a:	e9d7 0100 	ldrd	r0, r1, [r7]
3400773e:	f100 447c 	add.w	r4, r0, #4227858432	@ 0xfc000000
34007742:	4321      	orrs	r1, r4
34007744:	f000 81f7 	beq.w	34007b36 <HAL_RCCEx_GetPeriphCLKFreq+0x76a>
34007748:	e9d7 0100 	ldrd	r0, r1, [r7]
3400774c:	4cb9      	ldr	r4, [pc, #740]	@ (34007a34 <HAL_RCCEx_GetPeriphCLKFreq+0x668>)
3400774e:	42a0      	cmp	r0, r4
34007750:	f171 0100 	sbcs.w	r1, r1, #0
34007754:	f080 8284 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34007758:	e9d7 0100 	ldrd	r0, r1, [r7]
3400775c:	f100 447e 	add.w	r4, r0, #4261412864	@ 0xfe000000
34007760:	4321      	orrs	r1, r4
34007762:	f000 81e2 	beq.w	34007b2a <HAL_RCCEx_GetPeriphCLKFreq+0x75e>
34007766:	e9d7 0100 	ldrd	r0, r1, [r7]
3400776a:	4cb3      	ldr	r4, [pc, #716]	@ (34007a38 <HAL_RCCEx_GetPeriphCLKFreq+0x66c>)
3400776c:	42a0      	cmp	r0, r4
3400776e:	f171 0100 	sbcs.w	r1, r1, #0
34007772:	f080 8275 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34007776:	e9d7 0100 	ldrd	r0, r1, [r7]
3400777a:	f100 447f 	add.w	r4, r0, #4278190080	@ 0xff000000
3400777e:	4321      	orrs	r1, r4
34007780:	f000 81cd 	beq.w	34007b1e <HAL_RCCEx_GetPeriphCLKFreq+0x752>
34007784:	e9d7 0100 	ldrd	r0, r1, [r7]
34007788:	4cac      	ldr	r4, [pc, #688]	@ (34007a3c <HAL_RCCEx_GetPeriphCLKFreq+0x670>)
3400778a:	42a0      	cmp	r0, r4
3400778c:	f171 0100 	sbcs.w	r1, r1, #0
34007790:	f080 8266 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34007794:	e9d7 0100 	ldrd	r0, r1, [r7]
34007798:	f5a0 0400 	sub.w	r4, r0, #8388608	@ 0x800000
3400779c:	4321      	orrs	r1, r4
3400779e:	f000 81b8 	beq.w	34007b12 <HAL_RCCEx_GetPeriphCLKFreq+0x746>
340077a2:	e9d7 0100 	ldrd	r0, r1, [r7]
340077a6:	4ca6      	ldr	r4, [pc, #664]	@ (34007a40 <HAL_RCCEx_GetPeriphCLKFreq+0x674>)
340077a8:	42a0      	cmp	r0, r4
340077aa:	f171 0100 	sbcs.w	r1, r1, #0
340077ae:	f080 8257 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340077b2:	e9d7 0100 	ldrd	r0, r1, [r7]
340077b6:	f5a0 0480 	sub.w	r4, r0, #4194304	@ 0x400000
340077ba:	4321      	orrs	r1, r4
340077bc:	f000 81a4 	beq.w	34007b08 <HAL_RCCEx_GetPeriphCLKFreq+0x73c>
340077c0:	e9d7 0100 	ldrd	r0, r1, [r7]
340077c4:	4c9f      	ldr	r4, [pc, #636]	@ (34007a44 <HAL_RCCEx_GetPeriphCLKFreq+0x678>)
340077c6:	42a0      	cmp	r0, r4
340077c8:	f171 0100 	sbcs.w	r1, r1, #0
340077cc:	f080 8248 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340077d0:	e9d7 0100 	ldrd	r0, r1, [r7]
340077d4:	f5a0 1400 	sub.w	r4, r0, #2097152	@ 0x200000
340077d8:	4321      	orrs	r1, r4
340077da:	f000 8190 	beq.w	34007afe <HAL_RCCEx_GetPeriphCLKFreq+0x732>
340077de:	e9d7 0100 	ldrd	r0, r1, [r7]
340077e2:	4c99      	ldr	r4, [pc, #612]	@ (34007a48 <HAL_RCCEx_GetPeriphCLKFreq+0x67c>)
340077e4:	42a0      	cmp	r0, r4
340077e6:	f171 0100 	sbcs.w	r1, r1, #0
340077ea:	f080 8239 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340077ee:	e9d7 0100 	ldrd	r0, r1, [r7]
340077f2:	f5a0 1480 	sub.w	r4, r0, #1048576	@ 0x100000
340077f6:	4321      	orrs	r1, r4
340077f8:	f000 817c 	beq.w	34007af4 <HAL_RCCEx_GetPeriphCLKFreq+0x728>
340077fc:	e9d7 0100 	ldrd	r0, r1, [r7]
34007800:	4c92      	ldr	r4, [pc, #584]	@ (34007a4c <HAL_RCCEx_GetPeriphCLKFreq+0x680>)
34007802:	42a0      	cmp	r0, r4
34007804:	f171 0100 	sbcs.w	r1, r1, #0
34007808:	f080 822a 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3400780c:	e9d7 0100 	ldrd	r0, r1, [r7]
34007810:	f5a0 2400 	sub.w	r4, r0, #524288	@ 0x80000
34007814:	4321      	orrs	r1, r4
34007816:	f000 8168 	beq.w	34007aea <HAL_RCCEx_GetPeriphCLKFreq+0x71e>
3400781a:	e9d7 0100 	ldrd	r0, r1, [r7]
3400781e:	4c8c      	ldr	r4, [pc, #560]	@ (34007a50 <HAL_RCCEx_GetPeriphCLKFreq+0x684>)
34007820:	42a0      	cmp	r0, r4
34007822:	f171 0100 	sbcs.w	r1, r1, #0
34007826:	f080 821b 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3400782a:	e9d7 0100 	ldrd	r0, r1, [r7]
3400782e:	f5a0 2480 	sub.w	r4, r0, #262144	@ 0x40000
34007832:	4321      	orrs	r1, r4
34007834:	f000 8154 	beq.w	34007ae0 <HAL_RCCEx_GetPeriphCLKFreq+0x714>
34007838:	e9d7 0100 	ldrd	r0, r1, [r7]
3400783c:	4c85      	ldr	r4, [pc, #532]	@ (34007a54 <HAL_RCCEx_GetPeriphCLKFreq+0x688>)
3400783e:	42a0      	cmp	r0, r4
34007840:	f171 0100 	sbcs.w	r1, r1, #0
34007844:	f080 820c 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34007848:	e9d7 0100 	ldrd	r0, r1, [r7]
3400784c:	f5a0 3400 	sub.w	r4, r0, #131072	@ 0x20000
34007850:	4321      	orrs	r1, r4
34007852:	f000 8140 	beq.w	34007ad6 <HAL_RCCEx_GetPeriphCLKFreq+0x70a>
34007856:	e9d7 0100 	ldrd	r0, r1, [r7]
3400785a:	4c7f      	ldr	r4, [pc, #508]	@ (34007a58 <HAL_RCCEx_GetPeriphCLKFreq+0x68c>)
3400785c:	42a0      	cmp	r0, r4
3400785e:	f171 0100 	sbcs.w	r1, r1, #0
34007862:	f080 81fd 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34007866:	e9d7 0100 	ldrd	r0, r1, [r7]
3400786a:	f5a0 3480 	sub.w	r4, r0, #65536	@ 0x10000
3400786e:	4321      	orrs	r1, r4
34007870:	f000 812c 	beq.w	34007acc <HAL_RCCEx_GetPeriphCLKFreq+0x700>
34007874:	e9d7 0100 	ldrd	r0, r1, [r7]
34007878:	f1b0 1f01 	cmp.w	r0, #65537	@ 0x10001
3400787c:	f171 0100 	sbcs.w	r1, r1, #0
34007880:	f080 81ee 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34007884:	e9d7 0100 	ldrd	r0, r1, [r7]
34007888:	f5a0 4400 	sub.w	r4, r0, #32768	@ 0x8000
3400788c:	4321      	orrs	r1, r4
3400788e:	f000 8118 	beq.w	34007ac2 <HAL_RCCEx_GetPeriphCLKFreq+0x6f6>
34007892:	e9d7 0100 	ldrd	r0, r1, [r7]
34007896:	f248 0401 	movw	r4, #32769	@ 0x8001
3400789a:	42a0      	cmp	r0, r4
3400789c:	f171 0100 	sbcs.w	r1, r1, #0
340078a0:	f080 81de 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340078a4:	e9d7 0100 	ldrd	r0, r1, [r7]
340078a8:	f5a0 4480 	sub.w	r4, r0, #16384	@ 0x4000
340078ac:	4321      	orrs	r1, r4
340078ae:	f000 8103 	beq.w	34007ab8 <HAL_RCCEx_GetPeriphCLKFreq+0x6ec>
340078b2:	e9d7 0100 	ldrd	r0, r1, [r7]
340078b6:	f244 0401 	movw	r4, #16385	@ 0x4001
340078ba:	42a0      	cmp	r0, r4
340078bc:	f171 0100 	sbcs.w	r1, r1, #0
340078c0:	f080 81ce 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340078c4:	e9d7 0100 	ldrd	r0, r1, [r7]
340078c8:	f5a0 5400 	sub.w	r4, r0, #8192	@ 0x2000
340078cc:	4321      	orrs	r1, r4
340078ce:	f000 80ee 	beq.w	34007aae <HAL_RCCEx_GetPeriphCLKFreq+0x6e2>
340078d2:	e9d7 0100 	ldrd	r0, r1, [r7]
340078d6:	f242 0401 	movw	r4, #8193	@ 0x2001
340078da:	42a0      	cmp	r0, r4
340078dc:	f171 0100 	sbcs.w	r1, r1, #0
340078e0:	f080 81be 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340078e4:	e9d7 0100 	ldrd	r0, r1, [r7]
340078e8:	f5a0 5480 	sub.w	r4, r0, #4096	@ 0x1000
340078ec:	4321      	orrs	r1, r4
340078ee:	f000 80d9 	beq.w	34007aa4 <HAL_RCCEx_GetPeriphCLKFreq+0x6d8>
340078f2:	e9d7 0100 	ldrd	r0, r1, [r7]
340078f6:	f241 0401 	movw	r4, #4097	@ 0x1001
340078fa:	42a0      	cmp	r0, r4
340078fc:	f171 0100 	sbcs.w	r1, r1, #0
34007900:	f080 81ae 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34007904:	e9d7 0100 	ldrd	r0, r1, [r7]
34007908:	f5a0 6400 	sub.w	r4, r0, #2048	@ 0x800
3400790c:	4321      	orrs	r1, r4
3400790e:	f000 80c4 	beq.w	34007a9a <HAL_RCCEx_GetPeriphCLKFreq+0x6ce>
34007912:	e9d7 0100 	ldrd	r0, r1, [r7]
34007916:	f640 0401 	movw	r4, #2049	@ 0x801
3400791a:	42a0      	cmp	r0, r4
3400791c:	f171 0100 	sbcs.w	r1, r1, #0
34007920:	f080 819e 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34007924:	e9d7 0100 	ldrd	r0, r1, [r7]
34007928:	f5a0 6480 	sub.w	r4, r0, #1024	@ 0x400
3400792c:	4321      	orrs	r1, r4
3400792e:	f000 80af 	beq.w	34007a90 <HAL_RCCEx_GetPeriphCLKFreq+0x6c4>
34007932:	e9d7 0100 	ldrd	r0, r1, [r7]
34007936:	f240 4401 	movw	r4, #1025	@ 0x401
3400793a:	42a0      	cmp	r0, r4
3400793c:	f171 0100 	sbcs.w	r1, r1, #0
34007940:	f080 818e 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34007944:	e9d7 0100 	ldrd	r0, r1, [r7]
34007948:	2821      	cmp	r0, #33	@ 0x21
3400794a:	f171 0100 	sbcs.w	r1, r1, #0
3400794e:	d255      	bcs.n	340079fc <HAL_RCCEx_GetPeriphCLKFreq+0x630>
34007950:	e9d7 0100 	ldrd	r0, r1, [r7]
34007954:	4301      	orrs	r1, r0
34007956:	f000 8183 	beq.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3400795a:	e9d7 0100 	ldrd	r0, r1, [r7]
3400795e:	1e42      	subs	r2, r0, #1
34007960:	f141 33ff 	adc.w	r3, r1, #4294967295	@ 0xffffffff
34007964:	2a20      	cmp	r2, #32
34007966:	f173 0100 	sbcs.w	r1, r3, #0
3400796a:	f080 8179 	bcs.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3400796e:	2a1f      	cmp	r2, #31
34007970:	f200 8176 	bhi.w	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34007974:	a101      	add	r1, pc, #4	@ (adr r1, 3400797c <HAL_RCCEx_GetPeriphCLKFreq+0x5b0>)
34007976:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
3400797a:	bf00      	nop
3400797c:	34007a0b 	.word	0x34007a0b
34007980:	34007a15 	.word	0x34007a15
34007984:	34007c61 	.word	0x34007c61
34007988:	34007a65 	.word	0x34007a65
3400798c:	34007c61 	.word	0x34007c61
34007990:	34007c61 	.word	0x34007c61
34007994:	34007c61 	.word	0x34007c61
34007998:	34007a5d 	.word	0x34007a5d
3400799c:	34007c61 	.word	0x34007c61
340079a0:	34007c61 	.word	0x34007c61
340079a4:	34007c61 	.word	0x34007c61
340079a8:	34007c61 	.word	0x34007c61
340079ac:	34007c61 	.word	0x34007c61
340079b0:	34007c61 	.word	0x34007c61
340079b4:	34007c61 	.word	0x34007c61
340079b8:	34007a6f 	.word	0x34007a6f
340079bc:	34007c61 	.word	0x34007c61
340079c0:	34007c61 	.word	0x34007c61
340079c4:	34007c61 	.word	0x34007c61
340079c8:	34007c61 	.word	0x34007c61
340079cc:	34007c61 	.word	0x34007c61
340079d0:	34007c61 	.word	0x34007c61
340079d4:	34007c61 	.word	0x34007c61
340079d8:	34007c61 	.word	0x34007c61
340079dc:	34007c61 	.word	0x34007c61
340079e0:	34007c61 	.word	0x34007c61
340079e4:	34007c61 	.word	0x34007c61
340079e8:	34007c61 	.word	0x34007c61
340079ec:	34007c61 	.word	0x34007c61
340079f0:	34007c61 	.word	0x34007c61
340079f4:	34007c61 	.word	0x34007c61
340079f8:	34007a7b 	.word	0x34007a7b
340079fc:	e9d7 2300 	ldrd	r2, r3, [r7]
34007a00:	f5a2 7100 	sub.w	r1, r2, #512	@ 0x200
34007a04:	430b      	orrs	r3, r1
34007a06:	d03e      	beq.n	34007a86 <HAL_RCCEx_GetPeriphCLKFreq+0x6ba>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI3_CLKSOURCE);
      break;

    default:
      /* Unexpected case, frequency is by default set to 0 */
      break;
34007a08:	e12a      	b.n	34007c60 <HAL_RCCEx_GetPeriphCLKFreq+0x894>
      frequency = RCCEx_GetADCCLKFreq(LL_RCC_ADC_CLKSOURCE);
34007a0a:	2070      	movs	r0, #112	@ 0x70
34007a0c:	f000 fb90 	bl	34008130 <RCCEx_GetADCCLKFreq>
34007a10:	60f8      	str	r0, [r7, #12]
      break;
34007a12:	e126      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetADFCLKFreq(LL_RCC_ADF1_CLKSOURCE);
34007a14:	2007      	movs	r0, #7
34007a16:	f000 fc8d 	bl	34008334 <RCCEx_GetADFCLKFreq>
34007a1a:	60f8      	str	r0, [r7, #12]
      break;
34007a1c:	e121      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
34007a1e:	bf00      	nop
34007a20:	80000001 	.word	0x80000001
34007a24:	40000001 	.word	0x40000001
34007a28:	20000001 	.word	0x20000001
34007a2c:	10000001 	.word	0x10000001
34007a30:	08000001 	.word	0x08000001
34007a34:	04000001 	.word	0x04000001
34007a38:	02000001 	.word	0x02000001
34007a3c:	01000001 	.word	0x01000001
34007a40:	00800001 	.word	0x00800001
34007a44:	00400001 	.word	0x00400001
34007a48:	00200001 	.word	0x00200001
34007a4c:	00100001 	.word	0x00100001
34007a50:	00080001 	.word	0x00080001
34007a54:	00040001 	.word	0x00040001
34007a58:	00020001 	.word	0x00020001
      frequency = RCCEx_GetCSICLKFreq();
34007a5c:	f000 ff0c 	bl	34008878 <RCCEx_GetCSICLKFreq>
34007a60:	60f8      	str	r0, [r7, #12]
      break;
34007a62:	e0fe      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34007a64:	2007      	movs	r0, #7
34007a66:	f000 fd51 	bl	3400850c <RCCEx_GetCLKPCLKFreq>
34007a6a:	60f8      	str	r0, [r7, #12]
      break;
34007a6c:	e0f9      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetDCMIPPCLKFreq(LL_RCC_DCMIPP_CLKSOURCE);
34007a6e:	f44f 1040 	mov.w	r0, #3145728	@ 0x300000
34007a72:	f000 ff4d 	bl	34008910 <RCCEx_GetDCMIPPCLKFreq>
34007a76:	60f8      	str	r0, [r7, #12]
      break;
34007a78:	e0f3      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetETH1CLKFreq(LL_RCC_ETH1_CLKSOURCE);
34007a7a:	f44f 5040 	mov.w	r0, #12288	@ 0x3000
34007a7e:	f000 ffd1 	bl	34008a24 <RCCEx_GetETH1CLKFreq>
34007a82:	60f8      	str	r0, [r7, #12]
      break;
34007a84:	e0ed      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetETH1PTPCLKFreq(LL_RCC_ETH1PTP_CLKSOURCE);
34007a86:	2003      	movs	r0, #3
34007a88:	f001 f84c 	bl	34008b24 <RCCEx_GetETH1PTPCLKFreq>
34007a8c:	60f8      	str	r0, [r7, #12]
      break;
34007a8e:	e0e8      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetFDCANCLKFreq(LL_RCC_FDCAN_CLKSOURCE);
34007a90:	2003      	movs	r0, #3
34007a92:	f001 f8cb 	bl	34008c2c <RCCEx_GetFDCANCLKFreq>
34007a96:	60f8      	str	r0, [r7, #12]
      break;
34007a98:	e0e3      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetFMCCLKFreq(LL_RCC_FMC_CLKSOURCE);
34007a9a:	2030      	movs	r0, #48	@ 0x30
34007a9c:	f001 f946 	bl	34008d2c <RCCEx_GetFMCCLKFreq>
34007aa0:	60f8      	str	r0, [r7, #12]
      break;
34007aa2:	e0de      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C1_CLKSOURCE);
34007aa4:	4871      	ldr	r0, [pc, #452]	@ (34007c6c <HAL_RCCEx_GetPeriphCLKFreq+0x8a0>)
34007aa6:	f001 f9f9 	bl	34008e9c <RCCEx_GetI2CCLKFreq>
34007aaa:	60f8      	str	r0, [r7, #12]
      break;
34007aac:	e0d9      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C2_CLKSOURCE);
34007aae:	4870      	ldr	r0, [pc, #448]	@ (34007c70 <HAL_RCCEx_GetPeriphCLKFreq+0x8a4>)
34007ab0:	f001 f9f4 	bl	34008e9c <RCCEx_GetI2CCLKFreq>
34007ab4:	60f8      	str	r0, [r7, #12]
      break;
34007ab6:	e0d4      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C3_CLKSOURCE);
34007ab8:	486e      	ldr	r0, [pc, #440]	@ (34007c74 <HAL_RCCEx_GetPeriphCLKFreq+0x8a8>)
34007aba:	f001 f9ef 	bl	34008e9c <RCCEx_GetI2CCLKFreq>
34007abe:	60f8      	str	r0, [r7, #12]
      break;
34007ac0:	e0cf      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C4_CLKSOURCE);
34007ac2:	486d      	ldr	r0, [pc, #436]	@ (34007c78 <HAL_RCCEx_GetPeriphCLKFreq+0x8ac>)
34007ac4:	f001 f9ea 	bl	34008e9c <RCCEx_GetI2CCLKFreq>
34007ac8:	60f8      	str	r0, [r7, #12]
      break;
34007aca:	e0ca      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI3CCLKFreq(LL_RCC_I3C1_CLKSOURCE);
34007acc:	486b      	ldr	r0, [pc, #428]	@ (34007c7c <HAL_RCCEx_GetPeriphCLKFreq+0x8b0>)
34007ace:	f001 fb8d 	bl	340091ec <RCCEx_GetI3CCLKFreq>
34007ad2:	60f8      	str	r0, [r7, #12]
      break;
34007ad4:	e0c5      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI3CCLKFreq(LL_RCC_I3C2_CLKSOURCE);
34007ad6:	486a      	ldr	r0, [pc, #424]	@ (34007c80 <HAL_RCCEx_GetPeriphCLKFreq+0x8b4>)
34007ad8:	f001 fb88 	bl	340091ec <RCCEx_GetI3CCLKFreq>
34007adc:	60f8      	str	r0, [r7, #12]
      break;
34007ade:	e0c0      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM1_CLKSOURCE);
34007ae0:	4868      	ldr	r0, [pc, #416]	@ (34007c84 <HAL_RCCEx_GetPeriphCLKFreq+0x8b8>)
34007ae2:	f001 fcb7 	bl	34009454 <RCCEx_GetLPTIMCLKFreq>
34007ae6:	60f8      	str	r0, [r7, #12]
      break;
34007ae8:	e0bb      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM2_CLKSOURCE);
34007aea:	4867      	ldr	r0, [pc, #412]	@ (34007c88 <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
34007aec:	f001 fcb2 	bl	34009454 <RCCEx_GetLPTIMCLKFreq>
34007af0:	60f8      	str	r0, [r7, #12]
      break;
34007af2:	e0b6      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM3_CLKSOURCE);
34007af4:	4865      	ldr	r0, [pc, #404]	@ (34007c8c <HAL_RCCEx_GetPeriphCLKFreq+0x8c0>)
34007af6:	f001 fcad 	bl	34009454 <RCCEx_GetLPTIMCLKFreq>
34007afa:	60f8      	str	r0, [r7, #12]
      break;
34007afc:	e0b1      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM4_CLKSOURCE);
34007afe:	4864      	ldr	r0, [pc, #400]	@ (34007c90 <HAL_RCCEx_GetPeriphCLKFreq+0x8c4>)
34007b00:	f001 fca8 	bl	34009454 <RCCEx_GetLPTIMCLKFreq>
34007b04:	60f8      	str	r0, [r7, #12]
      break;
34007b06:	e0ac      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM5_CLKSOURCE);
34007b08:	4862      	ldr	r0, [pc, #392]	@ (34007c94 <HAL_RCCEx_GetPeriphCLKFreq+0x8c8>)
34007b0a:	f001 fca3 	bl	34009454 <RCCEx_GetLPTIMCLKFreq>
34007b0e:	60f8      	str	r0, [r7, #12]
      break;
34007b10:	e0a7      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPUARTCLKFreq(LL_RCC_LPUART1_CLKSOURCE);
34007b12:	f44f 60e0 	mov.w	r0, #1792	@ 0x700
34007b16:	f001 fe47 	bl	340097a8 <RCCEx_GetLPUARTCLKFreq>
34007b1a:	60f8      	str	r0, [r7, #12]
      break;
34007b1c:	e0a1      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLTDCCLKFreq(LL_RCC_LTDC_CLKSOURCE);
34007b1e:	f04f 7040 	mov.w	r0, #50331648	@ 0x3000000
34007b22:	f001 ff43 	bl	340099ac <RCCEx_GetLTDCCLKFreq>
34007b26:	60f8      	str	r0, [r7, #12]
      break;
34007b28:	e09b      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetMDFCLKFreq(LL_RCC_MDF1_CLKSOURCE);
34007b2a:	f44f 20e0 	mov.w	r0, #458752	@ 0x70000
34007b2e:	f001 ffc7 	bl	34009ac0 <RCCEx_GetMDFCLKFreq>
34007b32:	60f8      	str	r0, [r7, #12]
      break;
34007b34:	e095      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetPSSICLKFreq(LL_RCC_PSSI_CLKSOURCE);
34007b36:	2030      	movs	r0, #48	@ 0x30
34007b38:	f002 f8cc 	bl	34009cd4 <RCCEx_GetPSSICLKFreq>
34007b3c:	60f8      	str	r0, [r7, #12]
      break;
34007b3e:	e090      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetRTCCLKFreq();
34007b40:	f002 f94a 	bl	34009dd8 <RCCEx_GetRTCCLKFreq>
34007b44:	60f8      	str	r0, [r7, #12]
      break;
34007b46:	e08c      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSAICLKFreq(LL_RCC_SAI1_CLKSOURCE);
34007b48:	4853      	ldr	r0, [pc, #332]	@ (34007c98 <HAL_RCCEx_GetPeriphCLKFreq+0x8cc>)
34007b4a:	f002 f997 	bl	34009e7c <RCCEx_GetSAICLKFreq>
34007b4e:	60f8      	str	r0, [r7, #12]
      break;
34007b50:	e087      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSAICLKFreq(LL_RCC_SAI2_CLKSOURCE);
34007b52:	4852      	ldr	r0, [pc, #328]	@ (34007c9c <HAL_RCCEx_GetPeriphCLKFreq+0x8d0>)
34007b54:	f002 f992 	bl	34009e7c <RCCEx_GetSAICLKFreq>
34007b58:	60f8      	str	r0, [r7, #12]
      break;
34007b5a:	e082      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSDMMCCLKFreq(LL_RCC_SDMMC1_CLKSOURCE);
34007b5c:	4850      	ldr	r0, [pc, #320]	@ (34007ca0 <HAL_RCCEx_GetPeriphCLKFreq+0x8d4>)
34007b5e:	f002 faf3 	bl	3400a148 <RCCEx_GetSDMMCCLKFreq>
34007b62:	60f8      	str	r0, [r7, #12]
      break;
34007b64:	e07d      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSDMMCCLKFreq(LL_RCC_SDMMC2_CLKSOURCE);
34007b66:	484f      	ldr	r0, [pc, #316]	@ (34007ca4 <HAL_RCCEx_GetPeriphCLKFreq+0x8d8>)
34007b68:	f002 faee 	bl	3400a148 <RCCEx_GetSDMMCCLKFreq>
34007b6c:	60f8      	str	r0, [r7, #12]
      break;
34007b6e:	e078      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPDIFRXCLKFreq(LL_RCC_SPDIFRX1_CLKSOURCE);
34007b70:	2007      	movs	r0, #7
34007b72:	f002 fbd3 	bl	3400a31c <RCCEx_GetSPDIFRXCLKFreq>
34007b76:	60f8      	str	r0, [r7, #12]
      break;
34007b78:	e073      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI1_CLKSOURCE);
34007b7a:	484b      	ldr	r0, [pc, #300]	@ (34007ca8 <HAL_RCCEx_GetPeriphCLKFreq+0x8dc>)
34007b7c:	f002 fcb2 	bl	3400a4e4 <RCCEx_GetSPICLKFreq>
34007b80:	60f8      	str	r0, [r7, #12]
      break;
34007b82:	e06e      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI2_CLKSOURCE);
34007b84:	4849      	ldr	r0, [pc, #292]	@ (34007cac <HAL_RCCEx_GetPeriphCLKFreq+0x8e0>)
34007b86:	f002 fcad 	bl	3400a4e4 <RCCEx_GetSPICLKFreq>
34007b8a:	60f8      	str	r0, [r7, #12]
      break;
34007b8c:	e069      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI3_CLKSOURCE);
34007b8e:	4848      	ldr	r0, [pc, #288]	@ (34007cb0 <HAL_RCCEx_GetPeriphCLKFreq+0x8e4>)
34007b90:	f002 fca8 	bl	3400a4e4 <RCCEx_GetSPICLKFreq>
34007b94:	60f8      	str	r0, [r7, #12]
      break;
34007b96:	e064      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI4_CLKSOURCE);
34007b98:	4846      	ldr	r0, [pc, #280]	@ (34007cb4 <HAL_RCCEx_GetPeriphCLKFreq+0x8e8>)
34007b9a:	f002 fca3 	bl	3400a4e4 <RCCEx_GetSPICLKFreq>
34007b9e:	60f8      	str	r0, [r7, #12]
      break;
34007ba0:	e05f      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI5_CLKSOURCE);
34007ba2:	4845      	ldr	r0, [pc, #276]	@ (34007cb8 <HAL_RCCEx_GetPeriphCLKFreq+0x8ec>)
34007ba4:	f002 fc9e 	bl	3400a4e4 <RCCEx_GetSPICLKFreq>
34007ba8:	60f8      	str	r0, [r7, #12]
      break;
34007baa:	e05a      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI6_CLKSOURCE);
34007bac:	4843      	ldr	r0, [pc, #268]	@ (34007cbc <HAL_RCCEx_GetPeriphCLKFreq+0x8f0>)
34007bae:	f002 fc99 	bl	3400a4e4 <RCCEx_GetSPICLKFreq>
34007bb2:	60f8      	str	r0, [r7, #12]
      break;
34007bb4:	e055      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART1_CLKSOURCE);
34007bb6:	4842      	ldr	r0, [pc, #264]	@ (34007cc0 <HAL_RCCEx_GetPeriphCLKFreq+0x8f4>)
34007bb8:	f003 f990 	bl	3400aedc <RCCEx_GetUSARTCLKFreq>
34007bbc:	60f8      	str	r0, [r7, #12]
      break;
34007bbe:	e050      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART2_CLKSOURCE);
34007bc0:	4840      	ldr	r0, [pc, #256]	@ (34007cc4 <HAL_RCCEx_GetPeriphCLKFreq+0x8f8>)
34007bc2:	f003 f98b 	bl	3400aedc <RCCEx_GetUSARTCLKFreq>
34007bc6:	60f8      	str	r0, [r7, #12]
      break;
34007bc8:	e04b      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART3_CLKSOURCE);
34007bca:	483f      	ldr	r0, [pc, #252]	@ (34007cc8 <HAL_RCCEx_GetPeriphCLKFreq+0x8fc>)
34007bcc:	f003 f986 	bl	3400aedc <RCCEx_GetUSARTCLKFreq>
34007bd0:	60f8      	str	r0, [r7, #12]
      break;
34007bd2:	e046      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART4_CLKSOURCE);
34007bd4:	483d      	ldr	r0, [pc, #244]	@ (34007ccc <HAL_RCCEx_GetPeriphCLKFreq+0x900>)
34007bd6:	f002 ff57 	bl	3400aa88 <RCCEx_GetUARTCLKFreq>
34007bda:	60f8      	str	r0, [r7, #12]
      break;
34007bdc:	e041      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART5_CLKSOURCE);
34007bde:	483c      	ldr	r0, [pc, #240]	@ (34007cd0 <HAL_RCCEx_GetPeriphCLKFreq+0x904>)
34007be0:	f002 ff52 	bl	3400aa88 <RCCEx_GetUARTCLKFreq>
34007be4:	60f8      	str	r0, [r7, #12]
      break;
34007be6:	e03c      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART6_CLKSOURCE);
34007be8:	483a      	ldr	r0, [pc, #232]	@ (34007cd4 <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
34007bea:	f003 f977 	bl	3400aedc <RCCEx_GetUSARTCLKFreq>
34007bee:	60f8      	str	r0, [r7, #12]
      break;
34007bf0:	e037      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART7_CLKSOURCE);
34007bf2:	4839      	ldr	r0, [pc, #228]	@ (34007cd8 <HAL_RCCEx_GetPeriphCLKFreq+0x90c>)
34007bf4:	f002 ff48 	bl	3400aa88 <RCCEx_GetUARTCLKFreq>
34007bf8:	60f8      	str	r0, [r7, #12]
      break;
34007bfa:	e032      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART8_CLKSOURCE);
34007bfc:	4837      	ldr	r0, [pc, #220]	@ (34007cdc <HAL_RCCEx_GetPeriphCLKFreq+0x910>)
34007bfe:	f002 ff43 	bl	3400aa88 <RCCEx_GetUARTCLKFreq>
34007c02:	60f8      	str	r0, [r7, #12]
      break;
34007c04:	e02d      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART9_CLKSOURCE);
34007c06:	4836      	ldr	r0, [pc, #216]	@ (34007ce0 <HAL_RCCEx_GetPeriphCLKFreq+0x914>)
34007c08:	f002 ff3e 	bl	3400aa88 <RCCEx_GetUARTCLKFreq>
34007c0c:	60f8      	str	r0, [r7, #12]
      break;
34007c0e:	e028      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART10_CLKSOURCE);
34007c10:	4834      	ldr	r0, [pc, #208]	@ (34007ce4 <HAL_RCCEx_GetPeriphCLKFreq+0x918>)
34007c12:	f003 f963 	bl	3400aedc <RCCEx_GetUSARTCLKFreq>
34007c16:	60f8      	str	r0, [r7, #12]
      break;
34007c18:	e023      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY1_CLKSOURCE);
34007c1a:	4833      	ldr	r0, [pc, #204]	@ (34007ce8 <HAL_RCCEx_GetPeriphCLKFreq+0x91c>)
34007c1c:	f003 fb88 	bl	3400b330 <RCCEx_GetOTGPHYCLKFreq>
34007c20:	60f8      	str	r0, [r7, #12]
      break;
34007c22:	e01e      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetOTGPHYCKREFCLKFreq(LL_RCC_OTGPHY1CKREF_CLKSOURCE);
34007c24:	4831      	ldr	r0, [pc, #196]	@ (34007cec <HAL_RCCEx_GetPeriphCLKFreq+0x920>)
34007c26:	f003 fc39 	bl	3400b49c <RCCEx_GetOTGPHYCKREFCLKFreq>
34007c2a:	60f8      	str	r0, [r7, #12]
      break;
34007c2c:	e019      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
34007c2e:	4830      	ldr	r0, [pc, #192]	@ (34007cf0 <HAL_RCCEx_GetPeriphCLKFreq+0x924>)
34007c30:	f003 fb7e 	bl	3400b330 <RCCEx_GetOTGPHYCLKFreq>
34007c34:	60f8      	str	r0, [r7, #12]
      break;
34007c36:	e014      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetOTGPHYCKREFCLKFreq(LL_RCC_OTGPHY2CKREF_CLKSOURCE);
34007c38:	482e      	ldr	r0, [pc, #184]	@ (34007cf4 <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
34007c3a:	f003 fc2f 	bl	3400b49c <RCCEx_GetOTGPHYCKREFCLKFreq>
34007c3e:	60f8      	str	r0, [r7, #12]
      break;
34007c40:	e00f      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI1_CLKSOURCE);
34007c42:	482d      	ldr	r0, [pc, #180]	@ (34007cf8 <HAL_RCCEx_GetPeriphCLKFreq+0x92c>)
34007c44:	f003 fc7a 	bl	3400b53c <RCCEx_GetXSPICLKFreq>
34007c48:	60f8      	str	r0, [r7, #12]
      break;
34007c4a:	e00a      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI2_CLKSOURCE);
34007c4c:	482b      	ldr	r0, [pc, #172]	@ (34007cfc <HAL_RCCEx_GetPeriphCLKFreq+0x930>)
34007c4e:	f003 fc75 	bl	3400b53c <RCCEx_GetXSPICLKFreq>
34007c52:	60f8      	str	r0, [r7, #12]
      break;
34007c54:	e005      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI3_CLKSOURCE);
34007c56:	482a      	ldr	r0, [pc, #168]	@ (34007d00 <HAL_RCCEx_GetPeriphCLKFreq+0x934>)
34007c58:	f003 fc70 	bl	3400b53c <RCCEx_GetXSPICLKFreq>
34007c5c:	60f8      	str	r0, [r7, #12]
      break;
34007c5e:	e000      	b.n	34007c62 <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      break;
34007c60:	bf00      	nop
  }

  return frequency;
34007c62:	68fb      	ldr	r3, [r7, #12]
}
34007c64:	4618      	mov	r0, r3
34007c66:	3714      	adds	r7, #20
34007c68:	46bd      	mov	sp, r7
34007c6a:	bd90      	pop	{r4, r7, pc}
34007c6c:	0700000c 	.word	0x0700000c
34007c70:	0700040c 	.word	0x0700040c
34007c74:	0700080c 	.word	0x0700080c
34007c78:	07000c0c 	.word	0x07000c0c
34007c7c:	0700100c 	.word	0x0700100c
34007c80:	0700140c 	.word	0x0700140c
34007c84:	0700082c 	.word	0x0700082c
34007c88:	07000c2c 	.word	0x07000c2c
34007c8c:	0700102c 	.word	0x0700102c
34007c90:	0700142c 	.word	0x0700142c
34007c94:	0700182c 	.word	0x0700182c
34007c98:	07001418 	.word	0x07001418
34007c9c:	07001818 	.word	0x07001818
34007ca0:	0300001c 	.word	0x0300001c
34007ca4:	0300041c 	.word	0x0300041c
34007ca8:	07000420 	.word	0x07000420
34007cac:	07000820 	.word	0x07000820
34007cb0:	07000c20 	.word	0x07000c20
34007cb4:	07001020 	.word	0x07001020
34007cb8:	07001420 	.word	0x07001420
34007cbc:	07001820 	.word	0x07001820
34007cc0:	07000030 	.word	0x07000030
34007cc4:	07000430 	.word	0x07000430
34007cc8:	07000830 	.word	0x07000830
34007ccc:	07000c30 	.word	0x07000c30
34007cd0:	07001030 	.word	0x07001030
34007cd4:	07001430 	.word	0x07001430
34007cd8:	07001830 	.word	0x07001830
34007cdc:	07001c30 	.word	0x07001c30
34007ce0:	07000034 	.word	0x07000034
34007ce4:	07000434 	.word	0x07000434
34007ce8:	03000c14 	.word	0x03000c14
34007cec:	01001014 	.word	0x01001014
34007cf0:	03001414 	.word	0x03001414
34007cf4:	01001814 	.word	0x01001814
34007cf8:	03000014 	.word	0x03000014
34007cfc:	03000414 	.word	0x03000414
34007d00:	03000814 	.word	0x03000814

34007d04 <HAL_RCCEx_GetPLL1CLKFreq>:
  * @brief  Return PLL1 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL1 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL1CLKFreq(void)
{
34007d04:	b5f0      	push	{r4, r5, r6, r7, lr}
34007d06:	b087      	sub	sp, #28
34007d08:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
34007d0a:	2300      	movs	r3, #0
34007d0c:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL1_IsReady() != 0U)
34007d0e:	f7fc fa05 	bl	3400411c <LL_RCC_PLL1_IsReady>
34007d12:	4603      	mov	r3, r0
34007d14:	2b00      	cmp	r3, #0
34007d16:	d02a      	beq.n	34007d6e <HAL_RCCEx_GetPLL1CLKFreq+0x6a>
  {
    if (LL_RCC_PLL1P_IsEnabled() != 0U)
34007d18:	f7fc fa68 	bl	340041ec <LL_RCC_PLL1P_IsEnabled>
34007d1c:	4603      	mov	r3, r0
34007d1e:	2b00      	cmp	r3, #0
34007d20:	d031      	beq.n	34007d86 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
34007d22:	f7fc f9ed 	bl	34004100 <LL_RCC_PLL1_GetSource>
34007d26:	4603      	mov	r3, r0
34007d28:	4618      	mov	r0, r3
34007d2a:	f000 f957 	bl	34007fdc <RCCEx_GetPLLSourceFreq>
34007d2e:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
34007d30:	68bb      	ldr	r3, [r7, #8]
34007d32:	2b00      	cmp	r3, #0
34007d34:	d027      	beq.n	34007d86 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
      {
        divm = LL_RCC_PLL1_GetM();
34007d36:	f7fc fa29 	bl	3400418c <LL_RCC_PLL1_GetM>
34007d3a:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
34007d3c:	687b      	ldr	r3, [r7, #4]
34007d3e:	2b00      	cmp	r3, #0
34007d40:	d021      	beq.n	34007d86 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL1_GetN(), LL_RCC_PLL1_GetFRACN(), \
34007d42:	f7fc fa13 	bl	3400416c <LL_RCC_PLL1_GetN>
34007d46:	4605      	mov	r5, r0
34007d48:	f7fc fa64 	bl	34004214 <LL_RCC_PLL1_GetFRACN>
34007d4c:	4606      	mov	r6, r0
34007d4e:	f7fc fa2d 	bl	340041ac <LL_RCC_PLL1_GetP1>
34007d52:	4604      	mov	r4, r0
34007d54:	f7fc fa3a 	bl	340041cc <LL_RCC_PLL1_GetP2>
34007d58:	4603      	mov	r3, r0
34007d5a:	9301      	str	r3, [sp, #4]
34007d5c:	9400      	str	r4, [sp, #0]
34007d5e:	4633      	mov	r3, r6
34007d60:	462a      	mov	r2, r5
34007d62:	6879      	ldr	r1, [r7, #4]
34007d64:	68b8      	ldr	r0, [r7, #8]
34007d66:	f000 f997 	bl	34008098 <RCCEx_CalcPLLFreq>
34007d6a:	60f8      	str	r0, [r7, #12]
34007d6c:	e00b      	b.n	34007d86 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
                                            LL_RCC_PLL1_GetP1(), LL_RCC_PLL1_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL1_IsEnabledBypass() != 0U)
34007d6e:	f7fc f9e9 	bl	34004144 <LL_RCC_PLL1_IsEnabledBypass>
34007d72:	4603      	mov	r3, r0
34007d74:	2b00      	cmp	r3, #0
34007d76:	d006      	beq.n	34007d86 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
34007d78:	f7fc f9c2 	bl	34004100 <LL_RCC_PLL1_GetSource>
34007d7c:	4603      	mov	r3, r0
34007d7e:	4618      	mov	r0, r3
34007d80:	f000 f92c 	bl	34007fdc <RCCEx_GetPLLSourceFreq>
34007d84:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
34007d86:	68fb      	ldr	r3, [r7, #12]
}
34007d88:	4618      	mov	r0, r3
34007d8a:	3714      	adds	r7, #20
34007d8c:	46bd      	mov	sp, r7
34007d8e:	bdf0      	pop	{r4, r5, r6, r7, pc}

34007d90 <HAL_RCCEx_GetPLL2CLKFreq>:
  * @brief  Return PLL2 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL2 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL2CLKFreq(void)
{
34007d90:	b5f0      	push	{r4, r5, r6, r7, lr}
34007d92:	b087      	sub	sp, #28
34007d94:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
34007d96:	2300      	movs	r3, #0
34007d98:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL2_IsReady() != 0U)
34007d9a:	f7fc fa57 	bl	3400424c <LL_RCC_PLL2_IsReady>
34007d9e:	4603      	mov	r3, r0
34007da0:	2b00      	cmp	r3, #0
34007da2:	d02a      	beq.n	34007dfa <HAL_RCCEx_GetPLL2CLKFreq+0x6a>
  {
    if (LL_RCC_PLL2P_IsEnabled() != 0U)
34007da4:	f7fc faba 	bl	3400431c <LL_RCC_PLL2P_IsEnabled>
34007da8:	4603      	mov	r3, r0
34007daa:	2b00      	cmp	r3, #0
34007dac:	d031      	beq.n	34007e12 <HAL_RCCEx_GetPLL2CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
34007dae:	f7fc fa3f 	bl	34004230 <LL_RCC_PLL2_GetSource>
34007db2:	4603      	mov	r3, r0
34007db4:	4618      	mov	r0, r3
34007db6:	f000 f911 	bl	34007fdc <RCCEx_GetPLLSourceFreq>
34007dba:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
34007dbc:	68bb      	ldr	r3, [r7, #8]
34007dbe:	2b00      	cmp	r3, #0
34007dc0:	d027      	beq.n	34007e12 <HAL_RCCEx_GetPLL2CLKFreq+0x82>
      {

        divm = LL_RCC_PLL2_GetM();
34007dc2:	f7fc fa7b 	bl	340042bc <LL_RCC_PLL2_GetM>
34007dc6:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
34007dc8:	687b      	ldr	r3, [r7, #4]
34007dca:	2b00      	cmp	r3, #0
34007dcc:	d021      	beq.n	34007e12 <HAL_RCCEx_GetPLL2CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL2_GetN(), LL_RCC_PLL2_GetFRACN(), \
34007dce:	f7fc fa65 	bl	3400429c <LL_RCC_PLL2_GetN>
34007dd2:	4605      	mov	r5, r0
34007dd4:	f7fc fab6 	bl	34004344 <LL_RCC_PLL2_GetFRACN>
34007dd8:	4606      	mov	r6, r0
34007dda:	f7fc fa7f 	bl	340042dc <LL_RCC_PLL2_GetP1>
34007dde:	4604      	mov	r4, r0
34007de0:	f7fc fa8c 	bl	340042fc <LL_RCC_PLL2_GetP2>
34007de4:	4603      	mov	r3, r0
34007de6:	9301      	str	r3, [sp, #4]
34007de8:	9400      	str	r4, [sp, #0]
34007dea:	4633      	mov	r3, r6
34007dec:	462a      	mov	r2, r5
34007dee:	6879      	ldr	r1, [r7, #4]
34007df0:	68b8      	ldr	r0, [r7, #8]
34007df2:	f000 f951 	bl	34008098 <RCCEx_CalcPLLFreq>
34007df6:	60f8      	str	r0, [r7, #12]
34007df8:	e00b      	b.n	34007e12 <HAL_RCCEx_GetPLL2CLKFreq+0x82>
                                            LL_RCC_PLL2_GetP1(), LL_RCC_PLL2_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL2_IsEnabledBypass() != 0U)
34007dfa:	f7fc fa3b 	bl	34004274 <LL_RCC_PLL2_IsEnabledBypass>
34007dfe:	4603      	mov	r3, r0
34007e00:	2b00      	cmp	r3, #0
34007e02:	d006      	beq.n	34007e12 <HAL_RCCEx_GetPLL2CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
34007e04:	f7fc fa14 	bl	34004230 <LL_RCC_PLL2_GetSource>
34007e08:	4603      	mov	r3, r0
34007e0a:	4618      	mov	r0, r3
34007e0c:	f000 f8e6 	bl	34007fdc <RCCEx_GetPLLSourceFreq>
34007e10:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
34007e12:	68fb      	ldr	r3, [r7, #12]
}
34007e14:	4618      	mov	r0, r3
34007e16:	3714      	adds	r7, #20
34007e18:	46bd      	mov	sp, r7
34007e1a:	bdf0      	pop	{r4, r5, r6, r7, pc}

34007e1c <HAL_RCCEx_GetPLL3CLKFreq>:
  * @brief  Return PLL3 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL3 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL3CLKFreq(void)
{
34007e1c:	b5f0      	push	{r4, r5, r6, r7, lr}
34007e1e:	b087      	sub	sp, #28
34007e20:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
34007e22:	2300      	movs	r3, #0
34007e24:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL3_IsReady() != 0U)
34007e26:	f7fc faa9 	bl	3400437c <LL_RCC_PLL3_IsReady>
34007e2a:	4603      	mov	r3, r0
34007e2c:	2b00      	cmp	r3, #0
34007e2e:	d02a      	beq.n	34007e86 <HAL_RCCEx_GetPLL3CLKFreq+0x6a>
  {
    if (LL_RCC_PLL3P_IsEnabled() != 0U)
34007e30:	f7fc fb0c 	bl	3400444c <LL_RCC_PLL3P_IsEnabled>
34007e34:	4603      	mov	r3, r0
34007e36:	2b00      	cmp	r3, #0
34007e38:	d031      	beq.n	34007e9e <HAL_RCCEx_GetPLL3CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
34007e3a:	f7fc fa91 	bl	34004360 <LL_RCC_PLL3_GetSource>
34007e3e:	4603      	mov	r3, r0
34007e40:	4618      	mov	r0, r3
34007e42:	f000 f8cb 	bl	34007fdc <RCCEx_GetPLLSourceFreq>
34007e46:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
34007e48:	68bb      	ldr	r3, [r7, #8]
34007e4a:	2b00      	cmp	r3, #0
34007e4c:	d027      	beq.n	34007e9e <HAL_RCCEx_GetPLL3CLKFreq+0x82>
      {
        divm = LL_RCC_PLL3_GetM();
34007e4e:	f7fc facd 	bl	340043ec <LL_RCC_PLL3_GetM>
34007e52:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
34007e54:	687b      	ldr	r3, [r7, #4]
34007e56:	2b00      	cmp	r3, #0
34007e58:	d021      	beq.n	34007e9e <HAL_RCCEx_GetPLL3CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL3_GetN(), LL_RCC_PLL3_GetFRACN(), \
34007e5a:	f7fc fab7 	bl	340043cc <LL_RCC_PLL3_GetN>
34007e5e:	4605      	mov	r5, r0
34007e60:	f7fc fb08 	bl	34004474 <LL_RCC_PLL3_GetFRACN>
34007e64:	4606      	mov	r6, r0
34007e66:	f7fc fad1 	bl	3400440c <LL_RCC_PLL3_GetP1>
34007e6a:	4604      	mov	r4, r0
34007e6c:	f7fc fade 	bl	3400442c <LL_RCC_PLL3_GetP2>
34007e70:	4603      	mov	r3, r0
34007e72:	9301      	str	r3, [sp, #4]
34007e74:	9400      	str	r4, [sp, #0]
34007e76:	4633      	mov	r3, r6
34007e78:	462a      	mov	r2, r5
34007e7a:	6879      	ldr	r1, [r7, #4]
34007e7c:	68b8      	ldr	r0, [r7, #8]
34007e7e:	f000 f90b 	bl	34008098 <RCCEx_CalcPLLFreq>
34007e82:	60f8      	str	r0, [r7, #12]
34007e84:	e00b      	b.n	34007e9e <HAL_RCCEx_GetPLL3CLKFreq+0x82>
                                            LL_RCC_PLL3_GetP1(), LL_RCC_PLL3_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL3_IsEnabledBypass() != 0U)
34007e86:	f7fc fa8d 	bl	340043a4 <LL_RCC_PLL3_IsEnabledBypass>
34007e8a:	4603      	mov	r3, r0
34007e8c:	2b00      	cmp	r3, #0
34007e8e:	d006      	beq.n	34007e9e <HAL_RCCEx_GetPLL3CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
34007e90:	f7fc fa66 	bl	34004360 <LL_RCC_PLL3_GetSource>
34007e94:	4603      	mov	r3, r0
34007e96:	4618      	mov	r0, r3
34007e98:	f000 f8a0 	bl	34007fdc <RCCEx_GetPLLSourceFreq>
34007e9c:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
34007e9e:	68fb      	ldr	r3, [r7, #12]
}
34007ea0:	4618      	mov	r0, r3
34007ea2:	3714      	adds	r7, #20
34007ea4:	46bd      	mov	sp, r7
34007ea6:	bdf0      	pop	{r4, r5, r6, r7, pc}

34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>:
  * @brief  Return PLL4 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL4 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL4CLKFreq(void)
{
34007ea8:	b5f0      	push	{r4, r5, r6, r7, lr}
34007eaa:	b087      	sub	sp, #28
34007eac:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
34007eae:	2300      	movs	r3, #0
34007eb0:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL4_IsReady() != 0U)
34007eb2:	f7fc fafb 	bl	340044ac <LL_RCC_PLL4_IsReady>
34007eb6:	4603      	mov	r3, r0
34007eb8:	2b00      	cmp	r3, #0
34007eba:	d02a      	beq.n	34007f12 <HAL_RCCEx_GetPLL4CLKFreq+0x6a>
  {
    if (LL_RCC_PLL4P_IsEnabled() != 0U)
34007ebc:	f7fc fb5e 	bl	3400457c <LL_RCC_PLL4P_IsEnabled>
34007ec0:	4603      	mov	r3, r0
34007ec2:	2b00      	cmp	r3, #0
34007ec4:	d031      	beq.n	34007f2a <HAL_RCCEx_GetPLL4CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
34007ec6:	f7fc fae3 	bl	34004490 <LL_RCC_PLL4_GetSource>
34007eca:	4603      	mov	r3, r0
34007ecc:	4618      	mov	r0, r3
34007ece:	f000 f885 	bl	34007fdc <RCCEx_GetPLLSourceFreq>
34007ed2:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
34007ed4:	68bb      	ldr	r3, [r7, #8]
34007ed6:	2b00      	cmp	r3, #0
34007ed8:	d027      	beq.n	34007f2a <HAL_RCCEx_GetPLL4CLKFreq+0x82>
      {

        divm = LL_RCC_PLL4_GetM();
34007eda:	f7fc fb1f 	bl	3400451c <LL_RCC_PLL4_GetM>
34007ede:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
34007ee0:	687b      	ldr	r3, [r7, #4]
34007ee2:	2b00      	cmp	r3, #0
34007ee4:	d021      	beq.n	34007f2a <HAL_RCCEx_GetPLL4CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL4_GetN(), LL_RCC_PLL4_GetFRACN(), \
34007ee6:	f7fc fb09 	bl	340044fc <LL_RCC_PLL4_GetN>
34007eea:	4605      	mov	r5, r0
34007eec:	f7fc fb5a 	bl	340045a4 <LL_RCC_PLL4_GetFRACN>
34007ef0:	4606      	mov	r6, r0
34007ef2:	f7fc fb23 	bl	3400453c <LL_RCC_PLL4_GetP1>
34007ef6:	4604      	mov	r4, r0
34007ef8:	f7fc fb30 	bl	3400455c <LL_RCC_PLL4_GetP2>
34007efc:	4603      	mov	r3, r0
34007efe:	9301      	str	r3, [sp, #4]
34007f00:	9400      	str	r4, [sp, #0]
34007f02:	4633      	mov	r3, r6
34007f04:	462a      	mov	r2, r5
34007f06:	6879      	ldr	r1, [r7, #4]
34007f08:	68b8      	ldr	r0, [r7, #8]
34007f0a:	f000 f8c5 	bl	34008098 <RCCEx_CalcPLLFreq>
34007f0e:	60f8      	str	r0, [r7, #12]
34007f10:	e00b      	b.n	34007f2a <HAL_RCCEx_GetPLL4CLKFreq+0x82>
                                            LL_RCC_PLL4_GetP1(), LL_RCC_PLL4_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL4_IsEnabledBypass() != 0U)
34007f12:	f7fc fadf 	bl	340044d4 <LL_RCC_PLL4_IsEnabledBypass>
34007f16:	4603      	mov	r3, r0
34007f18:	2b00      	cmp	r3, #0
34007f1a:	d006      	beq.n	34007f2a <HAL_RCCEx_GetPLL4CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
34007f1c:	f7fc fab8 	bl	34004490 <LL_RCC_PLL4_GetSource>
34007f20:	4603      	mov	r3, r0
34007f22:	4618      	mov	r0, r3
34007f24:	f000 f85a 	bl	34007fdc <RCCEx_GetPLLSourceFreq>
34007f28:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
34007f2a:	68fb      	ldr	r3, [r7, #12]
}
34007f2c:	4618      	mov	r0, r3
34007f2e:	3714      	adds	r7, #20
34007f30:	46bd      	mov	sp, r7
34007f32:	bdf0      	pop	{r4, r5, r6, r7, pc}

34007f34 <RCCEx_GetHCLKFreq>:
  * @brief  Return HCLK clock frequency
  * @param  SYSCLK_Frequency SYSCLK clock frequency
  * @retval HCLK clock frequency (in Hz)
  */
static uint32_t RCCEx_GetHCLKFreq(uint32_t SYSCLK_Frequency)
{
34007f34:	b580      	push	{r7, lr}
34007f36:	b082      	sub	sp, #8
34007f38:	af00      	add	r7, sp, #0
34007f3a:	6078      	str	r0, [r7, #4]
  /* HCLK clock frequency */
  return LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
34007f3c:	f7fb fcca 	bl	340038d4 <LL_RCC_GetAHBPrescaler>
34007f40:	4603      	mov	r3, r0
34007f42:	0d1b      	lsrs	r3, r3, #20
34007f44:	f003 0307 	and.w	r3, r3, #7
34007f48:	687a      	ldr	r2, [r7, #4]
34007f4a:	fa22 f303 	lsr.w	r3, r2, r3
}
34007f4e:	4618      	mov	r0, r3
34007f50:	3708      	adds	r7, #8
34007f52:	46bd      	mov	sp, r7
34007f54:	bd80      	pop	{r7, pc}

34007f56 <RCCEx_GetPCLK1Freq>:
  * @brief  Return PCLK1 clock frequency
  * @param  HCLK_Frequency HCLK clock frequency
  * @retval PCLK1 clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPCLK1Freq(uint32_t HCLK_Frequency)
{
34007f56:	b580      	push	{r7, lr}
34007f58:	b082      	sub	sp, #8
34007f5a:	af00      	add	r7, sp, #0
34007f5c:	6078      	str	r0, [r7, #4]
  /* PCLK1 clock frequency */
  return LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());
34007f5e:	f7fb fcc7 	bl	340038f0 <LL_RCC_GetAPB1Prescaler>
34007f62:	4603      	mov	r3, r0
34007f64:	f003 0307 	and.w	r3, r3, #7
34007f68:	687a      	ldr	r2, [r7, #4]
34007f6a:	fa22 f303 	lsr.w	r3, r2, r3
}
34007f6e:	4618      	mov	r0, r3
34007f70:	3708      	adds	r7, #8
34007f72:	46bd      	mov	sp, r7
34007f74:	bd80      	pop	{r7, pc}

34007f76 <RCCEx_GetPCLK2Freq>:
  * @brief  Return PCLK2 clock frequency
  * @param  HCLK_Frequency HCLK clock frequency
  * @retval PCLK2 clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPCLK2Freq(uint32_t HCLK_Frequency)
{
34007f76:	b580      	push	{r7, lr}
34007f78:	b082      	sub	sp, #8
34007f7a:	af00      	add	r7, sp, #0
34007f7c:	6078      	str	r0, [r7, #4]
  /* PCLK2 clock frequency */
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
34007f7e:	f7fb fcc5 	bl	3400390c <LL_RCC_GetAPB2Prescaler>
34007f82:	4603      	mov	r3, r0
34007f84:	091b      	lsrs	r3, r3, #4
34007f86:	f003 0307 	and.w	r3, r3, #7
34007f8a:	687a      	ldr	r2, [r7, #4]
34007f8c:	fa22 f303 	lsr.w	r3, r2, r3
}
34007f90:	4618      	mov	r0, r3
34007f92:	3708      	adds	r7, #8
34007f94:	46bd      	mov	sp, r7
34007f96:	bd80      	pop	{r7, pc}

34007f98 <RCCEx_GetPCLK4Freq>:
  * @brief  Return PCLK4 clock frequency
  * @param  HCLK_Frequency HCLK clock frequency
  * @retval PCLK4 clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPCLK4Freq(uint32_t HCLK_Frequency)
{
34007f98:	b580      	push	{r7, lr}
34007f9a:	b082      	sub	sp, #8
34007f9c:	af00      	add	r7, sp, #0
34007f9e:	6078      	str	r0, [r7, #4]
  /* PCLK4 clock frequency */
  return LL_RCC_CALC_PCLK4_FREQ(HCLK_Frequency, LL_RCC_GetAPB4Prescaler());
34007fa0:	f7fb fcc2 	bl	34003928 <LL_RCC_GetAPB4Prescaler>
34007fa4:	4603      	mov	r3, r0
34007fa6:	0b1b      	lsrs	r3, r3, #12
34007fa8:	f003 0307 	and.w	r3, r3, #7
34007fac:	687a      	ldr	r2, [r7, #4]
34007fae:	fa22 f303 	lsr.w	r3, r2, r3
}
34007fb2:	4618      	mov	r0, r3
34007fb4:	3708      	adds	r7, #8
34007fb6:	46bd      	mov	sp, r7
34007fb8:	bd80      	pop	{r7, pc}

34007fba <RCCEx_GetPCLK5Freq>:
  * @brief  Return PCLK5 clock frequency
  * @param  HCLK_Frequency HCLK clock frequency
  * @retval PCLK5 clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPCLK5Freq(uint32_t HCLK_Frequency)
{
34007fba:	b580      	push	{r7, lr}
34007fbc:	b082      	sub	sp, #8
34007fbe:	af00      	add	r7, sp, #0
34007fc0:	6078      	str	r0, [r7, #4]
  /* PCLK5 clock frequency */
  return LL_RCC_CALC_PCLK5_FREQ(HCLK_Frequency, LL_RCC_GetAPB5Prescaler());
34007fc2:	f7fb fcbf 	bl	34003944 <LL_RCC_GetAPB5Prescaler>
34007fc6:	4603      	mov	r3, r0
34007fc8:	0c1b      	lsrs	r3, r3, #16
34007fca:	f003 0307 	and.w	r3, r3, #7
34007fce:	687a      	ldr	r2, [r7, #4]
34007fd0:	fa22 f303 	lsr.w	r3, r2, r3
}
34007fd4:	4618      	mov	r0, r3
34007fd6:	3708      	adds	r7, #8
34007fd8:	46bd      	mov	sp, r7
34007fda:	bd80      	pop	{r7, pc}

34007fdc <RCCEx_GetPLLSourceFreq>:
  * @brief  Return PLL source clock frequency
  * @param  PLLsource PLL source clock
  * @retval PLL source clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPLLSourceFreq(uint32_t PLLsource)
{
34007fdc:	b580      	push	{r7, lr}
34007fde:	b084      	sub	sp, #16
34007fe0:	af00      	add	r7, sp, #0
34007fe2:	6078      	str	r0, [r7, #4]
  uint32_t pllinputfreq = RCC_PERIPH_FREQUENCY_NO;
34007fe4:	2300      	movs	r3, #0
34007fe6:	60fb      	str	r3, [r7, #12]

  switch (PLLsource)
34007fe8:	687b      	ldr	r3, [r7, #4]
34007fea:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34007fee:	d039      	beq.n	34008064 <RCCEx_GetPLLSourceFreq+0x88>
34007ff0:	687b      	ldr	r3, [r7, #4]
34007ff2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34007ff6:	d838      	bhi.n	3400806a <RCCEx_GetPLLSourceFreq+0x8e>
34007ff8:	687b      	ldr	r3, [r7, #4]
34007ffa:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34007ffe:	d029      	beq.n	34008054 <RCCEx_GetPLLSourceFreq+0x78>
34008000:	687b      	ldr	r3, [r7, #4]
34008002:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34008006:	d830      	bhi.n	3400806a <RCCEx_GetPLLSourceFreq+0x8e>
34008008:	687b      	ldr	r3, [r7, #4]
3400800a:	2b00      	cmp	r3, #0
3400800c:	d004      	beq.n	34008018 <RCCEx_GetPLLSourceFreq+0x3c>
3400800e:	687b      	ldr	r3, [r7, #4]
34008010:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34008014:	d00e      	beq.n	34008034 <RCCEx_GetPLLSourceFreq+0x58>
      pllinputfreq = EXTERNAL_CLOCK_VALUE;
      break;

    default:
      /* unexpected case */
      break;
34008016:	e028      	b.n	3400806a <RCCEx_GetPLLSourceFreq+0x8e>
      if (LL_RCC_HSI_IsReady() != 0U)
34008018:	f7fb fbfc 	bl	34003814 <LL_RCC_HSI_IsReady>
3400801c:	4603      	mov	r3, r0
3400801e:	2b00      	cmp	r3, #0
34008020:	d025      	beq.n	3400806e <RCCEx_GetPLLSourceFreq+0x92>
        pllinputfreq = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34008022:	f7fb fc09 	bl	34003838 <LL_RCC_HSI_GetDivider>
34008026:	4603      	mov	r3, r0
34008028:	09db      	lsrs	r3, r3, #7
3400802a:	4a16      	ldr	r2, [pc, #88]	@ (34008084 <RCCEx_GetPLLSourceFreq+0xa8>)
3400802c:	fa22 f303 	lsr.w	r3, r2, r3
34008030:	60fb      	str	r3, [r7, #12]
      break;
34008032:	e01c      	b.n	3400806e <RCCEx_GetPLLSourceFreq+0x92>
      if (LL_RCC_MSI_IsReady() != 0U)
34008034:	f7fb fc0e 	bl	34003854 <LL_RCC_MSI_IsReady>
34008038:	4603      	mov	r3, r0
3400803a:	2b00      	cmp	r3, #0
3400803c:	d019      	beq.n	34008072 <RCCEx_GetPLLSourceFreq+0x96>
        if (LL_RCC_MSI_GetFrequency() == LL_RCC_MSI_FREQ_4MHZ)
3400803e:	f7fb fc1b 	bl	34003878 <LL_RCC_MSI_GetFrequency>
34008042:	4603      	mov	r3, r0
34008044:	2b00      	cmp	r3, #0
34008046:	d102      	bne.n	3400804e <RCCEx_GetPLLSourceFreq+0x72>
          pllinputfreq = MSI_VALUE;
34008048:	4b0f      	ldr	r3, [pc, #60]	@ (34008088 <RCCEx_GetPLLSourceFreq+0xac>)
3400804a:	60fb      	str	r3, [r7, #12]
      break;
3400804c:	e011      	b.n	34008072 <RCCEx_GetPLLSourceFreq+0x96>
          pllinputfreq = 16000000UL;
3400804e:	4b0f      	ldr	r3, [pc, #60]	@ (3400808c <RCCEx_GetPLLSourceFreq+0xb0>)
34008050:	60fb      	str	r3, [r7, #12]
      break;
34008052:	e00e      	b.n	34008072 <RCCEx_GetPLLSourceFreq+0x96>
      if (LL_RCC_HSE_IsReady() != 0U)
34008054:	f7fb fbcc 	bl	340037f0 <LL_RCC_HSE_IsReady>
34008058:	4603      	mov	r3, r0
3400805a:	2b00      	cmp	r3, #0
3400805c:	d00b      	beq.n	34008076 <RCCEx_GetPLLSourceFreq+0x9a>
        pllinputfreq = HSE_VALUE;
3400805e:	4b0c      	ldr	r3, [pc, #48]	@ (34008090 <RCCEx_GetPLLSourceFreq+0xb4>)
34008060:	60fb      	str	r3, [r7, #12]
      break;
34008062:	e008      	b.n	34008076 <RCCEx_GetPLLSourceFreq+0x9a>
      pllinputfreq = EXTERNAL_CLOCK_VALUE;
34008064:	4b0b      	ldr	r3, [pc, #44]	@ (34008094 <RCCEx_GetPLLSourceFreq+0xb8>)
34008066:	60fb      	str	r3, [r7, #12]
      break;
34008068:	e006      	b.n	34008078 <RCCEx_GetPLLSourceFreq+0x9c>
      break;
3400806a:	bf00      	nop
3400806c:	e004      	b.n	34008078 <RCCEx_GetPLLSourceFreq+0x9c>
      break;
3400806e:	bf00      	nop
34008070:	e002      	b.n	34008078 <RCCEx_GetPLLSourceFreq+0x9c>
      break;
34008072:	bf00      	nop
34008074:	e000      	b.n	34008078 <RCCEx_GetPLLSourceFreq+0x9c>
      break;
34008076:	bf00      	nop
  }

  return pllinputfreq;
34008078:	68fb      	ldr	r3, [r7, #12]
}
3400807a:	4618      	mov	r0, r3
3400807c:	3710      	adds	r7, #16
3400807e:	46bd      	mov	sp, r7
34008080:	bd80      	pop	{r7, pc}
34008082:	bf00      	nop
34008084:	03d09000 	.word	0x03d09000
34008088:	003d0900 	.word	0x003d0900
3400808c:	00f42400 	.word	0x00f42400
34008090:	016e3600 	.word	0x016e3600
34008094:	00bb8000 	.word	0x00bb8000

34008098 <RCCEx_CalcPLLFreq>:
  * @param  P2     VCO output divider P2 between 1 and 7
  * @retval PLL clock frequency (in Hz)
  */
static uint32_t RCCEx_CalcPLLFreq(uint32_t PLLInputFreq, uint32_t M, uint32_t N, uint32_t FRACN, uint32_t P1,
                                  uint32_t P2)
{
34008098:	b480      	push	{r7}
3400809a:	b087      	sub	sp, #28
3400809c:	af00      	add	r7, sp, #0
3400809e:	60f8      	str	r0, [r7, #12]
340080a0:	60b9      	str	r1, [r7, #8]
340080a2:	607a      	str	r2, [r7, #4]
340080a4:	603b      	str	r3, [r7, #0]
  float_t freq;

  freq = ((float_t)PLLInputFreq * ((float_t)N + ((float_t)FRACN / (float_t)0x1000000))) / (float_t)M;
340080a6:	68fb      	ldr	r3, [r7, #12]
340080a8:	ee07 3a90 	vmov	s15, r3
340080ac:	eeb8 7a67 	vcvt.f32.u32	s14, s15
340080b0:	687b      	ldr	r3, [r7, #4]
340080b2:	ee07 3a90 	vmov	s15, r3
340080b6:	eef8 6a67 	vcvt.f32.u32	s13, s15
340080ba:	683b      	ldr	r3, [r7, #0]
340080bc:	ee07 3a90 	vmov	s15, r3
340080c0:	eeb8 6a67 	vcvt.f32.u32	s12, s15
340080c4:	eddf 5a19 	vldr	s11, [pc, #100]	@ 3400812c <RCCEx_CalcPLLFreq+0x94>
340080c8:	eec6 7a25 	vdiv.f32	s15, s12, s11
340080cc:	ee76 7aa7 	vadd.f32	s15, s13, s15
340080d0:	ee67 6a27 	vmul.f32	s13, s14, s15
340080d4:	68bb      	ldr	r3, [r7, #8]
340080d6:	ee07 3a90 	vmov	s15, r3
340080da:	eeb8 7a67 	vcvt.f32.u32	s14, s15
340080de:	eec6 7a87 	vdiv.f32	s15, s13, s14
340080e2:	edc7 7a05 	vstr	s15, [r7, #20]

  freq = freq / (float_t)P1;
340080e6:	6a3b      	ldr	r3, [r7, #32]
340080e8:	ee07 3a90 	vmov	s15, r3
340080ec:	eeb8 7a67 	vcvt.f32.u32	s14, s15
340080f0:	edd7 6a05 	vldr	s13, [r7, #20]
340080f4:	eec6 7a87 	vdiv.f32	s15, s13, s14
340080f8:	edc7 7a05 	vstr	s15, [r7, #20]
  freq = freq / (float_t)P2;
340080fc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
340080fe:	ee07 3a90 	vmov	s15, r3
34008102:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34008106:	edd7 6a05 	vldr	s13, [r7, #20]
3400810a:	eec6 7a87 	vdiv.f32	s15, s13, s14
3400810e:	edc7 7a05 	vstr	s15, [r7, #20]

  return (uint32_t)freq;
34008112:	edd7 7a05 	vldr	s15, [r7, #20]
34008116:	eefc 7ae7 	vcvt.u32.f32	s15, s15
3400811a:	ee17 3a90 	vmov	r3, s15
}
3400811e:	4618      	mov	r0, r3
34008120:	371c      	adds	r7, #28
34008122:	46bd      	mov	sp, r7
34008124:	f85d 7b04 	ldr.w	r7, [sp], #4
34008128:	4770      	bx	lr
3400812a:	bf00      	nop
3400812c:	4b800000 	.word	0x4b800000

34008130 <RCCEx_GetADCCLKFreq>:
  *         @arg @ref RCCEx_ADC_Clock_Source
  * @retval ADC clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetADCCLKFreq(uint32_t ADCxSource)
{
34008130:	b590      	push	{r4, r7, lr}
34008132:	b085      	sub	sp, #20
34008134:	af00      	add	r7, sp, #0
34008136:	6078      	str	r0, [r7, #4]
  uint32_t adc_frequency = RCC_PERIPH_FREQUENCY_NO;
34008138:	2300      	movs	r3, #0
3400813a:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetADCClockSource(ADCxSource))
3400813c:	6878      	ldr	r0, [r7, #4]
3400813e:	f7fb fe1f 	bl	34003d80 <LL_RCC_GetADCClockSource>
34008142:	4603      	mov	r3, r0
34008144:	2b70      	cmp	r3, #112	@ 0x70
34008146:	f000 80d1 	beq.w	340082ec <RCCEx_GetADCCLKFreq+0x1bc>
3400814a:	2b70      	cmp	r3, #112	@ 0x70
3400814c:	f200 80d8 	bhi.w	34008300 <RCCEx_GetADCCLKFreq+0x1d0>
34008150:	2b60      	cmp	r3, #96	@ 0x60
34008152:	f000 80c8 	beq.w	340082e6 <RCCEx_GetADCCLKFreq+0x1b6>
34008156:	2b60      	cmp	r3, #96	@ 0x60
34008158:	f200 80d2 	bhi.w	34008300 <RCCEx_GetADCCLKFreq+0x1d0>
3400815c:	2b50      	cmp	r3, #80	@ 0x50
3400815e:	f000 80ac 	beq.w	340082ba <RCCEx_GetADCCLKFreq+0x18a>
34008162:	2b50      	cmp	r3, #80	@ 0x50
34008164:	f200 80cc 	bhi.w	34008300 <RCCEx_GetADCCLKFreq+0x1d0>
34008168:	2b40      	cmp	r3, #64	@ 0x40
3400816a:	f000 80b4 	beq.w	340082d6 <RCCEx_GetADCCLKFreq+0x1a6>
3400816e:	2b40      	cmp	r3, #64	@ 0x40
34008170:	f200 80c6 	bhi.w	34008300 <RCCEx_GetADCCLKFreq+0x1d0>
34008174:	2b30      	cmp	r3, #48	@ 0x30
34008176:	d05d      	beq.n	34008234 <RCCEx_GetADCCLKFreq+0x104>
34008178:	2b30      	cmp	r3, #48	@ 0x30
3400817a:	f200 80c1 	bhi.w	34008300 <RCCEx_GetADCCLKFreq+0x1d0>
3400817e:	2b20      	cmp	r3, #32
34008180:	d014      	beq.n	340081ac <RCCEx_GetADCCLKFreq+0x7c>
34008182:	2b20      	cmp	r3, #32
34008184:	f200 80bc 	bhi.w	34008300 <RCCEx_GetADCCLKFreq+0x1d0>
34008188:	2b00      	cmp	r3, #0
3400818a:	d002      	beq.n	34008192 <RCCEx_GetADCCLKFreq+0x62>
3400818c:	2b10      	cmp	r3, #16
3400818e:	d008      	beq.n	340081a2 <RCCEx_GetADCCLKFreq+0x72>
      adc_frequency = LL_RCC_CALC_TIMG_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetTIMPrescaler());
      break;

    default:
      /* Unexpected case */
      break;
34008190:	e0b6      	b.n	34008300 <RCCEx_GetADCCLKFreq+0x1d0>
      adc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34008192:	f7fb fa69 	bl	34003668 <HAL_RCC_GetSysClockFreq>
34008196:	4603      	mov	r3, r0
34008198:	4618      	mov	r0, r3
3400819a:	f7ff fecb 	bl	34007f34 <RCCEx_GetHCLKFreq>
3400819e:	60f8      	str	r0, [r7, #12]
      break;
340081a0:	e0b7      	b.n	34008312 <RCCEx_GetADCCLKFreq+0x1e2>
      adc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
340081a2:	2007      	movs	r0, #7
340081a4:	f000 f9b2 	bl	3400850c <RCCEx_GetCLKPCLKFreq>
340081a8:	60f8      	str	r0, [r7, #12]
      break;
340081aa:	e0b2      	b.n	34008312 <RCCEx_GetADCCLKFreq+0x1e2>
      if (LL_RCC_IC7_IsEnabled() != 0U)
340081ac:	f7fc fad6 	bl	3400475c <LL_RCC_IC7_IsEnabled>
340081b0:	4603      	mov	r3, r0
340081b2:	2b00      	cmp	r3, #0
340081b4:	f000 80a6 	beq.w	34008304 <RCCEx_GetADCCLKFreq+0x1d4>
        ic_divider = LL_RCC_IC7_GetDivider();
340081b8:	f7fc faf2 	bl	340047a0 <LL_RCC_IC7_GetDivider>
340081bc:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC7_GetSource())
340081be:	f7fc fae1 	bl	34004784 <LL_RCC_IC7_GetSource>
340081c2:	4603      	mov	r3, r0
340081c4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340081c8:	d029      	beq.n	3400821e <RCCEx_GetADCCLKFreq+0xee>
340081ca:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340081ce:	d82f      	bhi.n	34008230 <RCCEx_GetADCCLKFreq+0x100>
340081d0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340081d4:	d01a      	beq.n	3400820c <RCCEx_GetADCCLKFreq+0xdc>
340081d6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340081da:	d829      	bhi.n	34008230 <RCCEx_GetADCCLKFreq+0x100>
340081dc:	2b00      	cmp	r3, #0
340081de:	d003      	beq.n	340081e8 <RCCEx_GetADCCLKFreq+0xb8>
340081e0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340081e4:	d009      	beq.n	340081fa <RCCEx_GetADCCLKFreq+0xca>
            break;
340081e6:	e023      	b.n	34008230 <RCCEx_GetADCCLKFreq+0x100>
            adc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340081e8:	f7ff fd8c 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
340081ec:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
340081ee:	68fa      	ldr	r2, [r7, #12]
340081f0:	68bb      	ldr	r3, [r7, #8]
340081f2:	fbb2 f3f3 	udiv	r3, r2, r3
340081f6:	60fb      	str	r3, [r7, #12]
            break;
340081f8:	e01b      	b.n	34008232 <RCCEx_GetADCCLKFreq+0x102>
            adc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340081fa:	f7ff fdc9 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
340081fe:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34008200:	68fa      	ldr	r2, [r7, #12]
34008202:	68bb      	ldr	r3, [r7, #8]
34008204:	fbb2 f3f3 	udiv	r3, r2, r3
34008208:	60fb      	str	r3, [r7, #12]
            break;
3400820a:	e012      	b.n	34008232 <RCCEx_GetADCCLKFreq+0x102>
            adc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400820c:	f7ff fe06 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
34008210:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34008212:	68fa      	ldr	r2, [r7, #12]
34008214:	68bb      	ldr	r3, [r7, #8]
34008216:	fbb2 f3f3 	udiv	r3, r2, r3
3400821a:	60fb      	str	r3, [r7, #12]
            break;
3400821c:	e009      	b.n	34008232 <RCCEx_GetADCCLKFreq+0x102>
            adc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400821e:	f7ff fe43 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
34008222:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34008224:	68fa      	ldr	r2, [r7, #12]
34008226:	68bb      	ldr	r3, [r7, #8]
34008228:	fbb2 f3f3 	udiv	r3, r2, r3
3400822c:	60fb      	str	r3, [r7, #12]
            break;
3400822e:	e000      	b.n	34008232 <RCCEx_GetADCCLKFreq+0x102>
            break;
34008230:	bf00      	nop
      break;
34008232:	e067      	b.n	34008304 <RCCEx_GetADCCLKFreq+0x1d4>
      if (LL_RCC_IC8_IsEnabled() != 0U)
34008234:	f7fc fad2 	bl	340047dc <LL_RCC_IC8_IsEnabled>
34008238:	4603      	mov	r3, r0
3400823a:	2b00      	cmp	r3, #0
3400823c:	d064      	beq.n	34008308 <RCCEx_GetADCCLKFreq+0x1d8>
        ic_divider = LL_RCC_IC8_GetDivider();
3400823e:	f7fc faef 	bl	34004820 <LL_RCC_IC8_GetDivider>
34008242:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
34008244:	f7fc fade 	bl	34004804 <LL_RCC_IC8_GetSource>
34008248:	4603      	mov	r3, r0
3400824a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400824e:	d029      	beq.n	340082a4 <RCCEx_GetADCCLKFreq+0x174>
34008250:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34008254:	d82f      	bhi.n	340082b6 <RCCEx_GetADCCLKFreq+0x186>
34008256:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400825a:	d01a      	beq.n	34008292 <RCCEx_GetADCCLKFreq+0x162>
3400825c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34008260:	d829      	bhi.n	340082b6 <RCCEx_GetADCCLKFreq+0x186>
34008262:	2b00      	cmp	r3, #0
34008264:	d003      	beq.n	3400826e <RCCEx_GetADCCLKFreq+0x13e>
34008266:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400826a:	d009      	beq.n	34008280 <RCCEx_GetADCCLKFreq+0x150>
            break;
3400826c:	e023      	b.n	340082b6 <RCCEx_GetADCCLKFreq+0x186>
            adc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400826e:	f7ff fd49 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
34008272:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34008274:	68fa      	ldr	r2, [r7, #12]
34008276:	68bb      	ldr	r3, [r7, #8]
34008278:	fbb2 f3f3 	udiv	r3, r2, r3
3400827c:	60fb      	str	r3, [r7, #12]
            break;
3400827e:	e01b      	b.n	340082b8 <RCCEx_GetADCCLKFreq+0x188>
            adc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34008280:	f7ff fd86 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
34008284:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34008286:	68fa      	ldr	r2, [r7, #12]
34008288:	68bb      	ldr	r3, [r7, #8]
3400828a:	fbb2 f3f3 	udiv	r3, r2, r3
3400828e:	60fb      	str	r3, [r7, #12]
            break;
34008290:	e012      	b.n	340082b8 <RCCEx_GetADCCLKFreq+0x188>
            adc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34008292:	f7ff fdc3 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
34008296:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34008298:	68fa      	ldr	r2, [r7, #12]
3400829a:	68bb      	ldr	r3, [r7, #8]
3400829c:	fbb2 f3f3 	udiv	r3, r2, r3
340082a0:	60fb      	str	r3, [r7, #12]
            break;
340082a2:	e009      	b.n	340082b8 <RCCEx_GetADCCLKFreq+0x188>
            adc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340082a4:	f7ff fe00 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
340082a8:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
340082aa:	68fa      	ldr	r2, [r7, #12]
340082ac:	68bb      	ldr	r3, [r7, #8]
340082ae:	fbb2 f3f3 	udiv	r3, r2, r3
340082b2:	60fb      	str	r3, [r7, #12]
            break;
340082b4:	e000      	b.n	340082b8 <RCCEx_GetADCCLKFreq+0x188>
            break;
340082b6:	bf00      	nop
      break;
340082b8:	e026      	b.n	34008308 <RCCEx_GetADCCLKFreq+0x1d8>
      if (LL_RCC_HSI_IsReady() != 0U)
340082ba:	f7fb faab 	bl	34003814 <LL_RCC_HSI_IsReady>
340082be:	4603      	mov	r3, r0
340082c0:	2b00      	cmp	r3, #0
340082c2:	d023      	beq.n	3400830c <RCCEx_GetADCCLKFreq+0x1dc>
        adc_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
340082c4:	f7fb fab8 	bl	34003838 <LL_RCC_HSI_GetDivider>
340082c8:	4603      	mov	r3, r0
340082ca:	09db      	lsrs	r3, r3, #7
340082cc:	4a16      	ldr	r2, [pc, #88]	@ (34008328 <RCCEx_GetADCCLKFreq+0x1f8>)
340082ce:	fa22 f303 	lsr.w	r3, r2, r3
340082d2:	60fb      	str	r3, [r7, #12]
      break;
340082d4:	e01a      	b.n	3400830c <RCCEx_GetADCCLKFreq+0x1dc>
      if (LL_RCC_MSI_IsReady() != 0U)
340082d6:	f7fb fabd 	bl	34003854 <LL_RCC_MSI_IsReady>
340082da:	4603      	mov	r3, r0
340082dc:	2b00      	cmp	r3, #0
340082de:	d017      	beq.n	34008310 <RCCEx_GetADCCLKFreq+0x1e0>
        adc_frequency = MSI_VALUE;
340082e0:	4b12      	ldr	r3, [pc, #72]	@ (3400832c <RCCEx_GetADCCLKFreq+0x1fc>)
340082e2:	60fb      	str	r3, [r7, #12]
      break;
340082e4:	e014      	b.n	34008310 <RCCEx_GetADCCLKFreq+0x1e0>
      adc_frequency = EXTERNAL_CLOCK_VALUE;
340082e6:	4b12      	ldr	r3, [pc, #72]	@ (34008330 <RCCEx_GetADCCLKFreq+0x200>)
340082e8:	60fb      	str	r3, [r7, #12]
      break;
340082ea:	e012      	b.n	34008312 <RCCEx_GetADCCLKFreq+0x1e2>
      adc_frequency = LL_RCC_CALC_TIMG_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetTIMPrescaler());
340082ec:	f7fb f9bc 	bl	34003668 <HAL_RCC_GetSysClockFreq>
340082f0:	4604      	mov	r4, r0
340082f2:	f7fb fef7 	bl	340040e4 <LL_RCC_GetTIMPrescaler>
340082f6:	4603      	mov	r3, r0
340082f8:	fa24 f303 	lsr.w	r3, r4, r3
340082fc:	60fb      	str	r3, [r7, #12]
      break;
340082fe:	e008      	b.n	34008312 <RCCEx_GetADCCLKFreq+0x1e2>
      break;
34008300:	bf00      	nop
34008302:	e006      	b.n	34008312 <RCCEx_GetADCCLKFreq+0x1e2>
      break;
34008304:	bf00      	nop
34008306:	e004      	b.n	34008312 <RCCEx_GetADCCLKFreq+0x1e2>
      break;
34008308:	bf00      	nop
3400830a:	e002      	b.n	34008312 <RCCEx_GetADCCLKFreq+0x1e2>
      break;
3400830c:	bf00      	nop
3400830e:	e000      	b.n	34008312 <RCCEx_GetADCCLKFreq+0x1e2>
      break;
34008310:	bf00      	nop
  }

  return (adc_frequency / __HAL_RCC_GET_ADC_DIVIDER());
34008312:	f7fb fb4f 	bl	340039b4 <LL_RCC_GetADCPrescaler>
34008316:	4603      	mov	r3, r0
34008318:	3301      	adds	r3, #1
3400831a:	68fa      	ldr	r2, [r7, #12]
3400831c:	fbb2 f3f3 	udiv	r3, r2, r3
}
34008320:	4618      	mov	r0, r3
34008322:	3714      	adds	r7, #20
34008324:	46bd      	mov	sp, r7
34008326:	bd90      	pop	{r4, r7, pc}
34008328:	03d09000 	.word	0x03d09000
3400832c:	003d0900 	.word	0x003d0900
34008330:	00bb8000 	.word	0x00bb8000

34008334 <RCCEx_GetADFCLKFreq>:
  *         @arg @ref RCCEx_ADF1_Clock_Source
  * @retval ADF clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetADFCLKFreq(uint32_t ADFxSource)
{
34008334:	b590      	push	{r4, r7, lr}
34008336:	b085      	sub	sp, #20
34008338:	af00      	add	r7, sp, #0
3400833a:	6078      	str	r0, [r7, #4]
  uint32_t adf_frequency = RCC_PERIPH_FREQUENCY_NO;
3400833c:	2300      	movs	r3, #0
3400833e:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetADFClockSource(ADFxSource))
34008340:	6878      	ldr	r0, [r7, #4]
34008342:	f7fb fd2f 	bl	34003da4 <LL_RCC_GetADFClockSource>
34008346:	4603      	mov	r3, r0
34008348:	2b07      	cmp	r3, #7
3400834a:	f200 80ca 	bhi.w	340084e2 <RCCEx_GetADFCLKFreq+0x1ae>
3400834e:	a201      	add	r2, pc, #4	@ (adr r2, 34008354 <RCCEx_GetADFCLKFreq+0x20>)
34008350:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34008354:	34008375 	.word	0x34008375
34008358:	34008385 	.word	0x34008385
3400835c:	3400838f 	.word	0x3400838f
34008360:	34008417 	.word	0x34008417
34008364:	340084b9 	.word	0x340084b9
34008368:	3400849d 	.word	0x3400849d
3400836c:	340084c9 	.word	0x340084c9
34008370:	340084cf 	.word	0x340084cf
  {
    case LL_RCC_ADF1_CLKSOURCE_HCLK:
      adf_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34008374:	f7fb f978 	bl	34003668 <HAL_RCC_GetSysClockFreq>
34008378:	4603      	mov	r3, r0
3400837a:	4618      	mov	r0, r3
3400837c:	f7ff fdda 	bl	34007f34 <RCCEx_GetHCLKFreq>
34008380:	60f8      	str	r0, [r7, #12]
      break;
34008382:	e0b7      	b.n	340084f4 <RCCEx_GetADFCLKFreq+0x1c0>

    case LL_RCC_ADF1_CLKSOURCE_CLKP:
      adf_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34008384:	2007      	movs	r0, #7
34008386:	f000 f8c1 	bl	3400850c <RCCEx_GetCLKPCLKFreq>
3400838a:	60f8      	str	r0, [r7, #12]
      break;
3400838c:	e0b2      	b.n	340084f4 <RCCEx_GetADFCLKFreq+0x1c0>

    case LL_RCC_ADF1_CLKSOURCE_IC7:
      if (LL_RCC_IC7_IsEnabled() != 0U)
3400838e:	f7fc f9e5 	bl	3400475c <LL_RCC_IC7_IsEnabled>
34008392:	4603      	mov	r3, r0
34008394:	2b00      	cmp	r3, #0
34008396:	f000 80a6 	beq.w	340084e6 <RCCEx_GetADFCLKFreq+0x1b2>
      {
        ic_divider = LL_RCC_IC7_GetDivider();
3400839a:	f7fc fa01 	bl	340047a0 <LL_RCC_IC7_GetDivider>
3400839e:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC7_GetSource())
340083a0:	f7fc f9f0 	bl	34004784 <LL_RCC_IC7_GetSource>
340083a4:	4603      	mov	r3, r0
340083a6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340083aa:	d029      	beq.n	34008400 <RCCEx_GetADFCLKFreq+0xcc>
340083ac:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340083b0:	d82f      	bhi.n	34008412 <RCCEx_GetADFCLKFreq+0xde>
340083b2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340083b6:	d01a      	beq.n	340083ee <RCCEx_GetADFCLKFreq+0xba>
340083b8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340083bc:	d829      	bhi.n	34008412 <RCCEx_GetADFCLKFreq+0xde>
340083be:	2b00      	cmp	r3, #0
340083c0:	d003      	beq.n	340083ca <RCCEx_GetADFCLKFreq+0x96>
340083c2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340083c6:	d009      	beq.n	340083dc <RCCEx_GetADFCLKFreq+0xa8>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            adf_frequency = adf_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
340083c8:	e023      	b.n	34008412 <RCCEx_GetADFCLKFreq+0xde>
            adf_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340083ca:	f7ff fc9b 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
340083ce:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
340083d0:	68fa      	ldr	r2, [r7, #12]
340083d2:	68bb      	ldr	r3, [r7, #8]
340083d4:	fbb2 f3f3 	udiv	r3, r2, r3
340083d8:	60fb      	str	r3, [r7, #12]
            break;
340083da:	e01b      	b.n	34008414 <RCCEx_GetADFCLKFreq+0xe0>
            adf_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340083dc:	f7ff fcd8 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
340083e0:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
340083e2:	68fa      	ldr	r2, [r7, #12]
340083e4:	68bb      	ldr	r3, [r7, #8]
340083e6:	fbb2 f3f3 	udiv	r3, r2, r3
340083ea:	60fb      	str	r3, [r7, #12]
            break;
340083ec:	e012      	b.n	34008414 <RCCEx_GetADFCLKFreq+0xe0>
            adf_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340083ee:	f7ff fd15 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
340083f2:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
340083f4:	68fa      	ldr	r2, [r7, #12]
340083f6:	68bb      	ldr	r3, [r7, #8]
340083f8:	fbb2 f3f3 	udiv	r3, r2, r3
340083fc:	60fb      	str	r3, [r7, #12]
            break;
340083fe:	e009      	b.n	34008414 <RCCEx_GetADFCLKFreq+0xe0>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34008400:	f7ff fd52 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
34008404:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34008406:	68fa      	ldr	r2, [r7, #12]
34008408:	68bb      	ldr	r3, [r7, #8]
3400840a:	fbb2 f3f3 	udiv	r3, r2, r3
3400840e:	60fb      	str	r3, [r7, #12]
            break;
34008410:	e000      	b.n	34008414 <RCCEx_GetADFCLKFreq+0xe0>
            break;
34008412:	bf00      	nop
        }
      }
      break;
34008414:	e067      	b.n	340084e6 <RCCEx_GetADFCLKFreq+0x1b2>

    case LL_RCC_ADF1_CLKSOURCE_IC8:
      if (LL_RCC_IC8_IsEnabled() != 0U)
34008416:	f7fc f9e1 	bl	340047dc <LL_RCC_IC8_IsEnabled>
3400841a:	4603      	mov	r3, r0
3400841c:	2b00      	cmp	r3, #0
3400841e:	d064      	beq.n	340084ea <RCCEx_GetADFCLKFreq+0x1b6>
      {
        ic_divider = LL_RCC_IC8_GetDivider();
34008420:	f7fc f9fe 	bl	34004820 <LL_RCC_IC8_GetDivider>
34008424:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
34008426:	f7fc f9ed 	bl	34004804 <LL_RCC_IC8_GetSource>
3400842a:	4603      	mov	r3, r0
3400842c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34008430:	d029      	beq.n	34008486 <RCCEx_GetADFCLKFreq+0x152>
34008432:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34008436:	d82f      	bhi.n	34008498 <RCCEx_GetADFCLKFreq+0x164>
34008438:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400843c:	d01a      	beq.n	34008474 <RCCEx_GetADFCLKFreq+0x140>
3400843e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34008442:	d829      	bhi.n	34008498 <RCCEx_GetADFCLKFreq+0x164>
34008444:	2b00      	cmp	r3, #0
34008446:	d003      	beq.n	34008450 <RCCEx_GetADFCLKFreq+0x11c>
34008448:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400844c:	d009      	beq.n	34008462 <RCCEx_GetADFCLKFreq+0x12e>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            adf_frequency = adf_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
3400844e:	e023      	b.n	34008498 <RCCEx_GetADFCLKFreq+0x164>
            adf_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34008450:	f7ff fc58 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
34008454:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34008456:	68fa      	ldr	r2, [r7, #12]
34008458:	68bb      	ldr	r3, [r7, #8]
3400845a:	fbb2 f3f3 	udiv	r3, r2, r3
3400845e:	60fb      	str	r3, [r7, #12]
            break;
34008460:	e01b      	b.n	3400849a <RCCEx_GetADFCLKFreq+0x166>
            adf_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34008462:	f7ff fc95 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
34008466:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34008468:	68fa      	ldr	r2, [r7, #12]
3400846a:	68bb      	ldr	r3, [r7, #8]
3400846c:	fbb2 f3f3 	udiv	r3, r2, r3
34008470:	60fb      	str	r3, [r7, #12]
            break;
34008472:	e012      	b.n	3400849a <RCCEx_GetADFCLKFreq+0x166>
            adf_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34008474:	f7ff fcd2 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
34008478:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
3400847a:	68fa      	ldr	r2, [r7, #12]
3400847c:	68bb      	ldr	r3, [r7, #8]
3400847e:	fbb2 f3f3 	udiv	r3, r2, r3
34008482:	60fb      	str	r3, [r7, #12]
            break;
34008484:	e009      	b.n	3400849a <RCCEx_GetADFCLKFreq+0x166>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34008486:	f7ff fd0f 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
3400848a:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
3400848c:	68fa      	ldr	r2, [r7, #12]
3400848e:	68bb      	ldr	r3, [r7, #8]
34008490:	fbb2 f3f3 	udiv	r3, r2, r3
34008494:	60fb      	str	r3, [r7, #12]
            break;
34008496:	e000      	b.n	3400849a <RCCEx_GetADFCLKFreq+0x166>
            break;
34008498:	bf00      	nop
        }
      }
      break;
3400849a:	e026      	b.n	340084ea <RCCEx_GetADFCLKFreq+0x1b6>

    case LL_RCC_ADF1_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
3400849c:	f7fb f9ba 	bl	34003814 <LL_RCC_HSI_IsReady>
340084a0:	4603      	mov	r3, r0
340084a2:	2b00      	cmp	r3, #0
340084a4:	d023      	beq.n	340084ee <RCCEx_GetADFCLKFreq+0x1ba>
      {
        adf_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
340084a6:	f7fb f9c7 	bl	34003838 <LL_RCC_HSI_GetDivider>
340084aa:	4603      	mov	r3, r0
340084ac:	09db      	lsrs	r3, r3, #7
340084ae:	4a14      	ldr	r2, [pc, #80]	@ (34008500 <RCCEx_GetADFCLKFreq+0x1cc>)
340084b0:	fa22 f303 	lsr.w	r3, r2, r3
340084b4:	60fb      	str	r3, [r7, #12]
      }
      break;
340084b6:	e01a      	b.n	340084ee <RCCEx_GetADFCLKFreq+0x1ba>

    case LL_RCC_ADF1_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
340084b8:	f7fb f9cc 	bl	34003854 <LL_RCC_MSI_IsReady>
340084bc:	4603      	mov	r3, r0
340084be:	2b00      	cmp	r3, #0
340084c0:	d017      	beq.n	340084f2 <RCCEx_GetADFCLKFreq+0x1be>
      {
        adf_frequency = MSI_VALUE;
340084c2:	4b10      	ldr	r3, [pc, #64]	@ (34008504 <RCCEx_GetADFCLKFreq+0x1d0>)
340084c4:	60fb      	str	r3, [r7, #12]
      }
      break;
340084c6:	e014      	b.n	340084f2 <RCCEx_GetADFCLKFreq+0x1be>

    case LL_RCC_ADF1_CLKSOURCE_I2S_CKIN:
      adf_frequency = EXTERNAL_CLOCK_VALUE;
340084c8:	4b0f      	ldr	r3, [pc, #60]	@ (34008508 <RCCEx_GetADFCLKFreq+0x1d4>)
340084ca:	60fb      	str	r3, [r7, #12]
      break;
340084cc:	e012      	b.n	340084f4 <RCCEx_GetADFCLKFreq+0x1c0>

    case LL_RCC_ADF1_CLKSOURCE_TIMG:
      adf_frequency = LL_RCC_CALC_TIMG_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetTIMPrescaler());
340084ce:	f7fb f8cb 	bl	34003668 <HAL_RCC_GetSysClockFreq>
340084d2:	4604      	mov	r4, r0
340084d4:	f7fb fe06 	bl	340040e4 <LL_RCC_GetTIMPrescaler>
340084d8:	4603      	mov	r3, r0
340084da:	fa24 f303 	lsr.w	r3, r4, r3
340084de:	60fb      	str	r3, [r7, #12]
      break;
340084e0:	e008      	b.n	340084f4 <RCCEx_GetADFCLKFreq+0x1c0>

    default:
      /* Unexpected case */
      break;
340084e2:	bf00      	nop
340084e4:	e006      	b.n	340084f4 <RCCEx_GetADFCLKFreq+0x1c0>
      break;
340084e6:	bf00      	nop
340084e8:	e004      	b.n	340084f4 <RCCEx_GetADFCLKFreq+0x1c0>
      break;
340084ea:	bf00      	nop
340084ec:	e002      	b.n	340084f4 <RCCEx_GetADFCLKFreq+0x1c0>
      break;
340084ee:	bf00      	nop
340084f0:	e000      	b.n	340084f4 <RCCEx_GetADFCLKFreq+0x1c0>
      break;
340084f2:	bf00      	nop
  }

  return adf_frequency;
340084f4:	68fb      	ldr	r3, [r7, #12]
}
340084f6:	4618      	mov	r0, r3
340084f8:	3714      	adds	r7, #20
340084fa:	46bd      	mov	sp, r7
340084fc:	bd90      	pop	{r4, r7, pc}
340084fe:	bf00      	nop
34008500:	03d09000 	.word	0x03d09000
34008504:	003d0900 	.word	0x003d0900
34008508:	00bb8000 	.word	0x00bb8000

3400850c <RCCEx_GetCLKPCLKFreq>:
  *         @arg @ref RCCEx_CLKP_Clock_Source
  * @retval CLKP clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetCLKPCLKFreq(uint32_t CLKPxSource)
{
3400850c:	b580      	push	{r7, lr}
3400850e:	b084      	sub	sp, #16
34008510:	af00      	add	r7, sp, #0
34008512:	6078      	str	r0, [r7, #4]
  uint32_t clkp_frequency = RCC_PERIPH_FREQUENCY_NO;
34008514:	2300      	movs	r3, #0
34008516:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  if (LL_RCC_CLKP_IsEnabled() == 1U)
34008518:	f7fc fc60 	bl	34004ddc <LL_RCC_CLKP_IsEnabled>
3400851c:	4603      	mov	r3, r0
3400851e:	2b01      	cmp	r3, #1
34008520:	f040 81a5 	bne.w	3400886e <RCCEx_GetCLKPCLKFreq+0x362>
  {
    switch (LL_RCC_GetCLKPClockSource(CLKPxSource))
34008524:	6878      	ldr	r0, [r7, #4]
34008526:	f7fb fc4f 	bl	34003dc8 <LL_RCC_GetCLKPClockSource>
3400852a:	4603      	mov	r3, r0
3400852c:	2b07      	cmp	r3, #7
3400852e:	f200 818d 	bhi.w	3400884c <RCCEx_GetCLKPCLKFreq+0x340>
34008532:	a201      	add	r2, pc, #4	@ (adr r2, 34008538 <RCCEx_GetCLKPCLKFreq+0x2c>)
34008534:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34008538:	34008559 	.word	0x34008559
3400853c:	34008577 	.word	0x34008577
34008540:	34008589 	.word	0x34008589
34008544:	34008733 	.word	0x34008733
34008548:	3400859b 	.word	0x3400859b
3400854c:	34008623 	.word	0x34008623
34008550:	340086ab 	.word	0x340086ab
34008554:	340087bb 	.word	0x340087bb
    {
      case LL_RCC_CLKP_CLKSOURCE_HSI:
        if (LL_RCC_HSI_IsReady() != 0U)
34008558:	f7fb f95c 	bl	34003814 <LL_RCC_HSI_IsReady>
3400855c:	4603      	mov	r3, r0
3400855e:	2b00      	cmp	r3, #0
34008560:	f000 8176 	beq.w	34008850 <RCCEx_GetCLKPCLKFreq+0x344>
        {
          clkp_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34008564:	f7fb f968 	bl	34003838 <LL_RCC_HSI_GetDivider>
34008568:	4603      	mov	r3, r0
3400856a:	09db      	lsrs	r3, r3, #7
3400856c:	4aa1      	ldr	r2, [pc, #644]	@ (340087f4 <RCCEx_GetCLKPCLKFreq+0x2e8>)
3400856e:	fa22 f303 	lsr.w	r3, r2, r3
34008572:	60fb      	str	r3, [r7, #12]
        }
        break;
34008574:	e16c      	b.n	34008850 <RCCEx_GetCLKPCLKFreq+0x344>

      case LL_RCC_CLKP_CLKSOURCE_MSI:
        if (LL_RCC_MSI_IsReady() != 0U)
34008576:	f7fb f96d 	bl	34003854 <LL_RCC_MSI_IsReady>
3400857a:	4603      	mov	r3, r0
3400857c:	2b00      	cmp	r3, #0
3400857e:	f000 8169 	beq.w	34008854 <RCCEx_GetCLKPCLKFreq+0x348>
        {
          clkp_frequency = MSI_VALUE;
34008582:	4b9d      	ldr	r3, [pc, #628]	@ (340087f8 <RCCEx_GetCLKPCLKFreq+0x2ec>)
34008584:	60fb      	str	r3, [r7, #12]
        }
        break;
34008586:	e165      	b.n	34008854 <RCCEx_GetCLKPCLKFreq+0x348>

      case LL_RCC_CLKP_CLKSOURCE_HSE:
        if (LL_RCC_HSE_IsReady() != 0U)
34008588:	f7fb f932 	bl	340037f0 <LL_RCC_HSE_IsReady>
3400858c:	4603      	mov	r3, r0
3400858e:	2b00      	cmp	r3, #0
34008590:	f000 8162 	beq.w	34008858 <RCCEx_GetCLKPCLKFreq+0x34c>
        {
          clkp_frequency = HSE_VALUE;
34008594:	4b99      	ldr	r3, [pc, #612]	@ (340087fc <RCCEx_GetCLKPCLKFreq+0x2f0>)
34008596:	60fb      	str	r3, [r7, #12]
        }
        break;
34008598:	e15e      	b.n	34008858 <RCCEx_GetCLKPCLKFreq+0x34c>

      case LL_RCC_CLKP_CLKSOURCE_IC5:
        if (LL_RCC_IC5_IsEnabled() != 0U)
3400859a:	f7fc f89f 	bl	340046dc <LL_RCC_IC5_IsEnabled>
3400859e:	4603      	mov	r3, r0
340085a0:	2b00      	cmp	r3, #0
340085a2:	f000 815b 	beq.w	3400885c <RCCEx_GetCLKPCLKFreq+0x350>
        {
          ic_divider = LL_RCC_IC5_GetDivider();
340085a6:	f7fc f8bb 	bl	34004720 <LL_RCC_IC5_GetDivider>
340085aa:	60b8      	str	r0, [r7, #8]
          switch (LL_RCC_IC5_GetSource())
340085ac:	f7fc f8aa 	bl	34004704 <LL_RCC_IC5_GetSource>
340085b0:	4603      	mov	r3, r0
340085b2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340085b6:	d029      	beq.n	3400860c <RCCEx_GetCLKPCLKFreq+0x100>
340085b8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340085bc:	d82f      	bhi.n	3400861e <RCCEx_GetCLKPCLKFreq+0x112>
340085be:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340085c2:	d01a      	beq.n	340085fa <RCCEx_GetCLKPCLKFreq+0xee>
340085c4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340085c8:	d829      	bhi.n	3400861e <RCCEx_GetCLKPCLKFreq+0x112>
340085ca:	2b00      	cmp	r3, #0
340085cc:	d003      	beq.n	340085d6 <RCCEx_GetCLKPCLKFreq+0xca>
340085ce:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340085d2:	d009      	beq.n	340085e8 <RCCEx_GetCLKPCLKFreq+0xdc>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
              clkp_frequency = clkp_frequency / ic_divider;
              break;
            default:
              /* Unexpected case */
              break;
340085d4:	e023      	b.n	3400861e <RCCEx_GetCLKPCLKFreq+0x112>
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340085d6:	f7ff fb95 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
340085da:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
340085dc:	68fa      	ldr	r2, [r7, #12]
340085de:	68bb      	ldr	r3, [r7, #8]
340085e0:	fbb2 f3f3 	udiv	r3, r2, r3
340085e4:	60fb      	str	r3, [r7, #12]
              break;
340085e6:	e01b      	b.n	34008620 <RCCEx_GetCLKPCLKFreq+0x114>
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340085e8:	f7ff fbd2 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
340085ec:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
340085ee:	68fa      	ldr	r2, [r7, #12]
340085f0:	68bb      	ldr	r3, [r7, #8]
340085f2:	fbb2 f3f3 	udiv	r3, r2, r3
340085f6:	60fb      	str	r3, [r7, #12]
              break;
340085f8:	e012      	b.n	34008620 <RCCEx_GetCLKPCLKFreq+0x114>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340085fa:	f7ff fc0f 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
340085fe:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34008600:	68fa      	ldr	r2, [r7, #12]
34008602:	68bb      	ldr	r3, [r7, #8]
34008604:	fbb2 f3f3 	udiv	r3, r2, r3
34008608:	60fb      	str	r3, [r7, #12]
              break;
3400860a:	e009      	b.n	34008620 <RCCEx_GetCLKPCLKFreq+0x114>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400860c:	f7ff fc4c 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
34008610:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34008612:	68fa      	ldr	r2, [r7, #12]
34008614:	68bb      	ldr	r3, [r7, #8]
34008616:	fbb2 f3f3 	udiv	r3, r2, r3
3400861a:	60fb      	str	r3, [r7, #12]
              break;
3400861c:	e000      	b.n	34008620 <RCCEx_GetCLKPCLKFreq+0x114>
              break;
3400861e:	bf00      	nop
          }
        }
        break;
34008620:	e11c      	b.n	3400885c <RCCEx_GetCLKPCLKFreq+0x350>

      case LL_RCC_CLKP_CLKSOURCE_IC10:
        if (LL_RCC_IC10_IsEnabled() != 0U)
34008622:	f7fc f95b 	bl	340048dc <LL_RCC_IC10_IsEnabled>
34008626:	4603      	mov	r3, r0
34008628:	2b00      	cmp	r3, #0
3400862a:	f000 8119 	beq.w	34008860 <RCCEx_GetCLKPCLKFreq+0x354>
        {
          ic_divider = LL_RCC_IC10_GetDivider();
3400862e:	f7fc f977 	bl	34004920 <LL_RCC_IC10_GetDivider>
34008632:	60b8      	str	r0, [r7, #8]
          switch (LL_RCC_IC10_GetSource())
34008634:	f7fc f966 	bl	34004904 <LL_RCC_IC10_GetSource>
34008638:	4603      	mov	r3, r0
3400863a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400863e:	d029      	beq.n	34008694 <RCCEx_GetCLKPCLKFreq+0x188>
34008640:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34008644:	d82f      	bhi.n	340086a6 <RCCEx_GetCLKPCLKFreq+0x19a>
34008646:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400864a:	d01a      	beq.n	34008682 <RCCEx_GetCLKPCLKFreq+0x176>
3400864c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34008650:	d829      	bhi.n	340086a6 <RCCEx_GetCLKPCLKFreq+0x19a>
34008652:	2b00      	cmp	r3, #0
34008654:	d003      	beq.n	3400865e <RCCEx_GetCLKPCLKFreq+0x152>
34008656:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400865a:	d009      	beq.n	34008670 <RCCEx_GetCLKPCLKFreq+0x164>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
              clkp_frequency = clkp_frequency / ic_divider;
              break;
            default:
              /* Unexpected case */
              break;
3400865c:	e023      	b.n	340086a6 <RCCEx_GetCLKPCLKFreq+0x19a>
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400865e:	f7ff fb51 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
34008662:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34008664:	68fa      	ldr	r2, [r7, #12]
34008666:	68bb      	ldr	r3, [r7, #8]
34008668:	fbb2 f3f3 	udiv	r3, r2, r3
3400866c:	60fb      	str	r3, [r7, #12]
              break;
3400866e:	e01b      	b.n	340086a8 <RCCEx_GetCLKPCLKFreq+0x19c>
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34008670:	f7ff fb8e 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
34008674:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34008676:	68fa      	ldr	r2, [r7, #12]
34008678:	68bb      	ldr	r3, [r7, #8]
3400867a:	fbb2 f3f3 	udiv	r3, r2, r3
3400867e:	60fb      	str	r3, [r7, #12]
              break;
34008680:	e012      	b.n	340086a8 <RCCEx_GetCLKPCLKFreq+0x19c>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34008682:	f7ff fbcb 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
34008686:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34008688:	68fa      	ldr	r2, [r7, #12]
3400868a:	68bb      	ldr	r3, [r7, #8]
3400868c:	fbb2 f3f3 	udiv	r3, r2, r3
34008690:	60fb      	str	r3, [r7, #12]
              break;
34008692:	e009      	b.n	340086a8 <RCCEx_GetCLKPCLKFreq+0x19c>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34008694:	f7ff fc08 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
34008698:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
3400869a:	68fa      	ldr	r2, [r7, #12]
3400869c:	68bb      	ldr	r3, [r7, #8]
3400869e:	fbb2 f3f3 	udiv	r3, r2, r3
340086a2:	60fb      	str	r3, [r7, #12]
              break;
340086a4:	e000      	b.n	340086a8 <RCCEx_GetCLKPCLKFreq+0x19c>
              break;
340086a6:	bf00      	nop
          }
        }
        break;
340086a8:	e0da      	b.n	34008860 <RCCEx_GetCLKPCLKFreq+0x354>

      case LL_RCC_CLKP_CLKSOURCE_IC15:
        if (LL_RCC_IC15_IsEnabled() != 0U)
340086aa:	f7fc fa17 	bl	34004adc <LL_RCC_IC15_IsEnabled>
340086ae:	4603      	mov	r3, r0
340086b0:	2b00      	cmp	r3, #0
340086b2:	f000 80d7 	beq.w	34008864 <RCCEx_GetCLKPCLKFreq+0x358>
        {
          ic_divider = LL_RCC_IC15_GetDivider();
340086b6:	f7fc fa33 	bl	34004b20 <LL_RCC_IC15_GetDivider>
340086ba:	60b8      	str	r0, [r7, #8]
          switch (LL_RCC_IC15_GetSource())
340086bc:	f7fc fa22 	bl	34004b04 <LL_RCC_IC15_GetSource>
340086c0:	4603      	mov	r3, r0
340086c2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340086c6:	d029      	beq.n	3400871c <RCCEx_GetCLKPCLKFreq+0x210>
340086c8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340086cc:	d82f      	bhi.n	3400872e <RCCEx_GetCLKPCLKFreq+0x222>
340086ce:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340086d2:	d01a      	beq.n	3400870a <RCCEx_GetCLKPCLKFreq+0x1fe>
340086d4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340086d8:	d829      	bhi.n	3400872e <RCCEx_GetCLKPCLKFreq+0x222>
340086da:	2b00      	cmp	r3, #0
340086dc:	d003      	beq.n	340086e6 <RCCEx_GetCLKPCLKFreq+0x1da>
340086de:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340086e2:	d009      	beq.n	340086f8 <RCCEx_GetCLKPCLKFreq+0x1ec>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
              clkp_frequency = clkp_frequency / ic_divider;
              break;
            default:
              /* Unexpected case */
              break;
340086e4:	e023      	b.n	3400872e <RCCEx_GetCLKPCLKFreq+0x222>
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340086e6:	f7ff fb0d 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
340086ea:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
340086ec:	68fa      	ldr	r2, [r7, #12]
340086ee:	68bb      	ldr	r3, [r7, #8]
340086f0:	fbb2 f3f3 	udiv	r3, r2, r3
340086f4:	60fb      	str	r3, [r7, #12]
              break;
340086f6:	e01b      	b.n	34008730 <RCCEx_GetCLKPCLKFreq+0x224>
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340086f8:	f7ff fb4a 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
340086fc:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
340086fe:	68fa      	ldr	r2, [r7, #12]
34008700:	68bb      	ldr	r3, [r7, #8]
34008702:	fbb2 f3f3 	udiv	r3, r2, r3
34008706:	60fb      	str	r3, [r7, #12]
              break;
34008708:	e012      	b.n	34008730 <RCCEx_GetCLKPCLKFreq+0x224>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400870a:	f7ff fb87 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
3400870e:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34008710:	68fa      	ldr	r2, [r7, #12]
34008712:	68bb      	ldr	r3, [r7, #8]
34008714:	fbb2 f3f3 	udiv	r3, r2, r3
34008718:	60fb      	str	r3, [r7, #12]
              break;
3400871a:	e009      	b.n	34008730 <RCCEx_GetCLKPCLKFreq+0x224>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400871c:	f7ff fbc4 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
34008720:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34008722:	68fa      	ldr	r2, [r7, #12]
34008724:	68bb      	ldr	r3, [r7, #8]
34008726:	fbb2 f3f3 	udiv	r3, r2, r3
3400872a:	60fb      	str	r3, [r7, #12]
              break;
3400872c:	e000      	b.n	34008730 <RCCEx_GetCLKPCLKFreq+0x224>
              break;
3400872e:	bf00      	nop
          }
        }
        break;
34008730:	e098      	b.n	34008864 <RCCEx_GetCLKPCLKFreq+0x358>

      case LL_RCC_CLKP_CLKSOURCE_IC19:
        if (LL_RCC_IC19_IsEnabled() != 0U)
34008732:	f7fc fad3 	bl	34004cdc <LL_RCC_IC19_IsEnabled>
34008736:	4603      	mov	r3, r0
34008738:	2b00      	cmp	r3, #0
3400873a:	f000 8095 	beq.w	34008868 <RCCEx_GetCLKPCLKFreq+0x35c>
        {
          ic_divider = LL_RCC_IC19_GetDivider();
3400873e:	f7fc faef 	bl	34004d20 <LL_RCC_IC19_GetDivider>
34008742:	60b8      	str	r0, [r7, #8]
          switch (LL_RCC_IC19_GetSource())
34008744:	f7fc fade 	bl	34004d04 <LL_RCC_IC19_GetSource>
34008748:	4603      	mov	r3, r0
3400874a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400874e:	d029      	beq.n	340087a4 <RCCEx_GetCLKPCLKFreq+0x298>
34008750:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34008754:	d82f      	bhi.n	340087b6 <RCCEx_GetCLKPCLKFreq+0x2aa>
34008756:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400875a:	d01a      	beq.n	34008792 <RCCEx_GetCLKPCLKFreq+0x286>
3400875c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34008760:	d829      	bhi.n	340087b6 <RCCEx_GetCLKPCLKFreq+0x2aa>
34008762:	2b00      	cmp	r3, #0
34008764:	d003      	beq.n	3400876e <RCCEx_GetCLKPCLKFreq+0x262>
34008766:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400876a:	d009      	beq.n	34008780 <RCCEx_GetCLKPCLKFreq+0x274>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
              clkp_frequency = clkp_frequency / ic_divider;
              break;
            default:
              /* Unexpected case */
              break;
3400876c:	e023      	b.n	340087b6 <RCCEx_GetCLKPCLKFreq+0x2aa>
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400876e:	f7ff fac9 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
34008772:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34008774:	68fa      	ldr	r2, [r7, #12]
34008776:	68bb      	ldr	r3, [r7, #8]
34008778:	fbb2 f3f3 	udiv	r3, r2, r3
3400877c:	60fb      	str	r3, [r7, #12]
              break;
3400877e:	e01b      	b.n	340087b8 <RCCEx_GetCLKPCLKFreq+0x2ac>
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34008780:	f7ff fb06 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
34008784:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34008786:	68fa      	ldr	r2, [r7, #12]
34008788:	68bb      	ldr	r3, [r7, #8]
3400878a:	fbb2 f3f3 	udiv	r3, r2, r3
3400878e:	60fb      	str	r3, [r7, #12]
              break;
34008790:	e012      	b.n	340087b8 <RCCEx_GetCLKPCLKFreq+0x2ac>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34008792:	f7ff fb43 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
34008796:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34008798:	68fa      	ldr	r2, [r7, #12]
3400879a:	68bb      	ldr	r3, [r7, #8]
3400879c:	fbb2 f3f3 	udiv	r3, r2, r3
340087a0:	60fb      	str	r3, [r7, #12]
              break;
340087a2:	e009      	b.n	340087b8 <RCCEx_GetCLKPCLKFreq+0x2ac>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340087a4:	f7ff fb80 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
340087a8:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
340087aa:	68fa      	ldr	r2, [r7, #12]
340087ac:	68bb      	ldr	r3, [r7, #8]
340087ae:	fbb2 f3f3 	udiv	r3, r2, r3
340087b2:	60fb      	str	r3, [r7, #12]
              break;
340087b4:	e000      	b.n	340087b8 <RCCEx_GetCLKPCLKFreq+0x2ac>
              break;
340087b6:	bf00      	nop
          }
        }
        break;
340087b8:	e056      	b.n	34008868 <RCCEx_GetCLKPCLKFreq+0x35c>

      case LL_RCC_CLKP_CLKSOURCE_IC20:
        if (LL_RCC_IC20_IsEnabled() != 0U)
340087ba:	f7fc facf 	bl	34004d5c <LL_RCC_IC20_IsEnabled>
340087be:	4603      	mov	r3, r0
340087c0:	2b00      	cmp	r3, #0
340087c2:	d053      	beq.n	3400886c <RCCEx_GetCLKPCLKFreq+0x360>
        {
          ic_divider = LL_RCC_IC20_GetDivider();
340087c4:	f7fc faec 	bl	34004da0 <LL_RCC_IC20_GetDivider>
340087c8:	60b8      	str	r0, [r7, #8]
          switch (LL_RCC_IC20_GetSource())
340087ca:	f7fc fadb 	bl	34004d84 <LL_RCC_IC20_GetSource>
340087ce:	4603      	mov	r3, r0
340087d0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340087d4:	d02f      	beq.n	34008836 <RCCEx_GetCLKPCLKFreq+0x32a>
340087d6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340087da:	d835      	bhi.n	34008848 <RCCEx_GetCLKPCLKFreq+0x33c>
340087dc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340087e0:	d020      	beq.n	34008824 <RCCEx_GetCLKPCLKFreq+0x318>
340087e2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340087e6:	d82f      	bhi.n	34008848 <RCCEx_GetCLKPCLKFreq+0x33c>
340087e8:	2b00      	cmp	r3, #0
340087ea:	d009      	beq.n	34008800 <RCCEx_GetCLKPCLKFreq+0x2f4>
340087ec:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340087f0:	d00f      	beq.n	34008812 <RCCEx_GetCLKPCLKFreq+0x306>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
              clkp_frequency = clkp_frequency / ic_divider;
              break;
            default:
              /* Unexpected case */
              break;
340087f2:	e029      	b.n	34008848 <RCCEx_GetCLKPCLKFreq+0x33c>
340087f4:	03d09000 	.word	0x03d09000
340087f8:	003d0900 	.word	0x003d0900
340087fc:	016e3600 	.word	0x016e3600
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34008800:	f7ff fa80 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
34008804:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34008806:	68fa      	ldr	r2, [r7, #12]
34008808:	68bb      	ldr	r3, [r7, #8]
3400880a:	fbb2 f3f3 	udiv	r3, r2, r3
3400880e:	60fb      	str	r3, [r7, #12]
              break;
34008810:	e01b      	b.n	3400884a <RCCEx_GetCLKPCLKFreq+0x33e>
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34008812:	f7ff fabd 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
34008816:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34008818:	68fa      	ldr	r2, [r7, #12]
3400881a:	68bb      	ldr	r3, [r7, #8]
3400881c:	fbb2 f3f3 	udiv	r3, r2, r3
34008820:	60fb      	str	r3, [r7, #12]
              break;
34008822:	e012      	b.n	3400884a <RCCEx_GetCLKPCLKFreq+0x33e>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34008824:	f7ff fafa 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
34008828:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
3400882a:	68fa      	ldr	r2, [r7, #12]
3400882c:	68bb      	ldr	r3, [r7, #8]
3400882e:	fbb2 f3f3 	udiv	r3, r2, r3
34008832:	60fb      	str	r3, [r7, #12]
              break;
34008834:	e009      	b.n	3400884a <RCCEx_GetCLKPCLKFreq+0x33e>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34008836:	f7ff fb37 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
3400883a:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
3400883c:	68fa      	ldr	r2, [r7, #12]
3400883e:	68bb      	ldr	r3, [r7, #8]
34008840:	fbb2 f3f3 	udiv	r3, r2, r3
34008844:	60fb      	str	r3, [r7, #12]
              break;
34008846:	e000      	b.n	3400884a <RCCEx_GetCLKPCLKFreq+0x33e>
              break;
34008848:	bf00      	nop
          }
        }
        break;
3400884a:	e00f      	b.n	3400886c <RCCEx_GetCLKPCLKFreq+0x360>

      default:
        /* Unexpected case */
        break;
3400884c:	bf00      	nop
3400884e:	e00e      	b.n	3400886e <RCCEx_GetCLKPCLKFreq+0x362>
        break;
34008850:	bf00      	nop
34008852:	e00c      	b.n	3400886e <RCCEx_GetCLKPCLKFreq+0x362>
        break;
34008854:	bf00      	nop
34008856:	e00a      	b.n	3400886e <RCCEx_GetCLKPCLKFreq+0x362>
        break;
34008858:	bf00      	nop
3400885a:	e008      	b.n	3400886e <RCCEx_GetCLKPCLKFreq+0x362>
        break;
3400885c:	bf00      	nop
3400885e:	e006      	b.n	3400886e <RCCEx_GetCLKPCLKFreq+0x362>
        break;
34008860:	bf00      	nop
34008862:	e004      	b.n	3400886e <RCCEx_GetCLKPCLKFreq+0x362>
        break;
34008864:	bf00      	nop
34008866:	e002      	b.n	3400886e <RCCEx_GetCLKPCLKFreq+0x362>
        break;
34008868:	bf00      	nop
3400886a:	e000      	b.n	3400886e <RCCEx_GetCLKPCLKFreq+0x362>
        break;
3400886c:	bf00      	nop
    }
  }

  return clkp_frequency;
3400886e:	68fb      	ldr	r3, [r7, #12]
}
34008870:	4618      	mov	r0, r3
34008872:	3710      	adds	r7, #16
34008874:	46bd      	mov	sp, r7
34008876:	bd80      	pop	{r7, pc}

34008878 <RCCEx_GetCSICLKFreq>:
  * @brief  Return CSI clock frequency
  * @retval CLKP clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetCSICLKFreq(void)
{
34008878:	b580      	push	{r7, lr}
3400887a:	b082      	sub	sp, #8
3400887c:	af00      	add	r7, sp, #0
  uint32_t clkp_frequency = RCC_PERIPH_FREQUENCY_NO;
3400887e:	2300      	movs	r3, #0
34008880:	607b      	str	r3, [r7, #4]

  if (LL_RCC_IC18_IsEnabled() != 0U)
34008882:	f7fc f9eb 	bl	34004c5c <LL_RCC_IC18_IsEnabled>
34008886:	4603      	mov	r3, r0
34008888:	2b00      	cmp	r3, #0
3400888a:	d03c      	beq.n	34008906 <RCCEx_GetCSICLKFreq+0x8e>
  {
    uint32_t ic_divider = LL_RCC_IC18_GetDivider();
3400888c:	f7fc fa08 	bl	34004ca0 <LL_RCC_IC18_GetDivider>
34008890:	6038      	str	r0, [r7, #0]
    switch (LL_RCC_IC18_GetSource())
34008892:	f7fc f9f7 	bl	34004c84 <LL_RCC_IC18_GetSource>
34008896:	4603      	mov	r3, r0
34008898:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400889c:	d029      	beq.n	340088f2 <RCCEx_GetCSICLKFreq+0x7a>
3400889e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340088a2:	d82f      	bhi.n	34008904 <RCCEx_GetCSICLKFreq+0x8c>
340088a4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340088a8:	d01a      	beq.n	340088e0 <RCCEx_GetCSICLKFreq+0x68>
340088aa:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340088ae:	d829      	bhi.n	34008904 <RCCEx_GetCSICLKFreq+0x8c>
340088b0:	2b00      	cmp	r3, #0
340088b2:	d003      	beq.n	340088bc <RCCEx_GetCSICLKFreq+0x44>
340088b4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340088b8:	d009      	beq.n	340088ce <RCCEx_GetCSICLKFreq+0x56>
        clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
        clkp_frequency = clkp_frequency / ic_divider;
        break;
      default:
        /* Unexpected case */
        break;
340088ba:	e023      	b.n	34008904 <RCCEx_GetCSICLKFreq+0x8c>
        clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340088bc:	f7ff fa22 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
340088c0:	6078      	str	r0, [r7, #4]
        clkp_frequency = clkp_frequency / ic_divider;
340088c2:	687a      	ldr	r2, [r7, #4]
340088c4:	683b      	ldr	r3, [r7, #0]
340088c6:	fbb2 f3f3 	udiv	r3, r2, r3
340088ca:	607b      	str	r3, [r7, #4]
        break;
340088cc:	e01b      	b.n	34008906 <RCCEx_GetCSICLKFreq+0x8e>
        clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340088ce:	f7ff fa5f 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
340088d2:	6078      	str	r0, [r7, #4]
        clkp_frequency = clkp_frequency / ic_divider;
340088d4:	687a      	ldr	r2, [r7, #4]
340088d6:	683b      	ldr	r3, [r7, #0]
340088d8:	fbb2 f3f3 	udiv	r3, r2, r3
340088dc:	607b      	str	r3, [r7, #4]
        break;
340088de:	e012      	b.n	34008906 <RCCEx_GetCSICLKFreq+0x8e>
        clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340088e0:	f7ff fa9c 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
340088e4:	6078      	str	r0, [r7, #4]
        clkp_frequency = clkp_frequency / ic_divider;
340088e6:	687a      	ldr	r2, [r7, #4]
340088e8:	683b      	ldr	r3, [r7, #0]
340088ea:	fbb2 f3f3 	udiv	r3, r2, r3
340088ee:	607b      	str	r3, [r7, #4]
        break;
340088f0:	e009      	b.n	34008906 <RCCEx_GetCSICLKFreq+0x8e>
        clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340088f2:	f7ff fad9 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
340088f6:	6078      	str	r0, [r7, #4]
        clkp_frequency = clkp_frequency / ic_divider;
340088f8:	687a      	ldr	r2, [r7, #4]
340088fa:	683b      	ldr	r3, [r7, #0]
340088fc:	fbb2 f3f3 	udiv	r3, r2, r3
34008900:	607b      	str	r3, [r7, #4]
        break;
34008902:	e000      	b.n	34008906 <RCCEx_GetCSICLKFreq+0x8e>
        break;
34008904:	bf00      	nop
    }
  }

  return clkp_frequency;
34008906:	687b      	ldr	r3, [r7, #4]
}
34008908:	4618      	mov	r0, r3
3400890a:	3708      	adds	r7, #8
3400890c:	46bd      	mov	sp, r7
3400890e:	bd80      	pop	{r7, pc}

34008910 <RCCEx_GetDCMIPPCLKFreq>:
  *         @arg @ref RCCEx_DCMIPP_Clock_Source
  * @retval DCMIPP clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetDCMIPPCLKFreq(uint32_t DCMIPPxSource)
{
34008910:	b580      	push	{r7, lr}
34008912:	b084      	sub	sp, #16
34008914:	af00      	add	r7, sp, #0
34008916:	6078      	str	r0, [r7, #4]
  uint32_t dcmipp_frequency = RCC_PERIPH_FREQUENCY_NO;
34008918:	2300      	movs	r3, #0
3400891a:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetDCMIPPClockSource(DCMIPPxSource))
3400891c:	6878      	ldr	r0, [r7, #4]
3400891e:	f7fb fa65 	bl	34003dec <LL_RCC_GetDCMIPPClockSource>
34008922:	4603      	mov	r3, r0
34008924:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34008928:	d062      	beq.n	340089f0 <RCCEx_GetDCMIPPCLKFreq+0xe0>
3400892a:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3400892e:	d86d      	bhi.n	34008a0c <RCCEx_GetDCMIPPCLKFreq+0xfc>
34008930:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34008934:	d019      	beq.n	3400896a <RCCEx_GetDCMIPPCLKFreq+0x5a>
34008936:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3400893a:	d867      	bhi.n	34008a0c <RCCEx_GetDCMIPPCLKFreq+0xfc>
3400893c:	2b00      	cmp	r3, #0
3400893e:	d003      	beq.n	34008948 <RCCEx_GetDCMIPPCLKFreq+0x38>
34008940:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
34008944:	d00c      	beq.n	34008960 <RCCEx_GetDCMIPPCLKFreq+0x50>
      }
      break;

    default:
      /* Unexpected case */
      break;
34008946:	e061      	b.n	34008a0c <RCCEx_GetDCMIPPCLKFreq+0xfc>
      dcmipp_frequency = RCCEx_GetPCLK5Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34008948:	f7fa fe8e 	bl	34003668 <HAL_RCC_GetSysClockFreq>
3400894c:	4603      	mov	r3, r0
3400894e:	4618      	mov	r0, r3
34008950:	f7ff faf0 	bl	34007f34 <RCCEx_GetHCLKFreq>
34008954:	4603      	mov	r3, r0
34008956:	4618      	mov	r0, r3
34008958:	f7ff fb2f 	bl	34007fba <RCCEx_GetPCLK5Freq>
3400895c:	60f8      	str	r0, [r7, #12]
      break;
3400895e:	e05a      	b.n	34008a16 <RCCEx_GetDCMIPPCLKFreq+0x106>
      dcmipp_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34008960:	2007      	movs	r0, #7
34008962:	f7ff fdd3 	bl	3400850c <RCCEx_GetCLKPCLKFreq>
34008966:	60f8      	str	r0, [r7, #12]
      break;
34008968:	e055      	b.n	34008a16 <RCCEx_GetDCMIPPCLKFreq+0x106>
      if (LL_RCC_IC17_IsEnabled() != 0U)
3400896a:	f7fc f937 	bl	34004bdc <LL_RCC_IC17_IsEnabled>
3400896e:	4603      	mov	r3, r0
34008970:	2b00      	cmp	r3, #0
34008972:	d04d      	beq.n	34008a10 <RCCEx_GetDCMIPPCLKFreq+0x100>
        ic_divider = LL_RCC_IC17_GetDivider();
34008974:	f7fc f954 	bl	34004c20 <LL_RCC_IC17_GetDivider>
34008978:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC17_GetSource())
3400897a:	f7fc f943 	bl	34004c04 <LL_RCC_IC17_GetSource>
3400897e:	4603      	mov	r3, r0
34008980:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34008984:	d029      	beq.n	340089da <RCCEx_GetDCMIPPCLKFreq+0xca>
34008986:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400898a:	d82f      	bhi.n	340089ec <RCCEx_GetDCMIPPCLKFreq+0xdc>
3400898c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34008990:	d01a      	beq.n	340089c8 <RCCEx_GetDCMIPPCLKFreq+0xb8>
34008992:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34008996:	d829      	bhi.n	340089ec <RCCEx_GetDCMIPPCLKFreq+0xdc>
34008998:	2b00      	cmp	r3, #0
3400899a:	d003      	beq.n	340089a4 <RCCEx_GetDCMIPPCLKFreq+0x94>
3400899c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340089a0:	d009      	beq.n	340089b6 <RCCEx_GetDCMIPPCLKFreq+0xa6>
            break;
340089a2:	e023      	b.n	340089ec <RCCEx_GetDCMIPPCLKFreq+0xdc>
            dcmipp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340089a4:	f7ff f9ae 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
340089a8:	60f8      	str	r0, [r7, #12]
            dcmipp_frequency = dcmipp_frequency / ic_divider;
340089aa:	68fa      	ldr	r2, [r7, #12]
340089ac:	68bb      	ldr	r3, [r7, #8]
340089ae:	fbb2 f3f3 	udiv	r3, r2, r3
340089b2:	60fb      	str	r3, [r7, #12]
            break;
340089b4:	e01b      	b.n	340089ee <RCCEx_GetDCMIPPCLKFreq+0xde>
            dcmipp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340089b6:	f7ff f9eb 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
340089ba:	60f8      	str	r0, [r7, #12]
            dcmipp_frequency = dcmipp_frequency / ic_divider;
340089bc:	68fa      	ldr	r2, [r7, #12]
340089be:	68bb      	ldr	r3, [r7, #8]
340089c0:	fbb2 f3f3 	udiv	r3, r2, r3
340089c4:	60fb      	str	r3, [r7, #12]
            break;
340089c6:	e012      	b.n	340089ee <RCCEx_GetDCMIPPCLKFreq+0xde>
            dcmipp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340089c8:	f7ff fa28 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
340089cc:	60f8      	str	r0, [r7, #12]
            dcmipp_frequency = dcmipp_frequency / ic_divider;
340089ce:	68fa      	ldr	r2, [r7, #12]
340089d0:	68bb      	ldr	r3, [r7, #8]
340089d2:	fbb2 f3f3 	udiv	r3, r2, r3
340089d6:	60fb      	str	r3, [r7, #12]
            break;
340089d8:	e009      	b.n	340089ee <RCCEx_GetDCMIPPCLKFreq+0xde>
            dcmipp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340089da:	f7ff fa65 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
340089de:	60f8      	str	r0, [r7, #12]
            dcmipp_frequency = dcmipp_frequency / ic_divider;
340089e0:	68fa      	ldr	r2, [r7, #12]
340089e2:	68bb      	ldr	r3, [r7, #8]
340089e4:	fbb2 f3f3 	udiv	r3, r2, r3
340089e8:	60fb      	str	r3, [r7, #12]
            break;
340089ea:	e000      	b.n	340089ee <RCCEx_GetDCMIPPCLKFreq+0xde>
            break;
340089ec:	bf00      	nop
      break;
340089ee:	e00f      	b.n	34008a10 <RCCEx_GetDCMIPPCLKFreq+0x100>
      if (LL_RCC_HSI_IsReady() != 0U)
340089f0:	f7fa ff10 	bl	34003814 <LL_RCC_HSI_IsReady>
340089f4:	4603      	mov	r3, r0
340089f6:	2b00      	cmp	r3, #0
340089f8:	d00c      	beq.n	34008a14 <RCCEx_GetDCMIPPCLKFreq+0x104>
        dcmipp_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
340089fa:	f7fa ff1d 	bl	34003838 <LL_RCC_HSI_GetDivider>
340089fe:	4603      	mov	r3, r0
34008a00:	09db      	lsrs	r3, r3, #7
34008a02:	4a07      	ldr	r2, [pc, #28]	@ (34008a20 <RCCEx_GetDCMIPPCLKFreq+0x110>)
34008a04:	fa22 f303 	lsr.w	r3, r2, r3
34008a08:	60fb      	str	r3, [r7, #12]
      break;
34008a0a:	e003      	b.n	34008a14 <RCCEx_GetDCMIPPCLKFreq+0x104>
      break;
34008a0c:	bf00      	nop
34008a0e:	e002      	b.n	34008a16 <RCCEx_GetDCMIPPCLKFreq+0x106>
      break;
34008a10:	bf00      	nop
34008a12:	e000      	b.n	34008a16 <RCCEx_GetDCMIPPCLKFreq+0x106>
      break;
34008a14:	bf00      	nop
  }

  return dcmipp_frequency;
34008a16:	68fb      	ldr	r3, [r7, #12]
}
34008a18:	4618      	mov	r0, r3
34008a1a:	3710      	adds	r7, #16
34008a1c:	46bd      	mov	sp, r7
34008a1e:	bd80      	pop	{r7, pc}
34008a20:	03d09000 	.word	0x03d09000

34008a24 <RCCEx_GetETH1CLKFreq>:
  *         @arg @ref RCCEx_ETH1_Clock_Source
  * @retval ETH1 clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetETH1CLKFreq(uint32_t ETH1xSource)
{
34008a24:	b580      	push	{r7, lr}
34008a26:	b084      	sub	sp, #16
34008a28:	af00      	add	r7, sp, #0
34008a2a:	6078      	str	r0, [r7, #4]
  uint32_t eth1_frequency = RCC_PERIPH_FREQUENCY_NO;
34008a2c:	2300      	movs	r3, #0
34008a2e:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetETHClockSource(ETH1xSource))
34008a30:	6878      	ldr	r0, [r7, #4]
34008a32:	f7fb f9ed 	bl	34003e10 <LL_RCC_GetETHClockSource>
34008a36:	4603      	mov	r3, r0
34008a38:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
34008a3c:	d05e      	beq.n	34008afc <RCCEx_GetETH1CLKFreq+0xd8>
34008a3e:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
34008a42:	d863      	bhi.n	34008b0c <RCCEx_GetETH1CLKFreq+0xe8>
34008a44:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
34008a48:	d015      	beq.n	34008a76 <RCCEx_GetETH1CLKFreq+0x52>
34008a4a:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
34008a4e:	d85d      	bhi.n	34008b0c <RCCEx_GetETH1CLKFreq+0xe8>
34008a50:	2b00      	cmp	r3, #0
34008a52:	d003      	beq.n	34008a5c <RCCEx_GetETH1CLKFreq+0x38>
34008a54:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34008a58:	d008      	beq.n	34008a6c <RCCEx_GetETH1CLKFreq+0x48>
      }
      break;

    default:
      /* Unexpected case */
      break;
34008a5a:	e057      	b.n	34008b0c <RCCEx_GetETH1CLKFreq+0xe8>
      eth1_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34008a5c:	f7fa fe04 	bl	34003668 <HAL_RCC_GetSysClockFreq>
34008a60:	4603      	mov	r3, r0
34008a62:	4618      	mov	r0, r3
34008a64:	f7ff fa66 	bl	34007f34 <RCCEx_GetHCLKFreq>
34008a68:	60f8      	str	r0, [r7, #12]
      break;
34008a6a:	e054      	b.n	34008b16 <RCCEx_GetETH1CLKFreq+0xf2>
      eth1_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34008a6c:	2007      	movs	r0, #7
34008a6e:	f7ff fd4d 	bl	3400850c <RCCEx_GetCLKPCLKFreq>
34008a72:	60f8      	str	r0, [r7, #12]
      break;
34008a74:	e04f      	b.n	34008b16 <RCCEx_GetETH1CLKFreq+0xf2>
      if (LL_RCC_IC12_IsEnabled() != 0U)
34008a76:	f7fb ff71 	bl	3400495c <LL_RCC_IC12_IsEnabled>
34008a7a:	4603      	mov	r3, r0
34008a7c:	2b00      	cmp	r3, #0
34008a7e:	d047      	beq.n	34008b10 <RCCEx_GetETH1CLKFreq+0xec>
        ic_divider = LL_RCC_IC12_GetDivider();
34008a80:	f7fb ff8e 	bl	340049a0 <LL_RCC_IC12_GetDivider>
34008a84:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC12_GetSource())
34008a86:	f7fb ff7d 	bl	34004984 <LL_RCC_IC12_GetSource>
34008a8a:	4603      	mov	r3, r0
34008a8c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34008a90:	d029      	beq.n	34008ae6 <RCCEx_GetETH1CLKFreq+0xc2>
34008a92:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34008a96:	d82f      	bhi.n	34008af8 <RCCEx_GetETH1CLKFreq+0xd4>
34008a98:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34008a9c:	d01a      	beq.n	34008ad4 <RCCEx_GetETH1CLKFreq+0xb0>
34008a9e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34008aa2:	d829      	bhi.n	34008af8 <RCCEx_GetETH1CLKFreq+0xd4>
34008aa4:	2b00      	cmp	r3, #0
34008aa6:	d003      	beq.n	34008ab0 <RCCEx_GetETH1CLKFreq+0x8c>
34008aa8:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34008aac:	d009      	beq.n	34008ac2 <RCCEx_GetETH1CLKFreq+0x9e>
            break;
34008aae:	e023      	b.n	34008af8 <RCCEx_GetETH1CLKFreq+0xd4>
            eth1_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34008ab0:	f7ff f928 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
34008ab4:	60f8      	str	r0, [r7, #12]
            eth1_frequency = eth1_frequency / ic_divider;
34008ab6:	68fa      	ldr	r2, [r7, #12]
34008ab8:	68bb      	ldr	r3, [r7, #8]
34008aba:	fbb2 f3f3 	udiv	r3, r2, r3
34008abe:	60fb      	str	r3, [r7, #12]
            break;
34008ac0:	e01b      	b.n	34008afa <RCCEx_GetETH1CLKFreq+0xd6>
            eth1_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34008ac2:	f7ff f965 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
34008ac6:	60f8      	str	r0, [r7, #12]
            eth1_frequency = eth1_frequency / ic_divider;
34008ac8:	68fa      	ldr	r2, [r7, #12]
34008aca:	68bb      	ldr	r3, [r7, #8]
34008acc:	fbb2 f3f3 	udiv	r3, r2, r3
34008ad0:	60fb      	str	r3, [r7, #12]
            break;
34008ad2:	e012      	b.n	34008afa <RCCEx_GetETH1CLKFreq+0xd6>
            eth1_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34008ad4:	f7ff f9a2 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
34008ad8:	60f8      	str	r0, [r7, #12]
            eth1_frequency = eth1_frequency / ic_divider;
34008ada:	68fa      	ldr	r2, [r7, #12]
34008adc:	68bb      	ldr	r3, [r7, #8]
34008ade:	fbb2 f3f3 	udiv	r3, r2, r3
34008ae2:	60fb      	str	r3, [r7, #12]
            break;
34008ae4:	e009      	b.n	34008afa <RCCEx_GetETH1CLKFreq+0xd6>
            eth1_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34008ae6:	f7ff f9df 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
34008aea:	60f8      	str	r0, [r7, #12]
            eth1_frequency = eth1_frequency / ic_divider;
34008aec:	68fa      	ldr	r2, [r7, #12]
34008aee:	68bb      	ldr	r3, [r7, #8]
34008af0:	fbb2 f3f3 	udiv	r3, r2, r3
34008af4:	60fb      	str	r3, [r7, #12]
            break;
34008af6:	e000      	b.n	34008afa <RCCEx_GetETH1CLKFreq+0xd6>
            break;
34008af8:	bf00      	nop
      break;
34008afa:	e009      	b.n	34008b10 <RCCEx_GetETH1CLKFreq+0xec>
      if (LL_RCC_HSE_IsReady() != 0U)
34008afc:	f7fa fe78 	bl	340037f0 <LL_RCC_HSE_IsReady>
34008b00:	4603      	mov	r3, r0
34008b02:	2b00      	cmp	r3, #0
34008b04:	d006      	beq.n	34008b14 <RCCEx_GetETH1CLKFreq+0xf0>
        eth1_frequency = HSE_VALUE;
34008b06:	4b06      	ldr	r3, [pc, #24]	@ (34008b20 <RCCEx_GetETH1CLKFreq+0xfc>)
34008b08:	60fb      	str	r3, [r7, #12]
      break;
34008b0a:	e003      	b.n	34008b14 <RCCEx_GetETH1CLKFreq+0xf0>
      break;
34008b0c:	bf00      	nop
34008b0e:	e002      	b.n	34008b16 <RCCEx_GetETH1CLKFreq+0xf2>
      break;
34008b10:	bf00      	nop
34008b12:	e000      	b.n	34008b16 <RCCEx_GetETH1CLKFreq+0xf2>
      break;
34008b14:	bf00      	nop
  }

  return eth1_frequency;
34008b16:	68fb      	ldr	r3, [r7, #12]
}
34008b18:	4618      	mov	r0, r3
34008b1a:	3710      	adds	r7, #16
34008b1c:	46bd      	mov	sp, r7
34008b1e:	bd80      	pop	{r7, pc}
34008b20:	016e3600 	.word	0x016e3600

34008b24 <RCCEx_GetETH1PTPCLKFreq>:
  *         @arg @ref RCCEx_ETH1_PTP_Clock_Source
  * @retval ETH1PTP clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetETH1PTPCLKFreq(uint32_t ETH1PTPxSource)
{
34008b24:	b580      	push	{r7, lr}
34008b26:	b084      	sub	sp, #16
34008b28:	af00      	add	r7, sp, #0
34008b2a:	6078      	str	r0, [r7, #4]
  uint32_t eth1ptp_frequency = RCC_PERIPH_FREQUENCY_NO;
34008b2c:	2300      	movs	r3, #0
34008b2e:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetETHPTPClockSource(ETH1PTPxSource))
34008b30:	6878      	ldr	r0, [r7, #4]
34008b32:	f7fb f97f 	bl	34003e34 <LL_RCC_GetETHPTPClockSource>
34008b36:	4603      	mov	r3, r0
34008b38:	2b03      	cmp	r3, #3
34008b3a:	d863      	bhi.n	34008c04 <RCCEx_GetETH1PTPCLKFreq+0xe0>
34008b3c:	a201      	add	r2, pc, #4	@ (adr r2, 34008b44 <RCCEx_GetETH1PTPCLKFreq+0x20>)
34008b3e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34008b42:	bf00      	nop
34008b44:	34008b55 	.word	0x34008b55
34008b48:	34008b65 	.word	0x34008b65
34008b4c:	34008b6f 	.word	0x34008b6f
34008b50:	34008bf5 	.word	0x34008bf5
  {
    case LL_RCC_ETH1PTP_CLKSOURCE_HCLK:
      eth1ptp_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34008b54:	f7fa fd88 	bl	34003668 <HAL_RCC_GetSysClockFreq>
34008b58:	4603      	mov	r3, r0
34008b5a:	4618      	mov	r0, r3
34008b5c:	f7ff f9ea 	bl	34007f34 <RCCEx_GetHCLKFreq>
34008b60:	60f8      	str	r0, [r7, #12]
      break;
34008b62:	e054      	b.n	34008c0e <RCCEx_GetETH1PTPCLKFreq+0xea>

    case LL_RCC_ETH1PTP_CLKSOURCE_CLKP:
      eth1ptp_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34008b64:	2007      	movs	r0, #7
34008b66:	f7ff fcd1 	bl	3400850c <RCCEx_GetCLKPCLKFreq>
34008b6a:	60f8      	str	r0, [r7, #12]
      break;
34008b6c:	e04f      	b.n	34008c0e <RCCEx_GetETH1PTPCLKFreq+0xea>

    case LL_RCC_ETH1PTP_CLKSOURCE_IC13:
      if (LL_RCC_IC13_IsEnabled() != 0U)
34008b6e:	f7fb ff35 	bl	340049dc <LL_RCC_IC13_IsEnabled>
34008b72:	4603      	mov	r3, r0
34008b74:	2b00      	cmp	r3, #0
34008b76:	d047      	beq.n	34008c08 <RCCEx_GetETH1PTPCLKFreq+0xe4>
      {
        ic_divider = LL_RCC_IC13_GetDivider();
34008b78:	f7fb ff52 	bl	34004a20 <LL_RCC_IC13_GetDivider>
34008b7c:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC13_GetSource())
34008b7e:	f7fb ff41 	bl	34004a04 <LL_RCC_IC13_GetSource>
34008b82:	4603      	mov	r3, r0
34008b84:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34008b88:	d029      	beq.n	34008bde <RCCEx_GetETH1PTPCLKFreq+0xba>
34008b8a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34008b8e:	d82f      	bhi.n	34008bf0 <RCCEx_GetETH1PTPCLKFreq+0xcc>
34008b90:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34008b94:	d01a      	beq.n	34008bcc <RCCEx_GetETH1PTPCLKFreq+0xa8>
34008b96:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34008b9a:	d829      	bhi.n	34008bf0 <RCCEx_GetETH1PTPCLKFreq+0xcc>
34008b9c:	2b00      	cmp	r3, #0
34008b9e:	d003      	beq.n	34008ba8 <RCCEx_GetETH1PTPCLKFreq+0x84>
34008ba0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34008ba4:	d009      	beq.n	34008bba <RCCEx_GetETH1PTPCLKFreq+0x96>
            eth1ptp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34008ba6:	e023      	b.n	34008bf0 <RCCEx_GetETH1PTPCLKFreq+0xcc>
            eth1ptp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34008ba8:	f7ff f8ac 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
34008bac:	60f8      	str	r0, [r7, #12]
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
34008bae:	68fa      	ldr	r2, [r7, #12]
34008bb0:	68bb      	ldr	r3, [r7, #8]
34008bb2:	fbb2 f3f3 	udiv	r3, r2, r3
34008bb6:	60fb      	str	r3, [r7, #12]
            break;
34008bb8:	e01b      	b.n	34008bf2 <RCCEx_GetETH1PTPCLKFreq+0xce>
            eth1ptp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34008bba:	f7ff f8e9 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
34008bbe:	60f8      	str	r0, [r7, #12]
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
34008bc0:	68fa      	ldr	r2, [r7, #12]
34008bc2:	68bb      	ldr	r3, [r7, #8]
34008bc4:	fbb2 f3f3 	udiv	r3, r2, r3
34008bc8:	60fb      	str	r3, [r7, #12]
            break;
34008bca:	e012      	b.n	34008bf2 <RCCEx_GetETH1PTPCLKFreq+0xce>
            eth1ptp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34008bcc:	f7ff f926 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
34008bd0:	60f8      	str	r0, [r7, #12]
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
34008bd2:	68fa      	ldr	r2, [r7, #12]
34008bd4:	68bb      	ldr	r3, [r7, #8]
34008bd6:	fbb2 f3f3 	udiv	r3, r2, r3
34008bda:	60fb      	str	r3, [r7, #12]
            break;
34008bdc:	e009      	b.n	34008bf2 <RCCEx_GetETH1PTPCLKFreq+0xce>
            eth1ptp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34008bde:	f7ff f963 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
34008be2:	60f8      	str	r0, [r7, #12]
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
34008be4:	68fa      	ldr	r2, [r7, #12]
34008be6:	68bb      	ldr	r3, [r7, #8]
34008be8:	fbb2 f3f3 	udiv	r3, r2, r3
34008bec:	60fb      	str	r3, [r7, #12]
            break;
34008bee:	e000      	b.n	34008bf2 <RCCEx_GetETH1PTPCLKFreq+0xce>
            break;
34008bf0:	bf00      	nop
        }
      }
      break;
34008bf2:	e009      	b.n	34008c08 <RCCEx_GetETH1PTPCLKFreq+0xe4>

    case LL_RCC_ETH1PTP_CLKSOURCE_HSE:
      if (LL_RCC_HSE_IsReady() != 0U)
34008bf4:	f7fa fdfc 	bl	340037f0 <LL_RCC_HSE_IsReady>
34008bf8:	4603      	mov	r3, r0
34008bfa:	2b00      	cmp	r3, #0
34008bfc:	d006      	beq.n	34008c0c <RCCEx_GetETH1PTPCLKFreq+0xe8>
      {
        eth1ptp_frequency = HSE_VALUE;
34008bfe:	4b0a      	ldr	r3, [pc, #40]	@ (34008c28 <RCCEx_GetETH1PTPCLKFreq+0x104>)
34008c00:	60fb      	str	r3, [r7, #12]
      }
      break;
34008c02:	e003      	b.n	34008c0c <RCCEx_GetETH1PTPCLKFreq+0xe8>

    default:
      /* Unexpected case */
      break;
34008c04:	bf00      	nop
34008c06:	e002      	b.n	34008c0e <RCCEx_GetETH1PTPCLKFreq+0xea>
      break;
34008c08:	bf00      	nop
34008c0a:	e000      	b.n	34008c0e <RCCEx_GetETH1PTPCLKFreq+0xea>
      break;
34008c0c:	bf00      	nop
  }

  return (eth1ptp_frequency / __HAL_RCC_GET_ETH1PTP_DIVIDER());
34008c0e:	f7fa ff4d 	bl	34003aac <LL_RCC_GetETH1PTPDivider>
34008c12:	4603      	mov	r3, r0
34008c14:	091b      	lsrs	r3, r3, #4
34008c16:	3301      	adds	r3, #1
34008c18:	68fa      	ldr	r2, [r7, #12]
34008c1a:	fbb2 f3f3 	udiv	r3, r2, r3
}
34008c1e:	4618      	mov	r0, r3
34008c20:	3710      	adds	r7, #16
34008c22:	46bd      	mov	sp, r7
34008c24:	bd80      	pop	{r7, pc}
34008c26:	bf00      	nop
34008c28:	016e3600 	.word	0x016e3600

34008c2c <RCCEx_GetFDCANCLKFreq>:
  *         @arg @ref RCCEx_FDCAN_Clock_Source
  * @retval FDCAN clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetFDCANCLKFreq(uint32_t FDCANxSource)
{
34008c2c:	b580      	push	{r7, lr}
34008c2e:	b084      	sub	sp, #16
34008c30:	af00      	add	r7, sp, #0
34008c32:	6078      	str	r0, [r7, #4]
  uint32_t fdcan_frequency = RCC_PERIPH_FREQUENCY_NO;
34008c34:	2300      	movs	r3, #0
34008c36:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetFDCANClockSource(FDCANxSource))
34008c38:	6878      	ldr	r0, [r7, #4]
34008c3a:	f7fb f90d 	bl	34003e58 <LL_RCC_GetFDCANClockSource>
34008c3e:	4603      	mov	r3, r0
34008c40:	2b03      	cmp	r3, #3
34008c42:	d867      	bhi.n	34008d14 <RCCEx_GetFDCANCLKFreq+0xe8>
34008c44:	a201      	add	r2, pc, #4	@ (adr r2, 34008c4c <RCCEx_GetFDCANCLKFreq+0x20>)
34008c46:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34008c4a:	bf00      	nop
34008c4c:	34008c5d 	.word	0x34008c5d
34008c50:	34008c75 	.word	0x34008c75
34008c54:	34008c7f 	.word	0x34008c7f
34008c58:	34008d05 	.word	0x34008d05
  {
    case LL_RCC_FDCAN_CLKSOURCE_PCLK1:
      fdcan_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34008c5c:	f7fa fd04 	bl	34003668 <HAL_RCC_GetSysClockFreq>
34008c60:	4603      	mov	r3, r0
34008c62:	4618      	mov	r0, r3
34008c64:	f7ff f966 	bl	34007f34 <RCCEx_GetHCLKFreq>
34008c68:	4603      	mov	r3, r0
34008c6a:	4618      	mov	r0, r3
34008c6c:	f7ff f973 	bl	34007f56 <RCCEx_GetPCLK1Freq>
34008c70:	60f8      	str	r0, [r7, #12]
      break;
34008c72:	e054      	b.n	34008d1e <RCCEx_GetFDCANCLKFreq+0xf2>

    case LL_RCC_FDCAN_CLKSOURCE_CLKP:
      fdcan_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34008c74:	2007      	movs	r0, #7
34008c76:	f7ff fc49 	bl	3400850c <RCCEx_GetCLKPCLKFreq>
34008c7a:	60f8      	str	r0, [r7, #12]
      break;
34008c7c:	e04f      	b.n	34008d1e <RCCEx_GetFDCANCLKFreq+0xf2>

    case LL_RCC_FDCAN_CLKSOURCE_IC19:
      if (LL_RCC_IC19_IsEnabled() != 0U)
34008c7e:	f7fc f82d 	bl	34004cdc <LL_RCC_IC19_IsEnabled>
34008c82:	4603      	mov	r3, r0
34008c84:	2b00      	cmp	r3, #0
34008c86:	d047      	beq.n	34008d18 <RCCEx_GetFDCANCLKFreq+0xec>
      {
        ic_divider = LL_RCC_IC19_GetDivider();
34008c88:	f7fc f84a 	bl	34004d20 <LL_RCC_IC19_GetDivider>
34008c8c:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC19_GetSource())
34008c8e:	f7fc f839 	bl	34004d04 <LL_RCC_IC19_GetSource>
34008c92:	4603      	mov	r3, r0
34008c94:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34008c98:	d029      	beq.n	34008cee <RCCEx_GetFDCANCLKFreq+0xc2>
34008c9a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34008c9e:	d82f      	bhi.n	34008d00 <RCCEx_GetFDCANCLKFreq+0xd4>
34008ca0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34008ca4:	d01a      	beq.n	34008cdc <RCCEx_GetFDCANCLKFreq+0xb0>
34008ca6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34008caa:	d829      	bhi.n	34008d00 <RCCEx_GetFDCANCLKFreq+0xd4>
34008cac:	2b00      	cmp	r3, #0
34008cae:	d003      	beq.n	34008cb8 <RCCEx_GetFDCANCLKFreq+0x8c>
34008cb0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34008cb4:	d009      	beq.n	34008cca <RCCEx_GetFDCANCLKFreq+0x9e>
            fdcan_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            fdcan_frequency = fdcan_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34008cb6:	e023      	b.n	34008d00 <RCCEx_GetFDCANCLKFreq+0xd4>
            fdcan_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34008cb8:	f7ff f824 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
34008cbc:	60f8      	str	r0, [r7, #12]
            fdcan_frequency = fdcan_frequency / ic_divider;
34008cbe:	68fa      	ldr	r2, [r7, #12]
34008cc0:	68bb      	ldr	r3, [r7, #8]
34008cc2:	fbb2 f3f3 	udiv	r3, r2, r3
34008cc6:	60fb      	str	r3, [r7, #12]
            break;
34008cc8:	e01b      	b.n	34008d02 <RCCEx_GetFDCANCLKFreq+0xd6>
            fdcan_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34008cca:	f7ff f861 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
34008cce:	60f8      	str	r0, [r7, #12]
            fdcan_frequency = fdcan_frequency / ic_divider;
34008cd0:	68fa      	ldr	r2, [r7, #12]
34008cd2:	68bb      	ldr	r3, [r7, #8]
34008cd4:	fbb2 f3f3 	udiv	r3, r2, r3
34008cd8:	60fb      	str	r3, [r7, #12]
            break;
34008cda:	e012      	b.n	34008d02 <RCCEx_GetFDCANCLKFreq+0xd6>
            fdcan_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34008cdc:	f7ff f89e 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
34008ce0:	60f8      	str	r0, [r7, #12]
            fdcan_frequency = fdcan_frequency / ic_divider;
34008ce2:	68fa      	ldr	r2, [r7, #12]
34008ce4:	68bb      	ldr	r3, [r7, #8]
34008ce6:	fbb2 f3f3 	udiv	r3, r2, r3
34008cea:	60fb      	str	r3, [r7, #12]
            break;
34008cec:	e009      	b.n	34008d02 <RCCEx_GetFDCANCLKFreq+0xd6>
            fdcan_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34008cee:	f7ff f8db 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
34008cf2:	60f8      	str	r0, [r7, #12]
            fdcan_frequency = fdcan_frequency / ic_divider;
34008cf4:	68fa      	ldr	r2, [r7, #12]
34008cf6:	68bb      	ldr	r3, [r7, #8]
34008cf8:	fbb2 f3f3 	udiv	r3, r2, r3
34008cfc:	60fb      	str	r3, [r7, #12]
            break;
34008cfe:	e000      	b.n	34008d02 <RCCEx_GetFDCANCLKFreq+0xd6>
            break;
34008d00:	bf00      	nop
        }
      }
      break;
34008d02:	e009      	b.n	34008d18 <RCCEx_GetFDCANCLKFreq+0xec>

    case LL_RCC_FDCAN_CLKSOURCE_HSE:
      if (LL_RCC_HSE_IsReady() != 0U)
34008d04:	f7fa fd74 	bl	340037f0 <LL_RCC_HSE_IsReady>
34008d08:	4603      	mov	r3, r0
34008d0a:	2b00      	cmp	r3, #0
34008d0c:	d006      	beq.n	34008d1c <RCCEx_GetFDCANCLKFreq+0xf0>
      {
        fdcan_frequency = HSE_VALUE;
34008d0e:	4b06      	ldr	r3, [pc, #24]	@ (34008d28 <RCCEx_GetFDCANCLKFreq+0xfc>)
34008d10:	60fb      	str	r3, [r7, #12]
      }
      break;
34008d12:	e003      	b.n	34008d1c <RCCEx_GetFDCANCLKFreq+0xf0>

    default:
      /* Unexpected case */
      break;
34008d14:	bf00      	nop
34008d16:	e002      	b.n	34008d1e <RCCEx_GetFDCANCLKFreq+0xf2>
      break;
34008d18:	bf00      	nop
34008d1a:	e000      	b.n	34008d1e <RCCEx_GetFDCANCLKFreq+0xf2>
      break;
34008d1c:	bf00      	nop
  }

  return fdcan_frequency;
34008d1e:	68fb      	ldr	r3, [r7, #12]
}
34008d20:	4618      	mov	r0, r3
34008d22:	3710      	adds	r7, #16
34008d24:	46bd      	mov	sp, r7
34008d26:	bd80      	pop	{r7, pc}
34008d28:	016e3600 	.word	0x016e3600

34008d2c <RCCEx_GetFMCCLKFreq>:
  *         @arg @ref RCCEx_FMC_Clock_Source
  * @retval FMC clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetFMCCLKFreq(uint32_t FMCxSource)
{
34008d2c:	b580      	push	{r7, lr}
34008d2e:	b084      	sub	sp, #16
34008d30:	af00      	add	r7, sp, #0
34008d32:	6078      	str	r0, [r7, #4]
  uint32_t fmc_frequency = RCC_PERIPH_FREQUENCY_NO;
34008d34:	2300      	movs	r3, #0
34008d36:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetFMCClockSource(FMCxSource))
34008d38:	6878      	ldr	r0, [r7, #4]
34008d3a:	f7fb f89f 	bl	34003e7c <LL_RCC_GetFMCClockSource>
34008d3e:	4603      	mov	r3, r0
34008d40:	2b30      	cmp	r3, #48	@ 0x30
34008d42:	d05d      	beq.n	34008e00 <RCCEx_GetFMCCLKFreq+0xd4>
34008d44:	2b30      	cmp	r3, #48	@ 0x30
34008d46:	f200 809e 	bhi.w	34008e86 <RCCEx_GetFMCCLKFreq+0x15a>
34008d4a:	2b20      	cmp	r3, #32
34008d4c:	d014      	beq.n	34008d78 <RCCEx_GetFMCCLKFreq+0x4c>
34008d4e:	2b20      	cmp	r3, #32
34008d50:	f200 8099 	bhi.w	34008e86 <RCCEx_GetFMCCLKFreq+0x15a>
34008d54:	2b00      	cmp	r3, #0
34008d56:	d002      	beq.n	34008d5e <RCCEx_GetFMCCLKFreq+0x32>
34008d58:	2b10      	cmp	r3, #16
34008d5a:	d008      	beq.n	34008d6e <RCCEx_GetFMCCLKFreq+0x42>
      }
      break;

    default:
      /* Unexpected case */
      break;
34008d5c:	e093      	b.n	34008e86 <RCCEx_GetFMCCLKFreq+0x15a>
      fmc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34008d5e:	f7fa fc83 	bl	34003668 <HAL_RCC_GetSysClockFreq>
34008d62:	4603      	mov	r3, r0
34008d64:	4618      	mov	r0, r3
34008d66:	f7ff f8e5 	bl	34007f34 <RCCEx_GetHCLKFreq>
34008d6a:	60f8      	str	r0, [r7, #12]
      break;
34008d6c:	e090      	b.n	34008e90 <RCCEx_GetFMCCLKFreq+0x164>
      fmc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34008d6e:	2007      	movs	r0, #7
34008d70:	f7ff fbcc 	bl	3400850c <RCCEx_GetCLKPCLKFreq>
34008d74:	60f8      	str	r0, [r7, #12]
      break;
34008d76:	e08b      	b.n	34008e90 <RCCEx_GetFMCCLKFreq+0x164>
      if (LL_RCC_IC3_IsEnabled() != 0U)
34008d78:	f7fb fc30 	bl	340045dc <LL_RCC_IC3_IsEnabled>
34008d7c:	4603      	mov	r3, r0
34008d7e:	2b00      	cmp	r3, #0
34008d80:	f000 8083 	beq.w	34008e8a <RCCEx_GetFMCCLKFreq+0x15e>
        ic_divider = LL_RCC_IC3_GetDivider();
34008d84:	f7fb fc4c 	bl	34004620 <LL_RCC_IC3_GetDivider>
34008d88:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC3_GetSource())
34008d8a:	f7fb fc3b 	bl	34004604 <LL_RCC_IC3_GetSource>
34008d8e:	4603      	mov	r3, r0
34008d90:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34008d94:	d029      	beq.n	34008dea <RCCEx_GetFMCCLKFreq+0xbe>
34008d96:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34008d9a:	d82f      	bhi.n	34008dfc <RCCEx_GetFMCCLKFreq+0xd0>
34008d9c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34008da0:	d01a      	beq.n	34008dd8 <RCCEx_GetFMCCLKFreq+0xac>
34008da2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34008da6:	d829      	bhi.n	34008dfc <RCCEx_GetFMCCLKFreq+0xd0>
34008da8:	2b00      	cmp	r3, #0
34008daa:	d003      	beq.n	34008db4 <RCCEx_GetFMCCLKFreq+0x88>
34008dac:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34008db0:	d009      	beq.n	34008dc6 <RCCEx_GetFMCCLKFreq+0x9a>
            break;
34008db2:	e023      	b.n	34008dfc <RCCEx_GetFMCCLKFreq+0xd0>
            fmc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34008db4:	f7fe ffa6 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
34008db8:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
34008dba:	68fa      	ldr	r2, [r7, #12]
34008dbc:	68bb      	ldr	r3, [r7, #8]
34008dbe:	fbb2 f3f3 	udiv	r3, r2, r3
34008dc2:	60fb      	str	r3, [r7, #12]
            break;
34008dc4:	e01b      	b.n	34008dfe <RCCEx_GetFMCCLKFreq+0xd2>
            fmc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34008dc6:	f7fe ffe3 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
34008dca:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
34008dcc:	68fa      	ldr	r2, [r7, #12]
34008dce:	68bb      	ldr	r3, [r7, #8]
34008dd0:	fbb2 f3f3 	udiv	r3, r2, r3
34008dd4:	60fb      	str	r3, [r7, #12]
            break;
34008dd6:	e012      	b.n	34008dfe <RCCEx_GetFMCCLKFreq+0xd2>
            fmc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34008dd8:	f7ff f820 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
34008ddc:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
34008dde:	68fa      	ldr	r2, [r7, #12]
34008de0:	68bb      	ldr	r3, [r7, #8]
34008de2:	fbb2 f3f3 	udiv	r3, r2, r3
34008de6:	60fb      	str	r3, [r7, #12]
            break;
34008de8:	e009      	b.n	34008dfe <RCCEx_GetFMCCLKFreq+0xd2>
            fmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34008dea:	f7ff f85d 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
34008dee:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
34008df0:	68fa      	ldr	r2, [r7, #12]
34008df2:	68bb      	ldr	r3, [r7, #8]
34008df4:	fbb2 f3f3 	udiv	r3, r2, r3
34008df8:	60fb      	str	r3, [r7, #12]
            break;
34008dfa:	e000      	b.n	34008dfe <RCCEx_GetFMCCLKFreq+0xd2>
            break;
34008dfc:	bf00      	nop
      break;
34008dfe:	e044      	b.n	34008e8a <RCCEx_GetFMCCLKFreq+0x15e>
      if (LL_RCC_IC4_IsEnabled() != 0U)
34008e00:	f7fb fc2c 	bl	3400465c <LL_RCC_IC4_IsEnabled>
34008e04:	4603      	mov	r3, r0
34008e06:	2b00      	cmp	r3, #0
34008e08:	d041      	beq.n	34008e8e <RCCEx_GetFMCCLKFreq+0x162>
        ic_divider = LL_RCC_IC4_GetDivider();
34008e0a:	f7fb fc49 	bl	340046a0 <LL_RCC_IC4_GetDivider>
34008e0e:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC4_GetSource())
34008e10:	f7fb fc38 	bl	34004684 <LL_RCC_IC4_GetSource>
34008e14:	4603      	mov	r3, r0
34008e16:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34008e1a:	d029      	beq.n	34008e70 <RCCEx_GetFMCCLKFreq+0x144>
34008e1c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34008e20:	d82f      	bhi.n	34008e82 <RCCEx_GetFMCCLKFreq+0x156>
34008e22:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34008e26:	d01a      	beq.n	34008e5e <RCCEx_GetFMCCLKFreq+0x132>
34008e28:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34008e2c:	d829      	bhi.n	34008e82 <RCCEx_GetFMCCLKFreq+0x156>
34008e2e:	2b00      	cmp	r3, #0
34008e30:	d003      	beq.n	34008e3a <RCCEx_GetFMCCLKFreq+0x10e>
34008e32:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34008e36:	d009      	beq.n	34008e4c <RCCEx_GetFMCCLKFreq+0x120>
            break;
34008e38:	e023      	b.n	34008e82 <RCCEx_GetFMCCLKFreq+0x156>
            fmc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34008e3a:	f7fe ff63 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
34008e3e:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
34008e40:	68fa      	ldr	r2, [r7, #12]
34008e42:	68bb      	ldr	r3, [r7, #8]
34008e44:	fbb2 f3f3 	udiv	r3, r2, r3
34008e48:	60fb      	str	r3, [r7, #12]
            break;
34008e4a:	e01b      	b.n	34008e84 <RCCEx_GetFMCCLKFreq+0x158>
            fmc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34008e4c:	f7fe ffa0 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
34008e50:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
34008e52:	68fa      	ldr	r2, [r7, #12]
34008e54:	68bb      	ldr	r3, [r7, #8]
34008e56:	fbb2 f3f3 	udiv	r3, r2, r3
34008e5a:	60fb      	str	r3, [r7, #12]
            break;
34008e5c:	e012      	b.n	34008e84 <RCCEx_GetFMCCLKFreq+0x158>
            fmc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34008e5e:	f7fe ffdd 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
34008e62:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
34008e64:	68fa      	ldr	r2, [r7, #12]
34008e66:	68bb      	ldr	r3, [r7, #8]
34008e68:	fbb2 f3f3 	udiv	r3, r2, r3
34008e6c:	60fb      	str	r3, [r7, #12]
            break;
34008e6e:	e009      	b.n	34008e84 <RCCEx_GetFMCCLKFreq+0x158>
            fmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34008e70:	f7ff f81a 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
34008e74:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
34008e76:	68fa      	ldr	r2, [r7, #12]
34008e78:	68bb      	ldr	r3, [r7, #8]
34008e7a:	fbb2 f3f3 	udiv	r3, r2, r3
34008e7e:	60fb      	str	r3, [r7, #12]
            break;
34008e80:	e000      	b.n	34008e84 <RCCEx_GetFMCCLKFreq+0x158>
            break;
34008e82:	bf00      	nop
      break;
34008e84:	e003      	b.n	34008e8e <RCCEx_GetFMCCLKFreq+0x162>
      break;
34008e86:	bf00      	nop
34008e88:	e002      	b.n	34008e90 <RCCEx_GetFMCCLKFreq+0x164>
      break;
34008e8a:	bf00      	nop
34008e8c:	e000      	b.n	34008e90 <RCCEx_GetFMCCLKFreq+0x164>
      break;
34008e8e:	bf00      	nop
  }

  return fmc_frequency;
34008e90:	68fb      	ldr	r3, [r7, #12]
}
34008e92:	4618      	mov	r0, r3
34008e94:	3710      	adds	r7, #16
34008e96:	46bd      	mov	sp, r7
34008e98:	bd80      	pop	{r7, pc}
	...

34008e9c <RCCEx_GetI2CCLKFreq>:
  *         @arg @ref RCCEx_I2C4_Clock_Source
  * @retval I2C clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetI2CCLKFreq(uint32_t I2CxSource)
{
34008e9c:	b580      	push	{r7, lr}
34008e9e:	b084      	sub	sp, #16
34008ea0:	af00      	add	r7, sp, #0
34008ea2:	6078      	str	r0, [r7, #4]
  uint32_t i2c_frequency = RCC_PERIPH_FREQUENCY_NO;
34008ea4:	2300      	movs	r3, #0
34008ea6:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetI2CClockSource(I2CxSource))
34008ea8:	6878      	ldr	r0, [r7, #4]
34008eaa:	f7fa fff9 	bl	34003ea0 <LL_RCC_GetI2CClockSource>
34008eae:	4603      	mov	r3, r0
34008eb0:	4aa2      	ldr	r2, [pc, #648]	@ (3400913c <RCCEx_GetI2CCLKFreq+0x2a0>)
34008eb2:	4293      	cmp	r3, r2
34008eb4:	f000 8172 	beq.w	3400919c <RCCEx_GetI2CCLKFreq+0x300>
34008eb8:	4aa0      	ldr	r2, [pc, #640]	@ (3400913c <RCCEx_GetI2CCLKFreq+0x2a0>)
34008eba:	4293      	cmp	r3, r2
34008ebc:	f200 8184 	bhi.w	340091c8 <RCCEx_GetI2CCLKFreq+0x32c>
34008ec0:	4a9f      	ldr	r2, [pc, #636]	@ (34009140 <RCCEx_GetI2CCLKFreq+0x2a4>)
34008ec2:	4293      	cmp	r3, r2
34008ec4:	f000 816a 	beq.w	3400919c <RCCEx_GetI2CCLKFreq+0x300>
34008ec8:	4a9d      	ldr	r2, [pc, #628]	@ (34009140 <RCCEx_GetI2CCLKFreq+0x2a4>)
34008eca:	4293      	cmp	r3, r2
34008ecc:	f200 817c 	bhi.w	340091c8 <RCCEx_GetI2CCLKFreq+0x32c>
34008ed0:	4a9c      	ldr	r2, [pc, #624]	@ (34009144 <RCCEx_GetI2CCLKFreq+0x2a8>)
34008ed2:	4293      	cmp	r3, r2
34008ed4:	f000 8162 	beq.w	3400919c <RCCEx_GetI2CCLKFreq+0x300>
34008ed8:	4a9a      	ldr	r2, [pc, #616]	@ (34009144 <RCCEx_GetI2CCLKFreq+0x2a8>)
34008eda:	4293      	cmp	r3, r2
34008edc:	f200 8174 	bhi.w	340091c8 <RCCEx_GetI2CCLKFreq+0x32c>
34008ee0:	4a99      	ldr	r2, [pc, #612]	@ (34009148 <RCCEx_GetI2CCLKFreq+0x2ac>)
34008ee2:	4293      	cmp	r3, r2
34008ee4:	f000 815a 	beq.w	3400919c <RCCEx_GetI2CCLKFreq+0x300>
34008ee8:	4a97      	ldr	r2, [pc, #604]	@ (34009148 <RCCEx_GetI2CCLKFreq+0x2ac>)
34008eea:	4293      	cmp	r3, r2
34008eec:	f200 816c 	bhi.w	340091c8 <RCCEx_GetI2CCLKFreq+0x32c>
34008ef0:	4a96      	ldr	r2, [pc, #600]	@ (3400914c <RCCEx_GetI2CCLKFreq+0x2b0>)
34008ef2:	4293      	cmp	r3, r2
34008ef4:	f000 8160 	beq.w	340091b8 <RCCEx_GetI2CCLKFreq+0x31c>
34008ef8:	4a94      	ldr	r2, [pc, #592]	@ (3400914c <RCCEx_GetI2CCLKFreq+0x2b0>)
34008efa:	4293      	cmp	r3, r2
34008efc:	f200 8164 	bhi.w	340091c8 <RCCEx_GetI2CCLKFreq+0x32c>
34008f00:	4a93      	ldr	r2, [pc, #588]	@ (34009150 <RCCEx_GetI2CCLKFreq+0x2b4>)
34008f02:	4293      	cmp	r3, r2
34008f04:	f000 8158 	beq.w	340091b8 <RCCEx_GetI2CCLKFreq+0x31c>
34008f08:	4a91      	ldr	r2, [pc, #580]	@ (34009150 <RCCEx_GetI2CCLKFreq+0x2b4>)
34008f0a:	4293      	cmp	r3, r2
34008f0c:	f200 815c 	bhi.w	340091c8 <RCCEx_GetI2CCLKFreq+0x32c>
34008f10:	4a90      	ldr	r2, [pc, #576]	@ (34009154 <RCCEx_GetI2CCLKFreq+0x2b8>)
34008f12:	4293      	cmp	r3, r2
34008f14:	f000 8150 	beq.w	340091b8 <RCCEx_GetI2CCLKFreq+0x31c>
34008f18:	4a8e      	ldr	r2, [pc, #568]	@ (34009154 <RCCEx_GetI2CCLKFreq+0x2b8>)
34008f1a:	4293      	cmp	r3, r2
34008f1c:	f200 8154 	bhi.w	340091c8 <RCCEx_GetI2CCLKFreq+0x32c>
34008f20:	4a8d      	ldr	r2, [pc, #564]	@ (34009158 <RCCEx_GetI2CCLKFreq+0x2bc>)
34008f22:	4293      	cmp	r3, r2
34008f24:	f000 8148 	beq.w	340091b8 <RCCEx_GetI2CCLKFreq+0x31c>
34008f28:	4a8b      	ldr	r2, [pc, #556]	@ (34009158 <RCCEx_GetI2CCLKFreq+0x2bc>)
34008f2a:	4293      	cmp	r3, r2
34008f2c:	f200 814c 	bhi.w	340091c8 <RCCEx_GetI2CCLKFreq+0x32c>
34008f30:	4a8a      	ldr	r2, [pc, #552]	@ (3400915c <RCCEx_GetI2CCLKFreq+0x2c0>)
34008f32:	4293      	cmp	r3, r2
34008f34:	f000 80be 	beq.w	340090b4 <RCCEx_GetI2CCLKFreq+0x218>
34008f38:	4a88      	ldr	r2, [pc, #544]	@ (3400915c <RCCEx_GetI2CCLKFreq+0x2c0>)
34008f3a:	4293      	cmp	r3, r2
34008f3c:	f200 8144 	bhi.w	340091c8 <RCCEx_GetI2CCLKFreq+0x32c>
34008f40:	4a87      	ldr	r2, [pc, #540]	@ (34009160 <RCCEx_GetI2CCLKFreq+0x2c4>)
34008f42:	4293      	cmp	r3, r2
34008f44:	f000 80b6 	beq.w	340090b4 <RCCEx_GetI2CCLKFreq+0x218>
34008f48:	4a85      	ldr	r2, [pc, #532]	@ (34009160 <RCCEx_GetI2CCLKFreq+0x2c4>)
34008f4a:	4293      	cmp	r3, r2
34008f4c:	f200 813c 	bhi.w	340091c8 <RCCEx_GetI2CCLKFreq+0x32c>
34008f50:	4a84      	ldr	r2, [pc, #528]	@ (34009164 <RCCEx_GetI2CCLKFreq+0x2c8>)
34008f52:	4293      	cmp	r3, r2
34008f54:	f000 80ae 	beq.w	340090b4 <RCCEx_GetI2CCLKFreq+0x218>
34008f58:	4a82      	ldr	r2, [pc, #520]	@ (34009164 <RCCEx_GetI2CCLKFreq+0x2c8>)
34008f5a:	4293      	cmp	r3, r2
34008f5c:	f200 8134 	bhi.w	340091c8 <RCCEx_GetI2CCLKFreq+0x32c>
34008f60:	4a81      	ldr	r2, [pc, #516]	@ (34009168 <RCCEx_GetI2CCLKFreq+0x2cc>)
34008f62:	4293      	cmp	r3, r2
34008f64:	f000 80a6 	beq.w	340090b4 <RCCEx_GetI2CCLKFreq+0x218>
34008f68:	4a7f      	ldr	r2, [pc, #508]	@ (34009168 <RCCEx_GetI2CCLKFreq+0x2cc>)
34008f6a:	4293      	cmp	r3, r2
34008f6c:	f200 812c 	bhi.w	340091c8 <RCCEx_GetI2CCLKFreq+0x32c>
34008f70:	4a7e      	ldr	r2, [pc, #504]	@ (3400916c <RCCEx_GetI2CCLKFreq+0x2d0>)
34008f72:	4293      	cmp	r3, r2
34008f74:	d05a      	beq.n	3400902c <RCCEx_GetI2CCLKFreq+0x190>
34008f76:	4a7d      	ldr	r2, [pc, #500]	@ (3400916c <RCCEx_GetI2CCLKFreq+0x2d0>)
34008f78:	4293      	cmp	r3, r2
34008f7a:	f200 8125 	bhi.w	340091c8 <RCCEx_GetI2CCLKFreq+0x32c>
34008f7e:	4a7c      	ldr	r2, [pc, #496]	@ (34009170 <RCCEx_GetI2CCLKFreq+0x2d4>)
34008f80:	4293      	cmp	r3, r2
34008f82:	d053      	beq.n	3400902c <RCCEx_GetI2CCLKFreq+0x190>
34008f84:	4a7a      	ldr	r2, [pc, #488]	@ (34009170 <RCCEx_GetI2CCLKFreq+0x2d4>)
34008f86:	4293      	cmp	r3, r2
34008f88:	f200 811e 	bhi.w	340091c8 <RCCEx_GetI2CCLKFreq+0x32c>
34008f8c:	4a79      	ldr	r2, [pc, #484]	@ (34009174 <RCCEx_GetI2CCLKFreq+0x2d8>)
34008f8e:	4293      	cmp	r3, r2
34008f90:	d04c      	beq.n	3400902c <RCCEx_GetI2CCLKFreq+0x190>
34008f92:	4a78      	ldr	r2, [pc, #480]	@ (34009174 <RCCEx_GetI2CCLKFreq+0x2d8>)
34008f94:	4293      	cmp	r3, r2
34008f96:	f200 8117 	bhi.w	340091c8 <RCCEx_GetI2CCLKFreq+0x32c>
34008f9a:	4a77      	ldr	r2, [pc, #476]	@ (34009178 <RCCEx_GetI2CCLKFreq+0x2dc>)
34008f9c:	4293      	cmp	r3, r2
34008f9e:	d045      	beq.n	3400902c <RCCEx_GetI2CCLKFreq+0x190>
34008fa0:	4a75      	ldr	r2, [pc, #468]	@ (34009178 <RCCEx_GetI2CCLKFreq+0x2dc>)
34008fa2:	4293      	cmp	r3, r2
34008fa4:	f200 8110 	bhi.w	340091c8 <RCCEx_GetI2CCLKFreq+0x32c>
34008fa8:	4a74      	ldr	r2, [pc, #464]	@ (3400917c <RCCEx_GetI2CCLKFreq+0x2e0>)
34008faa:	4293      	cmp	r3, r2
34008fac:	d039      	beq.n	34009022 <RCCEx_GetI2CCLKFreq+0x186>
34008fae:	4a73      	ldr	r2, [pc, #460]	@ (3400917c <RCCEx_GetI2CCLKFreq+0x2e0>)
34008fb0:	4293      	cmp	r3, r2
34008fb2:	f200 8109 	bhi.w	340091c8 <RCCEx_GetI2CCLKFreq+0x32c>
34008fb6:	4a72      	ldr	r2, [pc, #456]	@ (34009180 <RCCEx_GetI2CCLKFreq+0x2e4>)
34008fb8:	4293      	cmp	r3, r2
34008fba:	d032      	beq.n	34009022 <RCCEx_GetI2CCLKFreq+0x186>
34008fbc:	4a70      	ldr	r2, [pc, #448]	@ (34009180 <RCCEx_GetI2CCLKFreq+0x2e4>)
34008fbe:	4293      	cmp	r3, r2
34008fc0:	f200 8102 	bhi.w	340091c8 <RCCEx_GetI2CCLKFreq+0x32c>
34008fc4:	4a6f      	ldr	r2, [pc, #444]	@ (34009184 <RCCEx_GetI2CCLKFreq+0x2e8>)
34008fc6:	4293      	cmp	r3, r2
34008fc8:	d02b      	beq.n	34009022 <RCCEx_GetI2CCLKFreq+0x186>
34008fca:	4a6e      	ldr	r2, [pc, #440]	@ (34009184 <RCCEx_GetI2CCLKFreq+0x2e8>)
34008fcc:	4293      	cmp	r3, r2
34008fce:	f200 80fb 	bhi.w	340091c8 <RCCEx_GetI2CCLKFreq+0x32c>
34008fd2:	4a6d      	ldr	r2, [pc, #436]	@ (34009188 <RCCEx_GetI2CCLKFreq+0x2ec>)
34008fd4:	4293      	cmp	r3, r2
34008fd6:	d024      	beq.n	34009022 <RCCEx_GetI2CCLKFreq+0x186>
34008fd8:	4a6b      	ldr	r2, [pc, #428]	@ (34009188 <RCCEx_GetI2CCLKFreq+0x2ec>)
34008fda:	4293      	cmp	r3, r2
34008fdc:	f200 80f4 	bhi.w	340091c8 <RCCEx_GetI2CCLKFreq+0x32c>
34008fe0:	4a6a      	ldr	r2, [pc, #424]	@ (3400918c <RCCEx_GetI2CCLKFreq+0x2f0>)
34008fe2:	4293      	cmp	r3, r2
34008fe4:	d011      	beq.n	3400900a <RCCEx_GetI2CCLKFreq+0x16e>
34008fe6:	4a69      	ldr	r2, [pc, #420]	@ (3400918c <RCCEx_GetI2CCLKFreq+0x2f0>)
34008fe8:	4293      	cmp	r3, r2
34008fea:	f200 80ed 	bhi.w	340091c8 <RCCEx_GetI2CCLKFreq+0x32c>
34008fee:	4a68      	ldr	r2, [pc, #416]	@ (34009190 <RCCEx_GetI2CCLKFreq+0x2f4>)
34008ff0:	4293      	cmp	r3, r2
34008ff2:	d00a      	beq.n	3400900a <RCCEx_GetI2CCLKFreq+0x16e>
34008ff4:	4a66      	ldr	r2, [pc, #408]	@ (34009190 <RCCEx_GetI2CCLKFreq+0x2f4>)
34008ff6:	4293      	cmp	r3, r2
34008ff8:	f200 80e6 	bhi.w	340091c8 <RCCEx_GetI2CCLKFreq+0x32c>
34008ffc:	4a65      	ldr	r2, [pc, #404]	@ (34009194 <RCCEx_GetI2CCLKFreq+0x2f8>)
34008ffe:	4293      	cmp	r3, r2
34009000:	d003      	beq.n	3400900a <RCCEx_GetI2CCLKFreq+0x16e>
34009002:	4a65      	ldr	r2, [pc, #404]	@ (34009198 <RCCEx_GetI2CCLKFreq+0x2fc>)
34009004:	4293      	cmp	r3, r2
34009006:	f040 80df 	bne.w	340091c8 <RCCEx_GetI2CCLKFreq+0x32c>
  {
    case LL_RCC_I2C1_CLKSOURCE_PCLK1:
    case LL_RCC_I2C2_CLKSOURCE_PCLK1:
    case LL_RCC_I2C3_CLKSOURCE_PCLK1:
    case LL_RCC_I2C4_CLKSOURCE_PCLK1:
      i2c_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400900a:	f7fa fb2d 	bl	34003668 <HAL_RCC_GetSysClockFreq>
3400900e:	4603      	mov	r3, r0
34009010:	4618      	mov	r0, r3
34009012:	f7fe ff8f 	bl	34007f34 <RCCEx_GetHCLKFreq>
34009016:	4603      	mov	r3, r0
34009018:	4618      	mov	r0, r3
3400901a:	f7fe ff9c 	bl	34007f56 <RCCEx_GetPCLK1Freq>
3400901e:	60f8      	str	r0, [r7, #12]
      break;
34009020:	e0db      	b.n	340091da <RCCEx_GetI2CCLKFreq+0x33e>

    case LL_RCC_I2C1_CLKSOURCE_CLKP:
    case LL_RCC_I2C2_CLKSOURCE_CLKP:
    case LL_RCC_I2C3_CLKSOURCE_CLKP:
    case LL_RCC_I2C4_CLKSOURCE_CLKP:
      i2c_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34009022:	2007      	movs	r0, #7
34009024:	f7ff fa72 	bl	3400850c <RCCEx_GetCLKPCLKFreq>
34009028:	60f8      	str	r0, [r7, #12]
      break;
3400902a:	e0d6      	b.n	340091da <RCCEx_GetI2CCLKFreq+0x33e>

    case LL_RCC_I2C1_CLKSOURCE_IC10:
    case LL_RCC_I2C2_CLKSOURCE_IC10:
    case LL_RCC_I2C3_CLKSOURCE_IC10:
    case LL_RCC_I2C4_CLKSOURCE_IC10:
      if (LL_RCC_IC10_IsEnabled() != 0U)
3400902c:	f7fb fc56 	bl	340048dc <LL_RCC_IC10_IsEnabled>
34009030:	4603      	mov	r3, r0
34009032:	2b00      	cmp	r3, #0
34009034:	f000 80ca 	beq.w	340091cc <RCCEx_GetI2CCLKFreq+0x330>
      {
        ic_divider = LL_RCC_IC10_GetDivider();
34009038:	f7fb fc72 	bl	34004920 <LL_RCC_IC10_GetDivider>
3400903c:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC10_GetSource())
3400903e:	f7fb fc61 	bl	34004904 <LL_RCC_IC10_GetSource>
34009042:	4603      	mov	r3, r0
34009044:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34009048:	d029      	beq.n	3400909e <RCCEx_GetI2CCLKFreq+0x202>
3400904a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400904e:	d82f      	bhi.n	340090b0 <RCCEx_GetI2CCLKFreq+0x214>
34009050:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34009054:	d01a      	beq.n	3400908c <RCCEx_GetI2CCLKFreq+0x1f0>
34009056:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400905a:	d829      	bhi.n	340090b0 <RCCEx_GetI2CCLKFreq+0x214>
3400905c:	2b00      	cmp	r3, #0
3400905e:	d003      	beq.n	34009068 <RCCEx_GetI2CCLKFreq+0x1cc>
34009060:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34009064:	d009      	beq.n	3400907a <RCCEx_GetI2CCLKFreq+0x1de>
            i2c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            i2c_frequency = i2c_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34009066:	e023      	b.n	340090b0 <RCCEx_GetI2CCLKFreq+0x214>
            i2c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34009068:	f7fe fe4c 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
3400906c:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
3400906e:	68fa      	ldr	r2, [r7, #12]
34009070:	68bb      	ldr	r3, [r7, #8]
34009072:	fbb2 f3f3 	udiv	r3, r2, r3
34009076:	60fb      	str	r3, [r7, #12]
            break;
34009078:	e01b      	b.n	340090b2 <RCCEx_GetI2CCLKFreq+0x216>
            i2c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400907a:	f7fe fe89 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
3400907e:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
34009080:	68fa      	ldr	r2, [r7, #12]
34009082:	68bb      	ldr	r3, [r7, #8]
34009084:	fbb2 f3f3 	udiv	r3, r2, r3
34009088:	60fb      	str	r3, [r7, #12]
            break;
3400908a:	e012      	b.n	340090b2 <RCCEx_GetI2CCLKFreq+0x216>
            i2c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400908c:	f7fe fec6 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
34009090:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
34009092:	68fa      	ldr	r2, [r7, #12]
34009094:	68bb      	ldr	r3, [r7, #8]
34009096:	fbb2 f3f3 	udiv	r3, r2, r3
3400909a:	60fb      	str	r3, [r7, #12]
            break;
3400909c:	e009      	b.n	340090b2 <RCCEx_GetI2CCLKFreq+0x216>
            i2c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400909e:	f7fe ff03 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
340090a2:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
340090a4:	68fa      	ldr	r2, [r7, #12]
340090a6:	68bb      	ldr	r3, [r7, #8]
340090a8:	fbb2 f3f3 	udiv	r3, r2, r3
340090ac:	60fb      	str	r3, [r7, #12]
            break;
340090ae:	e000      	b.n	340090b2 <RCCEx_GetI2CCLKFreq+0x216>
            break;
340090b0:	bf00      	nop
        }
      }
      break;
340090b2:	e08b      	b.n	340091cc <RCCEx_GetI2CCLKFreq+0x330>

    case LL_RCC_I2C1_CLKSOURCE_IC15:
    case LL_RCC_I2C2_CLKSOURCE_IC15:
    case LL_RCC_I2C3_CLKSOURCE_IC15:
    case LL_RCC_I2C4_CLKSOURCE_IC15:
      if (LL_RCC_IC15_IsEnabled() != 0U)
340090b4:	f7fb fd12 	bl	34004adc <LL_RCC_IC15_IsEnabled>
340090b8:	4603      	mov	r3, r0
340090ba:	2b00      	cmp	r3, #0
340090bc:	f000 8088 	beq.w	340091d0 <RCCEx_GetI2CCLKFreq+0x334>
      {
        ic_divider = LL_RCC_IC15_GetDivider();
340090c0:	f7fb fd2e 	bl	34004b20 <LL_RCC_IC15_GetDivider>
340090c4:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC15_GetSource())
340090c6:	f7fb fd1d 	bl	34004b04 <LL_RCC_IC15_GetSource>
340090ca:	4603      	mov	r3, r0
340090cc:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340090d0:	d029      	beq.n	34009126 <RCCEx_GetI2CCLKFreq+0x28a>
340090d2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340090d6:	d82f      	bhi.n	34009138 <RCCEx_GetI2CCLKFreq+0x29c>
340090d8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340090dc:	d01a      	beq.n	34009114 <RCCEx_GetI2CCLKFreq+0x278>
340090de:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340090e2:	d829      	bhi.n	34009138 <RCCEx_GetI2CCLKFreq+0x29c>
340090e4:	2b00      	cmp	r3, #0
340090e6:	d003      	beq.n	340090f0 <RCCEx_GetI2CCLKFreq+0x254>
340090e8:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340090ec:	d009      	beq.n	34009102 <RCCEx_GetI2CCLKFreq+0x266>
            i2c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            i2c_frequency = i2c_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
340090ee:	e023      	b.n	34009138 <RCCEx_GetI2CCLKFreq+0x29c>
            i2c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340090f0:	f7fe fe08 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
340090f4:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
340090f6:	68fa      	ldr	r2, [r7, #12]
340090f8:	68bb      	ldr	r3, [r7, #8]
340090fa:	fbb2 f3f3 	udiv	r3, r2, r3
340090fe:	60fb      	str	r3, [r7, #12]
            break;
34009100:	e01b      	b.n	3400913a <RCCEx_GetI2CCLKFreq+0x29e>
            i2c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34009102:	f7fe fe45 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
34009106:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
34009108:	68fa      	ldr	r2, [r7, #12]
3400910a:	68bb      	ldr	r3, [r7, #8]
3400910c:	fbb2 f3f3 	udiv	r3, r2, r3
34009110:	60fb      	str	r3, [r7, #12]
            break;
34009112:	e012      	b.n	3400913a <RCCEx_GetI2CCLKFreq+0x29e>
            i2c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34009114:	f7fe fe82 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
34009118:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
3400911a:	68fa      	ldr	r2, [r7, #12]
3400911c:	68bb      	ldr	r3, [r7, #8]
3400911e:	fbb2 f3f3 	udiv	r3, r2, r3
34009122:	60fb      	str	r3, [r7, #12]
            break;
34009124:	e009      	b.n	3400913a <RCCEx_GetI2CCLKFreq+0x29e>
            i2c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34009126:	f7fe febf 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
3400912a:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
3400912c:	68fa      	ldr	r2, [r7, #12]
3400912e:	68bb      	ldr	r3, [r7, #8]
34009130:	fbb2 f3f3 	udiv	r3, r2, r3
34009134:	60fb      	str	r3, [r7, #12]
            break;
34009136:	e000      	b.n	3400913a <RCCEx_GetI2CCLKFreq+0x29e>
            break;
34009138:	bf00      	nop
        }
      }
      break;
3400913a:	e049      	b.n	340091d0 <RCCEx_GetI2CCLKFreq+0x334>
3400913c:	07050c0c 	.word	0x07050c0c
34009140:	0705080c 	.word	0x0705080c
34009144:	0705040c 	.word	0x0705040c
34009148:	0705000c 	.word	0x0705000c
3400914c:	07040c0c 	.word	0x07040c0c
34009150:	0704080c 	.word	0x0704080c
34009154:	0704040c 	.word	0x0704040c
34009158:	0704000c 	.word	0x0704000c
3400915c:	07030c0c 	.word	0x07030c0c
34009160:	0703080c 	.word	0x0703080c
34009164:	0703040c 	.word	0x0703040c
34009168:	0703000c 	.word	0x0703000c
3400916c:	07020c0c 	.word	0x07020c0c
34009170:	0702080c 	.word	0x0702080c
34009174:	0702040c 	.word	0x0702040c
34009178:	0702000c 	.word	0x0702000c
3400917c:	07010c0c 	.word	0x07010c0c
34009180:	0701080c 	.word	0x0701080c
34009184:	0701040c 	.word	0x0701040c
34009188:	0701000c 	.word	0x0701000c
3400918c:	07000c0c 	.word	0x07000c0c
34009190:	0700080c 	.word	0x0700080c
34009194:	0700000c 	.word	0x0700000c
34009198:	0700040c 	.word	0x0700040c

    case LL_RCC_I2C1_CLKSOURCE_HSI:
    case LL_RCC_I2C2_CLKSOURCE_HSI:
    case LL_RCC_I2C3_CLKSOURCE_HSI:
    case LL_RCC_I2C4_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
3400919c:	f7fa fb3a 	bl	34003814 <LL_RCC_HSI_IsReady>
340091a0:	4603      	mov	r3, r0
340091a2:	2b00      	cmp	r3, #0
340091a4:	d016      	beq.n	340091d4 <RCCEx_GetI2CCLKFreq+0x338>
      {
        i2c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
340091a6:	f7fa fb47 	bl	34003838 <LL_RCC_HSI_GetDivider>
340091aa:	4603      	mov	r3, r0
340091ac:	09db      	lsrs	r3, r3, #7
340091ae:	4a0d      	ldr	r2, [pc, #52]	@ (340091e4 <RCCEx_GetI2CCLKFreq+0x348>)
340091b0:	fa22 f303 	lsr.w	r3, r2, r3
340091b4:	60fb      	str	r3, [r7, #12]
      }
      break;
340091b6:	e00d      	b.n	340091d4 <RCCEx_GetI2CCLKFreq+0x338>

    case LL_RCC_I2C1_CLKSOURCE_MSI:
    case LL_RCC_I2C2_CLKSOURCE_MSI:
    case LL_RCC_I2C3_CLKSOURCE_MSI:
    case LL_RCC_I2C4_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
340091b8:	f7fa fb4c 	bl	34003854 <LL_RCC_MSI_IsReady>
340091bc:	4603      	mov	r3, r0
340091be:	2b00      	cmp	r3, #0
340091c0:	d00a      	beq.n	340091d8 <RCCEx_GetI2CCLKFreq+0x33c>
      {
        i2c_frequency = MSI_VALUE;
340091c2:	4b09      	ldr	r3, [pc, #36]	@ (340091e8 <RCCEx_GetI2CCLKFreq+0x34c>)
340091c4:	60fb      	str	r3, [r7, #12]
      }
      break;
340091c6:	e007      	b.n	340091d8 <RCCEx_GetI2CCLKFreq+0x33c>

    default:
      /* Unexpected case */
      break;
340091c8:	bf00      	nop
340091ca:	e006      	b.n	340091da <RCCEx_GetI2CCLKFreq+0x33e>
      break;
340091cc:	bf00      	nop
340091ce:	e004      	b.n	340091da <RCCEx_GetI2CCLKFreq+0x33e>
      break;
340091d0:	bf00      	nop
340091d2:	e002      	b.n	340091da <RCCEx_GetI2CCLKFreq+0x33e>
      break;
340091d4:	bf00      	nop
340091d6:	e000      	b.n	340091da <RCCEx_GetI2CCLKFreq+0x33e>
      break;
340091d8:	bf00      	nop
  }

  return i2c_frequency;
340091da:	68fb      	ldr	r3, [r7, #12]
}
340091dc:	4618      	mov	r0, r3
340091de:	3710      	adds	r7, #16
340091e0:	46bd      	mov	sp, r7
340091e2:	bd80      	pop	{r7, pc}
340091e4:	03d09000 	.word	0x03d09000
340091e8:	003d0900 	.word	0x003d0900

340091ec <RCCEx_GetI3CCLKFreq>:
  *         @arg @ref RCCEx_I3C2_Clock_Source
  * @retval I3C clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetI3CCLKFreq(uint32_t I3CxSource)
{
340091ec:	b580      	push	{r7, lr}
340091ee:	b084      	sub	sp, #16
340091f0:	af00      	add	r7, sp, #0
340091f2:	6078      	str	r0, [r7, #4]
  uint32_t i3c_frequency = RCC_PERIPH_FREQUENCY_NO;
340091f4:	2300      	movs	r3, #0
340091f6:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetI3CClockSource(I3CxSource))
340091f8:	6878      	ldr	r0, [r7, #4]
340091fa:	f7fa fe5d 	bl	34003eb8 <LL_RCC_GetI3CClockSource>
340091fe:	4603      	mov	r3, r0
34009200:	4a86      	ldr	r2, [pc, #536]	@ (3400941c <RCCEx_GetI3CCLKFreq+0x230>)
34009202:	4293      	cmp	r3, r2
34009204:	f000 80e6 	beq.w	340093d4 <RCCEx_GetI3CCLKFreq+0x1e8>
34009208:	4a84      	ldr	r2, [pc, #528]	@ (3400941c <RCCEx_GetI3CCLKFreq+0x230>)
3400920a:	4293      	cmp	r3, r2
3400920c:	f200 80f8 	bhi.w	34009400 <RCCEx_GetI3CCLKFreq+0x214>
34009210:	4a83      	ldr	r2, [pc, #524]	@ (34009420 <RCCEx_GetI3CCLKFreq+0x234>)
34009212:	4293      	cmp	r3, r2
34009214:	f000 80de 	beq.w	340093d4 <RCCEx_GetI3CCLKFreq+0x1e8>
34009218:	4a81      	ldr	r2, [pc, #516]	@ (34009420 <RCCEx_GetI3CCLKFreq+0x234>)
3400921a:	4293      	cmp	r3, r2
3400921c:	f200 80f0 	bhi.w	34009400 <RCCEx_GetI3CCLKFreq+0x214>
34009220:	4a80      	ldr	r2, [pc, #512]	@ (34009424 <RCCEx_GetI3CCLKFreq+0x238>)
34009222:	4293      	cmp	r3, r2
34009224:	f000 80e4 	beq.w	340093f0 <RCCEx_GetI3CCLKFreq+0x204>
34009228:	4a7e      	ldr	r2, [pc, #504]	@ (34009424 <RCCEx_GetI3CCLKFreq+0x238>)
3400922a:	4293      	cmp	r3, r2
3400922c:	f200 80e8 	bhi.w	34009400 <RCCEx_GetI3CCLKFreq+0x214>
34009230:	4a7d      	ldr	r2, [pc, #500]	@ (34009428 <RCCEx_GetI3CCLKFreq+0x23c>)
34009232:	4293      	cmp	r3, r2
34009234:	f000 80dc 	beq.w	340093f0 <RCCEx_GetI3CCLKFreq+0x204>
34009238:	4a7b      	ldr	r2, [pc, #492]	@ (34009428 <RCCEx_GetI3CCLKFreq+0x23c>)
3400923a:	4293      	cmp	r3, r2
3400923c:	f200 80e0 	bhi.w	34009400 <RCCEx_GetI3CCLKFreq+0x214>
34009240:	4a7a      	ldr	r2, [pc, #488]	@ (3400942c <RCCEx_GetI3CCLKFreq+0x240>)
34009242:	4293      	cmp	r3, r2
34009244:	f000 8083 	beq.w	3400934e <RCCEx_GetI3CCLKFreq+0x162>
34009248:	4a78      	ldr	r2, [pc, #480]	@ (3400942c <RCCEx_GetI3CCLKFreq+0x240>)
3400924a:	4293      	cmp	r3, r2
3400924c:	f200 80d8 	bhi.w	34009400 <RCCEx_GetI3CCLKFreq+0x214>
34009250:	4a77      	ldr	r2, [pc, #476]	@ (34009430 <RCCEx_GetI3CCLKFreq+0x244>)
34009252:	4293      	cmp	r3, r2
34009254:	d07b      	beq.n	3400934e <RCCEx_GetI3CCLKFreq+0x162>
34009256:	4a76      	ldr	r2, [pc, #472]	@ (34009430 <RCCEx_GetI3CCLKFreq+0x244>)
34009258:	4293      	cmp	r3, r2
3400925a:	f200 80d1 	bhi.w	34009400 <RCCEx_GetI3CCLKFreq+0x214>
3400925e:	4a75      	ldr	r2, [pc, #468]	@ (34009434 <RCCEx_GetI3CCLKFreq+0x248>)
34009260:	4293      	cmp	r3, r2
34009262:	d030      	beq.n	340092c6 <RCCEx_GetI3CCLKFreq+0xda>
34009264:	4a73      	ldr	r2, [pc, #460]	@ (34009434 <RCCEx_GetI3CCLKFreq+0x248>)
34009266:	4293      	cmp	r3, r2
34009268:	f200 80ca 	bhi.w	34009400 <RCCEx_GetI3CCLKFreq+0x214>
3400926c:	4a72      	ldr	r2, [pc, #456]	@ (34009438 <RCCEx_GetI3CCLKFreq+0x24c>)
3400926e:	4293      	cmp	r3, r2
34009270:	d029      	beq.n	340092c6 <RCCEx_GetI3CCLKFreq+0xda>
34009272:	4a71      	ldr	r2, [pc, #452]	@ (34009438 <RCCEx_GetI3CCLKFreq+0x24c>)
34009274:	4293      	cmp	r3, r2
34009276:	f200 80c3 	bhi.w	34009400 <RCCEx_GetI3CCLKFreq+0x214>
3400927a:	4a70      	ldr	r2, [pc, #448]	@ (3400943c <RCCEx_GetI3CCLKFreq+0x250>)
3400927c:	4293      	cmp	r3, r2
3400927e:	d01d      	beq.n	340092bc <RCCEx_GetI3CCLKFreq+0xd0>
34009280:	4a6e      	ldr	r2, [pc, #440]	@ (3400943c <RCCEx_GetI3CCLKFreq+0x250>)
34009282:	4293      	cmp	r3, r2
34009284:	f200 80bc 	bhi.w	34009400 <RCCEx_GetI3CCLKFreq+0x214>
34009288:	4a6d      	ldr	r2, [pc, #436]	@ (34009440 <RCCEx_GetI3CCLKFreq+0x254>)
3400928a:	4293      	cmp	r3, r2
3400928c:	d016      	beq.n	340092bc <RCCEx_GetI3CCLKFreq+0xd0>
3400928e:	4a6c      	ldr	r2, [pc, #432]	@ (34009440 <RCCEx_GetI3CCLKFreq+0x254>)
34009290:	4293      	cmp	r3, r2
34009292:	f200 80b5 	bhi.w	34009400 <RCCEx_GetI3CCLKFreq+0x214>
34009296:	4a6b      	ldr	r2, [pc, #428]	@ (34009444 <RCCEx_GetI3CCLKFreq+0x258>)
34009298:	4293      	cmp	r3, r2
3400929a:	d003      	beq.n	340092a4 <RCCEx_GetI3CCLKFreq+0xb8>
3400929c:	4a6a      	ldr	r2, [pc, #424]	@ (34009448 <RCCEx_GetI3CCLKFreq+0x25c>)
3400929e:	4293      	cmp	r3, r2
340092a0:	f040 80ae 	bne.w	34009400 <RCCEx_GetI3CCLKFreq+0x214>
  {
    case LL_RCC_I3C1_CLKSOURCE_PCLK1:
    case LL_RCC_I3C2_CLKSOURCE_PCLK1:
      i3c_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
340092a4:	f7fa f9e0 	bl	34003668 <HAL_RCC_GetSysClockFreq>
340092a8:	4603      	mov	r3, r0
340092aa:	4618      	mov	r0, r3
340092ac:	f7fe fe42 	bl	34007f34 <RCCEx_GetHCLKFreq>
340092b0:	4603      	mov	r3, r0
340092b2:	4618      	mov	r0, r3
340092b4:	f7fe fe4f 	bl	34007f56 <RCCEx_GetPCLK1Freq>
340092b8:	60f8      	str	r0, [r7, #12]
      break;
340092ba:	e0aa      	b.n	34009412 <RCCEx_GetI3CCLKFreq+0x226>

    case LL_RCC_I3C1_CLKSOURCE_CLKP:
    case LL_RCC_I3C2_CLKSOURCE_CLKP:
      i3c_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
340092bc:	2007      	movs	r0, #7
340092be:	f7ff f925 	bl	3400850c <RCCEx_GetCLKPCLKFreq>
340092c2:	60f8      	str	r0, [r7, #12]
      break;
340092c4:	e0a5      	b.n	34009412 <RCCEx_GetI3CCLKFreq+0x226>

    case LL_RCC_I3C1_CLKSOURCE_IC10:
    case LL_RCC_I3C2_CLKSOURCE_IC10:
      if (LL_RCC_IC10_IsEnabled() != 0U)
340092c6:	f7fb fb09 	bl	340048dc <LL_RCC_IC10_IsEnabled>
340092ca:	4603      	mov	r3, r0
340092cc:	2b00      	cmp	r3, #0
340092ce:	f000 8099 	beq.w	34009404 <RCCEx_GetI3CCLKFreq+0x218>
      {
        ic_divider = LL_RCC_IC10_GetDivider();
340092d2:	f7fb fb25 	bl	34004920 <LL_RCC_IC10_GetDivider>
340092d6:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC10_GetSource())
340092d8:	f7fb fb14 	bl	34004904 <LL_RCC_IC10_GetSource>
340092dc:	4603      	mov	r3, r0
340092de:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340092e2:	d029      	beq.n	34009338 <RCCEx_GetI3CCLKFreq+0x14c>
340092e4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340092e8:	d82f      	bhi.n	3400934a <RCCEx_GetI3CCLKFreq+0x15e>
340092ea:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340092ee:	d01a      	beq.n	34009326 <RCCEx_GetI3CCLKFreq+0x13a>
340092f0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340092f4:	d829      	bhi.n	3400934a <RCCEx_GetI3CCLKFreq+0x15e>
340092f6:	2b00      	cmp	r3, #0
340092f8:	d003      	beq.n	34009302 <RCCEx_GetI3CCLKFreq+0x116>
340092fa:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340092fe:	d009      	beq.n	34009314 <RCCEx_GetI3CCLKFreq+0x128>
            i3c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            i3c_frequency = i3c_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34009300:	e023      	b.n	3400934a <RCCEx_GetI3CCLKFreq+0x15e>
            i3c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34009302:	f7fe fcff 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
34009306:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
34009308:	68fa      	ldr	r2, [r7, #12]
3400930a:	68bb      	ldr	r3, [r7, #8]
3400930c:	fbb2 f3f3 	udiv	r3, r2, r3
34009310:	60fb      	str	r3, [r7, #12]
            break;
34009312:	e01b      	b.n	3400934c <RCCEx_GetI3CCLKFreq+0x160>
            i3c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34009314:	f7fe fd3c 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
34009318:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
3400931a:	68fa      	ldr	r2, [r7, #12]
3400931c:	68bb      	ldr	r3, [r7, #8]
3400931e:	fbb2 f3f3 	udiv	r3, r2, r3
34009322:	60fb      	str	r3, [r7, #12]
            break;
34009324:	e012      	b.n	3400934c <RCCEx_GetI3CCLKFreq+0x160>
            i3c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34009326:	f7fe fd79 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
3400932a:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
3400932c:	68fa      	ldr	r2, [r7, #12]
3400932e:	68bb      	ldr	r3, [r7, #8]
34009330:	fbb2 f3f3 	udiv	r3, r2, r3
34009334:	60fb      	str	r3, [r7, #12]
            break;
34009336:	e009      	b.n	3400934c <RCCEx_GetI3CCLKFreq+0x160>
            i3c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34009338:	f7fe fdb6 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
3400933c:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
3400933e:	68fa      	ldr	r2, [r7, #12]
34009340:	68bb      	ldr	r3, [r7, #8]
34009342:	fbb2 f3f3 	udiv	r3, r2, r3
34009346:	60fb      	str	r3, [r7, #12]
            break;
34009348:	e000      	b.n	3400934c <RCCEx_GetI3CCLKFreq+0x160>
            break;
3400934a:	bf00      	nop
        }
      }
      break;
3400934c:	e05a      	b.n	34009404 <RCCEx_GetI3CCLKFreq+0x218>

    case LL_RCC_I3C1_CLKSOURCE_IC15:
    case LL_RCC_I3C2_CLKSOURCE_IC15:
      if (LL_RCC_IC15_IsEnabled() != 0U)
3400934e:	f7fb fbc5 	bl	34004adc <LL_RCC_IC15_IsEnabled>
34009352:	4603      	mov	r3, r0
34009354:	2b00      	cmp	r3, #0
34009356:	d057      	beq.n	34009408 <RCCEx_GetI3CCLKFreq+0x21c>
      {
        ic_divider = LL_RCC_IC15_GetDivider();
34009358:	f7fb fbe2 	bl	34004b20 <LL_RCC_IC15_GetDivider>
3400935c:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC15_GetSource())
3400935e:	f7fb fbd1 	bl	34004b04 <LL_RCC_IC15_GetSource>
34009362:	4603      	mov	r3, r0
34009364:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34009368:	d029      	beq.n	340093be <RCCEx_GetI3CCLKFreq+0x1d2>
3400936a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400936e:	d82f      	bhi.n	340093d0 <RCCEx_GetI3CCLKFreq+0x1e4>
34009370:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34009374:	d01a      	beq.n	340093ac <RCCEx_GetI3CCLKFreq+0x1c0>
34009376:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400937a:	d829      	bhi.n	340093d0 <RCCEx_GetI3CCLKFreq+0x1e4>
3400937c:	2b00      	cmp	r3, #0
3400937e:	d003      	beq.n	34009388 <RCCEx_GetI3CCLKFreq+0x19c>
34009380:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34009384:	d009      	beq.n	3400939a <RCCEx_GetI3CCLKFreq+0x1ae>
            i3c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            i3c_frequency = i3c_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34009386:	e023      	b.n	340093d0 <RCCEx_GetI3CCLKFreq+0x1e4>
            i3c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34009388:	f7fe fcbc 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
3400938c:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
3400938e:	68fa      	ldr	r2, [r7, #12]
34009390:	68bb      	ldr	r3, [r7, #8]
34009392:	fbb2 f3f3 	udiv	r3, r2, r3
34009396:	60fb      	str	r3, [r7, #12]
            break;
34009398:	e01b      	b.n	340093d2 <RCCEx_GetI3CCLKFreq+0x1e6>
            i3c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400939a:	f7fe fcf9 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
3400939e:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
340093a0:	68fa      	ldr	r2, [r7, #12]
340093a2:	68bb      	ldr	r3, [r7, #8]
340093a4:	fbb2 f3f3 	udiv	r3, r2, r3
340093a8:	60fb      	str	r3, [r7, #12]
            break;
340093aa:	e012      	b.n	340093d2 <RCCEx_GetI3CCLKFreq+0x1e6>
            i3c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340093ac:	f7fe fd36 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
340093b0:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
340093b2:	68fa      	ldr	r2, [r7, #12]
340093b4:	68bb      	ldr	r3, [r7, #8]
340093b6:	fbb2 f3f3 	udiv	r3, r2, r3
340093ba:	60fb      	str	r3, [r7, #12]
            break;
340093bc:	e009      	b.n	340093d2 <RCCEx_GetI3CCLKFreq+0x1e6>
            i3c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340093be:	f7fe fd73 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
340093c2:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
340093c4:	68fa      	ldr	r2, [r7, #12]
340093c6:	68bb      	ldr	r3, [r7, #8]
340093c8:	fbb2 f3f3 	udiv	r3, r2, r3
340093cc:	60fb      	str	r3, [r7, #12]
            break;
340093ce:	e000      	b.n	340093d2 <RCCEx_GetI3CCLKFreq+0x1e6>
            break;
340093d0:	bf00      	nop
        }
      }
      break;
340093d2:	e019      	b.n	34009408 <RCCEx_GetI3CCLKFreq+0x21c>

    case LL_RCC_I3C1_CLKSOURCE_HSI:
    case LL_RCC_I3C2_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
340093d4:	f7fa fa1e 	bl	34003814 <LL_RCC_HSI_IsReady>
340093d8:	4603      	mov	r3, r0
340093da:	2b00      	cmp	r3, #0
340093dc:	d016      	beq.n	3400940c <RCCEx_GetI3CCLKFreq+0x220>
      {
        i3c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
340093de:	f7fa fa2b 	bl	34003838 <LL_RCC_HSI_GetDivider>
340093e2:	4603      	mov	r3, r0
340093e4:	09db      	lsrs	r3, r3, #7
340093e6:	4a19      	ldr	r2, [pc, #100]	@ (3400944c <RCCEx_GetI3CCLKFreq+0x260>)
340093e8:	fa22 f303 	lsr.w	r3, r2, r3
340093ec:	60fb      	str	r3, [r7, #12]
      }
      break;
340093ee:	e00d      	b.n	3400940c <RCCEx_GetI3CCLKFreq+0x220>

    case LL_RCC_I3C1_CLKSOURCE_MSI:
    case LL_RCC_I3C2_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
340093f0:	f7fa fa30 	bl	34003854 <LL_RCC_MSI_IsReady>
340093f4:	4603      	mov	r3, r0
340093f6:	2b00      	cmp	r3, #0
340093f8:	d00a      	beq.n	34009410 <RCCEx_GetI3CCLKFreq+0x224>
      {
        i3c_frequency = MSI_VALUE;
340093fa:	4b15      	ldr	r3, [pc, #84]	@ (34009450 <RCCEx_GetI3CCLKFreq+0x264>)
340093fc:	60fb      	str	r3, [r7, #12]
      }
      break;
340093fe:	e007      	b.n	34009410 <RCCEx_GetI3CCLKFreq+0x224>

    default:
      /* Unexpected case */
      break;
34009400:	bf00      	nop
34009402:	e006      	b.n	34009412 <RCCEx_GetI3CCLKFreq+0x226>
      break;
34009404:	bf00      	nop
34009406:	e004      	b.n	34009412 <RCCEx_GetI3CCLKFreq+0x226>
      break;
34009408:	bf00      	nop
3400940a:	e002      	b.n	34009412 <RCCEx_GetI3CCLKFreq+0x226>
      break;
3400940c:	bf00      	nop
3400940e:	e000      	b.n	34009412 <RCCEx_GetI3CCLKFreq+0x226>
      break;
34009410:	bf00      	nop
  }

  return i3c_frequency;
34009412:	68fb      	ldr	r3, [r7, #12]
}
34009414:	4618      	mov	r0, r3
34009416:	3710      	adds	r7, #16
34009418:	46bd      	mov	sp, r7
3400941a:	bd80      	pop	{r7, pc}
3400941c:	0705140c 	.word	0x0705140c
34009420:	0705100c 	.word	0x0705100c
34009424:	0704140c 	.word	0x0704140c
34009428:	0704100c 	.word	0x0704100c
3400942c:	0703140c 	.word	0x0703140c
34009430:	0703100c 	.word	0x0703100c
34009434:	0702140c 	.word	0x0702140c
34009438:	0702100c 	.word	0x0702100c
3400943c:	0701140c 	.word	0x0701140c
34009440:	0701100c 	.word	0x0701100c
34009444:	0700100c 	.word	0x0700100c
34009448:	0700140c 	.word	0x0700140c
3400944c:	03d09000 	.word	0x03d09000
34009450:	003d0900 	.word	0x003d0900

34009454 <RCCEx_GetLPTIMCLKFreq>:
  *         @arg @ref RCCEx_LPTIM5_Clock_Source
  * @retval LPTIM clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetLPTIMCLKFreq(uint32_t LPTIMxSource)
{
34009454:	b590      	push	{r4, r7, lr}
34009456:	b085      	sub	sp, #20
34009458:	af00      	add	r7, sp, #0
3400945a:	6078      	str	r0, [r7, #4]
  uint32_t lptim_frequency = RCC_PERIPH_FREQUENCY_NO;
3400945c:	2300      	movs	r3, #0
3400945e:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
34009460:	6878      	ldr	r0, [r7, #4]
34009462:	f7fa fd35 	bl	34003ed0 <LL_RCC_GetLPTIMClockSource>
34009466:	4603      	mov	r3, r0
34009468:	4aa1      	ldr	r2, [pc, #644]	@ (340096f0 <RCCEx_GetLPTIMCLKFreq+0x29c>)
3400946a:	4293      	cmp	r3, r2
3400946c:	f000 8185 	beq.w	3400977a <RCCEx_GetLPTIMCLKFreq+0x326>
34009470:	4a9f      	ldr	r2, [pc, #636]	@ (340096f0 <RCCEx_GetLPTIMCLKFreq+0x29c>)
34009472:	4293      	cmp	r3, r2
34009474:	f200 818b 	bhi.w	3400978e <RCCEx_GetLPTIMCLKFreq+0x33a>
34009478:	4a9e      	ldr	r2, [pc, #632]	@ (340096f4 <RCCEx_GetLPTIMCLKFreq+0x2a0>)
3400947a:	4293      	cmp	r3, r2
3400947c:	f000 817d 	beq.w	3400977a <RCCEx_GetLPTIMCLKFreq+0x326>
34009480:	4a9c      	ldr	r2, [pc, #624]	@ (340096f4 <RCCEx_GetLPTIMCLKFreq+0x2a0>)
34009482:	4293      	cmp	r3, r2
34009484:	f200 8183 	bhi.w	3400978e <RCCEx_GetLPTIMCLKFreq+0x33a>
34009488:	4a9b      	ldr	r2, [pc, #620]	@ (340096f8 <RCCEx_GetLPTIMCLKFreq+0x2a4>)
3400948a:	4293      	cmp	r3, r2
3400948c:	f000 8175 	beq.w	3400977a <RCCEx_GetLPTIMCLKFreq+0x326>
34009490:	4a99      	ldr	r2, [pc, #612]	@ (340096f8 <RCCEx_GetLPTIMCLKFreq+0x2a4>)
34009492:	4293      	cmp	r3, r2
34009494:	f200 817b 	bhi.w	3400978e <RCCEx_GetLPTIMCLKFreq+0x33a>
34009498:	4a98      	ldr	r2, [pc, #608]	@ (340096fc <RCCEx_GetLPTIMCLKFreq+0x2a8>)
3400949a:	4293      	cmp	r3, r2
3400949c:	f000 816d 	beq.w	3400977a <RCCEx_GetLPTIMCLKFreq+0x326>
340094a0:	4a96      	ldr	r2, [pc, #600]	@ (340096fc <RCCEx_GetLPTIMCLKFreq+0x2a8>)
340094a2:	4293      	cmp	r3, r2
340094a4:	f200 8173 	bhi.w	3400978e <RCCEx_GetLPTIMCLKFreq+0x33a>
340094a8:	4a95      	ldr	r2, [pc, #596]	@ (34009700 <RCCEx_GetLPTIMCLKFreq+0x2ac>)
340094aa:	4293      	cmp	r3, r2
340094ac:	f000 8165 	beq.w	3400977a <RCCEx_GetLPTIMCLKFreq+0x326>
340094b0:	4a93      	ldr	r2, [pc, #588]	@ (34009700 <RCCEx_GetLPTIMCLKFreq+0x2ac>)
340094b2:	4293      	cmp	r3, r2
340094b4:	f200 816b 	bhi.w	3400978e <RCCEx_GetLPTIMCLKFreq+0x33a>
340094b8:	4a92      	ldr	r2, [pc, #584]	@ (34009704 <RCCEx_GetLPTIMCLKFreq+0x2b0>)
340094ba:	4293      	cmp	r3, r2
340094bc:	f000 8154 	beq.w	34009768 <RCCEx_GetLPTIMCLKFreq+0x314>
340094c0:	4a90      	ldr	r2, [pc, #576]	@ (34009704 <RCCEx_GetLPTIMCLKFreq+0x2b0>)
340094c2:	4293      	cmp	r3, r2
340094c4:	f200 8163 	bhi.w	3400978e <RCCEx_GetLPTIMCLKFreq+0x33a>
340094c8:	4a8f      	ldr	r2, [pc, #572]	@ (34009708 <RCCEx_GetLPTIMCLKFreq+0x2b4>)
340094ca:	4293      	cmp	r3, r2
340094cc:	f000 814c 	beq.w	34009768 <RCCEx_GetLPTIMCLKFreq+0x314>
340094d0:	4a8d      	ldr	r2, [pc, #564]	@ (34009708 <RCCEx_GetLPTIMCLKFreq+0x2b4>)
340094d2:	4293      	cmp	r3, r2
340094d4:	f200 815b 	bhi.w	3400978e <RCCEx_GetLPTIMCLKFreq+0x33a>
340094d8:	4a8c      	ldr	r2, [pc, #560]	@ (3400970c <RCCEx_GetLPTIMCLKFreq+0x2b8>)
340094da:	4293      	cmp	r3, r2
340094dc:	f000 8144 	beq.w	34009768 <RCCEx_GetLPTIMCLKFreq+0x314>
340094e0:	4a8a      	ldr	r2, [pc, #552]	@ (3400970c <RCCEx_GetLPTIMCLKFreq+0x2b8>)
340094e2:	4293      	cmp	r3, r2
340094e4:	f200 8153 	bhi.w	3400978e <RCCEx_GetLPTIMCLKFreq+0x33a>
340094e8:	4a89      	ldr	r2, [pc, #548]	@ (34009710 <RCCEx_GetLPTIMCLKFreq+0x2bc>)
340094ea:	4293      	cmp	r3, r2
340094ec:	f000 813c 	beq.w	34009768 <RCCEx_GetLPTIMCLKFreq+0x314>
340094f0:	4a87      	ldr	r2, [pc, #540]	@ (34009710 <RCCEx_GetLPTIMCLKFreq+0x2bc>)
340094f2:	4293      	cmp	r3, r2
340094f4:	f200 814b 	bhi.w	3400978e <RCCEx_GetLPTIMCLKFreq+0x33a>
340094f8:	4a86      	ldr	r2, [pc, #536]	@ (34009714 <RCCEx_GetLPTIMCLKFreq+0x2c0>)
340094fa:	4293      	cmp	r3, r2
340094fc:	f000 8134 	beq.w	34009768 <RCCEx_GetLPTIMCLKFreq+0x314>
34009500:	4a84      	ldr	r2, [pc, #528]	@ (34009714 <RCCEx_GetLPTIMCLKFreq+0x2c0>)
34009502:	4293      	cmp	r3, r2
34009504:	f200 8143 	bhi.w	3400978e <RCCEx_GetLPTIMCLKFreq+0x33a>
34009508:	4a83      	ldr	r2, [pc, #524]	@ (34009718 <RCCEx_GetLPTIMCLKFreq+0x2c4>)
3400950a:	4293      	cmp	r3, r2
3400950c:	f000 80e7 	beq.w	340096de <RCCEx_GetLPTIMCLKFreq+0x28a>
34009510:	4a81      	ldr	r2, [pc, #516]	@ (34009718 <RCCEx_GetLPTIMCLKFreq+0x2c4>)
34009512:	4293      	cmp	r3, r2
34009514:	f200 813b 	bhi.w	3400978e <RCCEx_GetLPTIMCLKFreq+0x33a>
34009518:	4a80      	ldr	r2, [pc, #512]	@ (3400971c <RCCEx_GetLPTIMCLKFreq+0x2c8>)
3400951a:	4293      	cmp	r3, r2
3400951c:	f000 80df 	beq.w	340096de <RCCEx_GetLPTIMCLKFreq+0x28a>
34009520:	4a7e      	ldr	r2, [pc, #504]	@ (3400971c <RCCEx_GetLPTIMCLKFreq+0x2c8>)
34009522:	4293      	cmp	r3, r2
34009524:	f200 8133 	bhi.w	3400978e <RCCEx_GetLPTIMCLKFreq+0x33a>
34009528:	4a7d      	ldr	r2, [pc, #500]	@ (34009720 <RCCEx_GetLPTIMCLKFreq+0x2cc>)
3400952a:	4293      	cmp	r3, r2
3400952c:	f000 80d7 	beq.w	340096de <RCCEx_GetLPTIMCLKFreq+0x28a>
34009530:	4a7b      	ldr	r2, [pc, #492]	@ (34009720 <RCCEx_GetLPTIMCLKFreq+0x2cc>)
34009532:	4293      	cmp	r3, r2
34009534:	f200 812b 	bhi.w	3400978e <RCCEx_GetLPTIMCLKFreq+0x33a>
34009538:	4a7a      	ldr	r2, [pc, #488]	@ (34009724 <RCCEx_GetLPTIMCLKFreq+0x2d0>)
3400953a:	4293      	cmp	r3, r2
3400953c:	f000 80cf 	beq.w	340096de <RCCEx_GetLPTIMCLKFreq+0x28a>
34009540:	4a78      	ldr	r2, [pc, #480]	@ (34009724 <RCCEx_GetLPTIMCLKFreq+0x2d0>)
34009542:	4293      	cmp	r3, r2
34009544:	f200 8123 	bhi.w	3400978e <RCCEx_GetLPTIMCLKFreq+0x33a>
34009548:	4a77      	ldr	r2, [pc, #476]	@ (34009728 <RCCEx_GetLPTIMCLKFreq+0x2d4>)
3400954a:	4293      	cmp	r3, r2
3400954c:	f000 80c7 	beq.w	340096de <RCCEx_GetLPTIMCLKFreq+0x28a>
34009550:	4a75      	ldr	r2, [pc, #468]	@ (34009728 <RCCEx_GetLPTIMCLKFreq+0x2d4>)
34009552:	4293      	cmp	r3, r2
34009554:	f200 811b 	bhi.w	3400978e <RCCEx_GetLPTIMCLKFreq+0x33a>
34009558:	4a74      	ldr	r2, [pc, #464]	@ (3400972c <RCCEx_GetLPTIMCLKFreq+0x2d8>)
3400955a:	4293      	cmp	r3, r2
3400955c:	d07b      	beq.n	34009656 <RCCEx_GetLPTIMCLKFreq+0x202>
3400955e:	4a73      	ldr	r2, [pc, #460]	@ (3400972c <RCCEx_GetLPTIMCLKFreq+0x2d8>)
34009560:	4293      	cmp	r3, r2
34009562:	f200 8114 	bhi.w	3400978e <RCCEx_GetLPTIMCLKFreq+0x33a>
34009566:	4a72      	ldr	r2, [pc, #456]	@ (34009730 <RCCEx_GetLPTIMCLKFreq+0x2dc>)
34009568:	4293      	cmp	r3, r2
3400956a:	d074      	beq.n	34009656 <RCCEx_GetLPTIMCLKFreq+0x202>
3400956c:	4a70      	ldr	r2, [pc, #448]	@ (34009730 <RCCEx_GetLPTIMCLKFreq+0x2dc>)
3400956e:	4293      	cmp	r3, r2
34009570:	f200 810d 	bhi.w	3400978e <RCCEx_GetLPTIMCLKFreq+0x33a>
34009574:	4a6f      	ldr	r2, [pc, #444]	@ (34009734 <RCCEx_GetLPTIMCLKFreq+0x2e0>)
34009576:	4293      	cmp	r3, r2
34009578:	d06d      	beq.n	34009656 <RCCEx_GetLPTIMCLKFreq+0x202>
3400957a:	4a6e      	ldr	r2, [pc, #440]	@ (34009734 <RCCEx_GetLPTIMCLKFreq+0x2e0>)
3400957c:	4293      	cmp	r3, r2
3400957e:	f200 8106 	bhi.w	3400978e <RCCEx_GetLPTIMCLKFreq+0x33a>
34009582:	4a6d      	ldr	r2, [pc, #436]	@ (34009738 <RCCEx_GetLPTIMCLKFreq+0x2e4>)
34009584:	4293      	cmp	r3, r2
34009586:	d066      	beq.n	34009656 <RCCEx_GetLPTIMCLKFreq+0x202>
34009588:	4a6b      	ldr	r2, [pc, #428]	@ (34009738 <RCCEx_GetLPTIMCLKFreq+0x2e4>)
3400958a:	4293      	cmp	r3, r2
3400958c:	f200 80ff 	bhi.w	3400978e <RCCEx_GetLPTIMCLKFreq+0x33a>
34009590:	4a6a      	ldr	r2, [pc, #424]	@ (3400973c <RCCEx_GetLPTIMCLKFreq+0x2e8>)
34009592:	4293      	cmp	r3, r2
34009594:	d05f      	beq.n	34009656 <RCCEx_GetLPTIMCLKFreq+0x202>
34009596:	4a69      	ldr	r2, [pc, #420]	@ (3400973c <RCCEx_GetLPTIMCLKFreq+0x2e8>)
34009598:	4293      	cmp	r3, r2
3400959a:	f200 80f8 	bhi.w	3400978e <RCCEx_GetLPTIMCLKFreq+0x33a>
3400959e:	4a68      	ldr	r2, [pc, #416]	@ (34009740 <RCCEx_GetLPTIMCLKFreq+0x2ec>)
340095a0:	4293      	cmp	r3, r2
340095a2:	d053      	beq.n	3400964c <RCCEx_GetLPTIMCLKFreq+0x1f8>
340095a4:	4a66      	ldr	r2, [pc, #408]	@ (34009740 <RCCEx_GetLPTIMCLKFreq+0x2ec>)
340095a6:	4293      	cmp	r3, r2
340095a8:	f200 80f1 	bhi.w	3400978e <RCCEx_GetLPTIMCLKFreq+0x33a>
340095ac:	4a65      	ldr	r2, [pc, #404]	@ (34009744 <RCCEx_GetLPTIMCLKFreq+0x2f0>)
340095ae:	4293      	cmp	r3, r2
340095b0:	d04c      	beq.n	3400964c <RCCEx_GetLPTIMCLKFreq+0x1f8>
340095b2:	4a64      	ldr	r2, [pc, #400]	@ (34009744 <RCCEx_GetLPTIMCLKFreq+0x2f0>)
340095b4:	4293      	cmp	r3, r2
340095b6:	f200 80ea 	bhi.w	3400978e <RCCEx_GetLPTIMCLKFreq+0x33a>
340095ba:	4a63      	ldr	r2, [pc, #396]	@ (34009748 <RCCEx_GetLPTIMCLKFreq+0x2f4>)
340095bc:	4293      	cmp	r3, r2
340095be:	d045      	beq.n	3400964c <RCCEx_GetLPTIMCLKFreq+0x1f8>
340095c0:	4a61      	ldr	r2, [pc, #388]	@ (34009748 <RCCEx_GetLPTIMCLKFreq+0x2f4>)
340095c2:	4293      	cmp	r3, r2
340095c4:	f200 80e3 	bhi.w	3400978e <RCCEx_GetLPTIMCLKFreq+0x33a>
340095c8:	4a60      	ldr	r2, [pc, #384]	@ (3400974c <RCCEx_GetLPTIMCLKFreq+0x2f8>)
340095ca:	4293      	cmp	r3, r2
340095cc:	d03e      	beq.n	3400964c <RCCEx_GetLPTIMCLKFreq+0x1f8>
340095ce:	4a5f      	ldr	r2, [pc, #380]	@ (3400974c <RCCEx_GetLPTIMCLKFreq+0x2f8>)
340095d0:	4293      	cmp	r3, r2
340095d2:	f200 80dc 	bhi.w	3400978e <RCCEx_GetLPTIMCLKFreq+0x33a>
340095d6:	4a5e      	ldr	r2, [pc, #376]	@ (34009750 <RCCEx_GetLPTIMCLKFreq+0x2fc>)
340095d8:	4293      	cmp	r3, r2
340095da:	d037      	beq.n	3400964c <RCCEx_GetLPTIMCLKFreq+0x1f8>
340095dc:	4a5c      	ldr	r2, [pc, #368]	@ (34009750 <RCCEx_GetLPTIMCLKFreq+0x2fc>)
340095de:	4293      	cmp	r3, r2
340095e0:	f200 80d5 	bhi.w	3400978e <RCCEx_GetLPTIMCLKFreq+0x33a>
340095e4:	4a5b      	ldr	r2, [pc, #364]	@ (34009754 <RCCEx_GetLPTIMCLKFreq+0x300>)
340095e6:	4293      	cmp	r3, r2
340095e8:	d024      	beq.n	34009634 <RCCEx_GetLPTIMCLKFreq+0x1e0>
340095ea:	4a5a      	ldr	r2, [pc, #360]	@ (34009754 <RCCEx_GetLPTIMCLKFreq+0x300>)
340095ec:	4293      	cmp	r3, r2
340095ee:	f200 80ce 	bhi.w	3400978e <RCCEx_GetLPTIMCLKFreq+0x33a>
340095f2:	4a59      	ldr	r2, [pc, #356]	@ (34009758 <RCCEx_GetLPTIMCLKFreq+0x304>)
340095f4:	4293      	cmp	r3, r2
340095f6:	d01d      	beq.n	34009634 <RCCEx_GetLPTIMCLKFreq+0x1e0>
340095f8:	4a57      	ldr	r2, [pc, #348]	@ (34009758 <RCCEx_GetLPTIMCLKFreq+0x304>)
340095fa:	4293      	cmp	r3, r2
340095fc:	f200 80c7 	bhi.w	3400978e <RCCEx_GetLPTIMCLKFreq+0x33a>
34009600:	4a56      	ldr	r2, [pc, #344]	@ (3400975c <RCCEx_GetLPTIMCLKFreq+0x308>)
34009602:	4293      	cmp	r3, r2
34009604:	d016      	beq.n	34009634 <RCCEx_GetLPTIMCLKFreq+0x1e0>
34009606:	4a55      	ldr	r2, [pc, #340]	@ (3400975c <RCCEx_GetLPTIMCLKFreq+0x308>)
34009608:	4293      	cmp	r3, r2
3400960a:	f200 80c0 	bhi.w	3400978e <RCCEx_GetLPTIMCLKFreq+0x33a>
3400960e:	4a54      	ldr	r2, [pc, #336]	@ (34009760 <RCCEx_GetLPTIMCLKFreq+0x30c>)
34009610:	4293      	cmp	r3, r2
34009612:	d003      	beq.n	3400961c <RCCEx_GetLPTIMCLKFreq+0x1c8>
34009614:	4a53      	ldr	r2, [pc, #332]	@ (34009764 <RCCEx_GetLPTIMCLKFreq+0x310>)
34009616:	4293      	cmp	r3, r2
34009618:	d00c      	beq.n	34009634 <RCCEx_GetLPTIMCLKFreq+0x1e0>
      lptim_frequency = LL_RCC_CALC_TIMG_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetTIMPrescaler());
      break;

    default:
      /* Unexpected case */
      break;
3400961a:	e0b8      	b.n	3400978e <RCCEx_GetLPTIMCLKFreq+0x33a>
      lptim_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400961c:	f7fa f824 	bl	34003668 <HAL_RCC_GetSysClockFreq>
34009620:	4603      	mov	r3, r0
34009622:	4618      	mov	r0, r3
34009624:	f7fe fc86 	bl	34007f34 <RCCEx_GetHCLKFreq>
34009628:	4603      	mov	r3, r0
3400962a:	4618      	mov	r0, r3
3400962c:	f7fe fc93 	bl	34007f56 <RCCEx_GetPCLK1Freq>
34009630:	60f8      	str	r0, [r7, #12]
      break;
34009632:	e0b3      	b.n	3400979c <RCCEx_GetLPTIMCLKFreq+0x348>
      lptim_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34009634:	f7fa f818 	bl	34003668 <HAL_RCC_GetSysClockFreq>
34009638:	4603      	mov	r3, r0
3400963a:	4618      	mov	r0, r3
3400963c:	f7fe fc7a 	bl	34007f34 <RCCEx_GetHCLKFreq>
34009640:	4603      	mov	r3, r0
34009642:	4618      	mov	r0, r3
34009644:	f7fe fca8 	bl	34007f98 <RCCEx_GetPCLK4Freq>
34009648:	60f8      	str	r0, [r7, #12]
      break;
3400964a:	e0a7      	b.n	3400979c <RCCEx_GetLPTIMCLKFreq+0x348>
      lptim_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400964c:	2007      	movs	r0, #7
3400964e:	f7fe ff5d 	bl	3400850c <RCCEx_GetCLKPCLKFreq>
34009652:	60f8      	str	r0, [r7, #12]
      break;
34009654:	e0a2      	b.n	3400979c <RCCEx_GetLPTIMCLKFreq+0x348>
      if (LL_RCC_IC15_IsEnabled() != 0U)
34009656:	f7fb fa41 	bl	34004adc <LL_RCC_IC15_IsEnabled>
3400965a:	4603      	mov	r3, r0
3400965c:	2b00      	cmp	r3, #0
3400965e:	f000 8098 	beq.w	34009792 <RCCEx_GetLPTIMCLKFreq+0x33e>
        ic_divider = LL_RCC_IC15_GetDivider();
34009662:	f7fb fa5d 	bl	34004b20 <LL_RCC_IC15_GetDivider>
34009666:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC15_GetSource())
34009668:	f7fb fa4c 	bl	34004b04 <LL_RCC_IC15_GetSource>
3400966c:	4603      	mov	r3, r0
3400966e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34009672:	d029      	beq.n	340096c8 <RCCEx_GetLPTIMCLKFreq+0x274>
34009674:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34009678:	d82f      	bhi.n	340096da <RCCEx_GetLPTIMCLKFreq+0x286>
3400967a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400967e:	d01a      	beq.n	340096b6 <RCCEx_GetLPTIMCLKFreq+0x262>
34009680:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34009684:	d829      	bhi.n	340096da <RCCEx_GetLPTIMCLKFreq+0x286>
34009686:	2b00      	cmp	r3, #0
34009688:	d003      	beq.n	34009692 <RCCEx_GetLPTIMCLKFreq+0x23e>
3400968a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400968e:	d009      	beq.n	340096a4 <RCCEx_GetLPTIMCLKFreq+0x250>
            break;
34009690:	e023      	b.n	340096da <RCCEx_GetLPTIMCLKFreq+0x286>
            lptim_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34009692:	f7fe fb37 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
34009696:	60f8      	str	r0, [r7, #12]
            lptim_frequency = lptim_frequency / ic_divider;
34009698:	68fa      	ldr	r2, [r7, #12]
3400969a:	68bb      	ldr	r3, [r7, #8]
3400969c:	fbb2 f3f3 	udiv	r3, r2, r3
340096a0:	60fb      	str	r3, [r7, #12]
            break;
340096a2:	e01b      	b.n	340096dc <RCCEx_GetLPTIMCLKFreq+0x288>
            lptim_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340096a4:	f7fe fb74 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
340096a8:	60f8      	str	r0, [r7, #12]
            lptim_frequency = lptim_frequency / ic_divider;
340096aa:	68fa      	ldr	r2, [r7, #12]
340096ac:	68bb      	ldr	r3, [r7, #8]
340096ae:	fbb2 f3f3 	udiv	r3, r2, r3
340096b2:	60fb      	str	r3, [r7, #12]
            break;
340096b4:	e012      	b.n	340096dc <RCCEx_GetLPTIMCLKFreq+0x288>
            lptim_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340096b6:	f7fe fbb1 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
340096ba:	60f8      	str	r0, [r7, #12]
            lptim_frequency = lptim_frequency / ic_divider;
340096bc:	68fa      	ldr	r2, [r7, #12]
340096be:	68bb      	ldr	r3, [r7, #8]
340096c0:	fbb2 f3f3 	udiv	r3, r2, r3
340096c4:	60fb      	str	r3, [r7, #12]
            break;
340096c6:	e009      	b.n	340096dc <RCCEx_GetLPTIMCLKFreq+0x288>
            lptim_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340096c8:	f7fe fbee 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
340096cc:	60f8      	str	r0, [r7, #12]
            lptim_frequency = lptim_frequency / ic_divider;
340096ce:	68fa      	ldr	r2, [r7, #12]
340096d0:	68bb      	ldr	r3, [r7, #8]
340096d2:	fbb2 f3f3 	udiv	r3, r2, r3
340096d6:	60fb      	str	r3, [r7, #12]
            break;
340096d8:	e000      	b.n	340096dc <RCCEx_GetLPTIMCLKFreq+0x288>
            break;
340096da:	bf00      	nop
      break;
340096dc:	e059      	b.n	34009792 <RCCEx_GetLPTIMCLKFreq+0x33e>
      if (LL_RCC_LSE_IsReady() != 0U)
340096de:	f7fa f8d9 	bl	34003894 <LL_RCC_LSE_IsReady>
340096e2:	4603      	mov	r3, r0
340096e4:	2b00      	cmp	r3, #0
340096e6:	d056      	beq.n	34009796 <RCCEx_GetLPTIMCLKFreq+0x342>
        lptim_frequency = LSE_VALUE;
340096e8:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
340096ec:	60fb      	str	r3, [r7, #12]
      break;
340096ee:	e052      	b.n	34009796 <RCCEx_GetLPTIMCLKFreq+0x342>
340096f0:	0705182c 	.word	0x0705182c
340096f4:	0705142c 	.word	0x0705142c
340096f8:	0705102c 	.word	0x0705102c
340096fc:	07050c2c 	.word	0x07050c2c
34009700:	0705082c 	.word	0x0705082c
34009704:	0704182c 	.word	0x0704182c
34009708:	0704142c 	.word	0x0704142c
3400970c:	0704102c 	.word	0x0704102c
34009710:	07040c2c 	.word	0x07040c2c
34009714:	0704082c 	.word	0x0704082c
34009718:	0703182c 	.word	0x0703182c
3400971c:	0703142c 	.word	0x0703142c
34009720:	0703102c 	.word	0x0703102c
34009724:	07030c2c 	.word	0x07030c2c
34009728:	0703082c 	.word	0x0703082c
3400972c:	0702182c 	.word	0x0702182c
34009730:	0702142c 	.word	0x0702142c
34009734:	0702102c 	.word	0x0702102c
34009738:	07020c2c 	.word	0x07020c2c
3400973c:	0702082c 	.word	0x0702082c
34009740:	0701182c 	.word	0x0701182c
34009744:	0701142c 	.word	0x0701142c
34009748:	0701102c 	.word	0x0701102c
3400974c:	07010c2c 	.word	0x07010c2c
34009750:	0701082c 	.word	0x0701082c
34009754:	0700182c 	.word	0x0700182c
34009758:	0700142c 	.word	0x0700142c
3400975c:	0700102c 	.word	0x0700102c
34009760:	0700082c 	.word	0x0700082c
34009764:	07000c2c 	.word	0x07000c2c
      if (LL_RCC_LSI_IsReady() != 0U)
34009768:	f7fa f8a6 	bl	340038b8 <LL_RCC_LSI_IsReady>
3400976c:	4603      	mov	r3, r0
3400976e:	2b00      	cmp	r3, #0
34009770:	d013      	beq.n	3400979a <RCCEx_GetLPTIMCLKFreq+0x346>
        lptim_frequency = LSI_VALUE;
34009772:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
34009776:	60fb      	str	r3, [r7, #12]
      break;
34009778:	e00f      	b.n	3400979a <RCCEx_GetLPTIMCLKFreq+0x346>
      lptim_frequency = LL_RCC_CALC_TIMG_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetTIMPrescaler());
3400977a:	f7f9 ff75 	bl	34003668 <HAL_RCC_GetSysClockFreq>
3400977e:	4604      	mov	r4, r0
34009780:	f7fa fcb0 	bl	340040e4 <LL_RCC_GetTIMPrescaler>
34009784:	4603      	mov	r3, r0
34009786:	fa24 f303 	lsr.w	r3, r4, r3
3400978a:	60fb      	str	r3, [r7, #12]
      break;
3400978c:	e006      	b.n	3400979c <RCCEx_GetLPTIMCLKFreq+0x348>
      break;
3400978e:	bf00      	nop
34009790:	e004      	b.n	3400979c <RCCEx_GetLPTIMCLKFreq+0x348>
      break;
34009792:	bf00      	nop
34009794:	e002      	b.n	3400979c <RCCEx_GetLPTIMCLKFreq+0x348>
      break;
34009796:	bf00      	nop
34009798:	e000      	b.n	3400979c <RCCEx_GetLPTIMCLKFreq+0x348>
      break;
3400979a:	bf00      	nop
  }

  return lptim_frequency;
3400979c:	68fb      	ldr	r3, [r7, #12]
}
3400979e:	4618      	mov	r0, r3
340097a0:	3714      	adds	r7, #20
340097a2:	46bd      	mov	sp, r7
340097a4:	bd90      	pop	{r4, r7, pc}
340097a6:	bf00      	nop

340097a8 <RCCEx_GetLPUARTCLKFreq>:
  *         @arg @ref RCCEx_LPUART1_Clock_Source
  * @retval LPUART clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetLPUARTCLKFreq(uint32_t LPUARTxSource)
{
340097a8:	b580      	push	{r7, lr}
340097aa:	b084      	sub	sp, #16
340097ac:	af00      	add	r7, sp, #0
340097ae:	6078      	str	r0, [r7, #4]
  uint32_t lpuart_frequency = RCC_PERIPH_FREQUENCY_NO;
340097b0:	2300      	movs	r3, #0
340097b2:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetLPUARTClockSource(LPUARTxSource))
340097b4:	6878      	ldr	r0, [r7, #4]
340097b6:	f7fa fb97 	bl	34003ee8 <LL_RCC_GetLPUARTClockSource>
340097ba:	4603      	mov	r3, r0
340097bc:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
340097c0:	f000 80c0 	beq.w	34009944 <RCCEx_GetLPUARTCLKFreq+0x19c>
340097c4:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
340097c8:	f200 80db 	bhi.w	34009982 <RCCEx_GetLPUARTCLKFreq+0x1da>
340097cc:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
340097d0:	f000 80c6 	beq.w	34009960 <RCCEx_GetLPUARTCLKFreq+0x1b8>
340097d4:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
340097d8:	f200 80d3 	bhi.w	34009982 <RCCEx_GetLPUARTCLKFreq+0x1da>
340097dc:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
340097e0:	f000 80c6 	beq.w	34009970 <RCCEx_GetLPUARTCLKFreq+0x1c8>
340097e4:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
340097e8:	f200 80cb 	bhi.w	34009982 <RCCEx_GetLPUARTCLKFreq+0x1da>
340097ec:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
340097f0:	d065      	beq.n	340098be <RCCEx_GetLPUARTCLKFreq+0x116>
340097f2:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
340097f6:	f200 80c4 	bhi.w	34009982 <RCCEx_GetLPUARTCLKFreq+0x1da>
340097fa:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
340097fe:	d01a      	beq.n	34009836 <RCCEx_GetLPUARTCLKFreq+0x8e>
34009800:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34009804:	f200 80bd 	bhi.w	34009982 <RCCEx_GetLPUARTCLKFreq+0x1da>
34009808:	2b00      	cmp	r3, #0
3400980a:	d003      	beq.n	34009814 <RCCEx_GetLPUARTCLKFreq+0x6c>
3400980c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34009810:	d00c      	beq.n	3400982c <RCCEx_GetLPUARTCLKFreq+0x84>
      }
      break;

    default:
      /* Unexpected case */
      break;
34009812:	e0b6      	b.n	34009982 <RCCEx_GetLPUARTCLKFreq+0x1da>
      lpuart_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34009814:	f7f9 ff28 	bl	34003668 <HAL_RCC_GetSysClockFreq>
34009818:	4603      	mov	r3, r0
3400981a:	4618      	mov	r0, r3
3400981c:	f7fe fb8a 	bl	34007f34 <RCCEx_GetHCLKFreq>
34009820:	4603      	mov	r3, r0
34009822:	4618      	mov	r0, r3
34009824:	f7fe fbb8 	bl	34007f98 <RCCEx_GetPCLK4Freq>
34009828:	60f8      	str	r0, [r7, #12]
      break;
3400982a:	e0b5      	b.n	34009998 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      lpuart_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400982c:	2007      	movs	r0, #7
3400982e:	f7fe fe6d 	bl	3400850c <RCCEx_GetCLKPCLKFreq>
34009832:	60f8      	str	r0, [r7, #12]
      break;
34009834:	e0b0      	b.n	34009998 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      if (LL_RCC_IC9_IsEnabled() != 0U)
34009836:	f7fb f811 	bl	3400485c <LL_RCC_IC9_IsEnabled>
3400983a:	4603      	mov	r3, r0
3400983c:	2b00      	cmp	r3, #0
3400983e:	f000 80a2 	beq.w	34009986 <RCCEx_GetLPUARTCLKFreq+0x1de>
        ic_divider = LL_RCC_IC9_GetDivider();
34009842:	f7fb f82d 	bl	340048a0 <LL_RCC_IC9_GetDivider>
34009846:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC9_GetSource())
34009848:	f7fb f81c 	bl	34004884 <LL_RCC_IC9_GetSource>
3400984c:	4603      	mov	r3, r0
3400984e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34009852:	d029      	beq.n	340098a8 <RCCEx_GetLPUARTCLKFreq+0x100>
34009854:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34009858:	d82f      	bhi.n	340098ba <RCCEx_GetLPUARTCLKFreq+0x112>
3400985a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400985e:	d01a      	beq.n	34009896 <RCCEx_GetLPUARTCLKFreq+0xee>
34009860:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34009864:	d829      	bhi.n	340098ba <RCCEx_GetLPUARTCLKFreq+0x112>
34009866:	2b00      	cmp	r3, #0
34009868:	d003      	beq.n	34009872 <RCCEx_GetLPUARTCLKFreq+0xca>
3400986a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400986e:	d009      	beq.n	34009884 <RCCEx_GetLPUARTCLKFreq+0xdc>
            break;
34009870:	e023      	b.n	340098ba <RCCEx_GetLPUARTCLKFreq+0x112>
            lpuart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34009872:	f7fe fa47 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
34009876:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
34009878:	68fa      	ldr	r2, [r7, #12]
3400987a:	68bb      	ldr	r3, [r7, #8]
3400987c:	fbb2 f3f3 	udiv	r3, r2, r3
34009880:	60fb      	str	r3, [r7, #12]
            break;
34009882:	e01b      	b.n	340098bc <RCCEx_GetLPUARTCLKFreq+0x114>
            lpuart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34009884:	f7fe fa84 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
34009888:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
3400988a:	68fa      	ldr	r2, [r7, #12]
3400988c:	68bb      	ldr	r3, [r7, #8]
3400988e:	fbb2 f3f3 	udiv	r3, r2, r3
34009892:	60fb      	str	r3, [r7, #12]
            break;
34009894:	e012      	b.n	340098bc <RCCEx_GetLPUARTCLKFreq+0x114>
            lpuart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34009896:	f7fe fac1 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
3400989a:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
3400989c:	68fa      	ldr	r2, [r7, #12]
3400989e:	68bb      	ldr	r3, [r7, #8]
340098a0:	fbb2 f3f3 	udiv	r3, r2, r3
340098a4:	60fb      	str	r3, [r7, #12]
            break;
340098a6:	e009      	b.n	340098bc <RCCEx_GetLPUARTCLKFreq+0x114>
            lpuart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340098a8:	f7fe fafe 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
340098ac:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
340098ae:	68fa      	ldr	r2, [r7, #12]
340098b0:	68bb      	ldr	r3, [r7, #8]
340098b2:	fbb2 f3f3 	udiv	r3, r2, r3
340098b6:	60fb      	str	r3, [r7, #12]
            break;
340098b8:	e000      	b.n	340098bc <RCCEx_GetLPUARTCLKFreq+0x114>
            break;
340098ba:	bf00      	nop
      break;
340098bc:	e063      	b.n	34009986 <RCCEx_GetLPUARTCLKFreq+0x1de>
      if (LL_RCC_IC14_IsEnabled() != 0U)
340098be:	f7fb f8cd 	bl	34004a5c <LL_RCC_IC14_IsEnabled>
340098c2:	4603      	mov	r3, r0
340098c4:	2b00      	cmp	r3, #0
340098c6:	d060      	beq.n	3400998a <RCCEx_GetLPUARTCLKFreq+0x1e2>
        ic_divider = LL_RCC_IC14_GetDivider();
340098c8:	f7fb f8ea 	bl	34004aa0 <LL_RCC_IC14_GetDivider>
340098cc:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC14_GetSource())
340098ce:	f7fb f8d9 	bl	34004a84 <LL_RCC_IC14_GetSource>
340098d2:	4603      	mov	r3, r0
340098d4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340098d8:	d029      	beq.n	3400992e <RCCEx_GetLPUARTCLKFreq+0x186>
340098da:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340098de:	d82f      	bhi.n	34009940 <RCCEx_GetLPUARTCLKFreq+0x198>
340098e0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340098e4:	d01a      	beq.n	3400991c <RCCEx_GetLPUARTCLKFreq+0x174>
340098e6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340098ea:	d829      	bhi.n	34009940 <RCCEx_GetLPUARTCLKFreq+0x198>
340098ec:	2b00      	cmp	r3, #0
340098ee:	d003      	beq.n	340098f8 <RCCEx_GetLPUARTCLKFreq+0x150>
340098f0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340098f4:	d009      	beq.n	3400990a <RCCEx_GetLPUARTCLKFreq+0x162>
            break;
340098f6:	e023      	b.n	34009940 <RCCEx_GetLPUARTCLKFreq+0x198>
            lpuart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340098f8:	f7fe fa04 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
340098fc:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
340098fe:	68fa      	ldr	r2, [r7, #12]
34009900:	68bb      	ldr	r3, [r7, #8]
34009902:	fbb2 f3f3 	udiv	r3, r2, r3
34009906:	60fb      	str	r3, [r7, #12]
            break;
34009908:	e01b      	b.n	34009942 <RCCEx_GetLPUARTCLKFreq+0x19a>
            lpuart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400990a:	f7fe fa41 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
3400990e:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
34009910:	68fa      	ldr	r2, [r7, #12]
34009912:	68bb      	ldr	r3, [r7, #8]
34009914:	fbb2 f3f3 	udiv	r3, r2, r3
34009918:	60fb      	str	r3, [r7, #12]
            break;
3400991a:	e012      	b.n	34009942 <RCCEx_GetLPUARTCLKFreq+0x19a>
            lpuart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400991c:	f7fe fa7e 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
34009920:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
34009922:	68fa      	ldr	r2, [r7, #12]
34009924:	68bb      	ldr	r3, [r7, #8]
34009926:	fbb2 f3f3 	udiv	r3, r2, r3
3400992a:	60fb      	str	r3, [r7, #12]
            break;
3400992c:	e009      	b.n	34009942 <RCCEx_GetLPUARTCLKFreq+0x19a>
            lpuart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400992e:	f7fe fabb 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
34009932:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
34009934:	68fa      	ldr	r2, [r7, #12]
34009936:	68bb      	ldr	r3, [r7, #8]
34009938:	fbb2 f3f3 	udiv	r3, r2, r3
3400993c:	60fb      	str	r3, [r7, #12]
            break;
3400993e:	e000      	b.n	34009942 <RCCEx_GetLPUARTCLKFreq+0x19a>
            break;
34009940:	bf00      	nop
      break;
34009942:	e022      	b.n	3400998a <RCCEx_GetLPUARTCLKFreq+0x1e2>
      if (LL_RCC_HSI_IsReady() != 0U)
34009944:	f7f9 ff66 	bl	34003814 <LL_RCC_HSI_IsReady>
34009948:	4603      	mov	r3, r0
3400994a:	2b00      	cmp	r3, #0
3400994c:	d01f      	beq.n	3400998e <RCCEx_GetLPUARTCLKFreq+0x1e6>
        lpuart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400994e:	f7f9 ff73 	bl	34003838 <LL_RCC_HSI_GetDivider>
34009952:	4603      	mov	r3, r0
34009954:	09db      	lsrs	r3, r3, #7
34009956:	4a13      	ldr	r2, [pc, #76]	@ (340099a4 <RCCEx_GetLPUARTCLKFreq+0x1fc>)
34009958:	fa22 f303 	lsr.w	r3, r2, r3
3400995c:	60fb      	str	r3, [r7, #12]
      break;
3400995e:	e016      	b.n	3400998e <RCCEx_GetLPUARTCLKFreq+0x1e6>
      if (LL_RCC_MSI_IsReady() != 0U)
34009960:	f7f9 ff78 	bl	34003854 <LL_RCC_MSI_IsReady>
34009964:	4603      	mov	r3, r0
34009966:	2b00      	cmp	r3, #0
34009968:	d013      	beq.n	34009992 <RCCEx_GetLPUARTCLKFreq+0x1ea>
        lpuart_frequency = MSI_VALUE;
3400996a:	4b0f      	ldr	r3, [pc, #60]	@ (340099a8 <RCCEx_GetLPUARTCLKFreq+0x200>)
3400996c:	60fb      	str	r3, [r7, #12]
      break;
3400996e:	e010      	b.n	34009992 <RCCEx_GetLPUARTCLKFreq+0x1ea>
      if (LL_RCC_LSE_IsReady() != 0U)
34009970:	f7f9 ff90 	bl	34003894 <LL_RCC_LSE_IsReady>
34009974:	4603      	mov	r3, r0
34009976:	2b00      	cmp	r3, #0
34009978:	d00d      	beq.n	34009996 <RCCEx_GetLPUARTCLKFreq+0x1ee>
        lpuart_frequency = LSE_VALUE;
3400997a:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
3400997e:	60fb      	str	r3, [r7, #12]
      break;
34009980:	e009      	b.n	34009996 <RCCEx_GetLPUARTCLKFreq+0x1ee>
      break;
34009982:	bf00      	nop
34009984:	e008      	b.n	34009998 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      break;
34009986:	bf00      	nop
34009988:	e006      	b.n	34009998 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      break;
3400998a:	bf00      	nop
3400998c:	e004      	b.n	34009998 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      break;
3400998e:	bf00      	nop
34009990:	e002      	b.n	34009998 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      break;
34009992:	bf00      	nop
34009994:	e000      	b.n	34009998 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      break;
34009996:	bf00      	nop
  }

  return lpuart_frequency;
34009998:	68fb      	ldr	r3, [r7, #12]
}
3400999a:	4618      	mov	r0, r3
3400999c:	3710      	adds	r7, #16
3400999e:	46bd      	mov	sp, r7
340099a0:	bd80      	pop	{r7, pc}
340099a2:	bf00      	nop
340099a4:	03d09000 	.word	0x03d09000
340099a8:	003d0900 	.word	0x003d0900

340099ac <RCCEx_GetLTDCCLKFreq>:
  *         @arg @ref RCCEx_LTDC_Clock_Source
  * @retval LTDC clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetLTDCCLKFreq(uint32_t LTDCxSource)
{
340099ac:	b580      	push	{r7, lr}
340099ae:	b084      	sub	sp, #16
340099b0:	af00      	add	r7, sp, #0
340099b2:	6078      	str	r0, [r7, #4]
  uint32_t ltdc_frequency = RCC_PERIPH_FREQUENCY_NO;
340099b4:	2300      	movs	r3, #0
340099b6:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetLTDCClockSource(LTDCxSource))
340099b8:	6878      	ldr	r0, [r7, #4]
340099ba:	f7fa faa7 	bl	34003f0c <LL_RCC_GetLTDCClockSource>
340099be:	4603      	mov	r3, r0
340099c0:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
340099c4:	d062      	beq.n	34009a8c <RCCEx_GetLTDCCLKFreq+0xe0>
340099c6:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
340099ca:	d86d      	bhi.n	34009aa8 <RCCEx_GetLTDCCLKFreq+0xfc>
340099cc:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
340099d0:	d019      	beq.n	34009a06 <RCCEx_GetLTDCCLKFreq+0x5a>
340099d2:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
340099d6:	d867      	bhi.n	34009aa8 <RCCEx_GetLTDCCLKFreq+0xfc>
340099d8:	2b00      	cmp	r3, #0
340099da:	d003      	beq.n	340099e4 <RCCEx_GetLTDCCLKFreq+0x38>
340099dc:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
340099e0:	d00c      	beq.n	340099fc <RCCEx_GetLTDCCLKFreq+0x50>
      }
      break;

    default:
      /* Unexpected case */
      break;
340099e2:	e061      	b.n	34009aa8 <RCCEx_GetLTDCCLKFreq+0xfc>
      ltdc_frequency = RCCEx_GetPCLK5Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
340099e4:	f7f9 fe40 	bl	34003668 <HAL_RCC_GetSysClockFreq>
340099e8:	4603      	mov	r3, r0
340099ea:	4618      	mov	r0, r3
340099ec:	f7fe faa2 	bl	34007f34 <RCCEx_GetHCLKFreq>
340099f0:	4603      	mov	r3, r0
340099f2:	4618      	mov	r0, r3
340099f4:	f7fe fae1 	bl	34007fba <RCCEx_GetPCLK5Freq>
340099f8:	60f8      	str	r0, [r7, #12]
      break;
340099fa:	e05a      	b.n	34009ab2 <RCCEx_GetLTDCCLKFreq+0x106>
      ltdc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
340099fc:	2007      	movs	r0, #7
340099fe:	f7fe fd85 	bl	3400850c <RCCEx_GetCLKPCLKFreq>
34009a02:	60f8      	str	r0, [r7, #12]
      break;
34009a04:	e055      	b.n	34009ab2 <RCCEx_GetLTDCCLKFreq+0x106>
      if (LL_RCC_IC16_IsEnabled() != 0U)
34009a06:	f7fb f8a9 	bl	34004b5c <LL_RCC_IC16_IsEnabled>
34009a0a:	4603      	mov	r3, r0
34009a0c:	2b00      	cmp	r3, #0
34009a0e:	d04d      	beq.n	34009aac <RCCEx_GetLTDCCLKFreq+0x100>
        ic_divider = LL_RCC_IC16_GetDivider();
34009a10:	f7fb f8c6 	bl	34004ba0 <LL_RCC_IC16_GetDivider>
34009a14:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC16_GetSource())
34009a16:	f7fb f8b5 	bl	34004b84 <LL_RCC_IC16_GetSource>
34009a1a:	4603      	mov	r3, r0
34009a1c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34009a20:	d029      	beq.n	34009a76 <RCCEx_GetLTDCCLKFreq+0xca>
34009a22:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34009a26:	d82f      	bhi.n	34009a88 <RCCEx_GetLTDCCLKFreq+0xdc>
34009a28:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34009a2c:	d01a      	beq.n	34009a64 <RCCEx_GetLTDCCLKFreq+0xb8>
34009a2e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34009a32:	d829      	bhi.n	34009a88 <RCCEx_GetLTDCCLKFreq+0xdc>
34009a34:	2b00      	cmp	r3, #0
34009a36:	d003      	beq.n	34009a40 <RCCEx_GetLTDCCLKFreq+0x94>
34009a38:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34009a3c:	d009      	beq.n	34009a52 <RCCEx_GetLTDCCLKFreq+0xa6>
            break;
34009a3e:	e023      	b.n	34009a88 <RCCEx_GetLTDCCLKFreq+0xdc>
            ltdc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34009a40:	f7fe f960 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
34009a44:	60f8      	str	r0, [r7, #12]
            ltdc_frequency = ltdc_frequency / ic_divider;
34009a46:	68fa      	ldr	r2, [r7, #12]
34009a48:	68bb      	ldr	r3, [r7, #8]
34009a4a:	fbb2 f3f3 	udiv	r3, r2, r3
34009a4e:	60fb      	str	r3, [r7, #12]
            break;
34009a50:	e01b      	b.n	34009a8a <RCCEx_GetLTDCCLKFreq+0xde>
            ltdc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34009a52:	f7fe f99d 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
34009a56:	60f8      	str	r0, [r7, #12]
            ltdc_frequency = ltdc_frequency / ic_divider;
34009a58:	68fa      	ldr	r2, [r7, #12]
34009a5a:	68bb      	ldr	r3, [r7, #8]
34009a5c:	fbb2 f3f3 	udiv	r3, r2, r3
34009a60:	60fb      	str	r3, [r7, #12]
            break;
34009a62:	e012      	b.n	34009a8a <RCCEx_GetLTDCCLKFreq+0xde>
            ltdc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34009a64:	f7fe f9da 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
34009a68:	60f8      	str	r0, [r7, #12]
            ltdc_frequency = ltdc_frequency / ic_divider;
34009a6a:	68fa      	ldr	r2, [r7, #12]
34009a6c:	68bb      	ldr	r3, [r7, #8]
34009a6e:	fbb2 f3f3 	udiv	r3, r2, r3
34009a72:	60fb      	str	r3, [r7, #12]
            break;
34009a74:	e009      	b.n	34009a8a <RCCEx_GetLTDCCLKFreq+0xde>
            ltdc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34009a76:	f7fe fa17 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
34009a7a:	60f8      	str	r0, [r7, #12]
            ltdc_frequency = ltdc_frequency / ic_divider;
34009a7c:	68fa      	ldr	r2, [r7, #12]
34009a7e:	68bb      	ldr	r3, [r7, #8]
34009a80:	fbb2 f3f3 	udiv	r3, r2, r3
34009a84:	60fb      	str	r3, [r7, #12]
            break;
34009a86:	e000      	b.n	34009a8a <RCCEx_GetLTDCCLKFreq+0xde>
            break;
34009a88:	bf00      	nop
      break;
34009a8a:	e00f      	b.n	34009aac <RCCEx_GetLTDCCLKFreq+0x100>
      if (LL_RCC_HSI_IsReady() != 0U)
34009a8c:	f7f9 fec2 	bl	34003814 <LL_RCC_HSI_IsReady>
34009a90:	4603      	mov	r3, r0
34009a92:	2b00      	cmp	r3, #0
34009a94:	d00c      	beq.n	34009ab0 <RCCEx_GetLTDCCLKFreq+0x104>
        ltdc_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34009a96:	f7f9 fecf 	bl	34003838 <LL_RCC_HSI_GetDivider>
34009a9a:	4603      	mov	r3, r0
34009a9c:	09db      	lsrs	r3, r3, #7
34009a9e:	4a07      	ldr	r2, [pc, #28]	@ (34009abc <RCCEx_GetLTDCCLKFreq+0x110>)
34009aa0:	fa22 f303 	lsr.w	r3, r2, r3
34009aa4:	60fb      	str	r3, [r7, #12]
      break;
34009aa6:	e003      	b.n	34009ab0 <RCCEx_GetLTDCCLKFreq+0x104>
      break;
34009aa8:	bf00      	nop
34009aaa:	e002      	b.n	34009ab2 <RCCEx_GetLTDCCLKFreq+0x106>
      break;
34009aac:	bf00      	nop
34009aae:	e000      	b.n	34009ab2 <RCCEx_GetLTDCCLKFreq+0x106>
      break;
34009ab0:	bf00      	nop
  }

  return ltdc_frequency;
34009ab2:	68fb      	ldr	r3, [r7, #12]
}
34009ab4:	4618      	mov	r0, r3
34009ab6:	3710      	adds	r7, #16
34009ab8:	46bd      	mov	sp, r7
34009aba:	bd80      	pop	{r7, pc}
34009abc:	03d09000 	.word	0x03d09000

34009ac0 <RCCEx_GetMDFCLKFreq>:
  *         @arg @ref RCCEx_MDF1_Clock_Source
  * @retval MDF clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetMDFCLKFreq(uint32_t MDFxSource)
{
34009ac0:	b590      	push	{r4, r7, lr}
34009ac2:	b085      	sub	sp, #20
34009ac4:	af00      	add	r7, sp, #0
34009ac6:	6078      	str	r0, [r7, #4]
  uint32_t adf_frequency = RCC_PERIPH_FREQUENCY_NO;
34009ac8:	2300      	movs	r3, #0
34009aca:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetMDFClockSource(MDFxSource))
34009acc:	6878      	ldr	r0, [r7, #4]
34009ace:	f7fa fa2f 	bl	34003f30 <LL_RCC_GetMDFClockSource>
34009ad2:	4603      	mov	r3, r0
34009ad4:	f5b3 2fe0 	cmp.w	r3, #458752	@ 0x70000
34009ad8:	f000 80dd 	beq.w	34009c96 <RCCEx_GetMDFCLKFreq+0x1d6>
34009adc:	f5b3 2fe0 	cmp.w	r3, #458752	@ 0x70000
34009ae0:	f200 80e3 	bhi.w	34009caa <RCCEx_GetMDFCLKFreq+0x1ea>
34009ae4:	f5b3 2fc0 	cmp.w	r3, #393216	@ 0x60000
34009ae8:	f000 80d2 	beq.w	34009c90 <RCCEx_GetMDFCLKFreq+0x1d0>
34009aec:	f5b3 2fc0 	cmp.w	r3, #393216	@ 0x60000
34009af0:	f200 80db 	bhi.w	34009caa <RCCEx_GetMDFCLKFreq+0x1ea>
34009af4:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
34009af8:	f000 80b4 	beq.w	34009c64 <RCCEx_GetMDFCLKFreq+0x1a4>
34009afc:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
34009b00:	f200 80d3 	bhi.w	34009caa <RCCEx_GetMDFCLKFreq+0x1ea>
34009b04:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
34009b08:	f000 80ba 	beq.w	34009c80 <RCCEx_GetMDFCLKFreq+0x1c0>
34009b0c:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
34009b10:	f200 80cb 	bhi.w	34009caa <RCCEx_GetMDFCLKFreq+0x1ea>
34009b14:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34009b18:	d061      	beq.n	34009bde <RCCEx_GetMDFCLKFreq+0x11e>
34009b1a:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34009b1e:	f200 80c4 	bhi.w	34009caa <RCCEx_GetMDFCLKFreq+0x1ea>
34009b22:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34009b26:	d016      	beq.n	34009b56 <RCCEx_GetMDFCLKFreq+0x96>
34009b28:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34009b2c:	f200 80bd 	bhi.w	34009caa <RCCEx_GetMDFCLKFreq+0x1ea>
34009b30:	2b00      	cmp	r3, #0
34009b32:	d003      	beq.n	34009b3c <RCCEx_GetMDFCLKFreq+0x7c>
34009b34:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34009b38:	d008      	beq.n	34009b4c <RCCEx_GetMDFCLKFreq+0x8c>
      adf_frequency = LL_RCC_CALC_TIMG_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetTIMPrescaler());
      break;

    default:
      /* Unexpected case */
      break;
34009b3a:	e0b6      	b.n	34009caa <RCCEx_GetMDFCLKFreq+0x1ea>
      adf_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34009b3c:	f7f9 fd94 	bl	34003668 <HAL_RCC_GetSysClockFreq>
34009b40:	4603      	mov	r3, r0
34009b42:	4618      	mov	r0, r3
34009b44:	f7fe f9f6 	bl	34007f34 <RCCEx_GetHCLKFreq>
34009b48:	60f8      	str	r0, [r7, #12]
      break;
34009b4a:	e0b7      	b.n	34009cbc <RCCEx_GetMDFCLKFreq+0x1fc>
      adf_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34009b4c:	2007      	movs	r0, #7
34009b4e:	f7fe fcdd 	bl	3400850c <RCCEx_GetCLKPCLKFreq>
34009b52:	60f8      	str	r0, [r7, #12]
      break;
34009b54:	e0b2      	b.n	34009cbc <RCCEx_GetMDFCLKFreq+0x1fc>
      if (LL_RCC_IC7_IsEnabled() != 0U)
34009b56:	f7fa fe01 	bl	3400475c <LL_RCC_IC7_IsEnabled>
34009b5a:	4603      	mov	r3, r0
34009b5c:	2b00      	cmp	r3, #0
34009b5e:	f000 80a6 	beq.w	34009cae <RCCEx_GetMDFCLKFreq+0x1ee>
        ic_divider = LL_RCC_IC7_GetDivider();
34009b62:	f7fa fe1d 	bl	340047a0 <LL_RCC_IC7_GetDivider>
34009b66:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC7_GetSource())
34009b68:	f7fa fe0c 	bl	34004784 <LL_RCC_IC7_GetSource>
34009b6c:	4603      	mov	r3, r0
34009b6e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34009b72:	d029      	beq.n	34009bc8 <RCCEx_GetMDFCLKFreq+0x108>
34009b74:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34009b78:	d82f      	bhi.n	34009bda <RCCEx_GetMDFCLKFreq+0x11a>
34009b7a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34009b7e:	d01a      	beq.n	34009bb6 <RCCEx_GetMDFCLKFreq+0xf6>
34009b80:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34009b84:	d829      	bhi.n	34009bda <RCCEx_GetMDFCLKFreq+0x11a>
34009b86:	2b00      	cmp	r3, #0
34009b88:	d003      	beq.n	34009b92 <RCCEx_GetMDFCLKFreq+0xd2>
34009b8a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34009b8e:	d009      	beq.n	34009ba4 <RCCEx_GetMDFCLKFreq+0xe4>
            break;
34009b90:	e023      	b.n	34009bda <RCCEx_GetMDFCLKFreq+0x11a>
            adf_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34009b92:	f7fe f8b7 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
34009b96:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34009b98:	68fa      	ldr	r2, [r7, #12]
34009b9a:	68bb      	ldr	r3, [r7, #8]
34009b9c:	fbb2 f3f3 	udiv	r3, r2, r3
34009ba0:	60fb      	str	r3, [r7, #12]
            break;
34009ba2:	e01b      	b.n	34009bdc <RCCEx_GetMDFCLKFreq+0x11c>
            adf_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34009ba4:	f7fe f8f4 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
34009ba8:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34009baa:	68fa      	ldr	r2, [r7, #12]
34009bac:	68bb      	ldr	r3, [r7, #8]
34009bae:	fbb2 f3f3 	udiv	r3, r2, r3
34009bb2:	60fb      	str	r3, [r7, #12]
            break;
34009bb4:	e012      	b.n	34009bdc <RCCEx_GetMDFCLKFreq+0x11c>
            adf_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34009bb6:	f7fe f931 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
34009bba:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34009bbc:	68fa      	ldr	r2, [r7, #12]
34009bbe:	68bb      	ldr	r3, [r7, #8]
34009bc0:	fbb2 f3f3 	udiv	r3, r2, r3
34009bc4:	60fb      	str	r3, [r7, #12]
            break;
34009bc6:	e009      	b.n	34009bdc <RCCEx_GetMDFCLKFreq+0x11c>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34009bc8:	f7fe f96e 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
34009bcc:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34009bce:	68fa      	ldr	r2, [r7, #12]
34009bd0:	68bb      	ldr	r3, [r7, #8]
34009bd2:	fbb2 f3f3 	udiv	r3, r2, r3
34009bd6:	60fb      	str	r3, [r7, #12]
            break;
34009bd8:	e000      	b.n	34009bdc <RCCEx_GetMDFCLKFreq+0x11c>
            break;
34009bda:	bf00      	nop
      break;
34009bdc:	e067      	b.n	34009cae <RCCEx_GetMDFCLKFreq+0x1ee>
      if (LL_RCC_IC8_IsEnabled() != 0U)
34009bde:	f7fa fdfd 	bl	340047dc <LL_RCC_IC8_IsEnabled>
34009be2:	4603      	mov	r3, r0
34009be4:	2b00      	cmp	r3, #0
34009be6:	d064      	beq.n	34009cb2 <RCCEx_GetMDFCLKFreq+0x1f2>
        ic_divider = LL_RCC_IC8_GetDivider();
34009be8:	f7fa fe1a 	bl	34004820 <LL_RCC_IC8_GetDivider>
34009bec:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
34009bee:	f7fa fe09 	bl	34004804 <LL_RCC_IC8_GetSource>
34009bf2:	4603      	mov	r3, r0
34009bf4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34009bf8:	d029      	beq.n	34009c4e <RCCEx_GetMDFCLKFreq+0x18e>
34009bfa:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34009bfe:	d82f      	bhi.n	34009c60 <RCCEx_GetMDFCLKFreq+0x1a0>
34009c00:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34009c04:	d01a      	beq.n	34009c3c <RCCEx_GetMDFCLKFreq+0x17c>
34009c06:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34009c0a:	d829      	bhi.n	34009c60 <RCCEx_GetMDFCLKFreq+0x1a0>
34009c0c:	2b00      	cmp	r3, #0
34009c0e:	d003      	beq.n	34009c18 <RCCEx_GetMDFCLKFreq+0x158>
34009c10:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34009c14:	d009      	beq.n	34009c2a <RCCEx_GetMDFCLKFreq+0x16a>
            break;
34009c16:	e023      	b.n	34009c60 <RCCEx_GetMDFCLKFreq+0x1a0>
            adf_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34009c18:	f7fe f874 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
34009c1c:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34009c1e:	68fa      	ldr	r2, [r7, #12]
34009c20:	68bb      	ldr	r3, [r7, #8]
34009c22:	fbb2 f3f3 	udiv	r3, r2, r3
34009c26:	60fb      	str	r3, [r7, #12]
            break;
34009c28:	e01b      	b.n	34009c62 <RCCEx_GetMDFCLKFreq+0x1a2>
            adf_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34009c2a:	f7fe f8b1 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
34009c2e:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34009c30:	68fa      	ldr	r2, [r7, #12]
34009c32:	68bb      	ldr	r3, [r7, #8]
34009c34:	fbb2 f3f3 	udiv	r3, r2, r3
34009c38:	60fb      	str	r3, [r7, #12]
            break;
34009c3a:	e012      	b.n	34009c62 <RCCEx_GetMDFCLKFreq+0x1a2>
            adf_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34009c3c:	f7fe f8ee 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
34009c40:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34009c42:	68fa      	ldr	r2, [r7, #12]
34009c44:	68bb      	ldr	r3, [r7, #8]
34009c46:	fbb2 f3f3 	udiv	r3, r2, r3
34009c4a:	60fb      	str	r3, [r7, #12]
            break;
34009c4c:	e009      	b.n	34009c62 <RCCEx_GetMDFCLKFreq+0x1a2>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34009c4e:	f7fe f92b 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
34009c52:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34009c54:	68fa      	ldr	r2, [r7, #12]
34009c56:	68bb      	ldr	r3, [r7, #8]
34009c58:	fbb2 f3f3 	udiv	r3, r2, r3
34009c5c:	60fb      	str	r3, [r7, #12]
            break;
34009c5e:	e000      	b.n	34009c62 <RCCEx_GetMDFCLKFreq+0x1a2>
            break;
34009c60:	bf00      	nop
      break;
34009c62:	e026      	b.n	34009cb2 <RCCEx_GetMDFCLKFreq+0x1f2>
      if (LL_RCC_HSI_IsReady() != 0U)
34009c64:	f7f9 fdd6 	bl	34003814 <LL_RCC_HSI_IsReady>
34009c68:	4603      	mov	r3, r0
34009c6a:	2b00      	cmp	r3, #0
34009c6c:	d023      	beq.n	34009cb6 <RCCEx_GetMDFCLKFreq+0x1f6>
        adf_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34009c6e:	f7f9 fde3 	bl	34003838 <LL_RCC_HSI_GetDivider>
34009c72:	4603      	mov	r3, r0
34009c74:	09db      	lsrs	r3, r3, #7
34009c76:	4a14      	ldr	r2, [pc, #80]	@ (34009cc8 <RCCEx_GetMDFCLKFreq+0x208>)
34009c78:	fa22 f303 	lsr.w	r3, r2, r3
34009c7c:	60fb      	str	r3, [r7, #12]
      break;
34009c7e:	e01a      	b.n	34009cb6 <RCCEx_GetMDFCLKFreq+0x1f6>
      if (LL_RCC_MSI_IsReady() != 0U)
34009c80:	f7f9 fde8 	bl	34003854 <LL_RCC_MSI_IsReady>
34009c84:	4603      	mov	r3, r0
34009c86:	2b00      	cmp	r3, #0
34009c88:	d017      	beq.n	34009cba <RCCEx_GetMDFCLKFreq+0x1fa>
        adf_frequency = MSI_VALUE;
34009c8a:	4b10      	ldr	r3, [pc, #64]	@ (34009ccc <RCCEx_GetMDFCLKFreq+0x20c>)
34009c8c:	60fb      	str	r3, [r7, #12]
      break;
34009c8e:	e014      	b.n	34009cba <RCCEx_GetMDFCLKFreq+0x1fa>
      adf_frequency = EXTERNAL_CLOCK_VALUE;
34009c90:	4b0f      	ldr	r3, [pc, #60]	@ (34009cd0 <RCCEx_GetMDFCLKFreq+0x210>)
34009c92:	60fb      	str	r3, [r7, #12]
      break;
34009c94:	e012      	b.n	34009cbc <RCCEx_GetMDFCLKFreq+0x1fc>
      adf_frequency = LL_RCC_CALC_TIMG_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetTIMPrescaler());
34009c96:	f7f9 fce7 	bl	34003668 <HAL_RCC_GetSysClockFreq>
34009c9a:	4604      	mov	r4, r0
34009c9c:	f7fa fa22 	bl	340040e4 <LL_RCC_GetTIMPrescaler>
34009ca0:	4603      	mov	r3, r0
34009ca2:	fa24 f303 	lsr.w	r3, r4, r3
34009ca6:	60fb      	str	r3, [r7, #12]
      break;
34009ca8:	e008      	b.n	34009cbc <RCCEx_GetMDFCLKFreq+0x1fc>
      break;
34009caa:	bf00      	nop
34009cac:	e006      	b.n	34009cbc <RCCEx_GetMDFCLKFreq+0x1fc>
      break;
34009cae:	bf00      	nop
34009cb0:	e004      	b.n	34009cbc <RCCEx_GetMDFCLKFreq+0x1fc>
      break;
34009cb2:	bf00      	nop
34009cb4:	e002      	b.n	34009cbc <RCCEx_GetMDFCLKFreq+0x1fc>
      break;
34009cb6:	bf00      	nop
34009cb8:	e000      	b.n	34009cbc <RCCEx_GetMDFCLKFreq+0x1fc>
      break;
34009cba:	bf00      	nop
  }

  return adf_frequency;
34009cbc:	68fb      	ldr	r3, [r7, #12]
}
34009cbe:	4618      	mov	r0, r3
34009cc0:	3714      	adds	r7, #20
34009cc2:	46bd      	mov	sp, r7
34009cc4:	bd90      	pop	{r4, r7, pc}
34009cc6:	bf00      	nop
34009cc8:	03d09000 	.word	0x03d09000
34009ccc:	003d0900 	.word	0x003d0900
34009cd0:	00bb8000 	.word	0x00bb8000

34009cd4 <RCCEx_GetPSSICLKFreq>:
  *         @arg @ref RCCEx_PSSI_Clock_Source
  * @retval PSSI clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetPSSICLKFreq(uint32_t PSSIxSource)
{
34009cd4:	b580      	push	{r7, lr}
34009cd6:	b084      	sub	sp, #16
34009cd8:	af00      	add	r7, sp, #0
34009cda:	6078      	str	r0, [r7, #4]
  uint32_t pssi_frequency = RCC_PERIPH_FREQUENCY_NO;
34009cdc:	2300      	movs	r3, #0
34009cde:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetPSSIClockSource(PSSIxSource))
34009ce0:	6878      	ldr	r0, [r7, #4]
34009ce2:	f7fa f937 	bl	34003f54 <LL_RCC_GetPSSIClockSource>
34009ce6:	4603      	mov	r3, r0
34009ce8:	2b30      	cmp	r3, #48	@ 0x30
34009cea:	d05a      	beq.n	34009da2 <RCCEx_GetPSSICLKFreq+0xce>
34009cec:	2b30      	cmp	r3, #48	@ 0x30
34009cee:	d866      	bhi.n	34009dbe <RCCEx_GetPSSICLKFreq+0xea>
34009cf0:	2b20      	cmp	r3, #32
34009cf2:	d013      	beq.n	34009d1c <RCCEx_GetPSSICLKFreq+0x48>
34009cf4:	2b20      	cmp	r3, #32
34009cf6:	d862      	bhi.n	34009dbe <RCCEx_GetPSSICLKFreq+0xea>
34009cf8:	2b00      	cmp	r3, #0
34009cfa:	d002      	beq.n	34009d02 <RCCEx_GetPSSICLKFreq+0x2e>
34009cfc:	2b10      	cmp	r3, #16
34009cfe:	d008      	beq.n	34009d12 <RCCEx_GetPSSICLKFreq+0x3e>
      }
      break;

    default:
      /* Unexpected case */
      break;
34009d00:	e05d      	b.n	34009dbe <RCCEx_GetPSSICLKFreq+0xea>
      pssi_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34009d02:	f7f9 fcb1 	bl	34003668 <HAL_RCC_GetSysClockFreq>
34009d06:	4603      	mov	r3, r0
34009d08:	4618      	mov	r0, r3
34009d0a:	f7fe f913 	bl	34007f34 <RCCEx_GetHCLKFreq>
34009d0e:	60f8      	str	r0, [r7, #12]
      break;
34009d10:	e05a      	b.n	34009dc8 <RCCEx_GetPSSICLKFreq+0xf4>
      pssi_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34009d12:	2007      	movs	r0, #7
34009d14:	f7fe fbfa 	bl	3400850c <RCCEx_GetCLKPCLKFreq>
34009d18:	60f8      	str	r0, [r7, #12]
      break;
34009d1a:	e055      	b.n	34009dc8 <RCCEx_GetPSSICLKFreq+0xf4>
      if (LL_RCC_IC20_IsEnabled() != 0U)
34009d1c:	f7fb f81e 	bl	34004d5c <LL_RCC_IC20_IsEnabled>
34009d20:	4603      	mov	r3, r0
34009d22:	2b00      	cmp	r3, #0
34009d24:	d04d      	beq.n	34009dc2 <RCCEx_GetPSSICLKFreq+0xee>
        ic_divider = LL_RCC_IC20_GetDivider();
34009d26:	f7fb f83b 	bl	34004da0 <LL_RCC_IC20_GetDivider>
34009d2a:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC20_GetSource())
34009d2c:	f7fb f82a 	bl	34004d84 <LL_RCC_IC20_GetSource>
34009d30:	4603      	mov	r3, r0
34009d32:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34009d36:	d029      	beq.n	34009d8c <RCCEx_GetPSSICLKFreq+0xb8>
34009d38:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34009d3c:	d82f      	bhi.n	34009d9e <RCCEx_GetPSSICLKFreq+0xca>
34009d3e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34009d42:	d01a      	beq.n	34009d7a <RCCEx_GetPSSICLKFreq+0xa6>
34009d44:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34009d48:	d829      	bhi.n	34009d9e <RCCEx_GetPSSICLKFreq+0xca>
34009d4a:	2b00      	cmp	r3, #0
34009d4c:	d003      	beq.n	34009d56 <RCCEx_GetPSSICLKFreq+0x82>
34009d4e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34009d52:	d009      	beq.n	34009d68 <RCCEx_GetPSSICLKFreq+0x94>
            break;
34009d54:	e023      	b.n	34009d9e <RCCEx_GetPSSICLKFreq+0xca>
            pssi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34009d56:	f7fd ffd5 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
34009d5a:	60f8      	str	r0, [r7, #12]
            pssi_frequency = pssi_frequency / ic_divider;
34009d5c:	68fa      	ldr	r2, [r7, #12]
34009d5e:	68bb      	ldr	r3, [r7, #8]
34009d60:	fbb2 f3f3 	udiv	r3, r2, r3
34009d64:	60fb      	str	r3, [r7, #12]
            break;
34009d66:	e01b      	b.n	34009da0 <RCCEx_GetPSSICLKFreq+0xcc>
            pssi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34009d68:	f7fe f812 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
34009d6c:	60f8      	str	r0, [r7, #12]
            pssi_frequency = pssi_frequency / ic_divider;
34009d6e:	68fa      	ldr	r2, [r7, #12]
34009d70:	68bb      	ldr	r3, [r7, #8]
34009d72:	fbb2 f3f3 	udiv	r3, r2, r3
34009d76:	60fb      	str	r3, [r7, #12]
            break;
34009d78:	e012      	b.n	34009da0 <RCCEx_GetPSSICLKFreq+0xcc>
            pssi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34009d7a:	f7fe f84f 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
34009d7e:	60f8      	str	r0, [r7, #12]
            pssi_frequency = pssi_frequency / ic_divider;
34009d80:	68fa      	ldr	r2, [r7, #12]
34009d82:	68bb      	ldr	r3, [r7, #8]
34009d84:	fbb2 f3f3 	udiv	r3, r2, r3
34009d88:	60fb      	str	r3, [r7, #12]
            break;
34009d8a:	e009      	b.n	34009da0 <RCCEx_GetPSSICLKFreq+0xcc>
            pssi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34009d8c:	f7fe f88c 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
34009d90:	60f8      	str	r0, [r7, #12]
            pssi_frequency = pssi_frequency / ic_divider;
34009d92:	68fa      	ldr	r2, [r7, #12]
34009d94:	68bb      	ldr	r3, [r7, #8]
34009d96:	fbb2 f3f3 	udiv	r3, r2, r3
34009d9a:	60fb      	str	r3, [r7, #12]
            break;
34009d9c:	e000      	b.n	34009da0 <RCCEx_GetPSSICLKFreq+0xcc>
            break;
34009d9e:	bf00      	nop
      break;
34009da0:	e00f      	b.n	34009dc2 <RCCEx_GetPSSICLKFreq+0xee>
      if (LL_RCC_HSI_IsReady() != 0U)
34009da2:	f7f9 fd37 	bl	34003814 <LL_RCC_HSI_IsReady>
34009da6:	4603      	mov	r3, r0
34009da8:	2b00      	cmp	r3, #0
34009daa:	d00c      	beq.n	34009dc6 <RCCEx_GetPSSICLKFreq+0xf2>
        pssi_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34009dac:	f7f9 fd44 	bl	34003838 <LL_RCC_HSI_GetDivider>
34009db0:	4603      	mov	r3, r0
34009db2:	09db      	lsrs	r3, r3, #7
34009db4:	4a07      	ldr	r2, [pc, #28]	@ (34009dd4 <RCCEx_GetPSSICLKFreq+0x100>)
34009db6:	fa22 f303 	lsr.w	r3, r2, r3
34009dba:	60fb      	str	r3, [r7, #12]
      break;
34009dbc:	e003      	b.n	34009dc6 <RCCEx_GetPSSICLKFreq+0xf2>
      break;
34009dbe:	bf00      	nop
34009dc0:	e002      	b.n	34009dc8 <RCCEx_GetPSSICLKFreq+0xf4>
      break;
34009dc2:	bf00      	nop
34009dc4:	e000      	b.n	34009dc8 <RCCEx_GetPSSICLKFreq+0xf4>
      break;
34009dc6:	bf00      	nop
  }

  return pssi_frequency;
34009dc8:	68fb      	ldr	r3, [r7, #12]
}
34009dca:	4618      	mov	r0, r3
34009dcc:	3710      	adds	r7, #16
34009dce:	46bd      	mov	sp, r7
34009dd0:	bd80      	pop	{r7, pc}
34009dd2:	bf00      	nop
34009dd4:	03d09000 	.word	0x03d09000

34009dd8 <RCCEx_GetRTCCLKFreq>:
  * @brief  Return RTC clock frequency
  * @retval RTC clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetRTCCLKFreq()
{
34009dd8:	b580      	push	{r7, lr}
34009dda:	b082      	sub	sp, #8
34009ddc:	af00      	add	r7, sp, #0
  uint32_t rtc_frequency = RCC_PERIPH_FREQUENCY_NO;
34009dde:	2300      	movs	r3, #0
34009de0:	607b      	str	r3, [r7, #4]

  switch (LL_RCC_GetRTCClockSource())
34009de2:	f7fa f945 	bl	34004070 <LL_RCC_GetRTCClockSource>
34009de6:	4603      	mov	r3, r0
34009de8:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
34009dec:	d020      	beq.n	34009e30 <RCCEx_GetRTCCLKFreq+0x58>
34009dee:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
34009df2:	d830      	bhi.n	34009e56 <RCCEx_GetRTCCLKFreq+0x7e>
34009df4:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34009df8:	d011      	beq.n	34009e1e <RCCEx_GetRTCCLKFreq+0x46>
34009dfa:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34009dfe:	d82a      	bhi.n	34009e56 <RCCEx_GetRTCCLKFreq+0x7e>
34009e00:	2b00      	cmp	r3, #0
34009e02:	d02a      	beq.n	34009e5a <RCCEx_GetRTCCLKFreq+0x82>
34009e04:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34009e08:	d000      	beq.n	34009e0c <RCCEx_GetRTCCLKFreq+0x34>
      }
      break;

    default:
      /* Unexpected case */
      break;
34009e0a:	e024      	b.n	34009e56 <RCCEx_GetRTCCLKFreq+0x7e>
      if (LL_RCC_LSE_IsReady() != 0U)
34009e0c:	f7f9 fd42 	bl	34003894 <LL_RCC_LSE_IsReady>
34009e10:	4603      	mov	r3, r0
34009e12:	2b00      	cmp	r3, #0
34009e14:	d023      	beq.n	34009e5e <RCCEx_GetRTCCLKFreq+0x86>
        rtc_frequency = LSE_VALUE;
34009e16:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
34009e1a:	607b      	str	r3, [r7, #4]
      break;
34009e1c:	e01f      	b.n	34009e5e <RCCEx_GetRTCCLKFreq+0x86>
      if (LL_RCC_LSI_IsReady() != 0U)
34009e1e:	f7f9 fd4b 	bl	340038b8 <LL_RCC_LSI_IsReady>
34009e22:	4603      	mov	r3, r0
34009e24:	2b00      	cmp	r3, #0
34009e26:	d01c      	beq.n	34009e62 <RCCEx_GetRTCCLKFreq+0x8a>
        rtc_frequency = LSI_VALUE;
34009e28:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
34009e2c:	607b      	str	r3, [r7, #4]
      break;
34009e2e:	e018      	b.n	34009e62 <RCCEx_GetRTCCLKFreq+0x8a>
      if (LL_RCC_HSE_IsReady() != 0U)
34009e30:	f7f9 fcde 	bl	340037f0 <LL_RCC_HSE_IsReady>
34009e34:	4603      	mov	r3, r0
34009e36:	2b00      	cmp	r3, #0
34009e38:	d015      	beq.n	34009e66 <RCCEx_GetRTCCLKFreq+0x8e>
        uint32_t prescaler = (READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCPRE) >> RCC_CCIPR7_RTCPRE_Pos) + 1U;
34009e3a:	4b0e      	ldr	r3, [pc, #56]	@ (34009e74 <RCCEx_GetRTCCLKFreq+0x9c>)
34009e3c:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
34009e40:	0b1b      	lsrs	r3, r3, #12
34009e42:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34009e46:	3301      	adds	r3, #1
34009e48:	603b      	str	r3, [r7, #0]
        rtc_frequency = HSE_VALUE / prescaler;
34009e4a:	4a0b      	ldr	r2, [pc, #44]	@ (34009e78 <RCCEx_GetRTCCLKFreq+0xa0>)
34009e4c:	683b      	ldr	r3, [r7, #0]
34009e4e:	fbb2 f3f3 	udiv	r3, r2, r3
34009e52:	607b      	str	r3, [r7, #4]
      break;
34009e54:	e007      	b.n	34009e66 <RCCEx_GetRTCCLKFreq+0x8e>
      break;
34009e56:	bf00      	nop
34009e58:	e006      	b.n	34009e68 <RCCEx_GetRTCCLKFreq+0x90>
      break;
34009e5a:	bf00      	nop
34009e5c:	e004      	b.n	34009e68 <RCCEx_GetRTCCLKFreq+0x90>
      break;
34009e5e:	bf00      	nop
34009e60:	e002      	b.n	34009e68 <RCCEx_GetRTCCLKFreq+0x90>
      break;
34009e62:	bf00      	nop
34009e64:	e000      	b.n	34009e68 <RCCEx_GetRTCCLKFreq+0x90>
      break;
34009e66:	bf00      	nop
  }

  return rtc_frequency;
34009e68:	687b      	ldr	r3, [r7, #4]
}
34009e6a:	4618      	mov	r0, r3
34009e6c:	3708      	adds	r7, #8
34009e6e:	46bd      	mov	sp, r7
34009e70:	bd80      	pop	{r7, pc}
34009e72:	bf00      	nop
34009e74:	56028000 	.word	0x56028000
34009e78:	016e3600 	.word	0x016e3600

34009e7c <RCCEx_GetSAICLKFreq>:
  *         @arg @ref RCCEx_SAI2_Clock_Source
  * @retval SAI clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetSAICLKFreq(uint32_t SAIxSource)
{
34009e7c:	b580      	push	{r7, lr}
34009e7e:	b084      	sub	sp, #16
34009e80:	af00      	add	r7, sp, #0
34009e82:	6078      	str	r0, [r7, #4]
  uint32_t sai_frequency = RCC_PERIPH_FREQUENCY_NO;
34009e84:	2300      	movs	r3, #0
34009e86:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetSAIClockSource(SAIxSource))
34009e88:	6878      	ldr	r0, [r7, #4]
34009e8a:	f7fa f875 	bl	34003f78 <LL_RCC_GetSAIClockSource>
34009e8e:	4603      	mov	r3, r0
34009e90:	4a9a      	ldr	r2, [pc, #616]	@ (3400a0fc <RCCEx_GetSAICLKFreq+0x280>)
34009e92:	4293      	cmp	r3, r2
34009e94:	f000 811f 	beq.w	3400a0d6 <RCCEx_GetSAICLKFreq+0x25a>
34009e98:	4a98      	ldr	r2, [pc, #608]	@ (3400a0fc <RCCEx_GetSAICLKFreq+0x280>)
34009e9a:	4293      	cmp	r3, r2
34009e9c:	f200 8120 	bhi.w	3400a0e0 <RCCEx_GetSAICLKFreq+0x264>
34009ea0:	4a97      	ldr	r2, [pc, #604]	@ (3400a100 <RCCEx_GetSAICLKFreq+0x284>)
34009ea2:	4293      	cmp	r3, r2
34009ea4:	f000 8117 	beq.w	3400a0d6 <RCCEx_GetSAICLKFreq+0x25a>
34009ea8:	4a95      	ldr	r2, [pc, #596]	@ (3400a100 <RCCEx_GetSAICLKFreq+0x284>)
34009eaa:	4293      	cmp	r3, r2
34009eac:	f200 8118 	bhi.w	3400a0e0 <RCCEx_GetSAICLKFreq+0x264>
34009eb0:	4a94      	ldr	r2, [pc, #592]	@ (3400a104 <RCCEx_GetSAICLKFreq+0x288>)
34009eb2:	4293      	cmp	r3, r2
34009eb4:	f000 810c 	beq.w	3400a0d0 <RCCEx_GetSAICLKFreq+0x254>
34009eb8:	4a92      	ldr	r2, [pc, #584]	@ (3400a104 <RCCEx_GetSAICLKFreq+0x288>)
34009eba:	4293      	cmp	r3, r2
34009ebc:	f200 8110 	bhi.w	3400a0e0 <RCCEx_GetSAICLKFreq+0x264>
34009ec0:	4a91      	ldr	r2, [pc, #580]	@ (3400a108 <RCCEx_GetSAICLKFreq+0x28c>)
34009ec2:	4293      	cmp	r3, r2
34009ec4:	f000 8104 	beq.w	3400a0d0 <RCCEx_GetSAICLKFreq+0x254>
34009ec8:	4a8f      	ldr	r2, [pc, #572]	@ (3400a108 <RCCEx_GetSAICLKFreq+0x28c>)
34009eca:	4293      	cmp	r3, r2
34009ecc:	f200 8108 	bhi.w	3400a0e0 <RCCEx_GetSAICLKFreq+0x264>
34009ed0:	4a8e      	ldr	r2, [pc, #568]	@ (3400a10c <RCCEx_GetSAICLKFreq+0x290>)
34009ed2:	4293      	cmp	r3, r2
34009ed4:	f000 80e6 	beq.w	3400a0a4 <RCCEx_GetSAICLKFreq+0x228>
34009ed8:	4a8c      	ldr	r2, [pc, #560]	@ (3400a10c <RCCEx_GetSAICLKFreq+0x290>)
34009eda:	4293      	cmp	r3, r2
34009edc:	f200 8100 	bhi.w	3400a0e0 <RCCEx_GetSAICLKFreq+0x264>
34009ee0:	4a8b      	ldr	r2, [pc, #556]	@ (3400a110 <RCCEx_GetSAICLKFreq+0x294>)
34009ee2:	4293      	cmp	r3, r2
34009ee4:	f000 80de 	beq.w	3400a0a4 <RCCEx_GetSAICLKFreq+0x228>
34009ee8:	4a89      	ldr	r2, [pc, #548]	@ (3400a110 <RCCEx_GetSAICLKFreq+0x294>)
34009eea:	4293      	cmp	r3, r2
34009eec:	f200 80f8 	bhi.w	3400a0e0 <RCCEx_GetSAICLKFreq+0x264>
34009ef0:	4a88      	ldr	r2, [pc, #544]	@ (3400a114 <RCCEx_GetSAICLKFreq+0x298>)
34009ef2:	4293      	cmp	r3, r2
34009ef4:	f000 80e4 	beq.w	3400a0c0 <RCCEx_GetSAICLKFreq+0x244>
34009ef8:	4a86      	ldr	r2, [pc, #536]	@ (3400a114 <RCCEx_GetSAICLKFreq+0x298>)
34009efa:	4293      	cmp	r3, r2
34009efc:	f200 80f0 	bhi.w	3400a0e0 <RCCEx_GetSAICLKFreq+0x264>
34009f00:	4a85      	ldr	r2, [pc, #532]	@ (3400a118 <RCCEx_GetSAICLKFreq+0x29c>)
34009f02:	4293      	cmp	r3, r2
34009f04:	f000 80dc 	beq.w	3400a0c0 <RCCEx_GetSAICLKFreq+0x244>
34009f08:	4a83      	ldr	r2, [pc, #524]	@ (3400a118 <RCCEx_GetSAICLKFreq+0x29c>)
34009f0a:	4293      	cmp	r3, r2
34009f0c:	f200 80e8 	bhi.w	3400a0e0 <RCCEx_GetSAICLKFreq+0x264>
34009f10:	4a82      	ldr	r2, [pc, #520]	@ (3400a11c <RCCEx_GetSAICLKFreq+0x2a0>)
34009f12:	4293      	cmp	r3, r2
34009f14:	f000 8083 	beq.w	3400a01e <RCCEx_GetSAICLKFreq+0x1a2>
34009f18:	4a80      	ldr	r2, [pc, #512]	@ (3400a11c <RCCEx_GetSAICLKFreq+0x2a0>)
34009f1a:	4293      	cmp	r3, r2
34009f1c:	f200 80e0 	bhi.w	3400a0e0 <RCCEx_GetSAICLKFreq+0x264>
34009f20:	4a7f      	ldr	r2, [pc, #508]	@ (3400a120 <RCCEx_GetSAICLKFreq+0x2a4>)
34009f22:	4293      	cmp	r3, r2
34009f24:	d07b      	beq.n	3400a01e <RCCEx_GetSAICLKFreq+0x1a2>
34009f26:	4a7e      	ldr	r2, [pc, #504]	@ (3400a120 <RCCEx_GetSAICLKFreq+0x2a4>)
34009f28:	4293      	cmp	r3, r2
34009f2a:	f200 80d9 	bhi.w	3400a0e0 <RCCEx_GetSAICLKFreq+0x264>
34009f2e:	4a7d      	ldr	r2, [pc, #500]	@ (3400a124 <RCCEx_GetSAICLKFreq+0x2a8>)
34009f30:	4293      	cmp	r3, r2
34009f32:	d030      	beq.n	34009f96 <RCCEx_GetSAICLKFreq+0x11a>
34009f34:	4a7b      	ldr	r2, [pc, #492]	@ (3400a124 <RCCEx_GetSAICLKFreq+0x2a8>)
34009f36:	4293      	cmp	r3, r2
34009f38:	f200 80d2 	bhi.w	3400a0e0 <RCCEx_GetSAICLKFreq+0x264>
34009f3c:	4a7a      	ldr	r2, [pc, #488]	@ (3400a128 <RCCEx_GetSAICLKFreq+0x2ac>)
34009f3e:	4293      	cmp	r3, r2
34009f40:	d029      	beq.n	34009f96 <RCCEx_GetSAICLKFreq+0x11a>
34009f42:	4a79      	ldr	r2, [pc, #484]	@ (3400a128 <RCCEx_GetSAICLKFreq+0x2ac>)
34009f44:	4293      	cmp	r3, r2
34009f46:	f200 80cb 	bhi.w	3400a0e0 <RCCEx_GetSAICLKFreq+0x264>
34009f4a:	4a78      	ldr	r2, [pc, #480]	@ (3400a12c <RCCEx_GetSAICLKFreq+0x2b0>)
34009f4c:	4293      	cmp	r3, r2
34009f4e:	d01d      	beq.n	34009f8c <RCCEx_GetSAICLKFreq+0x110>
34009f50:	4a76      	ldr	r2, [pc, #472]	@ (3400a12c <RCCEx_GetSAICLKFreq+0x2b0>)
34009f52:	4293      	cmp	r3, r2
34009f54:	f200 80c4 	bhi.w	3400a0e0 <RCCEx_GetSAICLKFreq+0x264>
34009f58:	4a75      	ldr	r2, [pc, #468]	@ (3400a130 <RCCEx_GetSAICLKFreq+0x2b4>)
34009f5a:	4293      	cmp	r3, r2
34009f5c:	d016      	beq.n	34009f8c <RCCEx_GetSAICLKFreq+0x110>
34009f5e:	4a74      	ldr	r2, [pc, #464]	@ (3400a130 <RCCEx_GetSAICLKFreq+0x2b4>)
34009f60:	4293      	cmp	r3, r2
34009f62:	f200 80bd 	bhi.w	3400a0e0 <RCCEx_GetSAICLKFreq+0x264>
34009f66:	4a73      	ldr	r2, [pc, #460]	@ (3400a134 <RCCEx_GetSAICLKFreq+0x2b8>)
34009f68:	4293      	cmp	r3, r2
34009f6a:	d003      	beq.n	34009f74 <RCCEx_GetSAICLKFreq+0xf8>
34009f6c:	4a72      	ldr	r2, [pc, #456]	@ (3400a138 <RCCEx_GetSAICLKFreq+0x2bc>)
34009f6e:	4293      	cmp	r3, r2
34009f70:	f040 80b6 	bne.w	3400a0e0 <RCCEx_GetSAICLKFreq+0x264>
  {
    case LL_RCC_SAI1_CLKSOURCE_PCLK2:
    case LL_RCC_SAI2_CLKSOURCE_PCLK2:
      sai_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34009f74:	f7f9 fb78 	bl	34003668 <HAL_RCC_GetSysClockFreq>
34009f78:	4603      	mov	r3, r0
34009f7a:	4618      	mov	r0, r3
34009f7c:	f7fd ffda 	bl	34007f34 <RCCEx_GetHCLKFreq>
34009f80:	4603      	mov	r3, r0
34009f82:	4618      	mov	r0, r3
34009f84:	f7fd fff7 	bl	34007f76 <RCCEx_GetPCLK2Freq>
34009f88:	60f8      	str	r0, [r7, #12]
      break;
34009f8a:	e0b2      	b.n	3400a0f2 <RCCEx_GetSAICLKFreq+0x276>

    case LL_RCC_SAI1_CLKSOURCE_CLKP:
    case LL_RCC_SAI2_CLKSOURCE_CLKP:
      sai_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34009f8c:	2007      	movs	r0, #7
34009f8e:	f7fe fabd 	bl	3400850c <RCCEx_GetCLKPCLKFreq>
34009f92:	60f8      	str	r0, [r7, #12]
      break;
34009f94:	e0ad      	b.n	3400a0f2 <RCCEx_GetSAICLKFreq+0x276>

    case LL_RCC_SAI1_CLKSOURCE_IC7:
    case LL_RCC_SAI2_CLKSOURCE_IC7:
      if (LL_RCC_IC7_IsEnabled() != 0U)
34009f96:	f7fa fbe1 	bl	3400475c <LL_RCC_IC7_IsEnabled>
34009f9a:	4603      	mov	r3, r0
34009f9c:	2b00      	cmp	r3, #0
34009f9e:	f000 80a1 	beq.w	3400a0e4 <RCCEx_GetSAICLKFreq+0x268>
      {
        ic_divider = LL_RCC_IC7_GetDivider();
34009fa2:	f7fa fbfd 	bl	340047a0 <LL_RCC_IC7_GetDivider>
34009fa6:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC7_GetSource())
34009fa8:	f7fa fbec 	bl	34004784 <LL_RCC_IC7_GetSource>
34009fac:	4603      	mov	r3, r0
34009fae:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34009fb2:	d029      	beq.n	3400a008 <RCCEx_GetSAICLKFreq+0x18c>
34009fb4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34009fb8:	d82f      	bhi.n	3400a01a <RCCEx_GetSAICLKFreq+0x19e>
34009fba:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34009fbe:	d01a      	beq.n	34009ff6 <RCCEx_GetSAICLKFreq+0x17a>
34009fc0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34009fc4:	d829      	bhi.n	3400a01a <RCCEx_GetSAICLKFreq+0x19e>
34009fc6:	2b00      	cmp	r3, #0
34009fc8:	d003      	beq.n	34009fd2 <RCCEx_GetSAICLKFreq+0x156>
34009fca:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34009fce:	d009      	beq.n	34009fe4 <RCCEx_GetSAICLKFreq+0x168>
            sai_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            sai_frequency = sai_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34009fd0:	e023      	b.n	3400a01a <RCCEx_GetSAICLKFreq+0x19e>
            sai_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34009fd2:	f7fd fe97 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
34009fd6:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
34009fd8:	68fa      	ldr	r2, [r7, #12]
34009fda:	68bb      	ldr	r3, [r7, #8]
34009fdc:	fbb2 f3f3 	udiv	r3, r2, r3
34009fe0:	60fb      	str	r3, [r7, #12]
            break;
34009fe2:	e01b      	b.n	3400a01c <RCCEx_GetSAICLKFreq+0x1a0>
            sai_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34009fe4:	f7fd fed4 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
34009fe8:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
34009fea:	68fa      	ldr	r2, [r7, #12]
34009fec:	68bb      	ldr	r3, [r7, #8]
34009fee:	fbb2 f3f3 	udiv	r3, r2, r3
34009ff2:	60fb      	str	r3, [r7, #12]
            break;
34009ff4:	e012      	b.n	3400a01c <RCCEx_GetSAICLKFreq+0x1a0>
            sai_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34009ff6:	f7fd ff11 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
34009ffa:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
34009ffc:	68fa      	ldr	r2, [r7, #12]
34009ffe:	68bb      	ldr	r3, [r7, #8]
3400a000:	fbb2 f3f3 	udiv	r3, r2, r3
3400a004:	60fb      	str	r3, [r7, #12]
            break;
3400a006:	e009      	b.n	3400a01c <RCCEx_GetSAICLKFreq+0x1a0>
            sai_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400a008:	f7fd ff4e 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
3400a00c:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
3400a00e:	68fa      	ldr	r2, [r7, #12]
3400a010:	68bb      	ldr	r3, [r7, #8]
3400a012:	fbb2 f3f3 	udiv	r3, r2, r3
3400a016:	60fb      	str	r3, [r7, #12]
            break;
3400a018:	e000      	b.n	3400a01c <RCCEx_GetSAICLKFreq+0x1a0>
            break;
3400a01a:	bf00      	nop
        }
      }
      break;
3400a01c:	e062      	b.n	3400a0e4 <RCCEx_GetSAICLKFreq+0x268>

    case LL_RCC_SAI1_CLKSOURCE_IC8:
    case LL_RCC_SAI2_CLKSOURCE_IC8:
      if (LL_RCC_IC8_IsEnabled() != 0U)
3400a01e:	f7fa fbdd 	bl	340047dc <LL_RCC_IC8_IsEnabled>
3400a022:	4603      	mov	r3, r0
3400a024:	2b00      	cmp	r3, #0
3400a026:	d05f      	beq.n	3400a0e8 <RCCEx_GetSAICLKFreq+0x26c>
      {
        ic_divider = LL_RCC_IC8_GetDivider();
3400a028:	f7fa fbfa 	bl	34004820 <LL_RCC_IC8_GetDivider>
3400a02c:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
3400a02e:	f7fa fbe9 	bl	34004804 <LL_RCC_IC8_GetSource>
3400a032:	4603      	mov	r3, r0
3400a034:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400a038:	d029      	beq.n	3400a08e <RCCEx_GetSAICLKFreq+0x212>
3400a03a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400a03e:	d82f      	bhi.n	3400a0a0 <RCCEx_GetSAICLKFreq+0x224>
3400a040:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400a044:	d01a      	beq.n	3400a07c <RCCEx_GetSAICLKFreq+0x200>
3400a046:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400a04a:	d829      	bhi.n	3400a0a0 <RCCEx_GetSAICLKFreq+0x224>
3400a04c:	2b00      	cmp	r3, #0
3400a04e:	d003      	beq.n	3400a058 <RCCEx_GetSAICLKFreq+0x1dc>
3400a050:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400a054:	d009      	beq.n	3400a06a <RCCEx_GetSAICLKFreq+0x1ee>
            sai_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            sai_frequency = sai_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
3400a056:	e023      	b.n	3400a0a0 <RCCEx_GetSAICLKFreq+0x224>
            sai_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400a058:	f7fd fe54 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
3400a05c:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
3400a05e:	68fa      	ldr	r2, [r7, #12]
3400a060:	68bb      	ldr	r3, [r7, #8]
3400a062:	fbb2 f3f3 	udiv	r3, r2, r3
3400a066:	60fb      	str	r3, [r7, #12]
            break;
3400a068:	e01b      	b.n	3400a0a2 <RCCEx_GetSAICLKFreq+0x226>
            sai_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400a06a:	f7fd fe91 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
3400a06e:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
3400a070:	68fa      	ldr	r2, [r7, #12]
3400a072:	68bb      	ldr	r3, [r7, #8]
3400a074:	fbb2 f3f3 	udiv	r3, r2, r3
3400a078:	60fb      	str	r3, [r7, #12]
            break;
3400a07a:	e012      	b.n	3400a0a2 <RCCEx_GetSAICLKFreq+0x226>
            sai_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400a07c:	f7fd fece 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
3400a080:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
3400a082:	68fa      	ldr	r2, [r7, #12]
3400a084:	68bb      	ldr	r3, [r7, #8]
3400a086:	fbb2 f3f3 	udiv	r3, r2, r3
3400a08a:	60fb      	str	r3, [r7, #12]
            break;
3400a08c:	e009      	b.n	3400a0a2 <RCCEx_GetSAICLKFreq+0x226>
            sai_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400a08e:	f7fd ff0b 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
3400a092:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
3400a094:	68fa      	ldr	r2, [r7, #12]
3400a096:	68bb      	ldr	r3, [r7, #8]
3400a098:	fbb2 f3f3 	udiv	r3, r2, r3
3400a09c:	60fb      	str	r3, [r7, #12]
            break;
3400a09e:	e000      	b.n	3400a0a2 <RCCEx_GetSAICLKFreq+0x226>
            break;
3400a0a0:	bf00      	nop
        }
      }
      break;
3400a0a2:	e021      	b.n	3400a0e8 <RCCEx_GetSAICLKFreq+0x26c>

    case LL_RCC_SAI1_CLKSOURCE_HSI:
    case LL_RCC_SAI2_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
3400a0a4:	f7f9 fbb6 	bl	34003814 <LL_RCC_HSI_IsReady>
3400a0a8:	4603      	mov	r3, r0
3400a0aa:	2b00      	cmp	r3, #0
3400a0ac:	d01e      	beq.n	3400a0ec <RCCEx_GetSAICLKFreq+0x270>
      {
        sai_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400a0ae:	f7f9 fbc3 	bl	34003838 <LL_RCC_HSI_GetDivider>
3400a0b2:	4603      	mov	r3, r0
3400a0b4:	09db      	lsrs	r3, r3, #7
3400a0b6:	4a21      	ldr	r2, [pc, #132]	@ (3400a13c <RCCEx_GetSAICLKFreq+0x2c0>)
3400a0b8:	fa22 f303 	lsr.w	r3, r2, r3
3400a0bc:	60fb      	str	r3, [r7, #12]
      }
      break;
3400a0be:	e015      	b.n	3400a0ec <RCCEx_GetSAICLKFreq+0x270>

    case LL_RCC_SAI1_CLKSOURCE_MSI:
    case LL_RCC_SAI2_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
3400a0c0:	f7f9 fbc8 	bl	34003854 <LL_RCC_MSI_IsReady>
3400a0c4:	4603      	mov	r3, r0
3400a0c6:	2b00      	cmp	r3, #0
3400a0c8:	d012      	beq.n	3400a0f0 <RCCEx_GetSAICLKFreq+0x274>
      {
        sai_frequency = MSI_VALUE;
3400a0ca:	4b1d      	ldr	r3, [pc, #116]	@ (3400a140 <RCCEx_GetSAICLKFreq+0x2c4>)
3400a0cc:	60fb      	str	r3, [r7, #12]
      }
      break;
3400a0ce:	e00f      	b.n	3400a0f0 <RCCEx_GetSAICLKFreq+0x274>

    case LL_RCC_SAI1_CLKSOURCE_I2S_CKIN:
    case LL_RCC_SAI2_CLKSOURCE_I2S_CKIN:
      sai_frequency = EXTERNAL_CLOCK_VALUE;
3400a0d0:	4b1c      	ldr	r3, [pc, #112]	@ (3400a144 <RCCEx_GetSAICLKFreq+0x2c8>)
3400a0d2:	60fb      	str	r3, [r7, #12]
      break;
3400a0d4:	e00d      	b.n	3400a0f2 <RCCEx_GetSAICLKFreq+0x276>

    case LL_RCC_SAI1_CLKSOURCE_SPDIFRX1:
    case LL_RCC_SAI2_CLKSOURCE_SPDIFRX1:
      sai_frequency = RCCEx_GetSPDIFRXCLKFreq(LL_RCC_SPDIFRX1_CLKSOURCE);
3400a0d6:	2007      	movs	r0, #7
3400a0d8:	f000 f920 	bl	3400a31c <RCCEx_GetSPDIFRXCLKFreq>
3400a0dc:	60f8      	str	r0, [r7, #12]
      break;
3400a0de:	e008      	b.n	3400a0f2 <RCCEx_GetSAICLKFreq+0x276>

    default:
      /* Unexpected case */
      break;
3400a0e0:	bf00      	nop
3400a0e2:	e006      	b.n	3400a0f2 <RCCEx_GetSAICLKFreq+0x276>
      break;
3400a0e4:	bf00      	nop
3400a0e6:	e004      	b.n	3400a0f2 <RCCEx_GetSAICLKFreq+0x276>
      break;
3400a0e8:	bf00      	nop
3400a0ea:	e002      	b.n	3400a0f2 <RCCEx_GetSAICLKFreq+0x276>
      break;
3400a0ec:	bf00      	nop
3400a0ee:	e000      	b.n	3400a0f2 <RCCEx_GetSAICLKFreq+0x276>
      break;
3400a0f0:	bf00      	nop
  }

  return sai_frequency;
3400a0f2:	68fb      	ldr	r3, [r7, #12]
}
3400a0f4:	4618      	mov	r0, r3
3400a0f6:	3710      	adds	r7, #16
3400a0f8:	46bd      	mov	sp, r7
3400a0fa:	bd80      	pop	{r7, pc}
3400a0fc:	07071818 	.word	0x07071818
3400a100:	07071418 	.word	0x07071418
3400a104:	07061818 	.word	0x07061818
3400a108:	07061418 	.word	0x07061418
3400a10c:	07051818 	.word	0x07051818
3400a110:	07051418 	.word	0x07051418
3400a114:	07041818 	.word	0x07041818
3400a118:	07041418 	.word	0x07041418
3400a11c:	07031818 	.word	0x07031818
3400a120:	07031418 	.word	0x07031418
3400a124:	07021818 	.word	0x07021818
3400a128:	07021418 	.word	0x07021418
3400a12c:	07011818 	.word	0x07011818
3400a130:	07011418 	.word	0x07011418
3400a134:	07001418 	.word	0x07001418
3400a138:	07001818 	.word	0x07001818
3400a13c:	03d09000 	.word	0x03d09000
3400a140:	003d0900 	.word	0x003d0900
3400a144:	00bb8000 	.word	0x00bb8000

3400a148 <RCCEx_GetSDMMCCLKFreq>:
  *         @arg @ref RCCEx_SDMMC2_Clock_Source
  * @retval SDMMC clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetSDMMCCLKFreq(uint32_t SDMMCxSource)
{
3400a148:	b580      	push	{r7, lr}
3400a14a:	b084      	sub	sp, #16
3400a14c:	af00      	add	r7, sp, #0
3400a14e:	6078      	str	r0, [r7, #4]
  uint32_t sdmmc_frequency = RCC_PERIPH_FREQUENCY_NO;
3400a150:	2300      	movs	r3, #0
3400a152:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetSDMMCClockSource(SDMMCxSource))
3400a154:	6878      	ldr	r0, [r7, #4]
3400a156:	f7f9 ff1b 	bl	34003f90 <LL_RCC_GetSDMMCClockSource>
3400a15a:	4603      	mov	r3, r0
3400a15c:	4a67      	ldr	r2, [pc, #412]	@ (3400a2fc <RCCEx_GetSDMMCCLKFreq+0x1b4>)
3400a15e:	4293      	cmp	r3, r2
3400a160:	d07e      	beq.n	3400a260 <RCCEx_GetSDMMCCLKFreq+0x118>
3400a162:	4a66      	ldr	r2, [pc, #408]	@ (3400a2fc <RCCEx_GetSDMMCCLKFreq+0x1b4>)
3400a164:	4293      	cmp	r3, r2
3400a166:	f200 80be 	bhi.w	3400a2e6 <RCCEx_GetSDMMCCLKFreq+0x19e>
3400a16a:	4a65      	ldr	r2, [pc, #404]	@ (3400a300 <RCCEx_GetSDMMCCLKFreq+0x1b8>)
3400a16c:	4293      	cmp	r3, r2
3400a16e:	d077      	beq.n	3400a260 <RCCEx_GetSDMMCCLKFreq+0x118>
3400a170:	4a63      	ldr	r2, [pc, #396]	@ (3400a300 <RCCEx_GetSDMMCCLKFreq+0x1b8>)
3400a172:	4293      	cmp	r3, r2
3400a174:	f200 80b7 	bhi.w	3400a2e6 <RCCEx_GetSDMMCCLKFreq+0x19e>
3400a178:	4a62      	ldr	r2, [pc, #392]	@ (3400a304 <RCCEx_GetSDMMCCLKFreq+0x1bc>)
3400a17a:	4293      	cmp	r3, r2
3400a17c:	d02c      	beq.n	3400a1d8 <RCCEx_GetSDMMCCLKFreq+0x90>
3400a17e:	4a61      	ldr	r2, [pc, #388]	@ (3400a304 <RCCEx_GetSDMMCCLKFreq+0x1bc>)
3400a180:	4293      	cmp	r3, r2
3400a182:	f200 80b0 	bhi.w	3400a2e6 <RCCEx_GetSDMMCCLKFreq+0x19e>
3400a186:	4a60      	ldr	r2, [pc, #384]	@ (3400a308 <RCCEx_GetSDMMCCLKFreq+0x1c0>)
3400a188:	4293      	cmp	r3, r2
3400a18a:	d025      	beq.n	3400a1d8 <RCCEx_GetSDMMCCLKFreq+0x90>
3400a18c:	4a5e      	ldr	r2, [pc, #376]	@ (3400a308 <RCCEx_GetSDMMCCLKFreq+0x1c0>)
3400a18e:	4293      	cmp	r3, r2
3400a190:	f200 80a9 	bhi.w	3400a2e6 <RCCEx_GetSDMMCCLKFreq+0x19e>
3400a194:	4a5d      	ldr	r2, [pc, #372]	@ (3400a30c <RCCEx_GetSDMMCCLKFreq+0x1c4>)
3400a196:	4293      	cmp	r3, r2
3400a198:	d019      	beq.n	3400a1ce <RCCEx_GetSDMMCCLKFreq+0x86>
3400a19a:	4a5c      	ldr	r2, [pc, #368]	@ (3400a30c <RCCEx_GetSDMMCCLKFreq+0x1c4>)
3400a19c:	4293      	cmp	r3, r2
3400a19e:	f200 80a2 	bhi.w	3400a2e6 <RCCEx_GetSDMMCCLKFreq+0x19e>
3400a1a2:	4a5b      	ldr	r2, [pc, #364]	@ (3400a310 <RCCEx_GetSDMMCCLKFreq+0x1c8>)
3400a1a4:	4293      	cmp	r3, r2
3400a1a6:	d012      	beq.n	3400a1ce <RCCEx_GetSDMMCCLKFreq+0x86>
3400a1a8:	4a59      	ldr	r2, [pc, #356]	@ (3400a310 <RCCEx_GetSDMMCCLKFreq+0x1c8>)
3400a1aa:	4293      	cmp	r3, r2
3400a1ac:	f200 809b 	bhi.w	3400a2e6 <RCCEx_GetSDMMCCLKFreq+0x19e>
3400a1b0:	4a58      	ldr	r2, [pc, #352]	@ (3400a314 <RCCEx_GetSDMMCCLKFreq+0x1cc>)
3400a1b2:	4293      	cmp	r3, r2
3400a1b4:	d003      	beq.n	3400a1be <RCCEx_GetSDMMCCLKFreq+0x76>
3400a1b6:	4a58      	ldr	r2, [pc, #352]	@ (3400a318 <RCCEx_GetSDMMCCLKFreq+0x1d0>)
3400a1b8:	4293      	cmp	r3, r2
3400a1ba:	f040 8094 	bne.w	3400a2e6 <RCCEx_GetSDMMCCLKFreq+0x19e>
  {
    case LL_RCC_SDMMC1_CLKSOURCE_HCLK:
    case LL_RCC_SDMMC2_CLKSOURCE_HCLK:
      sdmmc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3400a1be:	f7f9 fa53 	bl	34003668 <HAL_RCC_GetSysClockFreq>
3400a1c2:	4603      	mov	r3, r0
3400a1c4:	4618      	mov	r0, r3
3400a1c6:	f7fd feb5 	bl	34007f34 <RCCEx_GetHCLKFreq>
3400a1ca:	60f8      	str	r0, [r7, #12]
      break;
3400a1cc:	e090      	b.n	3400a2f0 <RCCEx_GetSDMMCCLKFreq+0x1a8>

    case LL_RCC_SDMMC1_CLKSOURCE_CLKP:
    case LL_RCC_SDMMC2_CLKSOURCE_CLKP:
      sdmmc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400a1ce:	2007      	movs	r0, #7
3400a1d0:	f7fe f99c 	bl	3400850c <RCCEx_GetCLKPCLKFreq>
3400a1d4:	60f8      	str	r0, [r7, #12]
      break;
3400a1d6:	e08b      	b.n	3400a2f0 <RCCEx_GetSDMMCCLKFreq+0x1a8>

    case LL_RCC_SDMMC1_CLKSOURCE_IC4:
    case LL_RCC_SDMMC2_CLKSOURCE_IC4:
      if (LL_RCC_IC4_IsEnabled() != 0U)
3400a1d8:	f7fa fa40 	bl	3400465c <LL_RCC_IC4_IsEnabled>
3400a1dc:	4603      	mov	r3, r0
3400a1de:	2b00      	cmp	r3, #0
3400a1e0:	f000 8083 	beq.w	3400a2ea <RCCEx_GetSDMMCCLKFreq+0x1a2>
      {
        ic_divider = LL_RCC_IC4_GetDivider();
3400a1e4:	f7fa fa5c 	bl	340046a0 <LL_RCC_IC4_GetDivider>
3400a1e8:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC4_GetSource())
3400a1ea:	f7fa fa4b 	bl	34004684 <LL_RCC_IC4_GetSource>
3400a1ee:	4603      	mov	r3, r0
3400a1f0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400a1f4:	d029      	beq.n	3400a24a <RCCEx_GetSDMMCCLKFreq+0x102>
3400a1f6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400a1fa:	d82f      	bhi.n	3400a25c <RCCEx_GetSDMMCCLKFreq+0x114>
3400a1fc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400a200:	d01a      	beq.n	3400a238 <RCCEx_GetSDMMCCLKFreq+0xf0>
3400a202:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400a206:	d829      	bhi.n	3400a25c <RCCEx_GetSDMMCCLKFreq+0x114>
3400a208:	2b00      	cmp	r3, #0
3400a20a:	d003      	beq.n	3400a214 <RCCEx_GetSDMMCCLKFreq+0xcc>
3400a20c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400a210:	d009      	beq.n	3400a226 <RCCEx_GetSDMMCCLKFreq+0xde>
            sdmmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            sdmmc_frequency = sdmmc_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
3400a212:	e023      	b.n	3400a25c <RCCEx_GetSDMMCCLKFreq+0x114>
            sdmmc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400a214:	f7fd fd76 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
3400a218:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
3400a21a:	68fa      	ldr	r2, [r7, #12]
3400a21c:	68bb      	ldr	r3, [r7, #8]
3400a21e:	fbb2 f3f3 	udiv	r3, r2, r3
3400a222:	60fb      	str	r3, [r7, #12]
            break;
3400a224:	e01b      	b.n	3400a25e <RCCEx_GetSDMMCCLKFreq+0x116>
            sdmmc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400a226:	f7fd fdb3 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
3400a22a:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
3400a22c:	68fa      	ldr	r2, [r7, #12]
3400a22e:	68bb      	ldr	r3, [r7, #8]
3400a230:	fbb2 f3f3 	udiv	r3, r2, r3
3400a234:	60fb      	str	r3, [r7, #12]
            break;
3400a236:	e012      	b.n	3400a25e <RCCEx_GetSDMMCCLKFreq+0x116>
            sdmmc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400a238:	f7fd fdf0 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
3400a23c:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
3400a23e:	68fa      	ldr	r2, [r7, #12]
3400a240:	68bb      	ldr	r3, [r7, #8]
3400a242:	fbb2 f3f3 	udiv	r3, r2, r3
3400a246:	60fb      	str	r3, [r7, #12]
            break;
3400a248:	e009      	b.n	3400a25e <RCCEx_GetSDMMCCLKFreq+0x116>
            sdmmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400a24a:	f7fd fe2d 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
3400a24e:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
3400a250:	68fa      	ldr	r2, [r7, #12]
3400a252:	68bb      	ldr	r3, [r7, #8]
3400a254:	fbb2 f3f3 	udiv	r3, r2, r3
3400a258:	60fb      	str	r3, [r7, #12]
            break;
3400a25a:	e000      	b.n	3400a25e <RCCEx_GetSDMMCCLKFreq+0x116>
            break;
3400a25c:	bf00      	nop
        }
      }
      break;
3400a25e:	e044      	b.n	3400a2ea <RCCEx_GetSDMMCCLKFreq+0x1a2>

    case LL_RCC_SDMMC1_CLKSOURCE_IC5:
    case LL_RCC_SDMMC2_CLKSOURCE_IC5:
      if (LL_RCC_IC5_IsEnabled() != 0U)
3400a260:	f7fa fa3c 	bl	340046dc <LL_RCC_IC5_IsEnabled>
3400a264:	4603      	mov	r3, r0
3400a266:	2b00      	cmp	r3, #0
3400a268:	d041      	beq.n	3400a2ee <RCCEx_GetSDMMCCLKFreq+0x1a6>
      {
        ic_divider = LL_RCC_IC5_GetDivider();
3400a26a:	f7fa fa59 	bl	34004720 <LL_RCC_IC5_GetDivider>
3400a26e:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC5_GetSource())
3400a270:	f7fa fa48 	bl	34004704 <LL_RCC_IC5_GetSource>
3400a274:	4603      	mov	r3, r0
3400a276:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400a27a:	d029      	beq.n	3400a2d0 <RCCEx_GetSDMMCCLKFreq+0x188>
3400a27c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400a280:	d82f      	bhi.n	3400a2e2 <RCCEx_GetSDMMCCLKFreq+0x19a>
3400a282:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400a286:	d01a      	beq.n	3400a2be <RCCEx_GetSDMMCCLKFreq+0x176>
3400a288:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400a28c:	d829      	bhi.n	3400a2e2 <RCCEx_GetSDMMCCLKFreq+0x19a>
3400a28e:	2b00      	cmp	r3, #0
3400a290:	d003      	beq.n	3400a29a <RCCEx_GetSDMMCCLKFreq+0x152>
3400a292:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400a296:	d009      	beq.n	3400a2ac <RCCEx_GetSDMMCCLKFreq+0x164>
            sdmmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            sdmmc_frequency = sdmmc_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
3400a298:	e023      	b.n	3400a2e2 <RCCEx_GetSDMMCCLKFreq+0x19a>
            sdmmc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400a29a:	f7fd fd33 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
3400a29e:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
3400a2a0:	68fa      	ldr	r2, [r7, #12]
3400a2a2:	68bb      	ldr	r3, [r7, #8]
3400a2a4:	fbb2 f3f3 	udiv	r3, r2, r3
3400a2a8:	60fb      	str	r3, [r7, #12]
            break;
3400a2aa:	e01b      	b.n	3400a2e4 <RCCEx_GetSDMMCCLKFreq+0x19c>
            sdmmc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400a2ac:	f7fd fd70 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
3400a2b0:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
3400a2b2:	68fa      	ldr	r2, [r7, #12]
3400a2b4:	68bb      	ldr	r3, [r7, #8]
3400a2b6:	fbb2 f3f3 	udiv	r3, r2, r3
3400a2ba:	60fb      	str	r3, [r7, #12]
            break;
3400a2bc:	e012      	b.n	3400a2e4 <RCCEx_GetSDMMCCLKFreq+0x19c>
            sdmmc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400a2be:	f7fd fdad 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
3400a2c2:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
3400a2c4:	68fa      	ldr	r2, [r7, #12]
3400a2c6:	68bb      	ldr	r3, [r7, #8]
3400a2c8:	fbb2 f3f3 	udiv	r3, r2, r3
3400a2cc:	60fb      	str	r3, [r7, #12]
            break;
3400a2ce:	e009      	b.n	3400a2e4 <RCCEx_GetSDMMCCLKFreq+0x19c>
            sdmmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400a2d0:	f7fd fdea 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
3400a2d4:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
3400a2d6:	68fa      	ldr	r2, [r7, #12]
3400a2d8:	68bb      	ldr	r3, [r7, #8]
3400a2da:	fbb2 f3f3 	udiv	r3, r2, r3
3400a2de:	60fb      	str	r3, [r7, #12]
            break;
3400a2e0:	e000      	b.n	3400a2e4 <RCCEx_GetSDMMCCLKFreq+0x19c>
            break;
3400a2e2:	bf00      	nop
        }
      }
      break;
3400a2e4:	e003      	b.n	3400a2ee <RCCEx_GetSDMMCCLKFreq+0x1a6>

    default:
      /* Unexpected case */
      break;
3400a2e6:	bf00      	nop
3400a2e8:	e002      	b.n	3400a2f0 <RCCEx_GetSDMMCCLKFreq+0x1a8>
      break;
3400a2ea:	bf00      	nop
3400a2ec:	e000      	b.n	3400a2f0 <RCCEx_GetSDMMCCLKFreq+0x1a8>
      break;
3400a2ee:	bf00      	nop
  }

  return sdmmc_frequency;
3400a2f0:	68fb      	ldr	r3, [r7, #12]
}
3400a2f2:	4618      	mov	r0, r3
3400a2f4:	3710      	adds	r7, #16
3400a2f6:	46bd      	mov	sp, r7
3400a2f8:	bd80      	pop	{r7, pc}
3400a2fa:	bf00      	nop
3400a2fc:	0303041c 	.word	0x0303041c
3400a300:	0303001c 	.word	0x0303001c
3400a304:	0302041c 	.word	0x0302041c
3400a308:	0302001c 	.word	0x0302001c
3400a30c:	0301041c 	.word	0x0301041c
3400a310:	0301001c 	.word	0x0301001c
3400a314:	0300001c 	.word	0x0300001c
3400a318:	0300041c 	.word	0x0300041c

3400a31c <RCCEx_GetSPDIFRXCLKFreq>:
  *         @arg @ref RCCEx_SPDIFRX1_Clock_Source
  * @retval SPDIF clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetSPDIFRXCLKFreq(uint32_t SPDIFRXxSource)
{
3400a31c:	b580      	push	{r7, lr}
3400a31e:	b084      	sub	sp, #16
3400a320:	af00      	add	r7, sp, #0
3400a322:	6078      	str	r0, [r7, #4]
  uint32_t spdifrx_frequency = RCC_PERIPH_FREQUENCY_NO;
3400a324:	2300      	movs	r3, #0
3400a326:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetSPDIFRXClockSource(SPDIFRXxSource))
3400a328:	6878      	ldr	r0, [r7, #4]
3400a32a:	f7f9 fe3d 	bl	34003fa8 <LL_RCC_GetSPDIFRXClockSource>
3400a32e:	4603      	mov	r3, r0
3400a330:	2b06      	cmp	r3, #6
3400a332:	f200 80c2 	bhi.w	3400a4ba <RCCEx_GetSPDIFRXCLKFreq+0x19e>
3400a336:	a201      	add	r2, pc, #4	@ (adr r2, 3400a33c <RCCEx_GetSPDIFRXCLKFreq+0x20>)
3400a338:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3400a33c:	3400a359 	.word	0x3400a359
3400a340:	3400a371 	.word	0x3400a371
3400a344:	3400a37b 	.word	0x3400a37b
3400a348:	3400a403 	.word	0x3400a403
3400a34c:	3400a4a5 	.word	0x3400a4a5
3400a350:	3400a489 	.word	0x3400a489
3400a354:	3400a4b5 	.word	0x3400a4b5
  {
    case LL_RCC_SPDIFRX1_CLKSOURCE_PCLK1:
      spdifrx_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400a358:	f7f9 f986 	bl	34003668 <HAL_RCC_GetSysClockFreq>
3400a35c:	4603      	mov	r3, r0
3400a35e:	4618      	mov	r0, r3
3400a360:	f7fd fde8 	bl	34007f34 <RCCEx_GetHCLKFreq>
3400a364:	4603      	mov	r3, r0
3400a366:	4618      	mov	r0, r3
3400a368:	f7fd fdf5 	bl	34007f56 <RCCEx_GetPCLK1Freq>
3400a36c:	60f8      	str	r0, [r7, #12]
      break;
3400a36e:	e0ad      	b.n	3400a4cc <RCCEx_GetSPDIFRXCLKFreq+0x1b0>

    case LL_RCC_SPDIFRX1_CLKSOURCE_CLKP:
      spdifrx_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400a370:	2007      	movs	r0, #7
3400a372:	f7fe f8cb 	bl	3400850c <RCCEx_GetCLKPCLKFreq>
3400a376:	60f8      	str	r0, [r7, #12]
      break;
3400a378:	e0a8      	b.n	3400a4cc <RCCEx_GetSPDIFRXCLKFreq+0x1b0>

    case LL_RCC_SPDIFRX1_CLKSOURCE_IC7:
      if (LL_RCC_IC7_IsEnabled() != 0U)
3400a37a:	f7fa f9ef 	bl	3400475c <LL_RCC_IC7_IsEnabled>
3400a37e:	4603      	mov	r3, r0
3400a380:	2b00      	cmp	r3, #0
3400a382:	f000 809c 	beq.w	3400a4be <RCCEx_GetSPDIFRXCLKFreq+0x1a2>
      {
        ic_divider = LL_RCC_IC7_GetDivider();
3400a386:	f7fa fa0b 	bl	340047a0 <LL_RCC_IC7_GetDivider>
3400a38a:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC7_GetSource())
3400a38c:	f7fa f9fa 	bl	34004784 <LL_RCC_IC7_GetSource>
3400a390:	4603      	mov	r3, r0
3400a392:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400a396:	d029      	beq.n	3400a3ec <RCCEx_GetSPDIFRXCLKFreq+0xd0>
3400a398:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400a39c:	d82f      	bhi.n	3400a3fe <RCCEx_GetSPDIFRXCLKFreq+0xe2>
3400a39e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400a3a2:	d01a      	beq.n	3400a3da <RCCEx_GetSPDIFRXCLKFreq+0xbe>
3400a3a4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400a3a8:	d829      	bhi.n	3400a3fe <RCCEx_GetSPDIFRXCLKFreq+0xe2>
3400a3aa:	2b00      	cmp	r3, #0
3400a3ac:	d003      	beq.n	3400a3b6 <RCCEx_GetSPDIFRXCLKFreq+0x9a>
3400a3ae:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400a3b2:	d009      	beq.n	3400a3c8 <RCCEx_GetSPDIFRXCLKFreq+0xac>
            spdifrx_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            spdifrx_frequency = spdifrx_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
3400a3b4:	e023      	b.n	3400a3fe <RCCEx_GetSPDIFRXCLKFreq+0xe2>
            spdifrx_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400a3b6:	f7fd fca5 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
3400a3ba:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
3400a3bc:	68fa      	ldr	r2, [r7, #12]
3400a3be:	68bb      	ldr	r3, [r7, #8]
3400a3c0:	fbb2 f3f3 	udiv	r3, r2, r3
3400a3c4:	60fb      	str	r3, [r7, #12]
            break;
3400a3c6:	e01b      	b.n	3400a400 <RCCEx_GetSPDIFRXCLKFreq+0xe4>
            spdifrx_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400a3c8:	f7fd fce2 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
3400a3cc:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
3400a3ce:	68fa      	ldr	r2, [r7, #12]
3400a3d0:	68bb      	ldr	r3, [r7, #8]
3400a3d2:	fbb2 f3f3 	udiv	r3, r2, r3
3400a3d6:	60fb      	str	r3, [r7, #12]
            break;
3400a3d8:	e012      	b.n	3400a400 <RCCEx_GetSPDIFRXCLKFreq+0xe4>
            spdifrx_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400a3da:	f7fd fd1f 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
3400a3de:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
3400a3e0:	68fa      	ldr	r2, [r7, #12]
3400a3e2:	68bb      	ldr	r3, [r7, #8]
3400a3e4:	fbb2 f3f3 	udiv	r3, r2, r3
3400a3e8:	60fb      	str	r3, [r7, #12]
            break;
3400a3ea:	e009      	b.n	3400a400 <RCCEx_GetSPDIFRXCLKFreq+0xe4>
            spdifrx_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400a3ec:	f7fd fd5c 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
3400a3f0:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
3400a3f2:	68fa      	ldr	r2, [r7, #12]
3400a3f4:	68bb      	ldr	r3, [r7, #8]
3400a3f6:	fbb2 f3f3 	udiv	r3, r2, r3
3400a3fa:	60fb      	str	r3, [r7, #12]
            break;
3400a3fc:	e000      	b.n	3400a400 <RCCEx_GetSPDIFRXCLKFreq+0xe4>
            break;
3400a3fe:	bf00      	nop
        }
      }
      break;
3400a400:	e05d      	b.n	3400a4be <RCCEx_GetSPDIFRXCLKFreq+0x1a2>

    case LL_RCC_SPDIFRX1_CLKSOURCE_IC8:
      if (LL_RCC_IC8_IsEnabled() != 0U)
3400a402:	f7fa f9eb 	bl	340047dc <LL_RCC_IC8_IsEnabled>
3400a406:	4603      	mov	r3, r0
3400a408:	2b00      	cmp	r3, #0
3400a40a:	d05a      	beq.n	3400a4c2 <RCCEx_GetSPDIFRXCLKFreq+0x1a6>
      {
        ic_divider = LL_RCC_IC8_GetDivider();
3400a40c:	f7fa fa08 	bl	34004820 <LL_RCC_IC8_GetDivider>
3400a410:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
3400a412:	f7fa f9f7 	bl	34004804 <LL_RCC_IC8_GetSource>
3400a416:	4603      	mov	r3, r0
3400a418:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400a41c:	d029      	beq.n	3400a472 <RCCEx_GetSPDIFRXCLKFreq+0x156>
3400a41e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400a422:	d82f      	bhi.n	3400a484 <RCCEx_GetSPDIFRXCLKFreq+0x168>
3400a424:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400a428:	d01a      	beq.n	3400a460 <RCCEx_GetSPDIFRXCLKFreq+0x144>
3400a42a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400a42e:	d829      	bhi.n	3400a484 <RCCEx_GetSPDIFRXCLKFreq+0x168>
3400a430:	2b00      	cmp	r3, #0
3400a432:	d003      	beq.n	3400a43c <RCCEx_GetSPDIFRXCLKFreq+0x120>
3400a434:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400a438:	d009      	beq.n	3400a44e <RCCEx_GetSPDIFRXCLKFreq+0x132>
            spdifrx_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            spdifrx_frequency = spdifrx_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
3400a43a:	e023      	b.n	3400a484 <RCCEx_GetSPDIFRXCLKFreq+0x168>
            spdifrx_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400a43c:	f7fd fc62 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
3400a440:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
3400a442:	68fa      	ldr	r2, [r7, #12]
3400a444:	68bb      	ldr	r3, [r7, #8]
3400a446:	fbb2 f3f3 	udiv	r3, r2, r3
3400a44a:	60fb      	str	r3, [r7, #12]
            break;
3400a44c:	e01b      	b.n	3400a486 <RCCEx_GetSPDIFRXCLKFreq+0x16a>
            spdifrx_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400a44e:	f7fd fc9f 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
3400a452:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
3400a454:	68fa      	ldr	r2, [r7, #12]
3400a456:	68bb      	ldr	r3, [r7, #8]
3400a458:	fbb2 f3f3 	udiv	r3, r2, r3
3400a45c:	60fb      	str	r3, [r7, #12]
            break;
3400a45e:	e012      	b.n	3400a486 <RCCEx_GetSPDIFRXCLKFreq+0x16a>
            spdifrx_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400a460:	f7fd fcdc 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
3400a464:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
3400a466:	68fa      	ldr	r2, [r7, #12]
3400a468:	68bb      	ldr	r3, [r7, #8]
3400a46a:	fbb2 f3f3 	udiv	r3, r2, r3
3400a46e:	60fb      	str	r3, [r7, #12]
            break;
3400a470:	e009      	b.n	3400a486 <RCCEx_GetSPDIFRXCLKFreq+0x16a>
            spdifrx_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400a472:	f7fd fd19 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
3400a476:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
3400a478:	68fa      	ldr	r2, [r7, #12]
3400a47a:	68bb      	ldr	r3, [r7, #8]
3400a47c:	fbb2 f3f3 	udiv	r3, r2, r3
3400a480:	60fb      	str	r3, [r7, #12]
            break;
3400a482:	e000      	b.n	3400a486 <RCCEx_GetSPDIFRXCLKFreq+0x16a>
            break;
3400a484:	bf00      	nop
        }
      }
      break;
3400a486:	e01c      	b.n	3400a4c2 <RCCEx_GetSPDIFRXCLKFreq+0x1a6>

    case LL_RCC_SPDIFRX1_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
3400a488:	f7f9 f9c4 	bl	34003814 <LL_RCC_HSI_IsReady>
3400a48c:	4603      	mov	r3, r0
3400a48e:	2b00      	cmp	r3, #0
3400a490:	d019      	beq.n	3400a4c6 <RCCEx_GetSPDIFRXCLKFreq+0x1aa>
      {
        spdifrx_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400a492:	f7f9 f9d1 	bl	34003838 <LL_RCC_HSI_GetDivider>
3400a496:	4603      	mov	r3, r0
3400a498:	09db      	lsrs	r3, r3, #7
3400a49a:	4a0f      	ldr	r2, [pc, #60]	@ (3400a4d8 <RCCEx_GetSPDIFRXCLKFreq+0x1bc>)
3400a49c:	fa22 f303 	lsr.w	r3, r2, r3
3400a4a0:	60fb      	str	r3, [r7, #12]
      }
      break;
3400a4a2:	e010      	b.n	3400a4c6 <RCCEx_GetSPDIFRXCLKFreq+0x1aa>

    case LL_RCC_SPDIFRX1_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
3400a4a4:	f7f9 f9d6 	bl	34003854 <LL_RCC_MSI_IsReady>
3400a4a8:	4603      	mov	r3, r0
3400a4aa:	2b00      	cmp	r3, #0
3400a4ac:	d00d      	beq.n	3400a4ca <RCCEx_GetSPDIFRXCLKFreq+0x1ae>
      {
        spdifrx_frequency = MSI_VALUE;
3400a4ae:	4b0b      	ldr	r3, [pc, #44]	@ (3400a4dc <RCCEx_GetSPDIFRXCLKFreq+0x1c0>)
3400a4b0:	60fb      	str	r3, [r7, #12]
      }
      break;
3400a4b2:	e00a      	b.n	3400a4ca <RCCEx_GetSPDIFRXCLKFreq+0x1ae>

    case LL_RCC_SPDIFRX1_CLKSOURCE_I2S_CKIN:
      spdifrx_frequency = EXTERNAL_CLOCK_VALUE;
3400a4b4:	4b0a      	ldr	r3, [pc, #40]	@ (3400a4e0 <RCCEx_GetSPDIFRXCLKFreq+0x1c4>)
3400a4b6:	60fb      	str	r3, [r7, #12]
      break;
3400a4b8:	e008      	b.n	3400a4cc <RCCEx_GetSPDIFRXCLKFreq+0x1b0>

    default:
      /* Unexpected case */
      break;
3400a4ba:	bf00      	nop
3400a4bc:	e006      	b.n	3400a4cc <RCCEx_GetSPDIFRXCLKFreq+0x1b0>
      break;
3400a4be:	bf00      	nop
3400a4c0:	e004      	b.n	3400a4cc <RCCEx_GetSPDIFRXCLKFreq+0x1b0>
      break;
3400a4c2:	bf00      	nop
3400a4c4:	e002      	b.n	3400a4cc <RCCEx_GetSPDIFRXCLKFreq+0x1b0>
      break;
3400a4c6:	bf00      	nop
3400a4c8:	e000      	b.n	3400a4cc <RCCEx_GetSPDIFRXCLKFreq+0x1b0>
      break;
3400a4ca:	bf00      	nop
  }

  return spdifrx_frequency;
3400a4cc:	68fb      	ldr	r3, [r7, #12]
}
3400a4ce:	4618      	mov	r0, r3
3400a4d0:	3710      	adds	r7, #16
3400a4d2:	46bd      	mov	sp, r7
3400a4d4:	bd80      	pop	{r7, pc}
3400a4d6:	bf00      	nop
3400a4d8:	03d09000 	.word	0x03d09000
3400a4dc:	003d0900 	.word	0x003d0900
3400a4e0:	00bb8000 	.word	0x00bb8000

3400a4e4 <RCCEx_GetSPICLKFreq>:
  *         @arg @ref RCCEx_SPI6_Clock_Source
  * @retval SPI clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetSPICLKFreq(uint32_t SPIxSource)
{
3400a4e4:	b580      	push	{r7, lr}
3400a4e6:	b084      	sub	sp, #16
3400a4e8:	af00      	add	r7, sp, #0
3400a4ea:	6078      	str	r0, [r7, #4]
  uint32_t spi_frequency = RCC_PERIPH_FREQUENCY_NO;
3400a4ec:	2300      	movs	r3, #0
3400a4ee:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3400a4f0:	6878      	ldr	r0, [r7, #4]
3400a4f2:	f7f9 fd6b 	bl	34003fcc <LL_RCC_GetSPIClockSource>
3400a4f6:	4603      	mov	r3, r0
3400a4f8:	4aa7      	ldr	r2, [pc, #668]	@ (3400a798 <RCCEx_GetSPICLKFreq+0x2b4>)
3400a4fa:	4293      	cmp	r3, r2
3400a4fc:	f000 829e 	beq.w	3400aa3c <RCCEx_GetSPICLKFreq+0x558>
3400a500:	4aa5      	ldr	r2, [pc, #660]	@ (3400a798 <RCCEx_GetSPICLKFreq+0x2b4>)
3400a502:	4293      	cmp	r3, r2
3400a504:	f200 82a5 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a508:	4aa4      	ldr	r2, [pc, #656]	@ (3400a79c <RCCEx_GetSPICLKFreq+0x2b8>)
3400a50a:	4293      	cmp	r3, r2
3400a50c:	f000 8299 	beq.w	3400aa42 <RCCEx_GetSPICLKFreq+0x55e>
3400a510:	4aa2      	ldr	r2, [pc, #648]	@ (3400a79c <RCCEx_GetSPICLKFreq+0x2b8>)
3400a512:	4293      	cmp	r3, r2
3400a514:	f200 829d 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a518:	4aa1      	ldr	r2, [pc, #644]	@ (3400a7a0 <RCCEx_GetSPICLKFreq+0x2bc>)
3400a51a:	4293      	cmp	r3, r2
3400a51c:	f000 8291 	beq.w	3400aa42 <RCCEx_GetSPICLKFreq+0x55e>
3400a520:	4a9f      	ldr	r2, [pc, #636]	@ (3400a7a0 <RCCEx_GetSPICLKFreq+0x2bc>)
3400a522:	4293      	cmp	r3, r2
3400a524:	f200 8295 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a528:	4a9e      	ldr	r2, [pc, #632]	@ (3400a7a4 <RCCEx_GetSPICLKFreq+0x2c0>)
3400a52a:	4293      	cmp	r3, r2
3400a52c:	f000 8286 	beq.w	3400aa3c <RCCEx_GetSPICLKFreq+0x558>
3400a530:	4a9c      	ldr	r2, [pc, #624]	@ (3400a7a4 <RCCEx_GetSPICLKFreq+0x2c0>)
3400a532:	4293      	cmp	r3, r2
3400a534:	f200 828d 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a538:	4a9b      	ldr	r2, [pc, #620]	@ (3400a7a8 <RCCEx_GetSPICLKFreq+0x2c4>)
3400a53a:	4293      	cmp	r3, r2
3400a53c:	f000 827e 	beq.w	3400aa3c <RCCEx_GetSPICLKFreq+0x558>
3400a540:	4a99      	ldr	r2, [pc, #612]	@ (3400a7a8 <RCCEx_GetSPICLKFreq+0x2c4>)
3400a542:	4293      	cmp	r3, r2
3400a544:	f200 8285 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a548:	4a98      	ldr	r2, [pc, #608]	@ (3400a7ac <RCCEx_GetSPICLKFreq+0x2c8>)
3400a54a:	4293      	cmp	r3, r2
3400a54c:	f000 8276 	beq.w	3400aa3c <RCCEx_GetSPICLKFreq+0x558>
3400a550:	4a96      	ldr	r2, [pc, #600]	@ (3400a7ac <RCCEx_GetSPICLKFreq+0x2c8>)
3400a552:	4293      	cmp	r3, r2
3400a554:	f200 827d 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a558:	4a95      	ldr	r2, [pc, #596]	@ (3400a7b0 <RCCEx_GetSPICLKFreq+0x2cc>)
3400a55a:	4293      	cmp	r3, r2
3400a55c:	f000 8258 	beq.w	3400aa10 <RCCEx_GetSPICLKFreq+0x52c>
3400a560:	4a93      	ldr	r2, [pc, #588]	@ (3400a7b0 <RCCEx_GetSPICLKFreq+0x2cc>)
3400a562:	4293      	cmp	r3, r2
3400a564:	f200 8275 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a568:	4a92      	ldr	r2, [pc, #584]	@ (3400a7b4 <RCCEx_GetSPICLKFreq+0x2d0>)
3400a56a:	4293      	cmp	r3, r2
3400a56c:	f000 8250 	beq.w	3400aa10 <RCCEx_GetSPICLKFreq+0x52c>
3400a570:	4a90      	ldr	r2, [pc, #576]	@ (3400a7b4 <RCCEx_GetSPICLKFreq+0x2d0>)
3400a572:	4293      	cmp	r3, r2
3400a574:	f200 826d 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a578:	4a8f      	ldr	r2, [pc, #572]	@ (3400a7b8 <RCCEx_GetSPICLKFreq+0x2d4>)
3400a57a:	4293      	cmp	r3, r2
3400a57c:	f000 8248 	beq.w	3400aa10 <RCCEx_GetSPICLKFreq+0x52c>
3400a580:	4a8d      	ldr	r2, [pc, #564]	@ (3400a7b8 <RCCEx_GetSPICLKFreq+0x2d4>)
3400a582:	4293      	cmp	r3, r2
3400a584:	f200 8265 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a588:	4a8c      	ldr	r2, [pc, #560]	@ (3400a7bc <RCCEx_GetSPICLKFreq+0x2d8>)
3400a58a:	4293      	cmp	r3, r2
3400a58c:	f000 8240 	beq.w	3400aa10 <RCCEx_GetSPICLKFreq+0x52c>
3400a590:	4a8a      	ldr	r2, [pc, #552]	@ (3400a7bc <RCCEx_GetSPICLKFreq+0x2d8>)
3400a592:	4293      	cmp	r3, r2
3400a594:	f200 825d 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a598:	4a89      	ldr	r2, [pc, #548]	@ (3400a7c0 <RCCEx_GetSPICLKFreq+0x2dc>)
3400a59a:	4293      	cmp	r3, r2
3400a59c:	f000 8238 	beq.w	3400aa10 <RCCEx_GetSPICLKFreq+0x52c>
3400a5a0:	4a87      	ldr	r2, [pc, #540]	@ (3400a7c0 <RCCEx_GetSPICLKFreq+0x2dc>)
3400a5a2:	4293      	cmp	r3, r2
3400a5a4:	f200 8255 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a5a8:	4a86      	ldr	r2, [pc, #536]	@ (3400a7c4 <RCCEx_GetSPICLKFreq+0x2e0>)
3400a5aa:	4293      	cmp	r3, r2
3400a5ac:	f000 8230 	beq.w	3400aa10 <RCCEx_GetSPICLKFreq+0x52c>
3400a5b0:	4a84      	ldr	r2, [pc, #528]	@ (3400a7c4 <RCCEx_GetSPICLKFreq+0x2e0>)
3400a5b2:	4293      	cmp	r3, r2
3400a5b4:	f200 824d 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a5b8:	4a83      	ldr	r2, [pc, #524]	@ (3400a7c8 <RCCEx_GetSPICLKFreq+0x2e4>)
3400a5ba:	4293      	cmp	r3, r2
3400a5bc:	f000 8236 	beq.w	3400aa2c <RCCEx_GetSPICLKFreq+0x548>
3400a5c0:	4a81      	ldr	r2, [pc, #516]	@ (3400a7c8 <RCCEx_GetSPICLKFreq+0x2e4>)
3400a5c2:	4293      	cmp	r3, r2
3400a5c4:	f200 8245 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a5c8:	4a80      	ldr	r2, [pc, #512]	@ (3400a7cc <RCCEx_GetSPICLKFreq+0x2e8>)
3400a5ca:	4293      	cmp	r3, r2
3400a5cc:	f000 822e 	beq.w	3400aa2c <RCCEx_GetSPICLKFreq+0x548>
3400a5d0:	4a7e      	ldr	r2, [pc, #504]	@ (3400a7cc <RCCEx_GetSPICLKFreq+0x2e8>)
3400a5d2:	4293      	cmp	r3, r2
3400a5d4:	f200 823d 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a5d8:	4a7d      	ldr	r2, [pc, #500]	@ (3400a7d0 <RCCEx_GetSPICLKFreq+0x2ec>)
3400a5da:	4293      	cmp	r3, r2
3400a5dc:	f000 8226 	beq.w	3400aa2c <RCCEx_GetSPICLKFreq+0x548>
3400a5e0:	4a7b      	ldr	r2, [pc, #492]	@ (3400a7d0 <RCCEx_GetSPICLKFreq+0x2ec>)
3400a5e2:	4293      	cmp	r3, r2
3400a5e4:	f200 8235 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a5e8:	4a7a      	ldr	r2, [pc, #488]	@ (3400a7d4 <RCCEx_GetSPICLKFreq+0x2f0>)
3400a5ea:	4293      	cmp	r3, r2
3400a5ec:	f000 821e 	beq.w	3400aa2c <RCCEx_GetSPICLKFreq+0x548>
3400a5f0:	4a78      	ldr	r2, [pc, #480]	@ (3400a7d4 <RCCEx_GetSPICLKFreq+0x2f0>)
3400a5f2:	4293      	cmp	r3, r2
3400a5f4:	f200 822d 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a5f8:	4a77      	ldr	r2, [pc, #476]	@ (3400a7d8 <RCCEx_GetSPICLKFreq+0x2f4>)
3400a5fa:	4293      	cmp	r3, r2
3400a5fc:	f000 8216 	beq.w	3400aa2c <RCCEx_GetSPICLKFreq+0x548>
3400a600:	4a75      	ldr	r2, [pc, #468]	@ (3400a7d8 <RCCEx_GetSPICLKFreq+0x2f4>)
3400a602:	4293      	cmp	r3, r2
3400a604:	f200 8225 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a608:	4a74      	ldr	r2, [pc, #464]	@ (3400a7dc <RCCEx_GetSPICLKFreq+0x2f8>)
3400a60a:	4293      	cmp	r3, r2
3400a60c:	f000 820e 	beq.w	3400aa2c <RCCEx_GetSPICLKFreq+0x548>
3400a610:	4a72      	ldr	r2, [pc, #456]	@ (3400a7dc <RCCEx_GetSPICLKFreq+0x2f8>)
3400a612:	4293      	cmp	r3, r2
3400a614:	f200 821d 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a618:	4a71      	ldr	r2, [pc, #452]	@ (3400a7e0 <RCCEx_GetSPICLKFreq+0x2fc>)
3400a61a:	4293      	cmp	r3, r2
3400a61c:	f000 8171 	beq.w	3400a902 <RCCEx_GetSPICLKFreq+0x41e>
3400a620:	4a6f      	ldr	r2, [pc, #444]	@ (3400a7e0 <RCCEx_GetSPICLKFreq+0x2fc>)
3400a622:	4293      	cmp	r3, r2
3400a624:	f200 8215 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a628:	4a6e      	ldr	r2, [pc, #440]	@ (3400a7e4 <RCCEx_GetSPICLKFreq+0x300>)
3400a62a:	4293      	cmp	r3, r2
3400a62c:	f000 81ad 	beq.w	3400a98a <RCCEx_GetSPICLKFreq+0x4a6>
3400a630:	4a6c      	ldr	r2, [pc, #432]	@ (3400a7e4 <RCCEx_GetSPICLKFreq+0x300>)
3400a632:	4293      	cmp	r3, r2
3400a634:	f200 820d 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a638:	4a6b      	ldr	r2, [pc, #428]	@ (3400a7e8 <RCCEx_GetSPICLKFreq+0x304>)
3400a63a:	4293      	cmp	r3, r2
3400a63c:	f000 81a5 	beq.w	3400a98a <RCCEx_GetSPICLKFreq+0x4a6>
3400a640:	4a69      	ldr	r2, [pc, #420]	@ (3400a7e8 <RCCEx_GetSPICLKFreq+0x304>)
3400a642:	4293      	cmp	r3, r2
3400a644:	f200 8205 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a648:	4a68      	ldr	r2, [pc, #416]	@ (3400a7ec <RCCEx_GetSPICLKFreq+0x308>)
3400a64a:	4293      	cmp	r3, r2
3400a64c:	f000 8159 	beq.w	3400a902 <RCCEx_GetSPICLKFreq+0x41e>
3400a650:	4a66      	ldr	r2, [pc, #408]	@ (3400a7ec <RCCEx_GetSPICLKFreq+0x308>)
3400a652:	4293      	cmp	r3, r2
3400a654:	f200 81fd 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a658:	4a65      	ldr	r2, [pc, #404]	@ (3400a7f0 <RCCEx_GetSPICLKFreq+0x30c>)
3400a65a:	4293      	cmp	r3, r2
3400a65c:	f000 8151 	beq.w	3400a902 <RCCEx_GetSPICLKFreq+0x41e>
3400a660:	4a63      	ldr	r2, [pc, #396]	@ (3400a7f0 <RCCEx_GetSPICLKFreq+0x30c>)
3400a662:	4293      	cmp	r3, r2
3400a664:	f200 81f5 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a668:	4a62      	ldr	r2, [pc, #392]	@ (3400a7f4 <RCCEx_GetSPICLKFreq+0x310>)
3400a66a:	4293      	cmp	r3, r2
3400a66c:	f000 8149 	beq.w	3400a902 <RCCEx_GetSPICLKFreq+0x41e>
3400a670:	4a60      	ldr	r2, [pc, #384]	@ (3400a7f4 <RCCEx_GetSPICLKFreq+0x310>)
3400a672:	4293      	cmp	r3, r2
3400a674:	f200 81ed 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a678:	4a5f      	ldr	r2, [pc, #380]	@ (3400a7f8 <RCCEx_GetSPICLKFreq+0x314>)
3400a67a:	4293      	cmp	r3, r2
3400a67c:	f000 80fd 	beq.w	3400a87a <RCCEx_GetSPICLKFreq+0x396>
3400a680:	4a5d      	ldr	r2, [pc, #372]	@ (3400a7f8 <RCCEx_GetSPICLKFreq+0x314>)
3400a682:	4293      	cmp	r3, r2
3400a684:	f200 81e5 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a688:	4a5c      	ldr	r2, [pc, #368]	@ (3400a7fc <RCCEx_GetSPICLKFreq+0x318>)
3400a68a:	4293      	cmp	r3, r2
3400a68c:	f000 8139 	beq.w	3400a902 <RCCEx_GetSPICLKFreq+0x41e>
3400a690:	4a5a      	ldr	r2, [pc, #360]	@ (3400a7fc <RCCEx_GetSPICLKFreq+0x318>)
3400a692:	4293      	cmp	r3, r2
3400a694:	f200 81dd 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a698:	4a59      	ldr	r2, [pc, #356]	@ (3400a800 <RCCEx_GetSPICLKFreq+0x31c>)
3400a69a:	4293      	cmp	r3, r2
3400a69c:	f000 8131 	beq.w	3400a902 <RCCEx_GetSPICLKFreq+0x41e>
3400a6a0:	4a57      	ldr	r2, [pc, #348]	@ (3400a800 <RCCEx_GetSPICLKFreq+0x31c>)
3400a6a2:	4293      	cmp	r3, r2
3400a6a4:	f200 81d5 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a6a8:	4a56      	ldr	r2, [pc, #344]	@ (3400a804 <RCCEx_GetSPICLKFreq+0x320>)
3400a6aa:	4293      	cmp	r3, r2
3400a6ac:	f000 80e5 	beq.w	3400a87a <RCCEx_GetSPICLKFreq+0x396>
3400a6b0:	4a54      	ldr	r2, [pc, #336]	@ (3400a804 <RCCEx_GetSPICLKFreq+0x320>)
3400a6b2:	4293      	cmp	r3, r2
3400a6b4:	f200 81cd 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a6b8:	4a53      	ldr	r2, [pc, #332]	@ (3400a808 <RCCEx_GetSPICLKFreq+0x324>)
3400a6ba:	4293      	cmp	r3, r2
3400a6bc:	f000 80dd 	beq.w	3400a87a <RCCEx_GetSPICLKFreq+0x396>
3400a6c0:	4a51      	ldr	r2, [pc, #324]	@ (3400a808 <RCCEx_GetSPICLKFreq+0x324>)
3400a6c2:	4293      	cmp	r3, r2
3400a6c4:	f200 81c5 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a6c8:	4a50      	ldr	r2, [pc, #320]	@ (3400a80c <RCCEx_GetSPICLKFreq+0x328>)
3400a6ca:	4293      	cmp	r3, r2
3400a6cc:	f000 80d5 	beq.w	3400a87a <RCCEx_GetSPICLKFreq+0x396>
3400a6d0:	4a4e      	ldr	r2, [pc, #312]	@ (3400a80c <RCCEx_GetSPICLKFreq+0x328>)
3400a6d2:	4293      	cmp	r3, r2
3400a6d4:	f200 81bd 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a6d8:	4a4d      	ldr	r2, [pc, #308]	@ (3400a810 <RCCEx_GetSPICLKFreq+0x32c>)
3400a6da:	4293      	cmp	r3, r2
3400a6dc:	f000 80c8 	beq.w	3400a870 <RCCEx_GetSPICLKFreq+0x38c>
3400a6e0:	4a4b      	ldr	r2, [pc, #300]	@ (3400a810 <RCCEx_GetSPICLKFreq+0x32c>)
3400a6e2:	4293      	cmp	r3, r2
3400a6e4:	f200 81b5 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a6e8:	4a4a      	ldr	r2, [pc, #296]	@ (3400a814 <RCCEx_GetSPICLKFreq+0x330>)
3400a6ea:	4293      	cmp	r3, r2
3400a6ec:	f000 80c0 	beq.w	3400a870 <RCCEx_GetSPICLKFreq+0x38c>
3400a6f0:	4a48      	ldr	r2, [pc, #288]	@ (3400a814 <RCCEx_GetSPICLKFreq+0x330>)
3400a6f2:	4293      	cmp	r3, r2
3400a6f4:	f200 81ad 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a6f8:	4a47      	ldr	r2, [pc, #284]	@ (3400a818 <RCCEx_GetSPICLKFreq+0x334>)
3400a6fa:	4293      	cmp	r3, r2
3400a6fc:	f000 80b8 	beq.w	3400a870 <RCCEx_GetSPICLKFreq+0x38c>
3400a700:	4a45      	ldr	r2, [pc, #276]	@ (3400a818 <RCCEx_GetSPICLKFreq+0x334>)
3400a702:	4293      	cmp	r3, r2
3400a704:	f200 81a5 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a708:	4a44      	ldr	r2, [pc, #272]	@ (3400a81c <RCCEx_GetSPICLKFreq+0x338>)
3400a70a:	4293      	cmp	r3, r2
3400a70c:	f000 80b0 	beq.w	3400a870 <RCCEx_GetSPICLKFreq+0x38c>
3400a710:	4a42      	ldr	r2, [pc, #264]	@ (3400a81c <RCCEx_GetSPICLKFreq+0x338>)
3400a712:	4293      	cmp	r3, r2
3400a714:	f200 819d 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a718:	4a41      	ldr	r2, [pc, #260]	@ (3400a820 <RCCEx_GetSPICLKFreq+0x33c>)
3400a71a:	4293      	cmp	r3, r2
3400a71c:	f000 80a8 	beq.w	3400a870 <RCCEx_GetSPICLKFreq+0x38c>
3400a720:	4a3f      	ldr	r2, [pc, #252]	@ (3400a820 <RCCEx_GetSPICLKFreq+0x33c>)
3400a722:	4293      	cmp	r3, r2
3400a724:	f200 8195 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a728:	4a3e      	ldr	r2, [pc, #248]	@ (3400a824 <RCCEx_GetSPICLKFreq+0x340>)
3400a72a:	4293      	cmp	r3, r2
3400a72c:	f000 80a0 	beq.w	3400a870 <RCCEx_GetSPICLKFreq+0x38c>
3400a730:	4a3c      	ldr	r2, [pc, #240]	@ (3400a824 <RCCEx_GetSPICLKFreq+0x340>)
3400a732:	4293      	cmp	r3, r2
3400a734:	f200 818d 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a738:	4a3b      	ldr	r2, [pc, #236]	@ (3400a828 <RCCEx_GetSPICLKFreq+0x344>)
3400a73a:	4293      	cmp	r3, r2
3400a73c:	f000 808c 	beq.w	3400a858 <RCCEx_GetSPICLKFreq+0x374>
3400a740:	4a39      	ldr	r2, [pc, #228]	@ (3400a828 <RCCEx_GetSPICLKFreq+0x344>)
3400a742:	4293      	cmp	r3, r2
3400a744:	f200 8185 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a748:	4a38      	ldr	r2, [pc, #224]	@ (3400a82c <RCCEx_GetSPICLKFreq+0x348>)
3400a74a:	4293      	cmp	r3, r2
3400a74c:	d078      	beq.n	3400a840 <RCCEx_GetSPICLKFreq+0x35c>
3400a74e:	4a37      	ldr	r2, [pc, #220]	@ (3400a82c <RCCEx_GetSPICLKFreq+0x348>)
3400a750:	4293      	cmp	r3, r2
3400a752:	f200 817e 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a756:	4a36      	ldr	r2, [pc, #216]	@ (3400a830 <RCCEx_GetSPICLKFreq+0x34c>)
3400a758:	4293      	cmp	r3, r2
3400a75a:	d071      	beq.n	3400a840 <RCCEx_GetSPICLKFreq+0x35c>
3400a75c:	4a34      	ldr	r2, [pc, #208]	@ (3400a830 <RCCEx_GetSPICLKFreq+0x34c>)
3400a75e:	4293      	cmp	r3, r2
3400a760:	f200 8177 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a764:	4a33      	ldr	r2, [pc, #204]	@ (3400a834 <RCCEx_GetSPICLKFreq+0x350>)
3400a766:	4293      	cmp	r3, r2
3400a768:	d00a      	beq.n	3400a780 <RCCEx_GetSPICLKFreq+0x29c>
3400a76a:	4a32      	ldr	r2, [pc, #200]	@ (3400a834 <RCCEx_GetSPICLKFreq+0x350>)
3400a76c:	4293      	cmp	r3, r2
3400a76e:	f200 8170 	bhi.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
3400a772:	4a31      	ldr	r2, [pc, #196]	@ (3400a838 <RCCEx_GetSPICLKFreq+0x354>)
3400a774:	4293      	cmp	r3, r2
3400a776:	d063      	beq.n	3400a840 <RCCEx_GetSPICLKFreq+0x35c>
3400a778:	4a30      	ldr	r2, [pc, #192]	@ (3400a83c <RCCEx_GetSPICLKFreq+0x358>)
3400a77a:	4293      	cmp	r3, r2
3400a77c:	f040 8169 	bne.w	3400aa52 <RCCEx_GetSPICLKFreq+0x56e>
  {
    case LL_RCC_SPI2_CLKSOURCE_PCLK1:
    case LL_RCC_SPI3_CLKSOURCE_PCLK1:
      spi_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400a780:	f7f8 ff72 	bl	34003668 <HAL_RCC_GetSysClockFreq>
3400a784:	4603      	mov	r3, r0
3400a786:	4618      	mov	r0, r3
3400a788:	f7fd fbd4 	bl	34007f34 <RCCEx_GetHCLKFreq>
3400a78c:	4603      	mov	r3, r0
3400a78e:	4618      	mov	r0, r3
3400a790:	f7fd fbe1 	bl	34007f56 <RCCEx_GetPCLK1Freq>
3400a794:	60f8      	str	r0, [r7, #12]
      break;
3400a796:	e169      	b.n	3400aa6c <RCCEx_GetSPICLKFreq+0x588>
3400a798:	07061820 	.word	0x07061820
3400a79c:	07061420 	.word	0x07061420
3400a7a0:	07061020 	.word	0x07061020
3400a7a4:	07060c20 	.word	0x07060c20
3400a7a8:	07060820 	.word	0x07060820
3400a7ac:	07060420 	.word	0x07060420
3400a7b0:	07051820 	.word	0x07051820
3400a7b4:	07051420 	.word	0x07051420
3400a7b8:	07051020 	.word	0x07051020
3400a7bc:	07050c20 	.word	0x07050c20
3400a7c0:	07050820 	.word	0x07050820
3400a7c4:	07050420 	.word	0x07050420
3400a7c8:	07041820 	.word	0x07041820
3400a7cc:	07041420 	.word	0x07041420
3400a7d0:	07041020 	.word	0x07041020
3400a7d4:	07040c20 	.word	0x07040c20
3400a7d8:	07040820 	.word	0x07040820
3400a7dc:	07040420 	.word	0x07040420
3400a7e0:	07031820 	.word	0x07031820
3400a7e4:	07031420 	.word	0x07031420
3400a7e8:	07031020 	.word	0x07031020
3400a7ec:	07030c20 	.word	0x07030c20
3400a7f0:	07030820 	.word	0x07030820
3400a7f4:	07030420 	.word	0x07030420
3400a7f8:	07021820 	.word	0x07021820
3400a7fc:	07021420 	.word	0x07021420
3400a800:	07021020 	.word	0x07021020
3400a804:	07020c20 	.word	0x07020c20
3400a808:	07020820 	.word	0x07020820
3400a80c:	07020420 	.word	0x07020420
3400a810:	07011820 	.word	0x07011820
3400a814:	07011420 	.word	0x07011420
3400a818:	07011020 	.word	0x07011020
3400a81c:	07010c20 	.word	0x07010c20
3400a820:	07010820 	.word	0x07010820
3400a824:	07010420 	.word	0x07010420
3400a828:	07001820 	.word	0x07001820
3400a82c:	07001420 	.word	0x07001420
3400a830:	07001020 	.word	0x07001020
3400a834:	07000c20 	.word	0x07000c20
3400a838:	07000420 	.word	0x07000420
3400a83c:	07000820 	.word	0x07000820

    case LL_RCC_SPI1_CLKSOURCE_PCLK2:
    case LL_RCC_SPI4_CLKSOURCE_PCLK2:
    case LL_RCC_SPI5_CLKSOURCE_PCLK2:
      spi_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400a840:	f7f8 ff12 	bl	34003668 <HAL_RCC_GetSysClockFreq>
3400a844:	4603      	mov	r3, r0
3400a846:	4618      	mov	r0, r3
3400a848:	f7fd fb74 	bl	34007f34 <RCCEx_GetHCLKFreq>
3400a84c:	4603      	mov	r3, r0
3400a84e:	4618      	mov	r0, r3
3400a850:	f7fd fb91 	bl	34007f76 <RCCEx_GetPCLK2Freq>
3400a854:	60f8      	str	r0, [r7, #12]
      break;
3400a856:	e109      	b.n	3400aa6c <RCCEx_GetSPICLKFreq+0x588>

    case LL_RCC_SPI6_CLKSOURCE_PCLK4:
      spi_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400a858:	f7f8 ff06 	bl	34003668 <HAL_RCC_GetSysClockFreq>
3400a85c:	4603      	mov	r3, r0
3400a85e:	4618      	mov	r0, r3
3400a860:	f7fd fb68 	bl	34007f34 <RCCEx_GetHCLKFreq>
3400a864:	4603      	mov	r3, r0
3400a866:	4618      	mov	r0, r3
3400a868:	f7fd fb96 	bl	34007f98 <RCCEx_GetPCLK4Freq>
3400a86c:	60f8      	str	r0, [r7, #12]
      break;
3400a86e:	e0fd      	b.n	3400aa6c <RCCEx_GetSPICLKFreq+0x588>
    case LL_RCC_SPI2_CLKSOURCE_CLKP:
    case LL_RCC_SPI3_CLKSOURCE_CLKP:
    case LL_RCC_SPI4_CLKSOURCE_CLKP:
    case LL_RCC_SPI5_CLKSOURCE_CLKP:
    case LL_RCC_SPI6_CLKSOURCE_CLKP:
      spi_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400a870:	2007      	movs	r0, #7
3400a872:	f7fd fe4b 	bl	3400850c <RCCEx_GetCLKPCLKFreq>
3400a876:	60f8      	str	r0, [r7, #12]
      break;
3400a878:	e0f8      	b.n	3400aa6c <RCCEx_GetSPICLKFreq+0x588>

    case LL_RCC_SPI1_CLKSOURCE_IC8:
    case LL_RCC_SPI2_CLKSOURCE_IC8:
    case LL_RCC_SPI3_CLKSOURCE_IC8:
    case LL_RCC_SPI6_CLKSOURCE_IC8:
      if (LL_RCC_IC8_IsEnabled() != 0U)
3400a87a:	f7f9 ffaf 	bl	340047dc <LL_RCC_IC8_IsEnabled>
3400a87e:	4603      	mov	r3, r0
3400a880:	2b00      	cmp	r3, #0
3400a882:	f000 80e8 	beq.w	3400aa56 <RCCEx_GetSPICLKFreq+0x572>
      {
        ic_divider = LL_RCC_IC8_GetDivider();
3400a886:	f7f9 ffcb 	bl	34004820 <LL_RCC_IC8_GetDivider>
3400a88a:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
3400a88c:	f7f9 ffba 	bl	34004804 <LL_RCC_IC8_GetSource>
3400a890:	4603      	mov	r3, r0
3400a892:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400a896:	d029      	beq.n	3400a8ec <RCCEx_GetSPICLKFreq+0x408>
3400a898:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400a89c:	d82f      	bhi.n	3400a8fe <RCCEx_GetSPICLKFreq+0x41a>
3400a89e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400a8a2:	d01a      	beq.n	3400a8da <RCCEx_GetSPICLKFreq+0x3f6>
3400a8a4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400a8a8:	d829      	bhi.n	3400a8fe <RCCEx_GetSPICLKFreq+0x41a>
3400a8aa:	2b00      	cmp	r3, #0
3400a8ac:	d003      	beq.n	3400a8b6 <RCCEx_GetSPICLKFreq+0x3d2>
3400a8ae:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400a8b2:	d009      	beq.n	3400a8c8 <RCCEx_GetSPICLKFreq+0x3e4>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            spi_frequency = spi_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
3400a8b4:	e023      	b.n	3400a8fe <RCCEx_GetSPICLKFreq+0x41a>
            spi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400a8b6:	f7fd fa25 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
3400a8ba:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
3400a8bc:	68fa      	ldr	r2, [r7, #12]
3400a8be:	68bb      	ldr	r3, [r7, #8]
3400a8c0:	fbb2 f3f3 	udiv	r3, r2, r3
3400a8c4:	60fb      	str	r3, [r7, #12]
            break;
3400a8c6:	e01b      	b.n	3400a900 <RCCEx_GetSPICLKFreq+0x41c>
            spi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400a8c8:	f7fd fa62 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
3400a8cc:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
3400a8ce:	68fa      	ldr	r2, [r7, #12]
3400a8d0:	68bb      	ldr	r3, [r7, #8]
3400a8d2:	fbb2 f3f3 	udiv	r3, r2, r3
3400a8d6:	60fb      	str	r3, [r7, #12]
            break;
3400a8d8:	e012      	b.n	3400a900 <RCCEx_GetSPICLKFreq+0x41c>
            spi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400a8da:	f7fd fa9f 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
3400a8de:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
3400a8e0:	68fa      	ldr	r2, [r7, #12]
3400a8e2:	68bb      	ldr	r3, [r7, #8]
3400a8e4:	fbb2 f3f3 	udiv	r3, r2, r3
3400a8e8:	60fb      	str	r3, [r7, #12]
            break;
3400a8ea:	e009      	b.n	3400a900 <RCCEx_GetSPICLKFreq+0x41c>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400a8ec:	f7fd fadc 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
3400a8f0:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
3400a8f2:	68fa      	ldr	r2, [r7, #12]
3400a8f4:	68bb      	ldr	r3, [r7, #8]
3400a8f6:	fbb2 f3f3 	udiv	r3, r2, r3
3400a8fa:	60fb      	str	r3, [r7, #12]
            break;
3400a8fc:	e000      	b.n	3400a900 <RCCEx_GetSPICLKFreq+0x41c>
            break;
3400a8fe:	bf00      	nop
        }
      }
      break;
3400a900:	e0a9      	b.n	3400aa56 <RCCEx_GetSPICLKFreq+0x572>
    case LL_RCC_SPI2_CLKSOURCE_IC9:
    case LL_RCC_SPI3_CLKSOURCE_IC9:
    case LL_RCC_SPI4_CLKSOURCE_IC9:
    case LL_RCC_SPI5_CLKSOURCE_IC9:
    case LL_RCC_SPI6_CLKSOURCE_IC9:
      if (LL_RCC_IC9_IsEnabled() != 0U)
3400a902:	f7f9 ffab 	bl	3400485c <LL_RCC_IC9_IsEnabled>
3400a906:	4603      	mov	r3, r0
3400a908:	2b00      	cmp	r3, #0
3400a90a:	f000 80a6 	beq.w	3400aa5a <RCCEx_GetSPICLKFreq+0x576>
      {
        ic_divider = LL_RCC_IC9_GetDivider();
3400a90e:	f7f9 ffc7 	bl	340048a0 <LL_RCC_IC9_GetDivider>
3400a912:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC9_GetSource())
3400a914:	f7f9 ffb6 	bl	34004884 <LL_RCC_IC9_GetSource>
3400a918:	4603      	mov	r3, r0
3400a91a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400a91e:	d029      	beq.n	3400a974 <RCCEx_GetSPICLKFreq+0x490>
3400a920:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400a924:	d82f      	bhi.n	3400a986 <RCCEx_GetSPICLKFreq+0x4a2>
3400a926:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400a92a:	d01a      	beq.n	3400a962 <RCCEx_GetSPICLKFreq+0x47e>
3400a92c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400a930:	d829      	bhi.n	3400a986 <RCCEx_GetSPICLKFreq+0x4a2>
3400a932:	2b00      	cmp	r3, #0
3400a934:	d003      	beq.n	3400a93e <RCCEx_GetSPICLKFreq+0x45a>
3400a936:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400a93a:	d009      	beq.n	3400a950 <RCCEx_GetSPICLKFreq+0x46c>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            spi_frequency = spi_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
3400a93c:	e023      	b.n	3400a986 <RCCEx_GetSPICLKFreq+0x4a2>
            spi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400a93e:	f7fd f9e1 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
3400a942:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
3400a944:	68fa      	ldr	r2, [r7, #12]
3400a946:	68bb      	ldr	r3, [r7, #8]
3400a948:	fbb2 f3f3 	udiv	r3, r2, r3
3400a94c:	60fb      	str	r3, [r7, #12]
            break;
3400a94e:	e01b      	b.n	3400a988 <RCCEx_GetSPICLKFreq+0x4a4>
            spi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400a950:	f7fd fa1e 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
3400a954:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
3400a956:	68fa      	ldr	r2, [r7, #12]
3400a958:	68bb      	ldr	r3, [r7, #8]
3400a95a:	fbb2 f3f3 	udiv	r3, r2, r3
3400a95e:	60fb      	str	r3, [r7, #12]
            break;
3400a960:	e012      	b.n	3400a988 <RCCEx_GetSPICLKFreq+0x4a4>
            spi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400a962:	f7fd fa5b 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
3400a966:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
3400a968:	68fa      	ldr	r2, [r7, #12]
3400a96a:	68bb      	ldr	r3, [r7, #8]
3400a96c:	fbb2 f3f3 	udiv	r3, r2, r3
3400a970:	60fb      	str	r3, [r7, #12]
            break;
3400a972:	e009      	b.n	3400a988 <RCCEx_GetSPICLKFreq+0x4a4>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400a974:	f7fd fa98 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
3400a978:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
3400a97a:	68fa      	ldr	r2, [r7, #12]
3400a97c:	68bb      	ldr	r3, [r7, #8]
3400a97e:	fbb2 f3f3 	udiv	r3, r2, r3
3400a982:	60fb      	str	r3, [r7, #12]
            break;
3400a984:	e000      	b.n	3400a988 <RCCEx_GetSPICLKFreq+0x4a4>
            break;
3400a986:	bf00      	nop
        }
      }
      break;
3400a988:	e067      	b.n	3400aa5a <RCCEx_GetSPICLKFreq+0x576>

    case LL_RCC_SPI4_CLKSOURCE_IC14:
    case LL_RCC_SPI5_CLKSOURCE_IC14:
      if (LL_RCC_IC14_IsEnabled() != 0U)
3400a98a:	f7fa f867 	bl	34004a5c <LL_RCC_IC14_IsEnabled>
3400a98e:	4603      	mov	r3, r0
3400a990:	2b00      	cmp	r3, #0
3400a992:	d064      	beq.n	3400aa5e <RCCEx_GetSPICLKFreq+0x57a>
      {
        ic_divider = LL_RCC_IC14_GetDivider();
3400a994:	f7fa f884 	bl	34004aa0 <LL_RCC_IC14_GetDivider>
3400a998:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC14_GetSource())
3400a99a:	f7fa f873 	bl	34004a84 <LL_RCC_IC14_GetSource>
3400a99e:	4603      	mov	r3, r0
3400a9a0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400a9a4:	d029      	beq.n	3400a9fa <RCCEx_GetSPICLKFreq+0x516>
3400a9a6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400a9aa:	d82f      	bhi.n	3400aa0c <RCCEx_GetSPICLKFreq+0x528>
3400a9ac:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400a9b0:	d01a      	beq.n	3400a9e8 <RCCEx_GetSPICLKFreq+0x504>
3400a9b2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400a9b6:	d829      	bhi.n	3400aa0c <RCCEx_GetSPICLKFreq+0x528>
3400a9b8:	2b00      	cmp	r3, #0
3400a9ba:	d003      	beq.n	3400a9c4 <RCCEx_GetSPICLKFreq+0x4e0>
3400a9bc:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400a9c0:	d009      	beq.n	3400a9d6 <RCCEx_GetSPICLKFreq+0x4f2>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            spi_frequency = spi_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
3400a9c2:	e023      	b.n	3400aa0c <RCCEx_GetSPICLKFreq+0x528>
            spi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400a9c4:	f7fd f99e 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
3400a9c8:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
3400a9ca:	68fa      	ldr	r2, [r7, #12]
3400a9cc:	68bb      	ldr	r3, [r7, #8]
3400a9ce:	fbb2 f3f3 	udiv	r3, r2, r3
3400a9d2:	60fb      	str	r3, [r7, #12]
            break;
3400a9d4:	e01b      	b.n	3400aa0e <RCCEx_GetSPICLKFreq+0x52a>
            spi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400a9d6:	f7fd f9db 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
3400a9da:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
3400a9dc:	68fa      	ldr	r2, [r7, #12]
3400a9de:	68bb      	ldr	r3, [r7, #8]
3400a9e0:	fbb2 f3f3 	udiv	r3, r2, r3
3400a9e4:	60fb      	str	r3, [r7, #12]
            break;
3400a9e6:	e012      	b.n	3400aa0e <RCCEx_GetSPICLKFreq+0x52a>
            spi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400a9e8:	f7fd fa18 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
3400a9ec:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
3400a9ee:	68fa      	ldr	r2, [r7, #12]
3400a9f0:	68bb      	ldr	r3, [r7, #8]
3400a9f2:	fbb2 f3f3 	udiv	r3, r2, r3
3400a9f6:	60fb      	str	r3, [r7, #12]
            break;
3400a9f8:	e009      	b.n	3400aa0e <RCCEx_GetSPICLKFreq+0x52a>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400a9fa:	f7fd fa55 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
3400a9fe:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
3400aa00:	68fa      	ldr	r2, [r7, #12]
3400aa02:	68bb      	ldr	r3, [r7, #8]
3400aa04:	fbb2 f3f3 	udiv	r3, r2, r3
3400aa08:	60fb      	str	r3, [r7, #12]
            break;
3400aa0a:	e000      	b.n	3400aa0e <RCCEx_GetSPICLKFreq+0x52a>
            break;
3400aa0c:	bf00      	nop
        }
      }
      break;
3400aa0e:	e026      	b.n	3400aa5e <RCCEx_GetSPICLKFreq+0x57a>
    case LL_RCC_SPI2_CLKSOURCE_HSI:
    case LL_RCC_SPI3_CLKSOURCE_HSI:
    case LL_RCC_SPI4_CLKSOURCE_HSI:
    case LL_RCC_SPI5_CLKSOURCE_HSI:
    case LL_RCC_SPI6_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
3400aa10:	f7f8 ff00 	bl	34003814 <LL_RCC_HSI_IsReady>
3400aa14:	4603      	mov	r3, r0
3400aa16:	2b00      	cmp	r3, #0
3400aa18:	d023      	beq.n	3400aa62 <RCCEx_GetSPICLKFreq+0x57e>
      {
        spi_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400aa1a:	f7f8 ff0d 	bl	34003838 <LL_RCC_HSI_GetDivider>
3400aa1e:	4603      	mov	r3, r0
3400aa20:	09db      	lsrs	r3, r3, #7
3400aa22:	4a15      	ldr	r2, [pc, #84]	@ (3400aa78 <RCCEx_GetSPICLKFreq+0x594>)
3400aa24:	fa22 f303 	lsr.w	r3, r2, r3
3400aa28:	60fb      	str	r3, [r7, #12]
      }
      break;
3400aa2a:	e01a      	b.n	3400aa62 <RCCEx_GetSPICLKFreq+0x57e>
    case LL_RCC_SPI2_CLKSOURCE_MSI:
    case LL_RCC_SPI3_CLKSOURCE_MSI:
    case LL_RCC_SPI4_CLKSOURCE_MSI:
    case LL_RCC_SPI5_CLKSOURCE_MSI:
    case LL_RCC_SPI6_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
3400aa2c:	f7f8 ff12 	bl	34003854 <LL_RCC_MSI_IsReady>
3400aa30:	4603      	mov	r3, r0
3400aa32:	2b00      	cmp	r3, #0
3400aa34:	d017      	beq.n	3400aa66 <RCCEx_GetSPICLKFreq+0x582>
      {
        spi_frequency = MSI_VALUE;
3400aa36:	4b11      	ldr	r3, [pc, #68]	@ (3400aa7c <RCCEx_GetSPICLKFreq+0x598>)
3400aa38:	60fb      	str	r3, [r7, #12]
      }
      break;
3400aa3a:	e014      	b.n	3400aa66 <RCCEx_GetSPICLKFreq+0x582>

    case LL_RCC_SPI1_CLKSOURCE_I2S_CKIN:
    case LL_RCC_SPI2_CLKSOURCE_I2S_CKIN:
    case LL_RCC_SPI3_CLKSOURCE_I2S_CKIN:
    case LL_RCC_SPI6_CLKSOURCE_I2S_CKIN:
      spi_frequency = EXTERNAL_CLOCK_VALUE;
3400aa3c:	4b10      	ldr	r3, [pc, #64]	@ (3400aa80 <RCCEx_GetSPICLKFreq+0x59c>)
3400aa3e:	60fb      	str	r3, [r7, #12]
      break;
3400aa40:	e014      	b.n	3400aa6c <RCCEx_GetSPICLKFreq+0x588>

    case LL_RCC_SPI4_CLKSOURCE_HSE:
    case LL_RCC_SPI5_CLKSOURCE_HSE:
      if (LL_RCC_HSE_IsReady() != 0U)
3400aa42:	f7f8 fed5 	bl	340037f0 <LL_RCC_HSE_IsReady>
3400aa46:	4603      	mov	r3, r0
3400aa48:	2b00      	cmp	r3, #0
3400aa4a:	d00e      	beq.n	3400aa6a <RCCEx_GetSPICLKFreq+0x586>
      {
        spi_frequency = HSE_VALUE;
3400aa4c:	4b0d      	ldr	r3, [pc, #52]	@ (3400aa84 <RCCEx_GetSPICLKFreq+0x5a0>)
3400aa4e:	60fb      	str	r3, [r7, #12]
      }
      break;
3400aa50:	e00b      	b.n	3400aa6a <RCCEx_GetSPICLKFreq+0x586>

    default:
      /* Unexpected case */
      break;
3400aa52:	bf00      	nop
3400aa54:	e00a      	b.n	3400aa6c <RCCEx_GetSPICLKFreq+0x588>
      break;
3400aa56:	bf00      	nop
3400aa58:	e008      	b.n	3400aa6c <RCCEx_GetSPICLKFreq+0x588>
      break;
3400aa5a:	bf00      	nop
3400aa5c:	e006      	b.n	3400aa6c <RCCEx_GetSPICLKFreq+0x588>
      break;
3400aa5e:	bf00      	nop
3400aa60:	e004      	b.n	3400aa6c <RCCEx_GetSPICLKFreq+0x588>
      break;
3400aa62:	bf00      	nop
3400aa64:	e002      	b.n	3400aa6c <RCCEx_GetSPICLKFreq+0x588>
      break;
3400aa66:	bf00      	nop
3400aa68:	e000      	b.n	3400aa6c <RCCEx_GetSPICLKFreq+0x588>
      break;
3400aa6a:	bf00      	nop
  }

  return spi_frequency;
3400aa6c:	68fb      	ldr	r3, [r7, #12]
}
3400aa6e:	4618      	mov	r0, r3
3400aa70:	3710      	adds	r7, #16
3400aa72:	46bd      	mov	sp, r7
3400aa74:	bd80      	pop	{r7, pc}
3400aa76:	bf00      	nop
3400aa78:	03d09000 	.word	0x03d09000
3400aa7c:	003d0900 	.word	0x003d0900
3400aa80:	00bb8000 	.word	0x00bb8000
3400aa84:	016e3600 	.word	0x016e3600

3400aa88 <RCCEx_GetUARTCLKFreq>:
  *         @arg @ref RCCEx_UART9_Clock_Source
  * @retval USART clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetUARTCLKFreq(uint32_t UARTxSource)
{
3400aa88:	b580      	push	{r7, lr}
3400aa8a:	b084      	sub	sp, #16
3400aa8c:	af00      	add	r7, sp, #0
3400aa8e:	6078      	str	r0, [r7, #4]
  uint32_t uart_frequency = RCC_PERIPH_FREQUENCY_NO;
3400aa90:	2300      	movs	r3, #0
3400aa92:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetUARTClockSource(UARTxSource))
3400aa94:	6878      	ldr	r0, [r7, #4]
3400aa96:	f7f9 fab1 	bl	34003ffc <LL_RCC_GetUARTClockSource>
3400aa9a:	4603      	mov	r3, r0
3400aa9c:	4aa2      	ldr	r2, [pc, #648]	@ (3400ad28 <RCCEx_GetUARTCLKFreq+0x2a0>)
3400aa9e:	4293      	cmp	r3, r2
3400aaa0:	f000 81e8 	beq.w	3400ae74 <RCCEx_GetUARTCLKFreq+0x3ec>
3400aaa4:	4aa0      	ldr	r2, [pc, #640]	@ (3400ad28 <RCCEx_GetUARTCLKFreq+0x2a0>)
3400aaa6:	4293      	cmp	r3, r2
3400aaa8:	f200 8203 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400aaac:	4a9f      	ldr	r2, [pc, #636]	@ (3400ad2c <RCCEx_GetUARTCLKFreq+0x2a4>)
3400aaae:	4293      	cmp	r3, r2
3400aab0:	f000 81e0 	beq.w	3400ae74 <RCCEx_GetUARTCLKFreq+0x3ec>
3400aab4:	4a9d      	ldr	r2, [pc, #628]	@ (3400ad2c <RCCEx_GetUARTCLKFreq+0x2a4>)
3400aab6:	4293      	cmp	r3, r2
3400aab8:	f200 81fb 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400aabc:	4a9c      	ldr	r2, [pc, #624]	@ (3400ad30 <RCCEx_GetUARTCLKFreq+0x2a8>)
3400aabe:	4293      	cmp	r3, r2
3400aac0:	f000 81d8 	beq.w	3400ae74 <RCCEx_GetUARTCLKFreq+0x3ec>
3400aac4:	4a9a      	ldr	r2, [pc, #616]	@ (3400ad30 <RCCEx_GetUARTCLKFreq+0x2a8>)
3400aac6:	4293      	cmp	r3, r2
3400aac8:	f200 81f3 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400aacc:	4a99      	ldr	r2, [pc, #612]	@ (3400ad34 <RCCEx_GetUARTCLKFreq+0x2ac>)
3400aace:	4293      	cmp	r3, r2
3400aad0:	f000 81d0 	beq.w	3400ae74 <RCCEx_GetUARTCLKFreq+0x3ec>
3400aad4:	4a97      	ldr	r2, [pc, #604]	@ (3400ad34 <RCCEx_GetUARTCLKFreq+0x2ac>)
3400aad6:	4293      	cmp	r3, r2
3400aad8:	f200 81eb 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400aadc:	4a96      	ldr	r2, [pc, #600]	@ (3400ad38 <RCCEx_GetUARTCLKFreq+0x2b0>)
3400aade:	4293      	cmp	r3, r2
3400aae0:	f000 81c8 	beq.w	3400ae74 <RCCEx_GetUARTCLKFreq+0x3ec>
3400aae4:	4a94      	ldr	r2, [pc, #592]	@ (3400ad38 <RCCEx_GetUARTCLKFreq+0x2b0>)
3400aae6:	4293      	cmp	r3, r2
3400aae8:	f200 81e3 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400aaec:	4a93      	ldr	r2, [pc, #588]	@ (3400ad3c <RCCEx_GetUARTCLKFreq+0x2b4>)
3400aaee:	4293      	cmp	r3, r2
3400aaf0:	f000 81ce 	beq.w	3400ae90 <RCCEx_GetUARTCLKFreq+0x408>
3400aaf4:	4a91      	ldr	r2, [pc, #580]	@ (3400ad3c <RCCEx_GetUARTCLKFreq+0x2b4>)
3400aaf6:	4293      	cmp	r3, r2
3400aaf8:	f200 81db 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400aafc:	4a90      	ldr	r2, [pc, #576]	@ (3400ad40 <RCCEx_GetUARTCLKFreq+0x2b8>)
3400aafe:	4293      	cmp	r3, r2
3400ab00:	f000 81c6 	beq.w	3400ae90 <RCCEx_GetUARTCLKFreq+0x408>
3400ab04:	4a8e      	ldr	r2, [pc, #568]	@ (3400ad40 <RCCEx_GetUARTCLKFreq+0x2b8>)
3400ab06:	4293      	cmp	r3, r2
3400ab08:	f200 81d3 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400ab0c:	4a8d      	ldr	r2, [pc, #564]	@ (3400ad44 <RCCEx_GetUARTCLKFreq+0x2bc>)
3400ab0e:	4293      	cmp	r3, r2
3400ab10:	f000 81be 	beq.w	3400ae90 <RCCEx_GetUARTCLKFreq+0x408>
3400ab14:	4a8b      	ldr	r2, [pc, #556]	@ (3400ad44 <RCCEx_GetUARTCLKFreq+0x2bc>)
3400ab16:	4293      	cmp	r3, r2
3400ab18:	f200 81cb 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400ab1c:	4a8a      	ldr	r2, [pc, #552]	@ (3400ad48 <RCCEx_GetUARTCLKFreq+0x2c0>)
3400ab1e:	4293      	cmp	r3, r2
3400ab20:	f000 81b6 	beq.w	3400ae90 <RCCEx_GetUARTCLKFreq+0x408>
3400ab24:	4a88      	ldr	r2, [pc, #544]	@ (3400ad48 <RCCEx_GetUARTCLKFreq+0x2c0>)
3400ab26:	4293      	cmp	r3, r2
3400ab28:	f200 81c3 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400ab2c:	4a87      	ldr	r2, [pc, #540]	@ (3400ad4c <RCCEx_GetUARTCLKFreq+0x2c4>)
3400ab2e:	4293      	cmp	r3, r2
3400ab30:	f000 81ae 	beq.w	3400ae90 <RCCEx_GetUARTCLKFreq+0x408>
3400ab34:	4a85      	ldr	r2, [pc, #532]	@ (3400ad4c <RCCEx_GetUARTCLKFreq+0x2c4>)
3400ab36:	4293      	cmp	r3, r2
3400ab38:	f200 81bb 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400ab3c:	4a84      	ldr	r2, [pc, #528]	@ (3400ad50 <RCCEx_GetUARTCLKFreq+0x2c8>)
3400ab3e:	4293      	cmp	r3, r2
3400ab40:	f000 81ae 	beq.w	3400aea0 <RCCEx_GetUARTCLKFreq+0x418>
3400ab44:	4a82      	ldr	r2, [pc, #520]	@ (3400ad50 <RCCEx_GetUARTCLKFreq+0x2c8>)
3400ab46:	4293      	cmp	r3, r2
3400ab48:	f200 81b3 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400ab4c:	4a81      	ldr	r2, [pc, #516]	@ (3400ad54 <RCCEx_GetUARTCLKFreq+0x2cc>)
3400ab4e:	4293      	cmp	r3, r2
3400ab50:	f000 81a6 	beq.w	3400aea0 <RCCEx_GetUARTCLKFreq+0x418>
3400ab54:	4a7f      	ldr	r2, [pc, #508]	@ (3400ad54 <RCCEx_GetUARTCLKFreq+0x2cc>)
3400ab56:	4293      	cmp	r3, r2
3400ab58:	f200 81ab 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400ab5c:	4a7e      	ldr	r2, [pc, #504]	@ (3400ad58 <RCCEx_GetUARTCLKFreq+0x2d0>)
3400ab5e:	4293      	cmp	r3, r2
3400ab60:	f000 819e 	beq.w	3400aea0 <RCCEx_GetUARTCLKFreq+0x418>
3400ab64:	4a7c      	ldr	r2, [pc, #496]	@ (3400ad58 <RCCEx_GetUARTCLKFreq+0x2d0>)
3400ab66:	4293      	cmp	r3, r2
3400ab68:	f200 81a3 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400ab6c:	4a7b      	ldr	r2, [pc, #492]	@ (3400ad5c <RCCEx_GetUARTCLKFreq+0x2d4>)
3400ab6e:	4293      	cmp	r3, r2
3400ab70:	f000 8196 	beq.w	3400aea0 <RCCEx_GetUARTCLKFreq+0x418>
3400ab74:	4a79      	ldr	r2, [pc, #484]	@ (3400ad5c <RCCEx_GetUARTCLKFreq+0x2d4>)
3400ab76:	4293      	cmp	r3, r2
3400ab78:	f200 819b 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400ab7c:	4a78      	ldr	r2, [pc, #480]	@ (3400ad60 <RCCEx_GetUARTCLKFreq+0x2d8>)
3400ab7e:	4293      	cmp	r3, r2
3400ab80:	f000 818e 	beq.w	3400aea0 <RCCEx_GetUARTCLKFreq+0x418>
3400ab84:	4a76      	ldr	r2, [pc, #472]	@ (3400ad60 <RCCEx_GetUARTCLKFreq+0x2d8>)
3400ab86:	4293      	cmp	r3, r2
3400ab88:	f200 8193 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400ab8c:	4a75      	ldr	r2, [pc, #468]	@ (3400ad64 <RCCEx_GetUARTCLKFreq+0x2dc>)
3400ab8e:	4293      	cmp	r3, r2
3400ab90:	f000 812d 	beq.w	3400adee <RCCEx_GetUARTCLKFreq+0x366>
3400ab94:	4a73      	ldr	r2, [pc, #460]	@ (3400ad64 <RCCEx_GetUARTCLKFreq+0x2dc>)
3400ab96:	4293      	cmp	r3, r2
3400ab98:	f200 818b 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400ab9c:	4a72      	ldr	r2, [pc, #456]	@ (3400ad68 <RCCEx_GetUARTCLKFreq+0x2e0>)
3400ab9e:	4293      	cmp	r3, r2
3400aba0:	f000 8125 	beq.w	3400adee <RCCEx_GetUARTCLKFreq+0x366>
3400aba4:	4a70      	ldr	r2, [pc, #448]	@ (3400ad68 <RCCEx_GetUARTCLKFreq+0x2e0>)
3400aba6:	4293      	cmp	r3, r2
3400aba8:	f200 8183 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400abac:	4a6f      	ldr	r2, [pc, #444]	@ (3400ad6c <RCCEx_GetUARTCLKFreq+0x2e4>)
3400abae:	4293      	cmp	r3, r2
3400abb0:	f000 811d 	beq.w	3400adee <RCCEx_GetUARTCLKFreq+0x366>
3400abb4:	4a6d      	ldr	r2, [pc, #436]	@ (3400ad6c <RCCEx_GetUARTCLKFreq+0x2e4>)
3400abb6:	4293      	cmp	r3, r2
3400abb8:	f200 817b 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400abbc:	4a6c      	ldr	r2, [pc, #432]	@ (3400ad70 <RCCEx_GetUARTCLKFreq+0x2e8>)
3400abbe:	4293      	cmp	r3, r2
3400abc0:	f000 8115 	beq.w	3400adee <RCCEx_GetUARTCLKFreq+0x366>
3400abc4:	4a6a      	ldr	r2, [pc, #424]	@ (3400ad70 <RCCEx_GetUARTCLKFreq+0x2e8>)
3400abc6:	4293      	cmp	r3, r2
3400abc8:	f200 8173 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400abcc:	4a69      	ldr	r2, [pc, #420]	@ (3400ad74 <RCCEx_GetUARTCLKFreq+0x2ec>)
3400abce:	4293      	cmp	r3, r2
3400abd0:	f000 810d 	beq.w	3400adee <RCCEx_GetUARTCLKFreq+0x366>
3400abd4:	4a67      	ldr	r2, [pc, #412]	@ (3400ad74 <RCCEx_GetUARTCLKFreq+0x2ec>)
3400abd6:	4293      	cmp	r3, r2
3400abd8:	f200 816b 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400abdc:	4a66      	ldr	r2, [pc, #408]	@ (3400ad78 <RCCEx_GetUARTCLKFreq+0x2f0>)
3400abde:	4293      	cmp	r3, r2
3400abe0:	d07b      	beq.n	3400acda <RCCEx_GetUARTCLKFreq+0x252>
3400abe2:	4a65      	ldr	r2, [pc, #404]	@ (3400ad78 <RCCEx_GetUARTCLKFreq+0x2f0>)
3400abe4:	4293      	cmp	r3, r2
3400abe6:	f200 8164 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400abea:	4a64      	ldr	r2, [pc, #400]	@ (3400ad7c <RCCEx_GetUARTCLKFreq+0x2f4>)
3400abec:	4293      	cmp	r3, r2
3400abee:	d074      	beq.n	3400acda <RCCEx_GetUARTCLKFreq+0x252>
3400abf0:	4a62      	ldr	r2, [pc, #392]	@ (3400ad7c <RCCEx_GetUARTCLKFreq+0x2f4>)
3400abf2:	4293      	cmp	r3, r2
3400abf4:	f200 815d 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400abf8:	4a61      	ldr	r2, [pc, #388]	@ (3400ad80 <RCCEx_GetUARTCLKFreq+0x2f8>)
3400abfa:	4293      	cmp	r3, r2
3400abfc:	d06d      	beq.n	3400acda <RCCEx_GetUARTCLKFreq+0x252>
3400abfe:	4a60      	ldr	r2, [pc, #384]	@ (3400ad80 <RCCEx_GetUARTCLKFreq+0x2f8>)
3400ac00:	4293      	cmp	r3, r2
3400ac02:	f200 8156 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400ac06:	4a5f      	ldr	r2, [pc, #380]	@ (3400ad84 <RCCEx_GetUARTCLKFreq+0x2fc>)
3400ac08:	4293      	cmp	r3, r2
3400ac0a:	d066      	beq.n	3400acda <RCCEx_GetUARTCLKFreq+0x252>
3400ac0c:	4a5d      	ldr	r2, [pc, #372]	@ (3400ad84 <RCCEx_GetUARTCLKFreq+0x2fc>)
3400ac0e:	4293      	cmp	r3, r2
3400ac10:	f200 814f 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400ac14:	4a5c      	ldr	r2, [pc, #368]	@ (3400ad88 <RCCEx_GetUARTCLKFreq+0x300>)
3400ac16:	4293      	cmp	r3, r2
3400ac18:	d05f      	beq.n	3400acda <RCCEx_GetUARTCLKFreq+0x252>
3400ac1a:	4a5b      	ldr	r2, [pc, #364]	@ (3400ad88 <RCCEx_GetUARTCLKFreq+0x300>)
3400ac1c:	4293      	cmp	r3, r2
3400ac1e:	f200 8148 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400ac22:	4a5a      	ldr	r2, [pc, #360]	@ (3400ad8c <RCCEx_GetUARTCLKFreq+0x304>)
3400ac24:	4293      	cmp	r3, r2
3400ac26:	d053      	beq.n	3400acd0 <RCCEx_GetUARTCLKFreq+0x248>
3400ac28:	4a58      	ldr	r2, [pc, #352]	@ (3400ad8c <RCCEx_GetUARTCLKFreq+0x304>)
3400ac2a:	4293      	cmp	r3, r2
3400ac2c:	f200 8141 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400ac30:	4a57      	ldr	r2, [pc, #348]	@ (3400ad90 <RCCEx_GetUARTCLKFreq+0x308>)
3400ac32:	4293      	cmp	r3, r2
3400ac34:	d04c      	beq.n	3400acd0 <RCCEx_GetUARTCLKFreq+0x248>
3400ac36:	4a56      	ldr	r2, [pc, #344]	@ (3400ad90 <RCCEx_GetUARTCLKFreq+0x308>)
3400ac38:	4293      	cmp	r3, r2
3400ac3a:	f200 813a 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400ac3e:	4a55      	ldr	r2, [pc, #340]	@ (3400ad94 <RCCEx_GetUARTCLKFreq+0x30c>)
3400ac40:	4293      	cmp	r3, r2
3400ac42:	d045      	beq.n	3400acd0 <RCCEx_GetUARTCLKFreq+0x248>
3400ac44:	4a53      	ldr	r2, [pc, #332]	@ (3400ad94 <RCCEx_GetUARTCLKFreq+0x30c>)
3400ac46:	4293      	cmp	r3, r2
3400ac48:	f200 8133 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400ac4c:	4a52      	ldr	r2, [pc, #328]	@ (3400ad98 <RCCEx_GetUARTCLKFreq+0x310>)
3400ac4e:	4293      	cmp	r3, r2
3400ac50:	d03e      	beq.n	3400acd0 <RCCEx_GetUARTCLKFreq+0x248>
3400ac52:	4a51      	ldr	r2, [pc, #324]	@ (3400ad98 <RCCEx_GetUARTCLKFreq+0x310>)
3400ac54:	4293      	cmp	r3, r2
3400ac56:	f200 812c 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400ac5a:	4a50      	ldr	r2, [pc, #320]	@ (3400ad9c <RCCEx_GetUARTCLKFreq+0x314>)
3400ac5c:	4293      	cmp	r3, r2
3400ac5e:	d037      	beq.n	3400acd0 <RCCEx_GetUARTCLKFreq+0x248>
3400ac60:	4a4e      	ldr	r2, [pc, #312]	@ (3400ad9c <RCCEx_GetUARTCLKFreq+0x314>)
3400ac62:	4293      	cmp	r3, r2
3400ac64:	f200 8125 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400ac68:	4a4d      	ldr	r2, [pc, #308]	@ (3400ada0 <RCCEx_GetUARTCLKFreq+0x318>)
3400ac6a:	4293      	cmp	r3, r2
3400ac6c:	d018      	beq.n	3400aca0 <RCCEx_GetUARTCLKFreq+0x218>
3400ac6e:	4a4c      	ldr	r2, [pc, #304]	@ (3400ada0 <RCCEx_GetUARTCLKFreq+0x318>)
3400ac70:	4293      	cmp	r3, r2
3400ac72:	f200 811e 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400ac76:	4a4b      	ldr	r2, [pc, #300]	@ (3400ada4 <RCCEx_GetUARTCLKFreq+0x31c>)
3400ac78:	4293      	cmp	r3, r2
3400ac7a:	d011      	beq.n	3400aca0 <RCCEx_GetUARTCLKFreq+0x218>
3400ac7c:	4a49      	ldr	r2, [pc, #292]	@ (3400ada4 <RCCEx_GetUARTCLKFreq+0x31c>)
3400ac7e:	4293      	cmp	r3, r2
3400ac80:	f200 8117 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400ac84:	4a48      	ldr	r2, [pc, #288]	@ (3400ada8 <RCCEx_GetUARTCLKFreq+0x320>)
3400ac86:	4293      	cmp	r3, r2
3400ac88:	d00a      	beq.n	3400aca0 <RCCEx_GetUARTCLKFreq+0x218>
3400ac8a:	4a47      	ldr	r2, [pc, #284]	@ (3400ada8 <RCCEx_GetUARTCLKFreq+0x320>)
3400ac8c:	4293      	cmp	r3, r2
3400ac8e:	f200 8110 	bhi.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
3400ac92:	4a46      	ldr	r2, [pc, #280]	@ (3400adac <RCCEx_GetUARTCLKFreq+0x324>)
3400ac94:	4293      	cmp	r3, r2
3400ac96:	d00f      	beq.n	3400acb8 <RCCEx_GetUARTCLKFreq+0x230>
3400ac98:	4a45      	ldr	r2, [pc, #276]	@ (3400adb0 <RCCEx_GetUARTCLKFreq+0x328>)
3400ac9a:	4293      	cmp	r3, r2
3400ac9c:	f040 8109 	bne.w	3400aeb2 <RCCEx_GetUARTCLKFreq+0x42a>
  {
    case LL_RCC_UART4_CLKSOURCE_PCLK1:
    case LL_RCC_UART5_CLKSOURCE_PCLK1:
    case LL_RCC_UART7_CLKSOURCE_PCLK1:
    case LL_RCC_UART8_CLKSOURCE_PCLK1:
      uart_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400aca0:	f7f8 fce2 	bl	34003668 <HAL_RCC_GetSysClockFreq>
3400aca4:	4603      	mov	r3, r0
3400aca6:	4618      	mov	r0, r3
3400aca8:	f7fd f944 	bl	34007f34 <RCCEx_GetHCLKFreq>
3400acac:	4603      	mov	r3, r0
3400acae:	4618      	mov	r0, r3
3400acb0:	f7fd f951 	bl	34007f56 <RCCEx_GetPCLK1Freq>
3400acb4:	60f8      	str	r0, [r7, #12]
      break;
3400acb6:	e107      	b.n	3400aec8 <RCCEx_GetUARTCLKFreq+0x440>

    case LL_RCC_UART9_CLKSOURCE_PCLK2:
      uart_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400acb8:	f7f8 fcd6 	bl	34003668 <HAL_RCC_GetSysClockFreq>
3400acbc:	4603      	mov	r3, r0
3400acbe:	4618      	mov	r0, r3
3400acc0:	f7fd f938 	bl	34007f34 <RCCEx_GetHCLKFreq>
3400acc4:	4603      	mov	r3, r0
3400acc6:	4618      	mov	r0, r3
3400acc8:	f7fd f955 	bl	34007f76 <RCCEx_GetPCLK2Freq>
3400accc:	60f8      	str	r0, [r7, #12]
      break;
3400acce:	e0fb      	b.n	3400aec8 <RCCEx_GetUARTCLKFreq+0x440>
    case LL_RCC_UART4_CLKSOURCE_CLKP:
    case LL_RCC_UART5_CLKSOURCE_CLKP:
    case LL_RCC_UART7_CLKSOURCE_CLKP:
    case LL_RCC_UART8_CLKSOURCE_CLKP:
    case LL_RCC_UART9_CLKSOURCE_CLKP:
      uart_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400acd0:	2007      	movs	r0, #7
3400acd2:	f7fd fc1b 	bl	3400850c <RCCEx_GetCLKPCLKFreq>
3400acd6:	60f8      	str	r0, [r7, #12]
      break;
3400acd8:	e0f6      	b.n	3400aec8 <RCCEx_GetUARTCLKFreq+0x440>
    case LL_RCC_UART4_CLKSOURCE_IC9:
    case LL_RCC_UART5_CLKSOURCE_IC9:
    case LL_RCC_UART7_CLKSOURCE_IC9:
    case LL_RCC_UART8_CLKSOURCE_IC9:
    case LL_RCC_UART9_CLKSOURCE_IC9:
      if (LL_RCC_IC9_IsEnabled() != 0U)
3400acda:	f7f9 fdbf 	bl	3400485c <LL_RCC_IC9_IsEnabled>
3400acde:	4603      	mov	r3, r0
3400ace0:	2b00      	cmp	r3, #0
3400ace2:	f000 80e8 	beq.w	3400aeb6 <RCCEx_GetUARTCLKFreq+0x42e>
      {
        ic_divider = LL_RCC_IC9_GetDivider();
3400ace6:	f7f9 fddb 	bl	340048a0 <LL_RCC_IC9_GetDivider>
3400acea:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC9_GetSource())
3400acec:	f7f9 fdca 	bl	34004884 <LL_RCC_IC9_GetSource>
3400acf0:	4603      	mov	r3, r0
3400acf2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400acf6:	d06f      	beq.n	3400add8 <RCCEx_GetUARTCLKFreq+0x350>
3400acf8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400acfc:	d875      	bhi.n	3400adea <RCCEx_GetUARTCLKFreq+0x362>
3400acfe:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400ad02:	d060      	beq.n	3400adc6 <RCCEx_GetUARTCLKFreq+0x33e>
3400ad04:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400ad08:	d86f      	bhi.n	3400adea <RCCEx_GetUARTCLKFreq+0x362>
3400ad0a:	2b00      	cmp	r3, #0
3400ad0c:	d003      	beq.n	3400ad16 <RCCEx_GetUARTCLKFreq+0x28e>
3400ad0e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400ad12:	d04f      	beq.n	3400adb4 <RCCEx_GetUARTCLKFreq+0x32c>
            uart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            uart_frequency = uart_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
3400ad14:	e069      	b.n	3400adea <RCCEx_GetUARTCLKFreq+0x362>
            uart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400ad16:	f7fc fff5 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
3400ad1a:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
3400ad1c:	68fa      	ldr	r2, [r7, #12]
3400ad1e:	68bb      	ldr	r3, [r7, #8]
3400ad20:	fbb2 f3f3 	udiv	r3, r2, r3
3400ad24:	60fb      	str	r3, [r7, #12]
            break;
3400ad26:	e061      	b.n	3400adec <RCCEx_GetUARTCLKFreq+0x364>
3400ad28:	07061c30 	.word	0x07061c30
3400ad2c:	07061830 	.word	0x07061830
3400ad30:	07061030 	.word	0x07061030
3400ad34:	07060c30 	.word	0x07060c30
3400ad38:	07060034 	.word	0x07060034
3400ad3c:	07051c30 	.word	0x07051c30
3400ad40:	07051830 	.word	0x07051830
3400ad44:	07051030 	.word	0x07051030
3400ad48:	07050c30 	.word	0x07050c30
3400ad4c:	07050034 	.word	0x07050034
3400ad50:	07041c30 	.word	0x07041c30
3400ad54:	07041830 	.word	0x07041830
3400ad58:	07041030 	.word	0x07041030
3400ad5c:	07040c30 	.word	0x07040c30
3400ad60:	07040034 	.word	0x07040034
3400ad64:	07031c30 	.word	0x07031c30
3400ad68:	07031830 	.word	0x07031830
3400ad6c:	07031030 	.word	0x07031030
3400ad70:	07030c30 	.word	0x07030c30
3400ad74:	07030034 	.word	0x07030034
3400ad78:	07021c30 	.word	0x07021c30
3400ad7c:	07021830 	.word	0x07021830
3400ad80:	07021030 	.word	0x07021030
3400ad84:	07020c30 	.word	0x07020c30
3400ad88:	07020034 	.word	0x07020034
3400ad8c:	07011c30 	.word	0x07011c30
3400ad90:	07011830 	.word	0x07011830
3400ad94:	07011030 	.word	0x07011030
3400ad98:	07010c30 	.word	0x07010c30
3400ad9c:	07010034 	.word	0x07010034
3400ada0:	07001c30 	.word	0x07001c30
3400ada4:	07001830 	.word	0x07001830
3400ada8:	07001030 	.word	0x07001030
3400adac:	07000034 	.word	0x07000034
3400adb0:	07000c30 	.word	0x07000c30
            uart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400adb4:	f7fc ffec 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
3400adb8:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
3400adba:	68fa      	ldr	r2, [r7, #12]
3400adbc:	68bb      	ldr	r3, [r7, #8]
3400adbe:	fbb2 f3f3 	udiv	r3, r2, r3
3400adc2:	60fb      	str	r3, [r7, #12]
            break;
3400adc4:	e012      	b.n	3400adec <RCCEx_GetUARTCLKFreq+0x364>
            uart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400adc6:	f7fd f829 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
3400adca:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
3400adcc:	68fa      	ldr	r2, [r7, #12]
3400adce:	68bb      	ldr	r3, [r7, #8]
3400add0:	fbb2 f3f3 	udiv	r3, r2, r3
3400add4:	60fb      	str	r3, [r7, #12]
            break;
3400add6:	e009      	b.n	3400adec <RCCEx_GetUARTCLKFreq+0x364>
            uart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400add8:	f7fd f866 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
3400addc:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
3400adde:	68fa      	ldr	r2, [r7, #12]
3400ade0:	68bb      	ldr	r3, [r7, #8]
3400ade2:	fbb2 f3f3 	udiv	r3, r2, r3
3400ade6:	60fb      	str	r3, [r7, #12]
            break;
3400ade8:	e000      	b.n	3400adec <RCCEx_GetUARTCLKFreq+0x364>
            break;
3400adea:	bf00      	nop
        }
      }
      break;
3400adec:	e063      	b.n	3400aeb6 <RCCEx_GetUARTCLKFreq+0x42e>
    case LL_RCC_UART4_CLKSOURCE_IC14:
    case LL_RCC_UART5_CLKSOURCE_IC14:
    case LL_RCC_UART7_CLKSOURCE_IC14:
    case LL_RCC_UART8_CLKSOURCE_IC14:
    case LL_RCC_UART9_CLKSOURCE_IC14:
      if (LL_RCC_IC14_IsEnabled() != 0U)
3400adee:	f7f9 fe35 	bl	34004a5c <LL_RCC_IC14_IsEnabled>
3400adf2:	4603      	mov	r3, r0
3400adf4:	2b00      	cmp	r3, #0
3400adf6:	d060      	beq.n	3400aeba <RCCEx_GetUARTCLKFreq+0x432>
      {
        ic_divider = LL_RCC_IC14_GetDivider();
3400adf8:	f7f9 fe52 	bl	34004aa0 <LL_RCC_IC14_GetDivider>
3400adfc:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC14_GetSource())
3400adfe:	f7f9 fe41 	bl	34004a84 <LL_RCC_IC14_GetSource>
3400ae02:	4603      	mov	r3, r0
3400ae04:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400ae08:	d029      	beq.n	3400ae5e <RCCEx_GetUARTCLKFreq+0x3d6>
3400ae0a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400ae0e:	d82f      	bhi.n	3400ae70 <RCCEx_GetUARTCLKFreq+0x3e8>
3400ae10:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400ae14:	d01a      	beq.n	3400ae4c <RCCEx_GetUARTCLKFreq+0x3c4>
3400ae16:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400ae1a:	d829      	bhi.n	3400ae70 <RCCEx_GetUARTCLKFreq+0x3e8>
3400ae1c:	2b00      	cmp	r3, #0
3400ae1e:	d003      	beq.n	3400ae28 <RCCEx_GetUARTCLKFreq+0x3a0>
3400ae20:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400ae24:	d009      	beq.n	3400ae3a <RCCEx_GetUARTCLKFreq+0x3b2>
            uart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            uart_frequency = uart_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
3400ae26:	e023      	b.n	3400ae70 <RCCEx_GetUARTCLKFreq+0x3e8>
            uart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400ae28:	f7fc ff6c 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
3400ae2c:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
3400ae2e:	68fa      	ldr	r2, [r7, #12]
3400ae30:	68bb      	ldr	r3, [r7, #8]
3400ae32:	fbb2 f3f3 	udiv	r3, r2, r3
3400ae36:	60fb      	str	r3, [r7, #12]
            break;
3400ae38:	e01b      	b.n	3400ae72 <RCCEx_GetUARTCLKFreq+0x3ea>
            uart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400ae3a:	f7fc ffa9 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
3400ae3e:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
3400ae40:	68fa      	ldr	r2, [r7, #12]
3400ae42:	68bb      	ldr	r3, [r7, #8]
3400ae44:	fbb2 f3f3 	udiv	r3, r2, r3
3400ae48:	60fb      	str	r3, [r7, #12]
            break;
3400ae4a:	e012      	b.n	3400ae72 <RCCEx_GetUARTCLKFreq+0x3ea>
            uart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400ae4c:	f7fc ffe6 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
3400ae50:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
3400ae52:	68fa      	ldr	r2, [r7, #12]
3400ae54:	68bb      	ldr	r3, [r7, #8]
3400ae56:	fbb2 f3f3 	udiv	r3, r2, r3
3400ae5a:	60fb      	str	r3, [r7, #12]
            break;
3400ae5c:	e009      	b.n	3400ae72 <RCCEx_GetUARTCLKFreq+0x3ea>
            uart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400ae5e:	f7fd f823 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
3400ae62:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
3400ae64:	68fa      	ldr	r2, [r7, #12]
3400ae66:	68bb      	ldr	r3, [r7, #8]
3400ae68:	fbb2 f3f3 	udiv	r3, r2, r3
3400ae6c:	60fb      	str	r3, [r7, #12]
            break;
3400ae6e:	e000      	b.n	3400ae72 <RCCEx_GetUARTCLKFreq+0x3ea>
            break;
3400ae70:	bf00      	nop
        }
      }
      break;
3400ae72:	e022      	b.n	3400aeba <RCCEx_GetUARTCLKFreq+0x432>
    case LL_RCC_UART4_CLKSOURCE_HSI:
    case LL_RCC_UART5_CLKSOURCE_HSI:
    case LL_RCC_UART7_CLKSOURCE_HSI:
    case LL_RCC_UART8_CLKSOURCE_HSI:
    case LL_RCC_UART9_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
3400ae74:	f7f8 fcce 	bl	34003814 <LL_RCC_HSI_IsReady>
3400ae78:	4603      	mov	r3, r0
3400ae7a:	2b00      	cmp	r3, #0
3400ae7c:	d01f      	beq.n	3400aebe <RCCEx_GetUARTCLKFreq+0x436>
      {
        uart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400ae7e:	f7f8 fcdb 	bl	34003838 <LL_RCC_HSI_GetDivider>
3400ae82:	4603      	mov	r3, r0
3400ae84:	09db      	lsrs	r3, r3, #7
3400ae86:	4a13      	ldr	r2, [pc, #76]	@ (3400aed4 <RCCEx_GetUARTCLKFreq+0x44c>)
3400ae88:	fa22 f303 	lsr.w	r3, r2, r3
3400ae8c:	60fb      	str	r3, [r7, #12]
      }
      break;
3400ae8e:	e016      	b.n	3400aebe <RCCEx_GetUARTCLKFreq+0x436>
    case LL_RCC_UART4_CLKSOURCE_MSI:
    case LL_RCC_UART5_CLKSOURCE_MSI:
    case LL_RCC_UART7_CLKSOURCE_MSI:
    case LL_RCC_UART8_CLKSOURCE_MSI:
    case LL_RCC_UART9_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
3400ae90:	f7f8 fce0 	bl	34003854 <LL_RCC_MSI_IsReady>
3400ae94:	4603      	mov	r3, r0
3400ae96:	2b00      	cmp	r3, #0
3400ae98:	d013      	beq.n	3400aec2 <RCCEx_GetUARTCLKFreq+0x43a>
      {
        uart_frequency = MSI_VALUE;
3400ae9a:	4b0f      	ldr	r3, [pc, #60]	@ (3400aed8 <RCCEx_GetUARTCLKFreq+0x450>)
3400ae9c:	60fb      	str	r3, [r7, #12]
      }
      break;
3400ae9e:	e010      	b.n	3400aec2 <RCCEx_GetUARTCLKFreq+0x43a>
    case LL_RCC_UART4_CLKSOURCE_LSE:
    case LL_RCC_UART5_CLKSOURCE_LSE:
    case LL_RCC_UART7_CLKSOURCE_LSE:
    case LL_RCC_UART8_CLKSOURCE_LSE:
    case LL_RCC_UART9_CLKSOURCE_LSE:
      if (LL_RCC_LSE_IsReady() != 0U)
3400aea0:	f7f8 fcf8 	bl	34003894 <LL_RCC_LSE_IsReady>
3400aea4:	4603      	mov	r3, r0
3400aea6:	2b00      	cmp	r3, #0
3400aea8:	d00d      	beq.n	3400aec6 <RCCEx_GetUARTCLKFreq+0x43e>
      {
        uart_frequency = LSE_VALUE;
3400aeaa:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
3400aeae:	60fb      	str	r3, [r7, #12]
      }
      break;
3400aeb0:	e009      	b.n	3400aec6 <RCCEx_GetUARTCLKFreq+0x43e>

    default:
      /* Unexpected case */
      break;
3400aeb2:	bf00      	nop
3400aeb4:	e008      	b.n	3400aec8 <RCCEx_GetUARTCLKFreq+0x440>
      break;
3400aeb6:	bf00      	nop
3400aeb8:	e006      	b.n	3400aec8 <RCCEx_GetUARTCLKFreq+0x440>
      break;
3400aeba:	bf00      	nop
3400aebc:	e004      	b.n	3400aec8 <RCCEx_GetUARTCLKFreq+0x440>
      break;
3400aebe:	bf00      	nop
3400aec0:	e002      	b.n	3400aec8 <RCCEx_GetUARTCLKFreq+0x440>
      break;
3400aec2:	bf00      	nop
3400aec4:	e000      	b.n	3400aec8 <RCCEx_GetUARTCLKFreq+0x440>
      break;
3400aec6:	bf00      	nop
  }

  return uart_frequency;
3400aec8:	68fb      	ldr	r3, [r7, #12]
}
3400aeca:	4618      	mov	r0, r3
3400aecc:	3710      	adds	r7, #16
3400aece:	46bd      	mov	sp, r7
3400aed0:	bd80      	pop	{r7, pc}
3400aed2:	bf00      	nop
3400aed4:	03d09000 	.word	0x03d09000
3400aed8:	003d0900 	.word	0x003d0900

3400aedc <RCCEx_GetUSARTCLKFreq>:
  *         @arg @ref RCCEx_USART10_Clock_Source
  * @retval USART clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetUSARTCLKFreq(uint32_t USARTxSource)
{
3400aedc:	b580      	push	{r7, lr}
3400aede:	b084      	sub	sp, #16
3400aee0:	af00      	add	r7, sp, #0
3400aee2:	6078      	str	r0, [r7, #4]
  uint32_t usart_frequency = RCC_PERIPH_FREQUENCY_NO;
3400aee4:	2300      	movs	r3, #0
3400aee6:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
3400aee8:	6878      	ldr	r0, [r7, #4]
3400aeea:	f7f9 f87b 	bl	34003fe4 <LL_RCC_GetUSARTClockSource>
3400aeee:	4603      	mov	r3, r0
3400aef0:	4aa2      	ldr	r2, [pc, #648]	@ (3400b17c <RCCEx_GetUSARTCLKFreq+0x2a0>)
3400aef2:	4293      	cmp	r3, r2
3400aef4:	f000 81e8 	beq.w	3400b2c8 <RCCEx_GetUSARTCLKFreq+0x3ec>
3400aef8:	4aa0      	ldr	r2, [pc, #640]	@ (3400b17c <RCCEx_GetUSARTCLKFreq+0x2a0>)
3400aefa:	4293      	cmp	r3, r2
3400aefc:	f200 8203 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400af00:	4a9f      	ldr	r2, [pc, #636]	@ (3400b180 <RCCEx_GetUSARTCLKFreq+0x2a4>)
3400af02:	4293      	cmp	r3, r2
3400af04:	f000 81e0 	beq.w	3400b2c8 <RCCEx_GetUSARTCLKFreq+0x3ec>
3400af08:	4a9d      	ldr	r2, [pc, #628]	@ (3400b180 <RCCEx_GetUSARTCLKFreq+0x2a4>)
3400af0a:	4293      	cmp	r3, r2
3400af0c:	f200 81fb 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400af10:	4a9c      	ldr	r2, [pc, #624]	@ (3400b184 <RCCEx_GetUSARTCLKFreq+0x2a8>)
3400af12:	4293      	cmp	r3, r2
3400af14:	f000 81d8 	beq.w	3400b2c8 <RCCEx_GetUSARTCLKFreq+0x3ec>
3400af18:	4a9a      	ldr	r2, [pc, #616]	@ (3400b184 <RCCEx_GetUSARTCLKFreq+0x2a8>)
3400af1a:	4293      	cmp	r3, r2
3400af1c:	f200 81f3 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400af20:	4a99      	ldr	r2, [pc, #612]	@ (3400b188 <RCCEx_GetUSARTCLKFreq+0x2ac>)
3400af22:	4293      	cmp	r3, r2
3400af24:	f000 81d0 	beq.w	3400b2c8 <RCCEx_GetUSARTCLKFreq+0x3ec>
3400af28:	4a97      	ldr	r2, [pc, #604]	@ (3400b188 <RCCEx_GetUSARTCLKFreq+0x2ac>)
3400af2a:	4293      	cmp	r3, r2
3400af2c:	f200 81eb 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400af30:	4a96      	ldr	r2, [pc, #600]	@ (3400b18c <RCCEx_GetUSARTCLKFreq+0x2b0>)
3400af32:	4293      	cmp	r3, r2
3400af34:	f000 81c8 	beq.w	3400b2c8 <RCCEx_GetUSARTCLKFreq+0x3ec>
3400af38:	4a94      	ldr	r2, [pc, #592]	@ (3400b18c <RCCEx_GetUSARTCLKFreq+0x2b0>)
3400af3a:	4293      	cmp	r3, r2
3400af3c:	f200 81e3 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400af40:	4a93      	ldr	r2, [pc, #588]	@ (3400b190 <RCCEx_GetUSARTCLKFreq+0x2b4>)
3400af42:	4293      	cmp	r3, r2
3400af44:	f000 81ce 	beq.w	3400b2e4 <RCCEx_GetUSARTCLKFreq+0x408>
3400af48:	4a91      	ldr	r2, [pc, #580]	@ (3400b190 <RCCEx_GetUSARTCLKFreq+0x2b4>)
3400af4a:	4293      	cmp	r3, r2
3400af4c:	f200 81db 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400af50:	4a90      	ldr	r2, [pc, #576]	@ (3400b194 <RCCEx_GetUSARTCLKFreq+0x2b8>)
3400af52:	4293      	cmp	r3, r2
3400af54:	f000 81c6 	beq.w	3400b2e4 <RCCEx_GetUSARTCLKFreq+0x408>
3400af58:	4a8e      	ldr	r2, [pc, #568]	@ (3400b194 <RCCEx_GetUSARTCLKFreq+0x2b8>)
3400af5a:	4293      	cmp	r3, r2
3400af5c:	f200 81d3 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400af60:	4a8d      	ldr	r2, [pc, #564]	@ (3400b198 <RCCEx_GetUSARTCLKFreq+0x2bc>)
3400af62:	4293      	cmp	r3, r2
3400af64:	f000 81be 	beq.w	3400b2e4 <RCCEx_GetUSARTCLKFreq+0x408>
3400af68:	4a8b      	ldr	r2, [pc, #556]	@ (3400b198 <RCCEx_GetUSARTCLKFreq+0x2bc>)
3400af6a:	4293      	cmp	r3, r2
3400af6c:	f200 81cb 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400af70:	4a8a      	ldr	r2, [pc, #552]	@ (3400b19c <RCCEx_GetUSARTCLKFreq+0x2c0>)
3400af72:	4293      	cmp	r3, r2
3400af74:	f000 81b6 	beq.w	3400b2e4 <RCCEx_GetUSARTCLKFreq+0x408>
3400af78:	4a88      	ldr	r2, [pc, #544]	@ (3400b19c <RCCEx_GetUSARTCLKFreq+0x2c0>)
3400af7a:	4293      	cmp	r3, r2
3400af7c:	f200 81c3 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400af80:	4a87      	ldr	r2, [pc, #540]	@ (3400b1a0 <RCCEx_GetUSARTCLKFreq+0x2c4>)
3400af82:	4293      	cmp	r3, r2
3400af84:	f000 81ae 	beq.w	3400b2e4 <RCCEx_GetUSARTCLKFreq+0x408>
3400af88:	4a85      	ldr	r2, [pc, #532]	@ (3400b1a0 <RCCEx_GetUSARTCLKFreq+0x2c4>)
3400af8a:	4293      	cmp	r3, r2
3400af8c:	f200 81bb 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400af90:	4a84      	ldr	r2, [pc, #528]	@ (3400b1a4 <RCCEx_GetUSARTCLKFreq+0x2c8>)
3400af92:	4293      	cmp	r3, r2
3400af94:	f000 81ae 	beq.w	3400b2f4 <RCCEx_GetUSARTCLKFreq+0x418>
3400af98:	4a82      	ldr	r2, [pc, #520]	@ (3400b1a4 <RCCEx_GetUSARTCLKFreq+0x2c8>)
3400af9a:	4293      	cmp	r3, r2
3400af9c:	f200 81b3 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400afa0:	4a81      	ldr	r2, [pc, #516]	@ (3400b1a8 <RCCEx_GetUSARTCLKFreq+0x2cc>)
3400afa2:	4293      	cmp	r3, r2
3400afa4:	f000 81a6 	beq.w	3400b2f4 <RCCEx_GetUSARTCLKFreq+0x418>
3400afa8:	4a7f      	ldr	r2, [pc, #508]	@ (3400b1a8 <RCCEx_GetUSARTCLKFreq+0x2cc>)
3400afaa:	4293      	cmp	r3, r2
3400afac:	f200 81ab 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400afb0:	4a7e      	ldr	r2, [pc, #504]	@ (3400b1ac <RCCEx_GetUSARTCLKFreq+0x2d0>)
3400afb2:	4293      	cmp	r3, r2
3400afb4:	f000 819e 	beq.w	3400b2f4 <RCCEx_GetUSARTCLKFreq+0x418>
3400afb8:	4a7c      	ldr	r2, [pc, #496]	@ (3400b1ac <RCCEx_GetUSARTCLKFreq+0x2d0>)
3400afba:	4293      	cmp	r3, r2
3400afbc:	f200 81a3 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400afc0:	4a7b      	ldr	r2, [pc, #492]	@ (3400b1b0 <RCCEx_GetUSARTCLKFreq+0x2d4>)
3400afc2:	4293      	cmp	r3, r2
3400afc4:	f000 8196 	beq.w	3400b2f4 <RCCEx_GetUSARTCLKFreq+0x418>
3400afc8:	4a79      	ldr	r2, [pc, #484]	@ (3400b1b0 <RCCEx_GetUSARTCLKFreq+0x2d4>)
3400afca:	4293      	cmp	r3, r2
3400afcc:	f200 819b 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400afd0:	4a78      	ldr	r2, [pc, #480]	@ (3400b1b4 <RCCEx_GetUSARTCLKFreq+0x2d8>)
3400afd2:	4293      	cmp	r3, r2
3400afd4:	f000 818e 	beq.w	3400b2f4 <RCCEx_GetUSARTCLKFreq+0x418>
3400afd8:	4a76      	ldr	r2, [pc, #472]	@ (3400b1b4 <RCCEx_GetUSARTCLKFreq+0x2d8>)
3400afda:	4293      	cmp	r3, r2
3400afdc:	f200 8193 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400afe0:	4a75      	ldr	r2, [pc, #468]	@ (3400b1b8 <RCCEx_GetUSARTCLKFreq+0x2dc>)
3400afe2:	4293      	cmp	r3, r2
3400afe4:	f000 812d 	beq.w	3400b242 <RCCEx_GetUSARTCLKFreq+0x366>
3400afe8:	4a73      	ldr	r2, [pc, #460]	@ (3400b1b8 <RCCEx_GetUSARTCLKFreq+0x2dc>)
3400afea:	4293      	cmp	r3, r2
3400afec:	f200 818b 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400aff0:	4a72      	ldr	r2, [pc, #456]	@ (3400b1bc <RCCEx_GetUSARTCLKFreq+0x2e0>)
3400aff2:	4293      	cmp	r3, r2
3400aff4:	f000 8125 	beq.w	3400b242 <RCCEx_GetUSARTCLKFreq+0x366>
3400aff8:	4a70      	ldr	r2, [pc, #448]	@ (3400b1bc <RCCEx_GetUSARTCLKFreq+0x2e0>)
3400affa:	4293      	cmp	r3, r2
3400affc:	f200 8183 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400b000:	4a6f      	ldr	r2, [pc, #444]	@ (3400b1c0 <RCCEx_GetUSARTCLKFreq+0x2e4>)
3400b002:	4293      	cmp	r3, r2
3400b004:	f000 811d 	beq.w	3400b242 <RCCEx_GetUSARTCLKFreq+0x366>
3400b008:	4a6d      	ldr	r2, [pc, #436]	@ (3400b1c0 <RCCEx_GetUSARTCLKFreq+0x2e4>)
3400b00a:	4293      	cmp	r3, r2
3400b00c:	f200 817b 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400b010:	4a6c      	ldr	r2, [pc, #432]	@ (3400b1c4 <RCCEx_GetUSARTCLKFreq+0x2e8>)
3400b012:	4293      	cmp	r3, r2
3400b014:	f000 8115 	beq.w	3400b242 <RCCEx_GetUSARTCLKFreq+0x366>
3400b018:	4a6a      	ldr	r2, [pc, #424]	@ (3400b1c4 <RCCEx_GetUSARTCLKFreq+0x2e8>)
3400b01a:	4293      	cmp	r3, r2
3400b01c:	f200 8173 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400b020:	4a69      	ldr	r2, [pc, #420]	@ (3400b1c8 <RCCEx_GetUSARTCLKFreq+0x2ec>)
3400b022:	4293      	cmp	r3, r2
3400b024:	f000 810d 	beq.w	3400b242 <RCCEx_GetUSARTCLKFreq+0x366>
3400b028:	4a67      	ldr	r2, [pc, #412]	@ (3400b1c8 <RCCEx_GetUSARTCLKFreq+0x2ec>)
3400b02a:	4293      	cmp	r3, r2
3400b02c:	f200 816b 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400b030:	4a66      	ldr	r2, [pc, #408]	@ (3400b1cc <RCCEx_GetUSARTCLKFreq+0x2f0>)
3400b032:	4293      	cmp	r3, r2
3400b034:	d07b      	beq.n	3400b12e <RCCEx_GetUSARTCLKFreq+0x252>
3400b036:	4a65      	ldr	r2, [pc, #404]	@ (3400b1cc <RCCEx_GetUSARTCLKFreq+0x2f0>)
3400b038:	4293      	cmp	r3, r2
3400b03a:	f200 8164 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400b03e:	4a64      	ldr	r2, [pc, #400]	@ (3400b1d0 <RCCEx_GetUSARTCLKFreq+0x2f4>)
3400b040:	4293      	cmp	r3, r2
3400b042:	d074      	beq.n	3400b12e <RCCEx_GetUSARTCLKFreq+0x252>
3400b044:	4a62      	ldr	r2, [pc, #392]	@ (3400b1d0 <RCCEx_GetUSARTCLKFreq+0x2f4>)
3400b046:	4293      	cmp	r3, r2
3400b048:	f200 815d 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400b04c:	4a61      	ldr	r2, [pc, #388]	@ (3400b1d4 <RCCEx_GetUSARTCLKFreq+0x2f8>)
3400b04e:	4293      	cmp	r3, r2
3400b050:	d06d      	beq.n	3400b12e <RCCEx_GetUSARTCLKFreq+0x252>
3400b052:	4a60      	ldr	r2, [pc, #384]	@ (3400b1d4 <RCCEx_GetUSARTCLKFreq+0x2f8>)
3400b054:	4293      	cmp	r3, r2
3400b056:	f200 8156 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400b05a:	4a5f      	ldr	r2, [pc, #380]	@ (3400b1d8 <RCCEx_GetUSARTCLKFreq+0x2fc>)
3400b05c:	4293      	cmp	r3, r2
3400b05e:	d066      	beq.n	3400b12e <RCCEx_GetUSARTCLKFreq+0x252>
3400b060:	4a5d      	ldr	r2, [pc, #372]	@ (3400b1d8 <RCCEx_GetUSARTCLKFreq+0x2fc>)
3400b062:	4293      	cmp	r3, r2
3400b064:	f200 814f 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400b068:	4a5c      	ldr	r2, [pc, #368]	@ (3400b1dc <RCCEx_GetUSARTCLKFreq+0x300>)
3400b06a:	4293      	cmp	r3, r2
3400b06c:	d05f      	beq.n	3400b12e <RCCEx_GetUSARTCLKFreq+0x252>
3400b06e:	4a5b      	ldr	r2, [pc, #364]	@ (3400b1dc <RCCEx_GetUSARTCLKFreq+0x300>)
3400b070:	4293      	cmp	r3, r2
3400b072:	f200 8148 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400b076:	4a5a      	ldr	r2, [pc, #360]	@ (3400b1e0 <RCCEx_GetUSARTCLKFreq+0x304>)
3400b078:	4293      	cmp	r3, r2
3400b07a:	d053      	beq.n	3400b124 <RCCEx_GetUSARTCLKFreq+0x248>
3400b07c:	4a58      	ldr	r2, [pc, #352]	@ (3400b1e0 <RCCEx_GetUSARTCLKFreq+0x304>)
3400b07e:	4293      	cmp	r3, r2
3400b080:	f200 8141 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400b084:	4a57      	ldr	r2, [pc, #348]	@ (3400b1e4 <RCCEx_GetUSARTCLKFreq+0x308>)
3400b086:	4293      	cmp	r3, r2
3400b088:	d04c      	beq.n	3400b124 <RCCEx_GetUSARTCLKFreq+0x248>
3400b08a:	4a56      	ldr	r2, [pc, #344]	@ (3400b1e4 <RCCEx_GetUSARTCLKFreq+0x308>)
3400b08c:	4293      	cmp	r3, r2
3400b08e:	f200 813a 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400b092:	4a55      	ldr	r2, [pc, #340]	@ (3400b1e8 <RCCEx_GetUSARTCLKFreq+0x30c>)
3400b094:	4293      	cmp	r3, r2
3400b096:	d045      	beq.n	3400b124 <RCCEx_GetUSARTCLKFreq+0x248>
3400b098:	4a53      	ldr	r2, [pc, #332]	@ (3400b1e8 <RCCEx_GetUSARTCLKFreq+0x30c>)
3400b09a:	4293      	cmp	r3, r2
3400b09c:	f200 8133 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400b0a0:	4a52      	ldr	r2, [pc, #328]	@ (3400b1ec <RCCEx_GetUSARTCLKFreq+0x310>)
3400b0a2:	4293      	cmp	r3, r2
3400b0a4:	d03e      	beq.n	3400b124 <RCCEx_GetUSARTCLKFreq+0x248>
3400b0a6:	4a51      	ldr	r2, [pc, #324]	@ (3400b1ec <RCCEx_GetUSARTCLKFreq+0x310>)
3400b0a8:	4293      	cmp	r3, r2
3400b0aa:	f200 812c 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400b0ae:	4a50      	ldr	r2, [pc, #320]	@ (3400b1f0 <RCCEx_GetUSARTCLKFreq+0x314>)
3400b0b0:	4293      	cmp	r3, r2
3400b0b2:	d037      	beq.n	3400b124 <RCCEx_GetUSARTCLKFreq+0x248>
3400b0b4:	4a4e      	ldr	r2, [pc, #312]	@ (3400b1f0 <RCCEx_GetUSARTCLKFreq+0x314>)
3400b0b6:	4293      	cmp	r3, r2
3400b0b8:	f200 8125 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400b0bc:	4a4d      	ldr	r2, [pc, #308]	@ (3400b1f4 <RCCEx_GetUSARTCLKFreq+0x318>)
3400b0be:	4293      	cmp	r3, r2
3400b0c0:	d018      	beq.n	3400b0f4 <RCCEx_GetUSARTCLKFreq+0x218>
3400b0c2:	4a4c      	ldr	r2, [pc, #304]	@ (3400b1f4 <RCCEx_GetUSARTCLKFreq+0x318>)
3400b0c4:	4293      	cmp	r3, r2
3400b0c6:	f200 811e 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400b0ca:	4a4b      	ldr	r2, [pc, #300]	@ (3400b1f8 <RCCEx_GetUSARTCLKFreq+0x31c>)
3400b0cc:	4293      	cmp	r3, r2
3400b0ce:	d01d      	beq.n	3400b10c <RCCEx_GetUSARTCLKFreq+0x230>
3400b0d0:	4a49      	ldr	r2, [pc, #292]	@ (3400b1f8 <RCCEx_GetUSARTCLKFreq+0x31c>)
3400b0d2:	4293      	cmp	r3, r2
3400b0d4:	f200 8117 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400b0d8:	4a48      	ldr	r2, [pc, #288]	@ (3400b1fc <RCCEx_GetUSARTCLKFreq+0x320>)
3400b0da:	4293      	cmp	r3, r2
3400b0dc:	d00a      	beq.n	3400b0f4 <RCCEx_GetUSARTCLKFreq+0x218>
3400b0de:	4a47      	ldr	r2, [pc, #284]	@ (3400b1fc <RCCEx_GetUSARTCLKFreq+0x320>)
3400b0e0:	4293      	cmp	r3, r2
3400b0e2:	f200 8110 	bhi.w	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
3400b0e6:	4a46      	ldr	r2, [pc, #280]	@ (3400b200 <RCCEx_GetUSARTCLKFreq+0x324>)
3400b0e8:	4293      	cmp	r3, r2
3400b0ea:	d003      	beq.n	3400b0f4 <RCCEx_GetUSARTCLKFreq+0x218>
3400b0ec:	4a45      	ldr	r2, [pc, #276]	@ (3400b204 <RCCEx_GetUSARTCLKFreq+0x328>)
3400b0ee:	4293      	cmp	r3, r2
3400b0f0:	d00c      	beq.n	3400b10c <RCCEx_GetUSARTCLKFreq+0x230>
      }
      break;

    default:
      /* Unexpected case */
      break;
3400b0f2:	e108      	b.n	3400b306 <RCCEx_GetUSARTCLKFreq+0x42a>
      usart_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400b0f4:	f7f8 fab8 	bl	34003668 <HAL_RCC_GetSysClockFreq>
3400b0f8:	4603      	mov	r3, r0
3400b0fa:	4618      	mov	r0, r3
3400b0fc:	f7fc ff1a 	bl	34007f34 <RCCEx_GetHCLKFreq>
3400b100:	4603      	mov	r3, r0
3400b102:	4618      	mov	r0, r3
3400b104:	f7fc ff37 	bl	34007f76 <RCCEx_GetPCLK2Freq>
3400b108:	60f8      	str	r0, [r7, #12]
      break;
3400b10a:	e107      	b.n	3400b31c <RCCEx_GetUSARTCLKFreq+0x440>
      usart_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3400b10c:	f7f8 faac 	bl	34003668 <HAL_RCC_GetSysClockFreq>
3400b110:	4603      	mov	r3, r0
3400b112:	4618      	mov	r0, r3
3400b114:	f7fc ff0e 	bl	34007f34 <RCCEx_GetHCLKFreq>
3400b118:	4603      	mov	r3, r0
3400b11a:	4618      	mov	r0, r3
3400b11c:	f7fc ff1b 	bl	34007f56 <RCCEx_GetPCLK1Freq>
3400b120:	60f8      	str	r0, [r7, #12]
      break;
3400b122:	e0fb      	b.n	3400b31c <RCCEx_GetUSARTCLKFreq+0x440>
      usart_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400b124:	2007      	movs	r0, #7
3400b126:	f7fd f9f1 	bl	3400850c <RCCEx_GetCLKPCLKFreq>
3400b12a:	60f8      	str	r0, [r7, #12]
      break;
3400b12c:	e0f6      	b.n	3400b31c <RCCEx_GetUSARTCLKFreq+0x440>
      if (LL_RCC_IC9_IsEnabled() != 0U)
3400b12e:	f7f9 fb95 	bl	3400485c <LL_RCC_IC9_IsEnabled>
3400b132:	4603      	mov	r3, r0
3400b134:	2b00      	cmp	r3, #0
3400b136:	f000 80e8 	beq.w	3400b30a <RCCEx_GetUSARTCLKFreq+0x42e>
        ic_divider = LL_RCC_IC9_GetDivider();
3400b13a:	f7f9 fbb1 	bl	340048a0 <LL_RCC_IC9_GetDivider>
3400b13e:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC9_GetSource())
3400b140:	f7f9 fba0 	bl	34004884 <LL_RCC_IC9_GetSource>
3400b144:	4603      	mov	r3, r0
3400b146:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400b14a:	d06f      	beq.n	3400b22c <RCCEx_GetUSARTCLKFreq+0x350>
3400b14c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400b150:	d875      	bhi.n	3400b23e <RCCEx_GetUSARTCLKFreq+0x362>
3400b152:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400b156:	d060      	beq.n	3400b21a <RCCEx_GetUSARTCLKFreq+0x33e>
3400b158:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400b15c:	d86f      	bhi.n	3400b23e <RCCEx_GetUSARTCLKFreq+0x362>
3400b15e:	2b00      	cmp	r3, #0
3400b160:	d003      	beq.n	3400b16a <RCCEx_GetUSARTCLKFreq+0x28e>
3400b162:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400b166:	d04f      	beq.n	3400b208 <RCCEx_GetUSARTCLKFreq+0x32c>
            break;
3400b168:	e069      	b.n	3400b23e <RCCEx_GetUSARTCLKFreq+0x362>
            usart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400b16a:	f7fc fdcb 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
3400b16e:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
3400b170:	68fa      	ldr	r2, [r7, #12]
3400b172:	68bb      	ldr	r3, [r7, #8]
3400b174:	fbb2 f3f3 	udiv	r3, r2, r3
3400b178:	60fb      	str	r3, [r7, #12]
            break;
3400b17a:	e061      	b.n	3400b240 <RCCEx_GetUSARTCLKFreq+0x364>
3400b17c:	07061430 	.word	0x07061430
3400b180:	07060830 	.word	0x07060830
3400b184:	07060434 	.word	0x07060434
3400b188:	07060430 	.word	0x07060430
3400b18c:	07060030 	.word	0x07060030
3400b190:	07051430 	.word	0x07051430
3400b194:	07050830 	.word	0x07050830
3400b198:	07050434 	.word	0x07050434
3400b19c:	07050430 	.word	0x07050430
3400b1a0:	07050030 	.word	0x07050030
3400b1a4:	07041430 	.word	0x07041430
3400b1a8:	07040830 	.word	0x07040830
3400b1ac:	07040434 	.word	0x07040434
3400b1b0:	07040430 	.word	0x07040430
3400b1b4:	07040030 	.word	0x07040030
3400b1b8:	07031430 	.word	0x07031430
3400b1bc:	07030830 	.word	0x07030830
3400b1c0:	07030434 	.word	0x07030434
3400b1c4:	07030430 	.word	0x07030430
3400b1c8:	07030030 	.word	0x07030030
3400b1cc:	07021430 	.word	0x07021430
3400b1d0:	07020830 	.word	0x07020830
3400b1d4:	07020434 	.word	0x07020434
3400b1d8:	07020430 	.word	0x07020430
3400b1dc:	07020030 	.word	0x07020030
3400b1e0:	07011430 	.word	0x07011430
3400b1e4:	07010830 	.word	0x07010830
3400b1e8:	07010434 	.word	0x07010434
3400b1ec:	07010430 	.word	0x07010430
3400b1f0:	07010030 	.word	0x07010030
3400b1f4:	07001430 	.word	0x07001430
3400b1f8:	07000830 	.word	0x07000830
3400b1fc:	07000434 	.word	0x07000434
3400b200:	07000030 	.word	0x07000030
3400b204:	07000430 	.word	0x07000430
            usart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400b208:	f7fc fdc2 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
3400b20c:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
3400b20e:	68fa      	ldr	r2, [r7, #12]
3400b210:	68bb      	ldr	r3, [r7, #8]
3400b212:	fbb2 f3f3 	udiv	r3, r2, r3
3400b216:	60fb      	str	r3, [r7, #12]
            break;
3400b218:	e012      	b.n	3400b240 <RCCEx_GetUSARTCLKFreq+0x364>
            usart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400b21a:	f7fc fdff 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
3400b21e:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
3400b220:	68fa      	ldr	r2, [r7, #12]
3400b222:	68bb      	ldr	r3, [r7, #8]
3400b224:	fbb2 f3f3 	udiv	r3, r2, r3
3400b228:	60fb      	str	r3, [r7, #12]
            break;
3400b22a:	e009      	b.n	3400b240 <RCCEx_GetUSARTCLKFreq+0x364>
            usart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400b22c:	f7fc fe3c 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
3400b230:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
3400b232:	68fa      	ldr	r2, [r7, #12]
3400b234:	68bb      	ldr	r3, [r7, #8]
3400b236:	fbb2 f3f3 	udiv	r3, r2, r3
3400b23a:	60fb      	str	r3, [r7, #12]
            break;
3400b23c:	e000      	b.n	3400b240 <RCCEx_GetUSARTCLKFreq+0x364>
            break;
3400b23e:	bf00      	nop
      break;
3400b240:	e063      	b.n	3400b30a <RCCEx_GetUSARTCLKFreq+0x42e>
      if (LL_RCC_IC14_IsEnabled() != 0U)
3400b242:	f7f9 fc0b 	bl	34004a5c <LL_RCC_IC14_IsEnabled>
3400b246:	4603      	mov	r3, r0
3400b248:	2b00      	cmp	r3, #0
3400b24a:	d060      	beq.n	3400b30e <RCCEx_GetUSARTCLKFreq+0x432>
        ic_divider = LL_RCC_IC14_GetDivider();
3400b24c:	f7f9 fc28 	bl	34004aa0 <LL_RCC_IC14_GetDivider>
3400b250:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC14_GetSource())
3400b252:	f7f9 fc17 	bl	34004a84 <LL_RCC_IC14_GetSource>
3400b256:	4603      	mov	r3, r0
3400b258:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400b25c:	d029      	beq.n	3400b2b2 <RCCEx_GetUSARTCLKFreq+0x3d6>
3400b25e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400b262:	d82f      	bhi.n	3400b2c4 <RCCEx_GetUSARTCLKFreq+0x3e8>
3400b264:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400b268:	d01a      	beq.n	3400b2a0 <RCCEx_GetUSARTCLKFreq+0x3c4>
3400b26a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400b26e:	d829      	bhi.n	3400b2c4 <RCCEx_GetUSARTCLKFreq+0x3e8>
3400b270:	2b00      	cmp	r3, #0
3400b272:	d003      	beq.n	3400b27c <RCCEx_GetUSARTCLKFreq+0x3a0>
3400b274:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400b278:	d009      	beq.n	3400b28e <RCCEx_GetUSARTCLKFreq+0x3b2>
            break;
3400b27a:	e023      	b.n	3400b2c4 <RCCEx_GetUSARTCLKFreq+0x3e8>
            usart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400b27c:	f7fc fd42 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
3400b280:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
3400b282:	68fa      	ldr	r2, [r7, #12]
3400b284:	68bb      	ldr	r3, [r7, #8]
3400b286:	fbb2 f3f3 	udiv	r3, r2, r3
3400b28a:	60fb      	str	r3, [r7, #12]
            break;
3400b28c:	e01b      	b.n	3400b2c6 <RCCEx_GetUSARTCLKFreq+0x3ea>
            usart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400b28e:	f7fc fd7f 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
3400b292:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
3400b294:	68fa      	ldr	r2, [r7, #12]
3400b296:	68bb      	ldr	r3, [r7, #8]
3400b298:	fbb2 f3f3 	udiv	r3, r2, r3
3400b29c:	60fb      	str	r3, [r7, #12]
            break;
3400b29e:	e012      	b.n	3400b2c6 <RCCEx_GetUSARTCLKFreq+0x3ea>
            usart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400b2a0:	f7fc fdbc 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
3400b2a4:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
3400b2a6:	68fa      	ldr	r2, [r7, #12]
3400b2a8:	68bb      	ldr	r3, [r7, #8]
3400b2aa:	fbb2 f3f3 	udiv	r3, r2, r3
3400b2ae:	60fb      	str	r3, [r7, #12]
            break;
3400b2b0:	e009      	b.n	3400b2c6 <RCCEx_GetUSARTCLKFreq+0x3ea>
            usart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400b2b2:	f7fc fdf9 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
3400b2b6:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
3400b2b8:	68fa      	ldr	r2, [r7, #12]
3400b2ba:	68bb      	ldr	r3, [r7, #8]
3400b2bc:	fbb2 f3f3 	udiv	r3, r2, r3
3400b2c0:	60fb      	str	r3, [r7, #12]
            break;
3400b2c2:	e000      	b.n	3400b2c6 <RCCEx_GetUSARTCLKFreq+0x3ea>
            break;
3400b2c4:	bf00      	nop
      break;
3400b2c6:	e022      	b.n	3400b30e <RCCEx_GetUSARTCLKFreq+0x432>
      if (LL_RCC_HSI_IsReady() != 0U)
3400b2c8:	f7f8 faa4 	bl	34003814 <LL_RCC_HSI_IsReady>
3400b2cc:	4603      	mov	r3, r0
3400b2ce:	2b00      	cmp	r3, #0
3400b2d0:	d01f      	beq.n	3400b312 <RCCEx_GetUSARTCLKFreq+0x436>
        usart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400b2d2:	f7f8 fab1 	bl	34003838 <LL_RCC_HSI_GetDivider>
3400b2d6:	4603      	mov	r3, r0
3400b2d8:	09db      	lsrs	r3, r3, #7
3400b2da:	4a13      	ldr	r2, [pc, #76]	@ (3400b328 <RCCEx_GetUSARTCLKFreq+0x44c>)
3400b2dc:	fa22 f303 	lsr.w	r3, r2, r3
3400b2e0:	60fb      	str	r3, [r7, #12]
      break;
3400b2e2:	e016      	b.n	3400b312 <RCCEx_GetUSARTCLKFreq+0x436>
      if (LL_RCC_MSI_IsReady() != 0U)
3400b2e4:	f7f8 fab6 	bl	34003854 <LL_RCC_MSI_IsReady>
3400b2e8:	4603      	mov	r3, r0
3400b2ea:	2b00      	cmp	r3, #0
3400b2ec:	d013      	beq.n	3400b316 <RCCEx_GetUSARTCLKFreq+0x43a>
        usart_frequency = MSI_VALUE;
3400b2ee:	4b0f      	ldr	r3, [pc, #60]	@ (3400b32c <RCCEx_GetUSARTCLKFreq+0x450>)
3400b2f0:	60fb      	str	r3, [r7, #12]
      break;
3400b2f2:	e010      	b.n	3400b316 <RCCEx_GetUSARTCLKFreq+0x43a>
      if (LL_RCC_LSE_IsReady() != 0U)
3400b2f4:	f7f8 face 	bl	34003894 <LL_RCC_LSE_IsReady>
3400b2f8:	4603      	mov	r3, r0
3400b2fa:	2b00      	cmp	r3, #0
3400b2fc:	d00d      	beq.n	3400b31a <RCCEx_GetUSARTCLKFreq+0x43e>
        usart_frequency = LSE_VALUE;
3400b2fe:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
3400b302:	60fb      	str	r3, [r7, #12]
      break;
3400b304:	e009      	b.n	3400b31a <RCCEx_GetUSARTCLKFreq+0x43e>
      break;
3400b306:	bf00      	nop
3400b308:	e008      	b.n	3400b31c <RCCEx_GetUSARTCLKFreq+0x440>
      break;
3400b30a:	bf00      	nop
3400b30c:	e006      	b.n	3400b31c <RCCEx_GetUSARTCLKFreq+0x440>
      break;
3400b30e:	bf00      	nop
3400b310:	e004      	b.n	3400b31c <RCCEx_GetUSARTCLKFreq+0x440>
      break;
3400b312:	bf00      	nop
3400b314:	e002      	b.n	3400b31c <RCCEx_GetUSARTCLKFreq+0x440>
      break;
3400b316:	bf00      	nop
3400b318:	e000      	b.n	3400b31c <RCCEx_GetUSARTCLKFreq+0x440>
      break;
3400b31a:	bf00      	nop
  }

  return usart_frequency;
3400b31c:	68fb      	ldr	r3, [r7, #12]
}
3400b31e:	4618      	mov	r0, r3
3400b320:	3710      	adds	r7, #16
3400b322:	46bd      	mov	sp, r7
3400b324:	bd80      	pop	{r7, pc}
3400b326:	bf00      	nop
3400b328:	03d09000 	.word	0x03d09000
3400b32c:	003d0900 	.word	0x003d0900

3400b330 <RCCEx_GetOTGPHYCLKFreq>:
  *         @arg @ref RCCEx_USB_OTGHS2_Clock_Source
  * @retval OTGPHY clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready or Disabled
  */
static uint32_t RCCEx_GetOTGPHYCLKFreq(uint32_t OTGPHYxSource)
{
3400b330:	b580      	push	{r7, lr}
3400b332:	b084      	sub	sp, #16
3400b334:	af00      	add	r7, sp, #0
3400b336:	6078      	str	r0, [r7, #4]
  uint32_t usb_frequency = RCC_PERIPH_FREQUENCY_NO;
3400b338:	2300      	movs	r3, #0
3400b33a:	60fb      	str	r3, [r7, #12]

  switch (LL_RCC_GetUSBClockSource(OTGPHYxSource))
3400b33c:	6878      	ldr	r0, [r7, #4]
3400b33e:	f7f8 fe69 	bl	34004014 <LL_RCC_GetUSBClockSource>
3400b342:	4603      	mov	r3, r0
3400b344:	4a4b      	ldr	r2, [pc, #300]	@ (3400b474 <RCCEx_GetOTGPHYCLKFreq+0x144>)
3400b346:	4293      	cmp	r3, r2
3400b348:	d035      	beq.n	3400b3b6 <RCCEx_GetOTGPHYCLKFreq+0x86>
3400b34a:	4a4a      	ldr	r2, [pc, #296]	@ (3400b474 <RCCEx_GetOTGPHYCLKFreq+0x144>)
3400b34c:	4293      	cmp	r3, r2
3400b34e:	f200 8085 	bhi.w	3400b45c <RCCEx_GetOTGPHYCLKFreq+0x12c>
3400b352:	4a49      	ldr	r2, [pc, #292]	@ (3400b478 <RCCEx_GetOTGPHYCLKFreq+0x148>)
3400b354:	4293      	cmp	r3, r2
3400b356:	d02e      	beq.n	3400b3b6 <RCCEx_GetOTGPHYCLKFreq+0x86>
3400b358:	4a47      	ldr	r2, [pc, #284]	@ (3400b478 <RCCEx_GetOTGPHYCLKFreq+0x148>)
3400b35a:	4293      	cmp	r3, r2
3400b35c:	d87e      	bhi.n	3400b45c <RCCEx_GetOTGPHYCLKFreq+0x12c>
3400b35e:	4a47      	ldr	r2, [pc, #284]	@ (3400b47c <RCCEx_GetOTGPHYCLKFreq+0x14c>)
3400b360:	4293      	cmp	r3, r2
3400b362:	d038      	beq.n	3400b3d6 <RCCEx_GetOTGPHYCLKFreq+0xa6>
3400b364:	4a45      	ldr	r2, [pc, #276]	@ (3400b47c <RCCEx_GetOTGPHYCLKFreq+0x14c>)
3400b366:	4293      	cmp	r3, r2
3400b368:	d878      	bhi.n	3400b45c <RCCEx_GetOTGPHYCLKFreq+0x12c>
3400b36a:	4a45      	ldr	r2, [pc, #276]	@ (3400b480 <RCCEx_GetOTGPHYCLKFreq+0x150>)
3400b36c:	4293      	cmp	r3, r2
3400b36e:	d032      	beq.n	3400b3d6 <RCCEx_GetOTGPHYCLKFreq+0xa6>
3400b370:	4a43      	ldr	r2, [pc, #268]	@ (3400b480 <RCCEx_GetOTGPHYCLKFreq+0x150>)
3400b372:	4293      	cmp	r3, r2
3400b374:	d872      	bhi.n	3400b45c <RCCEx_GetOTGPHYCLKFreq+0x12c>
3400b376:	4a43      	ldr	r2, [pc, #268]	@ (3400b484 <RCCEx_GetOTGPHYCLKFreq+0x154>)
3400b378:	4293      	cmp	r3, r2
3400b37a:	d00f      	beq.n	3400b39c <RCCEx_GetOTGPHYCLKFreq+0x6c>
3400b37c:	4a41      	ldr	r2, [pc, #260]	@ (3400b484 <RCCEx_GetOTGPHYCLKFreq+0x154>)
3400b37e:	4293      	cmp	r3, r2
3400b380:	d86c      	bhi.n	3400b45c <RCCEx_GetOTGPHYCLKFreq+0x12c>
3400b382:	4a41      	ldr	r2, [pc, #260]	@ (3400b488 <RCCEx_GetOTGPHYCLKFreq+0x158>)
3400b384:	4293      	cmp	r3, r2
3400b386:	d009      	beq.n	3400b39c <RCCEx_GetOTGPHYCLKFreq+0x6c>
3400b388:	4a3f      	ldr	r2, [pc, #252]	@ (3400b488 <RCCEx_GetOTGPHYCLKFreq+0x158>)
3400b38a:	4293      	cmp	r3, r2
3400b38c:	d866      	bhi.n	3400b45c <RCCEx_GetOTGPHYCLKFreq+0x12c>
3400b38e:	4a3f      	ldr	r2, [pc, #252]	@ (3400b48c <RCCEx_GetOTGPHYCLKFreq+0x15c>)
3400b390:	4293      	cmp	r3, r2
3400b392:	d008      	beq.n	3400b3a6 <RCCEx_GetOTGPHYCLKFreq+0x76>
3400b394:	4a3e      	ldr	r2, [pc, #248]	@ (3400b490 <RCCEx_GetOTGPHYCLKFreq+0x160>)
3400b396:	4293      	cmp	r3, r2
3400b398:	d005      	beq.n	3400b3a6 <RCCEx_GetOTGPHYCLKFreq+0x76>
      }
      break;

    default:
      /* Unexpected case */
      break;
3400b39a:	e05f      	b.n	3400b45c <RCCEx_GetOTGPHYCLKFreq+0x12c>
      usb_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400b39c:	2007      	movs	r0, #7
3400b39e:	f7fd f8b5 	bl	3400850c <RCCEx_GetCLKPCLKFreq>
3400b3a2:	60f8      	str	r0, [r7, #12]
      break;
3400b3a4:	e061      	b.n	3400b46a <RCCEx_GetOTGPHYCLKFreq+0x13a>
      if (LL_RCC_HSE_IsReady() != 0U)
3400b3a6:	f7f8 fa23 	bl	340037f0 <LL_RCC_HSE_IsReady>
3400b3aa:	4603      	mov	r3, r0
3400b3ac:	2b00      	cmp	r3, #0
3400b3ae:	d057      	beq.n	3400b460 <RCCEx_GetOTGPHYCLKFreq+0x130>
        usb_frequency = HSE_VALUE / 2U;
3400b3b0:	4b38      	ldr	r3, [pc, #224]	@ (3400b494 <RCCEx_GetOTGPHYCLKFreq+0x164>)
3400b3b2:	60fb      	str	r3, [r7, #12]
      break;
3400b3b4:	e054      	b.n	3400b460 <RCCEx_GetOTGPHYCLKFreq+0x130>
      if (LL_RCC_HSE_IsReady() != 0U)
3400b3b6:	f7f8 fa1b 	bl	340037f0 <LL_RCC_HSE_IsReady>
3400b3ba:	4603      	mov	r3, r0
3400b3bc:	2b00      	cmp	r3, #0
3400b3be:	d051      	beq.n	3400b464 <RCCEx_GetOTGPHYCLKFreq+0x134>
        if (LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock() == 0UL)
3400b3c0:	f7f8 fa04 	bl	340037cc <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>
3400b3c4:	4603      	mov	r3, r0
3400b3c6:	2b00      	cmp	r3, #0
3400b3c8:	d102      	bne.n	3400b3d0 <RCCEx_GetOTGPHYCLKFreq+0xa0>
          usb_frequency = HSE_VALUE;
3400b3ca:	4b33      	ldr	r3, [pc, #204]	@ (3400b498 <RCCEx_GetOTGPHYCLKFreq+0x168>)
3400b3cc:	60fb      	str	r3, [r7, #12]
      break;
3400b3ce:	e049      	b.n	3400b464 <RCCEx_GetOTGPHYCLKFreq+0x134>
          usb_frequency = HSE_VALUE / 2U;
3400b3d0:	4b30      	ldr	r3, [pc, #192]	@ (3400b494 <RCCEx_GetOTGPHYCLKFreq+0x164>)
3400b3d2:	60fb      	str	r3, [r7, #12]
      break;
3400b3d4:	e046      	b.n	3400b464 <RCCEx_GetOTGPHYCLKFreq+0x134>
      if (LL_RCC_IC15_IsEnabled() != 0U)
3400b3d6:	f7f9 fb81 	bl	34004adc <LL_RCC_IC15_IsEnabled>
3400b3da:	4603      	mov	r3, r0
3400b3dc:	2b00      	cmp	r3, #0
3400b3de:	d043      	beq.n	3400b468 <RCCEx_GetOTGPHYCLKFreq+0x138>
        uint32_t ic_divider = LL_RCC_IC15_GetDivider();
3400b3e0:	f7f9 fb9e 	bl	34004b20 <LL_RCC_IC15_GetDivider>
3400b3e4:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC15_GetSource())
3400b3e6:	f7f9 fb8d 	bl	34004b04 <LL_RCC_IC15_GetSource>
3400b3ea:	4603      	mov	r3, r0
3400b3ec:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400b3f0:	d029      	beq.n	3400b446 <RCCEx_GetOTGPHYCLKFreq+0x116>
3400b3f2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400b3f6:	d82f      	bhi.n	3400b458 <RCCEx_GetOTGPHYCLKFreq+0x128>
3400b3f8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400b3fc:	d01a      	beq.n	3400b434 <RCCEx_GetOTGPHYCLKFreq+0x104>
3400b3fe:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400b402:	d829      	bhi.n	3400b458 <RCCEx_GetOTGPHYCLKFreq+0x128>
3400b404:	2b00      	cmp	r3, #0
3400b406:	d003      	beq.n	3400b410 <RCCEx_GetOTGPHYCLKFreq+0xe0>
3400b408:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400b40c:	d009      	beq.n	3400b422 <RCCEx_GetOTGPHYCLKFreq+0xf2>
            break;
3400b40e:	e023      	b.n	3400b458 <RCCEx_GetOTGPHYCLKFreq+0x128>
            usb_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400b410:	f7fc fc78 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
3400b414:	60f8      	str	r0, [r7, #12]
            usb_frequency = usb_frequency / ic_divider;
3400b416:	68fa      	ldr	r2, [r7, #12]
3400b418:	68bb      	ldr	r3, [r7, #8]
3400b41a:	fbb2 f3f3 	udiv	r3, r2, r3
3400b41e:	60fb      	str	r3, [r7, #12]
            break;
3400b420:	e01b      	b.n	3400b45a <RCCEx_GetOTGPHYCLKFreq+0x12a>
            usb_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400b422:	f7fc fcb5 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
3400b426:	60f8      	str	r0, [r7, #12]
            usb_frequency = usb_frequency / ic_divider;
3400b428:	68fa      	ldr	r2, [r7, #12]
3400b42a:	68bb      	ldr	r3, [r7, #8]
3400b42c:	fbb2 f3f3 	udiv	r3, r2, r3
3400b430:	60fb      	str	r3, [r7, #12]
            break;
3400b432:	e012      	b.n	3400b45a <RCCEx_GetOTGPHYCLKFreq+0x12a>
            usb_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400b434:	f7fc fcf2 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
3400b438:	60f8      	str	r0, [r7, #12]
            usb_frequency = usb_frequency / ic_divider;
3400b43a:	68fa      	ldr	r2, [r7, #12]
3400b43c:	68bb      	ldr	r3, [r7, #8]
3400b43e:	fbb2 f3f3 	udiv	r3, r2, r3
3400b442:	60fb      	str	r3, [r7, #12]
            break;
3400b444:	e009      	b.n	3400b45a <RCCEx_GetOTGPHYCLKFreq+0x12a>
            usb_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400b446:	f7fc fd2f 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
3400b44a:	60f8      	str	r0, [r7, #12]
            usb_frequency = usb_frequency / ic_divider;
3400b44c:	68fa      	ldr	r2, [r7, #12]
3400b44e:	68bb      	ldr	r3, [r7, #8]
3400b450:	fbb2 f3f3 	udiv	r3, r2, r3
3400b454:	60fb      	str	r3, [r7, #12]
            break;
3400b456:	e000      	b.n	3400b45a <RCCEx_GetOTGPHYCLKFreq+0x12a>
            break;
3400b458:	bf00      	nop
      break;
3400b45a:	e005      	b.n	3400b468 <RCCEx_GetOTGPHYCLKFreq+0x138>
      break;
3400b45c:	bf00      	nop
3400b45e:	e004      	b.n	3400b46a <RCCEx_GetOTGPHYCLKFreq+0x13a>
      break;
3400b460:	bf00      	nop
3400b462:	e002      	b.n	3400b46a <RCCEx_GetOTGPHYCLKFreq+0x13a>
      break;
3400b464:	bf00      	nop
3400b466:	e000      	b.n	3400b46a <RCCEx_GetOTGPHYCLKFreq+0x13a>
      break;
3400b468:	bf00      	nop
  }

  return usb_frequency;
3400b46a:	68fb      	ldr	r3, [r7, #12]
}
3400b46c:	4618      	mov	r0, r3
3400b46e:	3710      	adds	r7, #16
3400b470:	46bd      	mov	sp, r7
3400b472:	bd80      	pop	{r7, pc}
3400b474:	03031414 	.word	0x03031414
3400b478:	03030c14 	.word	0x03030c14
3400b47c:	03021414 	.word	0x03021414
3400b480:	03020c14 	.word	0x03020c14
3400b484:	03011414 	.word	0x03011414
3400b488:	03010c14 	.word	0x03010c14
3400b48c:	03000c14 	.word	0x03000c14
3400b490:	03001414 	.word	0x03001414
3400b494:	00b71b00 	.word	0x00b71b00
3400b498:	016e3600 	.word	0x016e3600

3400b49c <RCCEx_GetOTGPHYCKREFCLKFreq>:
  *         @arg @ref RCCEx_USBPHY2_Clock_Source
  * @retval OTGPHYCKREF clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready or Disabled
  */
static uint32_t RCCEx_GetOTGPHYCKREFCLKFreq(uint32_t OTGPHYxCKREFSource)
{
3400b49c:	b580      	push	{r7, lr}
3400b49e:	b084      	sub	sp, #16
3400b4a0:	af00      	add	r7, sp, #0
3400b4a2:	6078      	str	r0, [r7, #4]
  uint32_t usb_frequency = RCC_PERIPH_FREQUENCY_NO;
3400b4a4:	2300      	movs	r3, #0
3400b4a6:	60fb      	str	r3, [r7, #12]

  switch (LL_RCC_GetUSBClockSource(OTGPHYxCKREFSource))
3400b4a8:	6878      	ldr	r0, [r7, #4]
3400b4aa:	f7f8 fdb3 	bl	34004014 <LL_RCC_GetUSBClockSource>
3400b4ae:	4603      	mov	r3, r0
3400b4b0:	4a1a      	ldr	r2, [pc, #104]	@ (3400b51c <RCCEx_GetOTGPHYCKREFCLKFreq+0x80>)
3400b4b2:	4293      	cmp	r3, r2
3400b4b4:	d00f      	beq.n	3400b4d6 <RCCEx_GetOTGPHYCKREFCLKFreq+0x3a>
3400b4b6:	4a19      	ldr	r2, [pc, #100]	@ (3400b51c <RCCEx_GetOTGPHYCKREFCLKFreq+0x80>)
3400b4b8:	4293      	cmp	r3, r2
3400b4ba:	d826      	bhi.n	3400b50a <RCCEx_GetOTGPHYCKREFCLKFreq+0x6e>
3400b4bc:	4a18      	ldr	r2, [pc, #96]	@ (3400b520 <RCCEx_GetOTGPHYCKREFCLKFreq+0x84>)
3400b4be:	4293      	cmp	r3, r2
3400b4c0:	d009      	beq.n	3400b4d6 <RCCEx_GetOTGPHYCKREFCLKFreq+0x3a>
3400b4c2:	4a17      	ldr	r2, [pc, #92]	@ (3400b520 <RCCEx_GetOTGPHYCKREFCLKFreq+0x84>)
3400b4c4:	4293      	cmp	r3, r2
3400b4c6:	d820      	bhi.n	3400b50a <RCCEx_GetOTGPHYCKREFCLKFreq+0x6e>
3400b4c8:	4a16      	ldr	r2, [pc, #88]	@ (3400b524 <RCCEx_GetOTGPHYCKREFCLKFreq+0x88>)
3400b4ca:	4293      	cmp	r3, r2
3400b4cc:	d013      	beq.n	3400b4f6 <RCCEx_GetOTGPHYCKREFCLKFreq+0x5a>
3400b4ce:	4a16      	ldr	r2, [pc, #88]	@ (3400b528 <RCCEx_GetOTGPHYCKREFCLKFreq+0x8c>)
3400b4d0:	4293      	cmp	r3, r2
3400b4d2:	d015      	beq.n	3400b500 <RCCEx_GetOTGPHYCKREFCLKFreq+0x64>
      usb_frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
      break;

    default:
      /* Unexpected case */
      break;
3400b4d4:	e019      	b.n	3400b50a <RCCEx_GetOTGPHYCKREFCLKFreq+0x6e>
      if (LL_RCC_HSE_IsReady() != 0U)
3400b4d6:	f7f8 f98b 	bl	340037f0 <LL_RCC_HSE_IsReady>
3400b4da:	4603      	mov	r3, r0
3400b4dc:	2b00      	cmp	r3, #0
3400b4de:	d016      	beq.n	3400b50e <RCCEx_GetOTGPHYCKREFCLKFreq+0x72>
        if (LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock() == 0UL)
3400b4e0:	f7f8 f974 	bl	340037cc <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>
3400b4e4:	4603      	mov	r3, r0
3400b4e6:	2b00      	cmp	r3, #0
3400b4e8:	d102      	bne.n	3400b4f0 <RCCEx_GetOTGPHYCKREFCLKFreq+0x54>
          usb_frequency = HSE_VALUE;
3400b4ea:	4b10      	ldr	r3, [pc, #64]	@ (3400b52c <RCCEx_GetOTGPHYCKREFCLKFreq+0x90>)
3400b4ec:	60fb      	str	r3, [r7, #12]
      break;
3400b4ee:	e00e      	b.n	3400b50e <RCCEx_GetOTGPHYCKREFCLKFreq+0x72>
          usb_frequency = HSE_VALUE / 2U;
3400b4f0:	4b0f      	ldr	r3, [pc, #60]	@ (3400b530 <RCCEx_GetOTGPHYCKREFCLKFreq+0x94>)
3400b4f2:	60fb      	str	r3, [r7, #12]
      break;
3400b4f4:	e00b      	b.n	3400b50e <RCCEx_GetOTGPHYCKREFCLKFreq+0x72>
      usb_frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY1_CLKSOURCE);
3400b4f6:	480f      	ldr	r0, [pc, #60]	@ (3400b534 <RCCEx_GetOTGPHYCKREFCLKFreq+0x98>)
3400b4f8:	f7ff ff1a 	bl	3400b330 <RCCEx_GetOTGPHYCLKFreq>
3400b4fc:	60f8      	str	r0, [r7, #12]
      break;
3400b4fe:	e007      	b.n	3400b510 <RCCEx_GetOTGPHYCKREFCLKFreq+0x74>
      usb_frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
3400b500:	480d      	ldr	r0, [pc, #52]	@ (3400b538 <RCCEx_GetOTGPHYCKREFCLKFreq+0x9c>)
3400b502:	f7ff ff15 	bl	3400b330 <RCCEx_GetOTGPHYCLKFreq>
3400b506:	60f8      	str	r0, [r7, #12]
      break;
3400b508:	e002      	b.n	3400b510 <RCCEx_GetOTGPHYCKREFCLKFreq+0x74>
      break;
3400b50a:	bf00      	nop
3400b50c:	e000      	b.n	3400b510 <RCCEx_GetOTGPHYCKREFCLKFreq+0x74>
      break;
3400b50e:	bf00      	nop
  }

  return usb_frequency;
3400b510:	68fb      	ldr	r3, [r7, #12]
}
3400b512:	4618      	mov	r0, r3
3400b514:	3710      	adds	r7, #16
3400b516:	46bd      	mov	sp, r7
3400b518:	bd80      	pop	{r7, pc}
3400b51a:	bf00      	nop
3400b51c:	01011814 	.word	0x01011814
3400b520:	01011014 	.word	0x01011014
3400b524:	01001014 	.word	0x01001014
3400b528:	01001814 	.word	0x01001814
3400b52c:	016e3600 	.word	0x016e3600
3400b530:	00b71b00 	.word	0x00b71b00
3400b534:	03000c14 	.word	0x03000c14
3400b538:	03001414 	.word	0x03001414

3400b53c <RCCEx_GetXSPICLKFreq>:
  * @retval XSPI clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */

static uint32_t RCCEx_GetXSPICLKFreq(uint32_t XSPIxSource)
{
3400b53c:	b580      	push	{r7, lr}
3400b53e:	b084      	sub	sp, #16
3400b540:	af00      	add	r7, sp, #0
3400b542:	6078      	str	r0, [r7, #4]
  uint32_t xspi_frequency = RCC_PERIPH_FREQUENCY_NO;
3400b544:	2300      	movs	r3, #0
3400b546:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetXSPIClockSource(XSPIxSource))
3400b548:	6878      	ldr	r0, [r7, #4]
3400b54a:	f7f8 fd6f 	bl	3400402c <LL_RCC_GetXSPIClockSource>
3400b54e:	4603      	mov	r3, r0
3400b550:	4a76      	ldr	r2, [pc, #472]	@ (3400b72c <RCCEx_GetXSPICLKFreq+0x1f0>)
3400b552:	4293      	cmp	r3, r2
3400b554:	f000 809d 	beq.w	3400b692 <RCCEx_GetXSPICLKFreq+0x156>
3400b558:	4a74      	ldr	r2, [pc, #464]	@ (3400b72c <RCCEx_GetXSPICLKFreq+0x1f0>)
3400b55a:	4293      	cmp	r3, r2
3400b55c:	f200 80dc 	bhi.w	3400b718 <RCCEx_GetXSPICLKFreq+0x1dc>
3400b560:	4a73      	ldr	r2, [pc, #460]	@ (3400b730 <RCCEx_GetXSPICLKFreq+0x1f4>)
3400b562:	4293      	cmp	r3, r2
3400b564:	f000 8095 	beq.w	3400b692 <RCCEx_GetXSPICLKFreq+0x156>
3400b568:	4a71      	ldr	r2, [pc, #452]	@ (3400b730 <RCCEx_GetXSPICLKFreq+0x1f4>)
3400b56a:	4293      	cmp	r3, r2
3400b56c:	f200 80d4 	bhi.w	3400b718 <RCCEx_GetXSPICLKFreq+0x1dc>
3400b570:	4a70      	ldr	r2, [pc, #448]	@ (3400b734 <RCCEx_GetXSPICLKFreq+0x1f8>)
3400b572:	4293      	cmp	r3, r2
3400b574:	f000 808d 	beq.w	3400b692 <RCCEx_GetXSPICLKFreq+0x156>
3400b578:	4a6e      	ldr	r2, [pc, #440]	@ (3400b734 <RCCEx_GetXSPICLKFreq+0x1f8>)
3400b57a:	4293      	cmp	r3, r2
3400b57c:	f200 80cc 	bhi.w	3400b718 <RCCEx_GetXSPICLKFreq+0x1dc>
3400b580:	4a6d      	ldr	r2, [pc, #436]	@ (3400b738 <RCCEx_GetXSPICLKFreq+0x1fc>)
3400b582:	4293      	cmp	r3, r2
3400b584:	d041      	beq.n	3400b60a <RCCEx_GetXSPICLKFreq+0xce>
3400b586:	4a6c      	ldr	r2, [pc, #432]	@ (3400b738 <RCCEx_GetXSPICLKFreq+0x1fc>)
3400b588:	4293      	cmp	r3, r2
3400b58a:	f200 80c5 	bhi.w	3400b718 <RCCEx_GetXSPICLKFreq+0x1dc>
3400b58e:	4a6b      	ldr	r2, [pc, #428]	@ (3400b73c <RCCEx_GetXSPICLKFreq+0x200>)
3400b590:	4293      	cmp	r3, r2
3400b592:	d03a      	beq.n	3400b60a <RCCEx_GetXSPICLKFreq+0xce>
3400b594:	4a69      	ldr	r2, [pc, #420]	@ (3400b73c <RCCEx_GetXSPICLKFreq+0x200>)
3400b596:	4293      	cmp	r3, r2
3400b598:	f200 80be 	bhi.w	3400b718 <RCCEx_GetXSPICLKFreq+0x1dc>
3400b59c:	4a68      	ldr	r2, [pc, #416]	@ (3400b740 <RCCEx_GetXSPICLKFreq+0x204>)
3400b59e:	4293      	cmp	r3, r2
3400b5a0:	d033      	beq.n	3400b60a <RCCEx_GetXSPICLKFreq+0xce>
3400b5a2:	4a67      	ldr	r2, [pc, #412]	@ (3400b740 <RCCEx_GetXSPICLKFreq+0x204>)
3400b5a4:	4293      	cmp	r3, r2
3400b5a6:	f200 80b7 	bhi.w	3400b718 <RCCEx_GetXSPICLKFreq+0x1dc>
3400b5aa:	4a66      	ldr	r2, [pc, #408]	@ (3400b744 <RCCEx_GetXSPICLKFreq+0x208>)
3400b5ac:	4293      	cmp	r3, r2
3400b5ae:	d027      	beq.n	3400b600 <RCCEx_GetXSPICLKFreq+0xc4>
3400b5b0:	4a64      	ldr	r2, [pc, #400]	@ (3400b744 <RCCEx_GetXSPICLKFreq+0x208>)
3400b5b2:	4293      	cmp	r3, r2
3400b5b4:	f200 80b0 	bhi.w	3400b718 <RCCEx_GetXSPICLKFreq+0x1dc>
3400b5b8:	4a63      	ldr	r2, [pc, #396]	@ (3400b748 <RCCEx_GetXSPICLKFreq+0x20c>)
3400b5ba:	4293      	cmp	r3, r2
3400b5bc:	d020      	beq.n	3400b600 <RCCEx_GetXSPICLKFreq+0xc4>
3400b5be:	4a62      	ldr	r2, [pc, #392]	@ (3400b748 <RCCEx_GetXSPICLKFreq+0x20c>)
3400b5c0:	4293      	cmp	r3, r2
3400b5c2:	f200 80a9 	bhi.w	3400b718 <RCCEx_GetXSPICLKFreq+0x1dc>
3400b5c6:	4a61      	ldr	r2, [pc, #388]	@ (3400b74c <RCCEx_GetXSPICLKFreq+0x210>)
3400b5c8:	4293      	cmp	r3, r2
3400b5ca:	d019      	beq.n	3400b600 <RCCEx_GetXSPICLKFreq+0xc4>
3400b5cc:	4a5f      	ldr	r2, [pc, #380]	@ (3400b74c <RCCEx_GetXSPICLKFreq+0x210>)
3400b5ce:	4293      	cmp	r3, r2
3400b5d0:	f200 80a2 	bhi.w	3400b718 <RCCEx_GetXSPICLKFreq+0x1dc>
3400b5d4:	4a5e      	ldr	r2, [pc, #376]	@ (3400b750 <RCCEx_GetXSPICLKFreq+0x214>)
3400b5d6:	4293      	cmp	r3, r2
3400b5d8:	d00a      	beq.n	3400b5f0 <RCCEx_GetXSPICLKFreq+0xb4>
3400b5da:	4a5d      	ldr	r2, [pc, #372]	@ (3400b750 <RCCEx_GetXSPICLKFreq+0x214>)
3400b5dc:	4293      	cmp	r3, r2
3400b5de:	f200 809b 	bhi.w	3400b718 <RCCEx_GetXSPICLKFreq+0x1dc>
3400b5e2:	4a5c      	ldr	r2, [pc, #368]	@ (3400b754 <RCCEx_GetXSPICLKFreq+0x218>)
3400b5e4:	4293      	cmp	r3, r2
3400b5e6:	d003      	beq.n	3400b5f0 <RCCEx_GetXSPICLKFreq+0xb4>
3400b5e8:	4a5b      	ldr	r2, [pc, #364]	@ (3400b758 <RCCEx_GetXSPICLKFreq+0x21c>)
3400b5ea:	4293      	cmp	r3, r2
3400b5ec:	f040 8094 	bne.w	3400b718 <RCCEx_GetXSPICLKFreq+0x1dc>
  {
    case LL_RCC_XSPI1_CLKSOURCE_HCLK:
    case LL_RCC_XSPI2_CLKSOURCE_HCLK:
    case LL_RCC_XSPI3_CLKSOURCE_HCLK:
      xspi_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3400b5f0:	f7f8 f83a 	bl	34003668 <HAL_RCC_GetSysClockFreq>
3400b5f4:	4603      	mov	r3, r0
3400b5f6:	4618      	mov	r0, r3
3400b5f8:	f7fc fc9c 	bl	34007f34 <RCCEx_GetHCLKFreq>
3400b5fc:	60f8      	str	r0, [r7, #12]
      break;
3400b5fe:	e090      	b.n	3400b722 <RCCEx_GetXSPICLKFreq+0x1e6>

    case LL_RCC_XSPI1_CLKSOURCE_CLKP:
    case LL_RCC_XSPI2_CLKSOURCE_CLKP:
    case LL_RCC_XSPI3_CLKSOURCE_CLKP:
      xspi_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3400b600:	2007      	movs	r0, #7
3400b602:	f7fc ff83 	bl	3400850c <RCCEx_GetCLKPCLKFreq>
3400b606:	60f8      	str	r0, [r7, #12]
      break;
3400b608:	e08b      	b.n	3400b722 <RCCEx_GetXSPICLKFreq+0x1e6>

    case LL_RCC_XSPI1_CLKSOURCE_IC3:
    case LL_RCC_XSPI2_CLKSOURCE_IC3:
    case LL_RCC_XSPI3_CLKSOURCE_IC3:
      if (LL_RCC_IC3_IsEnabled() != 0U)
3400b60a:	f7f8 ffe7 	bl	340045dc <LL_RCC_IC3_IsEnabled>
3400b60e:	4603      	mov	r3, r0
3400b610:	2b00      	cmp	r3, #0
3400b612:	f000 8083 	beq.w	3400b71c <RCCEx_GetXSPICLKFreq+0x1e0>
      {
        ic_divider = LL_RCC_IC3_GetDivider();
3400b616:	f7f9 f803 	bl	34004620 <LL_RCC_IC3_GetDivider>
3400b61a:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC3_GetSource())
3400b61c:	f7f8 fff2 	bl	34004604 <LL_RCC_IC3_GetSource>
3400b620:	4603      	mov	r3, r0
3400b622:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400b626:	d029      	beq.n	3400b67c <RCCEx_GetXSPICLKFreq+0x140>
3400b628:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400b62c:	d82f      	bhi.n	3400b68e <RCCEx_GetXSPICLKFreq+0x152>
3400b62e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400b632:	d01a      	beq.n	3400b66a <RCCEx_GetXSPICLKFreq+0x12e>
3400b634:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400b638:	d829      	bhi.n	3400b68e <RCCEx_GetXSPICLKFreq+0x152>
3400b63a:	2b00      	cmp	r3, #0
3400b63c:	d003      	beq.n	3400b646 <RCCEx_GetXSPICLKFreq+0x10a>
3400b63e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400b642:	d009      	beq.n	3400b658 <RCCEx_GetXSPICLKFreq+0x11c>
            xspi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            xspi_frequency = xspi_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
3400b644:	e023      	b.n	3400b68e <RCCEx_GetXSPICLKFreq+0x152>
            xspi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400b646:	f7fc fb5d 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
3400b64a:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
3400b64c:	68fa      	ldr	r2, [r7, #12]
3400b64e:	68bb      	ldr	r3, [r7, #8]
3400b650:	fbb2 f3f3 	udiv	r3, r2, r3
3400b654:	60fb      	str	r3, [r7, #12]
            break;
3400b656:	e01b      	b.n	3400b690 <RCCEx_GetXSPICLKFreq+0x154>
            xspi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400b658:	f7fc fb9a 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
3400b65c:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
3400b65e:	68fa      	ldr	r2, [r7, #12]
3400b660:	68bb      	ldr	r3, [r7, #8]
3400b662:	fbb2 f3f3 	udiv	r3, r2, r3
3400b666:	60fb      	str	r3, [r7, #12]
            break;
3400b668:	e012      	b.n	3400b690 <RCCEx_GetXSPICLKFreq+0x154>
            xspi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400b66a:	f7fc fbd7 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
3400b66e:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
3400b670:	68fa      	ldr	r2, [r7, #12]
3400b672:	68bb      	ldr	r3, [r7, #8]
3400b674:	fbb2 f3f3 	udiv	r3, r2, r3
3400b678:	60fb      	str	r3, [r7, #12]
            break;
3400b67a:	e009      	b.n	3400b690 <RCCEx_GetXSPICLKFreq+0x154>
            xspi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400b67c:	f7fc fc14 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
3400b680:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
3400b682:	68fa      	ldr	r2, [r7, #12]
3400b684:	68bb      	ldr	r3, [r7, #8]
3400b686:	fbb2 f3f3 	udiv	r3, r2, r3
3400b68a:	60fb      	str	r3, [r7, #12]
            break;
3400b68c:	e000      	b.n	3400b690 <RCCEx_GetXSPICLKFreq+0x154>
            break;
3400b68e:	bf00      	nop
        }
      }
      break;
3400b690:	e044      	b.n	3400b71c <RCCEx_GetXSPICLKFreq+0x1e0>

    case LL_RCC_XSPI1_CLKSOURCE_IC4:
    case LL_RCC_XSPI2_CLKSOURCE_IC4:
    case LL_RCC_XSPI3_CLKSOURCE_IC4:
      if (LL_RCC_IC4_IsEnabled() != 0U)
3400b692:	f7f8 ffe3 	bl	3400465c <LL_RCC_IC4_IsEnabled>
3400b696:	4603      	mov	r3, r0
3400b698:	2b00      	cmp	r3, #0
3400b69a:	d041      	beq.n	3400b720 <RCCEx_GetXSPICLKFreq+0x1e4>
      {
        ic_divider = LL_RCC_IC4_GetDivider();
3400b69c:	f7f9 f800 	bl	340046a0 <LL_RCC_IC4_GetDivider>
3400b6a0:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC4_GetSource())
3400b6a2:	f7f8 ffef 	bl	34004684 <LL_RCC_IC4_GetSource>
3400b6a6:	4603      	mov	r3, r0
3400b6a8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400b6ac:	d029      	beq.n	3400b702 <RCCEx_GetXSPICLKFreq+0x1c6>
3400b6ae:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400b6b2:	d82f      	bhi.n	3400b714 <RCCEx_GetXSPICLKFreq+0x1d8>
3400b6b4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400b6b8:	d01a      	beq.n	3400b6f0 <RCCEx_GetXSPICLKFreq+0x1b4>
3400b6ba:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400b6be:	d829      	bhi.n	3400b714 <RCCEx_GetXSPICLKFreq+0x1d8>
3400b6c0:	2b00      	cmp	r3, #0
3400b6c2:	d003      	beq.n	3400b6cc <RCCEx_GetXSPICLKFreq+0x190>
3400b6c4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400b6c8:	d009      	beq.n	3400b6de <RCCEx_GetXSPICLKFreq+0x1a2>
            xspi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            xspi_frequency = xspi_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
3400b6ca:	e023      	b.n	3400b714 <RCCEx_GetXSPICLKFreq+0x1d8>
            xspi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400b6cc:	f7fc fb1a 	bl	34007d04 <HAL_RCCEx_GetPLL1CLKFreq>
3400b6d0:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
3400b6d2:	68fa      	ldr	r2, [r7, #12]
3400b6d4:	68bb      	ldr	r3, [r7, #8]
3400b6d6:	fbb2 f3f3 	udiv	r3, r2, r3
3400b6da:	60fb      	str	r3, [r7, #12]
            break;
3400b6dc:	e01b      	b.n	3400b716 <RCCEx_GetXSPICLKFreq+0x1da>
            xspi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400b6de:	f7fc fb57 	bl	34007d90 <HAL_RCCEx_GetPLL2CLKFreq>
3400b6e2:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
3400b6e4:	68fa      	ldr	r2, [r7, #12]
3400b6e6:	68bb      	ldr	r3, [r7, #8]
3400b6e8:	fbb2 f3f3 	udiv	r3, r2, r3
3400b6ec:	60fb      	str	r3, [r7, #12]
            break;
3400b6ee:	e012      	b.n	3400b716 <RCCEx_GetXSPICLKFreq+0x1da>
            xspi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400b6f0:	f7fc fb94 	bl	34007e1c <HAL_RCCEx_GetPLL3CLKFreq>
3400b6f4:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
3400b6f6:	68fa      	ldr	r2, [r7, #12]
3400b6f8:	68bb      	ldr	r3, [r7, #8]
3400b6fa:	fbb2 f3f3 	udiv	r3, r2, r3
3400b6fe:	60fb      	str	r3, [r7, #12]
            break;
3400b700:	e009      	b.n	3400b716 <RCCEx_GetXSPICLKFreq+0x1da>
            xspi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400b702:	f7fc fbd1 	bl	34007ea8 <HAL_RCCEx_GetPLL4CLKFreq>
3400b706:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
3400b708:	68fa      	ldr	r2, [r7, #12]
3400b70a:	68bb      	ldr	r3, [r7, #8]
3400b70c:	fbb2 f3f3 	udiv	r3, r2, r3
3400b710:	60fb      	str	r3, [r7, #12]
            break;
3400b712:	e000      	b.n	3400b716 <RCCEx_GetXSPICLKFreq+0x1da>
            break;
3400b714:	bf00      	nop
        }
      }
      break;
3400b716:	e003      	b.n	3400b720 <RCCEx_GetXSPICLKFreq+0x1e4>

    default:
      /* Nothing to do */
      break;
3400b718:	bf00      	nop
3400b71a:	e002      	b.n	3400b722 <RCCEx_GetXSPICLKFreq+0x1e6>
      break;
3400b71c:	bf00      	nop
3400b71e:	e000      	b.n	3400b722 <RCCEx_GetXSPICLKFreq+0x1e6>
      break;
3400b720:	bf00      	nop
  }

  return xspi_frequency;
3400b722:	68fb      	ldr	r3, [r7, #12]
}
3400b724:	4618      	mov	r0, r3
3400b726:	3710      	adds	r7, #16
3400b728:	46bd      	mov	sp, r7
3400b72a:	bd80      	pop	{r7, pc}
3400b72c:	03030814 	.word	0x03030814
3400b730:	03030414 	.word	0x03030414
3400b734:	03030014 	.word	0x03030014
3400b738:	03020814 	.word	0x03020814
3400b73c:	03020414 	.word	0x03020414
3400b740:	03020014 	.word	0x03020014
3400b744:	03010814 	.word	0x03010814
3400b748:	03010414 	.word	0x03010414
3400b74c:	03010014 	.word	0x03010014
3400b750:	03000814 	.word	0x03000814
3400b754:	03000014 	.word	0x03000014
3400b758:	03000414 	.word	0x03000414

3400b75c <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
3400b75c:	b580      	push	{r7, lr}
3400b75e:	b082      	sub	sp, #8
3400b760:	af00      	add	r7, sp, #0
3400b762:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
3400b764:	687b      	ldr	r3, [r7, #4]
3400b766:	2b00      	cmp	r3, #0
3400b768:	d101      	bne.n	3400b76e <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
3400b76a:	2301      	movs	r3, #1
3400b76c:	e042      	b.n	3400b7f4 <HAL_UART_Init+0x98>
  {
    /* Check the parameters */
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
  }

  if (huart->gState == HAL_UART_STATE_RESET)
3400b76e:	687b      	ldr	r3, [r7, #4]
3400b770:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3400b774:	2b00      	cmp	r3, #0
3400b776:	d106      	bne.n	3400b786 <HAL_UART_Init+0x2a>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
3400b778:	687b      	ldr	r3, [r7, #4]
3400b77a:	2200      	movs	r2, #0
3400b77c:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
3400b780:	6878      	ldr	r0, [r7, #4]
3400b782:	f7f5 fca1 	bl	340010c8 <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
3400b786:	687b      	ldr	r3, [r7, #4]
3400b788:	2224      	movs	r2, #36	@ 0x24
3400b78a:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  __HAL_UART_DISABLE(huart);
3400b78e:	687b      	ldr	r3, [r7, #4]
3400b790:	681b      	ldr	r3, [r3, #0]
3400b792:	681a      	ldr	r2, [r3, #0]
3400b794:	687b      	ldr	r3, [r7, #4]
3400b796:	681b      	ldr	r3, [r3, #0]
3400b798:	f022 0201 	bic.w	r2, r2, #1
3400b79c:	601a      	str	r2, [r3, #0]

  /* Perform advanced settings configuration */
  /* For some items, configuration requires to be done prior TE and RE bits are set */
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
3400b79e:	687b      	ldr	r3, [r7, #4]
3400b7a0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400b7a2:	2b00      	cmp	r3, #0
3400b7a4:	d002      	beq.n	3400b7ac <HAL_UART_Init+0x50>
  {
    UART_AdvFeatureConfig(huart);
3400b7a6:	6878      	ldr	r0, [r7, #4]
3400b7a8:	f000 fa14 	bl	3400bbd4 <UART_AdvFeatureConfig>
  }

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
3400b7ac:	6878      	ldr	r0, [r7, #4]
3400b7ae:	f000 f825 	bl	3400b7fc <UART_SetConfig>
3400b7b2:	4603      	mov	r3, r0
3400b7b4:	2b01      	cmp	r3, #1
3400b7b6:	d101      	bne.n	3400b7bc <HAL_UART_Init+0x60>
  {
    return HAL_ERROR;
3400b7b8:	2301      	movs	r3, #1
3400b7ba:	e01b      	b.n	3400b7f4 <HAL_UART_Init+0x98>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
3400b7bc:	687b      	ldr	r3, [r7, #4]
3400b7be:	681b      	ldr	r3, [r3, #0]
3400b7c0:	685a      	ldr	r2, [r3, #4]
3400b7c2:	687b      	ldr	r3, [r7, #4]
3400b7c4:	681b      	ldr	r3, [r3, #0]
3400b7c6:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
3400b7ca:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
3400b7cc:	687b      	ldr	r3, [r7, #4]
3400b7ce:	681b      	ldr	r3, [r3, #0]
3400b7d0:	689a      	ldr	r2, [r3, #8]
3400b7d2:	687b      	ldr	r3, [r7, #4]
3400b7d4:	681b      	ldr	r3, [r3, #0]
3400b7d6:	f022 022a 	bic.w	r2, r2, #42	@ 0x2a
3400b7da:	609a      	str	r2, [r3, #8]

  __HAL_UART_ENABLE(huart);
3400b7dc:	687b      	ldr	r3, [r7, #4]
3400b7de:	681b      	ldr	r3, [r3, #0]
3400b7e0:	681a      	ldr	r2, [r3, #0]
3400b7e2:	687b      	ldr	r3, [r7, #4]
3400b7e4:	681b      	ldr	r3, [r3, #0]
3400b7e6:	f042 0201 	orr.w	r2, r2, #1
3400b7ea:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
3400b7ec:	6878      	ldr	r0, [r7, #4]
3400b7ee:	f000 fa93 	bl	3400bd18 <UART_CheckIdleState>
3400b7f2:	4603      	mov	r3, r0
}
3400b7f4:	4618      	mov	r0, r3
3400b7f6:	3708      	adds	r7, #8
3400b7f8:	46bd      	mov	sp, r7
3400b7fa:	bd80      	pop	{r7, pc}

3400b7fc <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
3400b7fc:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
3400b800:	b090      	sub	sp, #64	@ 0x40
3400b802:	af00      	add	r7, sp, #0
3400b804:	6178      	str	r0, [r7, #20]
  uint32_t tmpreg;
  uint16_t brrtemp;
  uint64_t clocksource;
  uint32_t usartdiv;
  HAL_StatusTypeDef ret               = HAL_OK;
3400b806:	2300      	movs	r3, #0
3400b808:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
  uint32_t pclk;

  /* Check the parameters */
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  if (UART_INSTANCE_LOWPOWER(huart))
3400b80c:	697b      	ldr	r3, [r7, #20]
3400b80e:	681b      	ldr	r3, [r3, #0]
3400b810:	4aa3      	ldr	r2, [pc, #652]	@ (3400baa0 <UART_SetConfig+0x2a4>)
3400b812:	4293      	cmp	r3, r2
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
3400b814:	697b      	ldr	r3, [r7, #20]
3400b816:	689a      	ldr	r2, [r3, #8]
3400b818:	697b      	ldr	r3, [r7, #20]
3400b81a:	691b      	ldr	r3, [r3, #16]
3400b81c:	431a      	orrs	r2, r3
3400b81e:	697b      	ldr	r3, [r7, #20]
3400b820:	695b      	ldr	r3, [r3, #20]
3400b822:	431a      	orrs	r2, r3
3400b824:	697b      	ldr	r3, [r7, #20]
3400b826:	69db      	ldr	r3, [r3, #28]
3400b828:	4313      	orrs	r3, r2
3400b82a:	63fb      	str	r3, [r7, #60]	@ 0x3c
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
3400b82c:	697b      	ldr	r3, [r7, #20]
3400b82e:	681b      	ldr	r3, [r3, #0]
3400b830:	681a      	ldr	r2, [r3, #0]
3400b832:	4b9c      	ldr	r3, [pc, #624]	@ (3400baa4 <UART_SetConfig+0x2a8>)
3400b834:	4013      	ands	r3, r2
3400b836:	697a      	ldr	r2, [r7, #20]
3400b838:	6812      	ldr	r2, [r2, #0]
3400b83a:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
3400b83c:	430b      	orrs	r3, r1
3400b83e:	6013      	str	r3, [r2, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
3400b840:	697b      	ldr	r3, [r7, #20]
3400b842:	681b      	ldr	r3, [r3, #0]
3400b844:	685b      	ldr	r3, [r3, #4]
3400b846:	f423 5140 	bic.w	r1, r3, #12288	@ 0x3000
3400b84a:	697b      	ldr	r3, [r7, #20]
3400b84c:	68da      	ldr	r2, [r3, #12]
3400b84e:	697b      	ldr	r3, [r7, #20]
3400b850:	681b      	ldr	r3, [r3, #0]
3400b852:	430a      	orrs	r2, r1
3400b854:	605a      	str	r2, [r3, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
3400b856:	697b      	ldr	r3, [r7, #20]
3400b858:	699b      	ldr	r3, [r3, #24]
3400b85a:	63fb      	str	r3, [r7, #60]	@ 0x3c

  if (!(UART_INSTANCE_LOWPOWER(huart)))
3400b85c:	697b      	ldr	r3, [r7, #20]
3400b85e:	681b      	ldr	r3, [r3, #0]
3400b860:	4a8f      	ldr	r2, [pc, #572]	@ (3400baa0 <UART_SetConfig+0x2a4>)
3400b862:	4293      	cmp	r3, r2
3400b864:	d009      	beq.n	3400b87a <UART_SetConfig+0x7e>
3400b866:	697b      	ldr	r3, [r7, #20]
3400b868:	681b      	ldr	r3, [r3, #0]
3400b86a:	4a8f      	ldr	r2, [pc, #572]	@ (3400baa8 <UART_SetConfig+0x2ac>)
3400b86c:	4293      	cmp	r3, r2
3400b86e:	d004      	beq.n	3400b87a <UART_SetConfig+0x7e>
  {
    tmpreg |= huart->Init.OneBitSampling;
3400b870:	697b      	ldr	r3, [r7, #20]
3400b872:	6a1b      	ldr	r3, [r3, #32]
3400b874:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
3400b876:	4313      	orrs	r3, r2
3400b878:	63fb      	str	r3, [r7, #60]	@ 0x3c
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
3400b87a:	697b      	ldr	r3, [r7, #20]
3400b87c:	681b      	ldr	r3, [r3, #0]
3400b87e:	689b      	ldr	r3, [r3, #8]
3400b880:	f023 436e 	bic.w	r3, r3, #3992977408	@ 0xee000000
3400b884:	f423 6330 	bic.w	r3, r3, #2816	@ 0xb00
3400b888:	697a      	ldr	r2, [r7, #20]
3400b88a:	6812      	ldr	r2, [r2, #0]
3400b88c:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
3400b88e:	430b      	orrs	r3, r1
3400b890:	6093      	str	r3, [r2, #8]

  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
3400b892:	697b      	ldr	r3, [r7, #20]
3400b894:	681b      	ldr	r3, [r3, #0]
3400b896:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400b898:	f023 010f 	bic.w	r1, r3, #15
3400b89c:	697b      	ldr	r3, [r7, #20]
3400b89e:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
3400b8a0:	697b      	ldr	r3, [r7, #20]
3400b8a2:	681b      	ldr	r3, [r3, #0]
3400b8a4:	430a      	orrs	r2, r1
3400b8a6:	62da      	str	r2, [r3, #44]	@ 0x2c

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
3400b8a8:	697b      	ldr	r3, [r7, #20]
3400b8aa:	681b      	ldr	r3, [r3, #0]
3400b8ac:	4a7f      	ldr	r2, [pc, #508]	@ (3400baac <UART_SetConfig+0x2b0>)
3400b8ae:	4293      	cmp	r3, r2
3400b8b0:	d106      	bne.n	3400b8c0 <UART_SetConfig+0xc4>
3400b8b2:	f04f 0200 	mov.w	r2, #0
3400b8b6:	f44f 7380 	mov.w	r3, #256	@ 0x100
3400b8ba:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
3400b8be:	e07d      	b.n	3400b9bc <UART_SetConfig+0x1c0>
3400b8c0:	697b      	ldr	r3, [r7, #20]
3400b8c2:	681b      	ldr	r3, [r3, #0]
3400b8c4:	4a7a      	ldr	r2, [pc, #488]	@ (3400bab0 <UART_SetConfig+0x2b4>)
3400b8c6:	4293      	cmp	r3, r2
3400b8c8:	d106      	bne.n	3400b8d8 <UART_SetConfig+0xdc>
3400b8ca:	f04f 0200 	mov.w	r2, #0
3400b8ce:	f44f 7300 	mov.w	r3, #512	@ 0x200
3400b8d2:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
3400b8d6:	e071      	b.n	3400b9bc <UART_SetConfig+0x1c0>
3400b8d8:	697b      	ldr	r3, [r7, #20]
3400b8da:	681b      	ldr	r3, [r3, #0]
3400b8dc:	4a75      	ldr	r2, [pc, #468]	@ (3400bab4 <UART_SetConfig+0x2b8>)
3400b8de:	4293      	cmp	r3, r2
3400b8e0:	d106      	bne.n	3400b8f0 <UART_SetConfig+0xf4>
3400b8e2:	f04f 0200 	mov.w	r2, #0
3400b8e6:	f44f 6380 	mov.w	r3, #1024	@ 0x400
3400b8ea:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
3400b8ee:	e065      	b.n	3400b9bc <UART_SetConfig+0x1c0>
3400b8f0:	697b      	ldr	r3, [r7, #20]
3400b8f2:	681b      	ldr	r3, [r3, #0]
3400b8f4:	4a70      	ldr	r2, [pc, #448]	@ (3400bab8 <UART_SetConfig+0x2bc>)
3400b8f6:	4293      	cmp	r3, r2
3400b8f8:	d106      	bne.n	3400b908 <UART_SetConfig+0x10c>
3400b8fa:	f04f 0200 	mov.w	r2, #0
3400b8fe:	f44f 6300 	mov.w	r3, #2048	@ 0x800
3400b902:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
3400b906:	e059      	b.n	3400b9bc <UART_SetConfig+0x1c0>
3400b908:	697b      	ldr	r3, [r7, #20]
3400b90a:	681b      	ldr	r3, [r3, #0]
3400b90c:	f1b3 2f50 	cmp.w	r3, #1342197760	@ 0x50005000
3400b910:	d106      	bne.n	3400b920 <UART_SetConfig+0x124>
3400b912:	f04f 0200 	mov.w	r2, #0
3400b916:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
3400b91a:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
3400b91e:	e04d      	b.n	3400b9bc <UART_SetConfig+0x1c0>
3400b920:	697b      	ldr	r3, [r7, #20]
3400b922:	681b      	ldr	r3, [r3, #0]
3400b924:	4a65      	ldr	r2, [pc, #404]	@ (3400babc <UART_SetConfig+0x2c0>)
3400b926:	4293      	cmp	r3, r2
3400b928:	d106      	bne.n	3400b938 <UART_SetConfig+0x13c>
3400b92a:	f04f 0200 	mov.w	r2, #0
3400b92e:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
3400b932:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
3400b936:	e041      	b.n	3400b9bc <UART_SetConfig+0x1c0>
3400b938:	697b      	ldr	r3, [r7, #20]
3400b93a:	681b      	ldr	r3, [r3, #0]
3400b93c:	4a60      	ldr	r2, [pc, #384]	@ (3400bac0 <UART_SetConfig+0x2c4>)
3400b93e:	4293      	cmp	r3, r2
3400b940:	d106      	bne.n	3400b950 <UART_SetConfig+0x154>
3400b942:	f04f 0200 	mov.w	r2, #0
3400b946:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
3400b94a:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
3400b94e:	e035      	b.n	3400b9bc <UART_SetConfig+0x1c0>
3400b950:	697b      	ldr	r3, [r7, #20]
3400b952:	681b      	ldr	r3, [r3, #0]
3400b954:	4a5b      	ldr	r2, [pc, #364]	@ (3400bac4 <UART_SetConfig+0x2c8>)
3400b956:	4293      	cmp	r3, r2
3400b958:	d106      	bne.n	3400b968 <UART_SetConfig+0x16c>
3400b95a:	f04f 0200 	mov.w	r2, #0
3400b95e:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
3400b962:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
3400b966:	e029      	b.n	3400b9bc <UART_SetConfig+0x1c0>
3400b968:	697b      	ldr	r3, [r7, #20]
3400b96a:	681b      	ldr	r3, [r3, #0]
3400b96c:	4a56      	ldr	r2, [pc, #344]	@ (3400bac8 <UART_SetConfig+0x2cc>)
3400b96e:	4293      	cmp	r3, r2
3400b970:	d106      	bne.n	3400b980 <UART_SetConfig+0x184>
3400b972:	f04f 0200 	mov.w	r2, #0
3400b976:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
3400b97a:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
3400b97e:	e01d      	b.n	3400b9bc <UART_SetConfig+0x1c0>
3400b980:	697b      	ldr	r3, [r7, #20]
3400b982:	681b      	ldr	r3, [r3, #0]
3400b984:	4a51      	ldr	r2, [pc, #324]	@ (3400bacc <UART_SetConfig+0x2d0>)
3400b986:	4293      	cmp	r3, r2
3400b988:	d106      	bne.n	3400b998 <UART_SetConfig+0x19c>
3400b98a:	f04f 0200 	mov.w	r2, #0
3400b98e:	f44f 3300 	mov.w	r3, #131072	@ 0x20000
3400b992:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
3400b996:	e011      	b.n	3400b9bc <UART_SetConfig+0x1c0>
3400b998:	697b      	ldr	r3, [r7, #20]
3400b99a:	681b      	ldr	r3, [r3, #0]
3400b99c:	4a40      	ldr	r2, [pc, #256]	@ (3400baa0 <UART_SetConfig+0x2a4>)
3400b99e:	4293      	cmp	r3, r2
3400b9a0:	d106      	bne.n	3400b9b0 <UART_SetConfig+0x1b4>
3400b9a2:	f44f 0200 	mov.w	r2, #8388608	@ 0x800000
3400b9a6:	f04f 0300 	mov.w	r3, #0
3400b9aa:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
3400b9ae:	e005      	b.n	3400b9bc <UART_SetConfig+0x1c0>
3400b9b0:	f04f 0200 	mov.w	r2, #0
3400b9b4:	f04f 0300 	mov.w	r3, #0
3400b9b8:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30

  /* Check LPUART instance */
  if (UART_INSTANCE_LOWPOWER(huart))
3400b9bc:	697b      	ldr	r3, [r7, #20]
3400b9be:	681b      	ldr	r3, [r3, #0]
3400b9c0:	4a37      	ldr	r2, [pc, #220]	@ (3400baa0 <UART_SetConfig+0x2a4>)
3400b9c2:	4293      	cmp	r3, r2
3400b9c4:	d005      	beq.n	3400b9d2 <UART_SetConfig+0x1d6>
3400b9c6:	697b      	ldr	r3, [r7, #20]
3400b9c8:	681b      	ldr	r3, [r3, #0]
3400b9ca:	4a37      	ldr	r2, [pc, #220]	@ (3400baa8 <UART_SetConfig+0x2ac>)
3400b9cc:	4293      	cmp	r3, r2
3400b9ce:	f040 8081 	bne.w	3400bad4 <UART_SetConfig+0x2d8>
  {
    /* Retrieve frequency clock */
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
3400b9d2:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	@ 0x30
3400b9d6:	f7fb fcf9 	bl	340073cc <HAL_RCCEx_GetPeriphCLKFreq>
3400b9da:	62b8      	str	r0, [r7, #40]	@ 0x28

    /* If proper clock source reported */
    if (pclk != 0U)
3400b9dc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400b9de:	2b00      	cmp	r3, #0
3400b9e0:	f000 80e0 	beq.w	3400bba4 <UART_SetConfig+0x3a8>
    {
      /* Compute clock after Prescaler */
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
3400b9e4:	697b      	ldr	r3, [r7, #20]
3400b9e6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400b9e8:	4a39      	ldr	r2, [pc, #228]	@ (3400bad0 <UART_SetConfig+0x2d4>)
3400b9ea:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
3400b9ee:	461a      	mov	r2, r3
3400b9f0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400b9f2:	fbb3 f3f2 	udiv	r3, r3, r2
3400b9f6:	61fb      	str	r3, [r7, #28]

      /* Ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
3400b9f8:	697b      	ldr	r3, [r7, #20]
3400b9fa:	685a      	ldr	r2, [r3, #4]
3400b9fc:	4613      	mov	r3, r2
3400b9fe:	005b      	lsls	r3, r3, #1
3400ba00:	4413      	add	r3, r2
3400ba02:	69fa      	ldr	r2, [r7, #28]
3400ba04:	429a      	cmp	r2, r3
3400ba06:	d305      	bcc.n	3400ba14 <UART_SetConfig+0x218>
          (lpuart_ker_ck_pres > (4096U * huart->Init.BaudRate)))
3400ba08:	697b      	ldr	r3, [r7, #20]
3400ba0a:	685b      	ldr	r3, [r3, #4]
3400ba0c:	031b      	lsls	r3, r3, #12
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
3400ba0e:	69fa      	ldr	r2, [r7, #28]
3400ba10:	429a      	cmp	r2, r3
3400ba12:	d903      	bls.n	3400ba1c <UART_SetConfig+0x220>
      {
        ret = HAL_ERROR;
3400ba14:	2301      	movs	r3, #1
3400ba16:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
3400ba1a:	e040      	b.n	3400ba9e <UART_SetConfig+0x2a2>
      }
      else
      {
        /* Check computed UsartDiv value is in allocated range
           (it is forbidden to write values lower than 0x300 in the LPUART_BRR register) */
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
3400ba1c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400ba1e:	2200      	movs	r2, #0
3400ba20:	60bb      	str	r3, [r7, #8]
3400ba22:	60fa      	str	r2, [r7, #12]
3400ba24:	697b      	ldr	r3, [r7, #20]
3400ba26:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400ba28:	4a29      	ldr	r2, [pc, #164]	@ (3400bad0 <UART_SetConfig+0x2d4>)
3400ba2a:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
3400ba2e:	b29b      	uxth	r3, r3
3400ba30:	2200      	movs	r2, #0
3400ba32:	603b      	str	r3, [r7, #0]
3400ba34:	607a      	str	r2, [r7, #4]
3400ba36:	e9d7 2300 	ldrd	r2, r3, [r7]
3400ba3a:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
3400ba3e:	f7f4 fea5 	bl	3400078c <__aeabi_uldivmod>
3400ba42:	4602      	mov	r2, r0
3400ba44:	460b      	mov	r3, r1
3400ba46:	ea52 230f 	orrs.w	r3, r2, pc, lsl #8
3400ba4a:	6979      	ldr	r1, [r7, #20]
3400ba4c:	6849      	ldr	r1, [r1, #4]
3400ba4e:	0849      	lsrs	r1, r1, #1
3400ba50:	2000      	movs	r0, #0
3400ba52:	460c      	mov	r4, r1
3400ba54:	4605      	mov	r5, r0
3400ba56:	eb12 0804 	adds.w	r8, r2, r4
3400ba5a:	eb43 0905 	adc.w	r9, r3, r5
3400ba5e:	697b      	ldr	r3, [r7, #20]
3400ba60:	685b      	ldr	r3, [r3, #4]
3400ba62:	2200      	movs	r2, #0
3400ba64:	469a      	mov	sl, r3
3400ba66:	4693      	mov	fp, r2
3400ba68:	4652      	mov	r2, sl
3400ba6a:	465b      	mov	r3, fp
3400ba6c:	4640      	mov	r0, r8
3400ba6e:	4649      	mov	r1, r9
3400ba70:	f7f4 fe8c 	bl	3400078c <__aeabi_uldivmod>
3400ba74:	4602      	mov	r2, r0
3400ba76:	460b      	mov	r3, r1
3400ba78:	4613      	mov	r3, r2
3400ba7a:	627b      	str	r3, [r7, #36]	@ 0x24
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
3400ba7c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3400ba7e:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3400ba82:	d308      	bcc.n	3400ba96 <UART_SetConfig+0x29a>
3400ba84:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3400ba86:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3400ba8a:	d204      	bcs.n	3400ba96 <UART_SetConfig+0x29a>
        {
          huart->Instance->BRR = usartdiv;
3400ba8c:	697b      	ldr	r3, [r7, #20]
3400ba8e:	681b      	ldr	r3, [r3, #0]
3400ba90:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3400ba92:	60da      	str	r2, [r3, #12]
3400ba94:	e003      	b.n	3400ba9e <UART_SetConfig+0x2a2>
        }
        else
        {
          ret = HAL_ERROR;
3400ba96:	2301      	movs	r3, #1
3400ba98:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    if (pclk != 0U)
3400ba9c:	e082      	b.n	3400bba4 <UART_SetConfig+0x3a8>
3400ba9e:	e081      	b.n	3400bba4 <UART_SetConfig+0x3a8>
3400baa0:	56000c00 	.word	0x56000c00
3400baa4:	cfff69f3 	.word	0xcfff69f3
3400baa8:	46000c00 	.word	0x46000c00
3400baac:	52001000 	.word	0x52001000
3400bab0:	50004400 	.word	0x50004400
3400bab4:	50004800 	.word	0x50004800
3400bab8:	50004c00 	.word	0x50004c00
3400babc:	52001400 	.word	0x52001400
3400bac0:	50007800 	.word	0x50007800
3400bac4:	50007c00 	.word	0x50007c00
3400bac8:	52001800 	.word	0x52001800
3400bacc:	52001c00 	.word	0x52001c00
3400bad0:	3400ca98 	.word	0x3400ca98
      } /* if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) ||
                (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate) )) */
    } /* if (pclk != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
3400bad4:	697b      	ldr	r3, [r7, #20]
3400bad6:	69db      	ldr	r3, [r3, #28]
3400bad8:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
3400badc:	d138      	bne.n	3400bb50 <UART_SetConfig+0x354>
  {
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
3400bade:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	@ 0x30
3400bae2:	f7fb fc73 	bl	340073cc <HAL_RCCEx_GetPeriphCLKFreq>
3400bae6:	62b8      	str	r0, [r7, #40]	@ 0x28

    /* USARTDIV must be greater than or equal to 0d16 */
    if (pclk != 0U)
3400bae8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400baea:	2b00      	cmp	r3, #0
3400baec:	d05a      	beq.n	3400bba4 <UART_SetConfig+0x3a8>
    {
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
3400baee:	697b      	ldr	r3, [r7, #20]
3400baf0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400baf2:	4a37      	ldr	r2, [pc, #220]	@ (3400bbd0 <UART_SetConfig+0x3d4>)
3400baf4:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
3400baf8:	461a      	mov	r2, r3
3400bafa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400bafc:	fbb3 f3f2 	udiv	r3, r3, r2
3400bb00:	005a      	lsls	r2, r3, #1
3400bb02:	697b      	ldr	r3, [r7, #20]
3400bb04:	685b      	ldr	r3, [r3, #4]
3400bb06:	085b      	lsrs	r3, r3, #1
3400bb08:	441a      	add	r2, r3
3400bb0a:	697b      	ldr	r3, [r7, #20]
3400bb0c:	685b      	ldr	r3, [r3, #4]
3400bb0e:	fbb2 f3f3 	udiv	r3, r2, r3
3400bb12:	627b      	str	r3, [r7, #36]	@ 0x24
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
3400bb14:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3400bb16:	2b0f      	cmp	r3, #15
3400bb18:	d916      	bls.n	3400bb48 <UART_SetConfig+0x34c>
3400bb1a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3400bb1c:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
3400bb20:	d212      	bcs.n	3400bb48 <UART_SetConfig+0x34c>
      {
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
3400bb22:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3400bb24:	b29b      	uxth	r3, r3
3400bb26:	f023 030f 	bic.w	r3, r3, #15
3400bb2a:	847b      	strh	r3, [r7, #34]	@ 0x22
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
3400bb2c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3400bb2e:	085b      	lsrs	r3, r3, #1
3400bb30:	b29b      	uxth	r3, r3
3400bb32:	f003 0307 	and.w	r3, r3, #7
3400bb36:	b29a      	uxth	r2, r3
3400bb38:	8c7b      	ldrh	r3, [r7, #34]	@ 0x22
3400bb3a:	4313      	orrs	r3, r2
3400bb3c:	847b      	strh	r3, [r7, #34]	@ 0x22
        huart->Instance->BRR = brrtemp;
3400bb3e:	697b      	ldr	r3, [r7, #20]
3400bb40:	681b      	ldr	r3, [r3, #0]
3400bb42:	8c7a      	ldrh	r2, [r7, #34]	@ 0x22
3400bb44:	60da      	str	r2, [r3, #12]
3400bb46:	e02d      	b.n	3400bba4 <UART_SetConfig+0x3a8>
      }
      else
      {
        ret = HAL_ERROR;
3400bb48:	2301      	movs	r3, #1
3400bb4a:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
3400bb4e:	e029      	b.n	3400bba4 <UART_SetConfig+0x3a8>
      }
    }
  }
  else
  {
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
3400bb50:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	@ 0x30
3400bb54:	f7fb fc3a 	bl	340073cc <HAL_RCCEx_GetPeriphCLKFreq>
3400bb58:	62b8      	str	r0, [r7, #40]	@ 0x28

    if (pclk != 0U)
3400bb5a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400bb5c:	2b00      	cmp	r3, #0
3400bb5e:	d021      	beq.n	3400bba4 <UART_SetConfig+0x3a8>
    {
      /* USARTDIV must be greater than or equal to 0d16 */
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
3400bb60:	697b      	ldr	r3, [r7, #20]
3400bb62:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400bb64:	4a1a      	ldr	r2, [pc, #104]	@ (3400bbd0 <UART_SetConfig+0x3d4>)
3400bb66:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
3400bb6a:	461a      	mov	r2, r3
3400bb6c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400bb6e:	fbb3 f2f2 	udiv	r2, r3, r2
3400bb72:	697b      	ldr	r3, [r7, #20]
3400bb74:	685b      	ldr	r3, [r3, #4]
3400bb76:	085b      	lsrs	r3, r3, #1
3400bb78:	441a      	add	r2, r3
3400bb7a:	697b      	ldr	r3, [r7, #20]
3400bb7c:	685b      	ldr	r3, [r3, #4]
3400bb7e:	fbb2 f3f3 	udiv	r3, r2, r3
3400bb82:	627b      	str	r3, [r7, #36]	@ 0x24
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
3400bb84:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3400bb86:	2b0f      	cmp	r3, #15
3400bb88:	d909      	bls.n	3400bb9e <UART_SetConfig+0x3a2>
3400bb8a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3400bb8c:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
3400bb90:	d205      	bcs.n	3400bb9e <UART_SetConfig+0x3a2>
      {
        huart->Instance->BRR = (uint16_t)usartdiv;
3400bb92:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3400bb94:	b29a      	uxth	r2, r3
3400bb96:	697b      	ldr	r3, [r7, #20]
3400bb98:	681b      	ldr	r3, [r3, #0]
3400bb9a:	60da      	str	r2, [r3, #12]
3400bb9c:	e002      	b.n	3400bba4 <UART_SetConfig+0x3a8>
      }
      else
      {
        ret = HAL_ERROR;
3400bb9e:	2301      	movs	r3, #1
3400bba0:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
      }
    }
  }

  /* Initialize the number of data to process during RX/TX ISR execution */
  huart->NbTxDataToProcess = 1;
3400bba4:	697b      	ldr	r3, [r7, #20]
3400bba6:	2201      	movs	r2, #1
3400bba8:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
  huart->NbRxDataToProcess = 1;
3400bbac:	697b      	ldr	r3, [r7, #20]
3400bbae:	2201      	movs	r2, #1
3400bbb0:	f8a3 2068 	strh.w	r2, [r3, #104]	@ 0x68

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
3400bbb4:	697b      	ldr	r3, [r7, #20]
3400bbb6:	2200      	movs	r2, #0
3400bbb8:	675a      	str	r2, [r3, #116]	@ 0x74
  huart->TxISR = NULL;
3400bbba:	697b      	ldr	r3, [r7, #20]
3400bbbc:	2200      	movs	r2, #0
3400bbbe:	679a      	str	r2, [r3, #120]	@ 0x78

  return ret;
3400bbc0:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
}
3400bbc4:	4618      	mov	r0, r3
3400bbc6:	3740      	adds	r7, #64	@ 0x40
3400bbc8:	46bd      	mov	sp, r7
3400bbca:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
3400bbce:	bf00      	nop
3400bbd0:	3400ca98 	.word	0x3400ca98

3400bbd4 <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
3400bbd4:	b480      	push	{r7}
3400bbd6:	b083      	sub	sp, #12
3400bbd8:	af00      	add	r7, sp, #0
3400bbda:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
3400bbdc:	687b      	ldr	r3, [r7, #4]
3400bbde:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400bbe0:	f003 0308 	and.w	r3, r3, #8
3400bbe4:	2b00      	cmp	r3, #0
3400bbe6:	d00a      	beq.n	3400bbfe <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
3400bbe8:	687b      	ldr	r3, [r7, #4]
3400bbea:	681b      	ldr	r3, [r3, #0]
3400bbec:	685b      	ldr	r3, [r3, #4]
3400bbee:	f423 4100 	bic.w	r1, r3, #32768	@ 0x8000
3400bbf2:	687b      	ldr	r3, [r7, #4]
3400bbf4:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
3400bbf6:	687b      	ldr	r3, [r7, #4]
3400bbf8:	681b      	ldr	r3, [r3, #0]
3400bbfa:	430a      	orrs	r2, r1
3400bbfc:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
3400bbfe:	687b      	ldr	r3, [r7, #4]
3400bc00:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400bc02:	f003 0301 	and.w	r3, r3, #1
3400bc06:	2b00      	cmp	r3, #0
3400bc08:	d00a      	beq.n	3400bc20 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
3400bc0a:	687b      	ldr	r3, [r7, #4]
3400bc0c:	681b      	ldr	r3, [r3, #0]
3400bc0e:	685b      	ldr	r3, [r3, #4]
3400bc10:	f423 3100 	bic.w	r1, r3, #131072	@ 0x20000
3400bc14:	687b      	ldr	r3, [r7, #4]
3400bc16:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
3400bc18:	687b      	ldr	r3, [r7, #4]
3400bc1a:	681b      	ldr	r3, [r3, #0]
3400bc1c:	430a      	orrs	r2, r1
3400bc1e:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
3400bc20:	687b      	ldr	r3, [r7, #4]
3400bc22:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400bc24:	f003 0302 	and.w	r3, r3, #2
3400bc28:	2b00      	cmp	r3, #0
3400bc2a:	d00a      	beq.n	3400bc42 <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
3400bc2c:	687b      	ldr	r3, [r7, #4]
3400bc2e:	681b      	ldr	r3, [r3, #0]
3400bc30:	685b      	ldr	r3, [r3, #4]
3400bc32:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
3400bc36:	687b      	ldr	r3, [r7, #4]
3400bc38:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
3400bc3a:	687b      	ldr	r3, [r7, #4]
3400bc3c:	681b      	ldr	r3, [r3, #0]
3400bc3e:	430a      	orrs	r2, r1
3400bc40:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
3400bc42:	687b      	ldr	r3, [r7, #4]
3400bc44:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400bc46:	f003 0304 	and.w	r3, r3, #4
3400bc4a:	2b00      	cmp	r3, #0
3400bc4c:	d00a      	beq.n	3400bc64 <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
3400bc4e:	687b      	ldr	r3, [r7, #4]
3400bc50:	681b      	ldr	r3, [r3, #0]
3400bc52:	685b      	ldr	r3, [r3, #4]
3400bc54:	f423 2180 	bic.w	r1, r3, #262144	@ 0x40000
3400bc58:	687b      	ldr	r3, [r7, #4]
3400bc5a:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
3400bc5c:	687b      	ldr	r3, [r7, #4]
3400bc5e:	681b      	ldr	r3, [r3, #0]
3400bc60:	430a      	orrs	r2, r1
3400bc62:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
3400bc64:	687b      	ldr	r3, [r7, #4]
3400bc66:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400bc68:	f003 0310 	and.w	r3, r3, #16
3400bc6c:	2b00      	cmp	r3, #0
3400bc6e:	d00a      	beq.n	3400bc86 <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
3400bc70:	687b      	ldr	r3, [r7, #4]
3400bc72:	681b      	ldr	r3, [r3, #0]
3400bc74:	689b      	ldr	r3, [r3, #8]
3400bc76:	f423 5180 	bic.w	r1, r3, #4096	@ 0x1000
3400bc7a:	687b      	ldr	r3, [r7, #4]
3400bc7c:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
3400bc7e:	687b      	ldr	r3, [r7, #4]
3400bc80:	681b      	ldr	r3, [r3, #0]
3400bc82:	430a      	orrs	r2, r1
3400bc84:	609a      	str	r2, [r3, #8]
  }

#if defined(HAL_DMA_MODULE_ENABLED)
  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
3400bc86:	687b      	ldr	r3, [r7, #4]
3400bc88:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400bc8a:	f003 0320 	and.w	r3, r3, #32
3400bc8e:	2b00      	cmp	r3, #0
3400bc90:	d00a      	beq.n	3400bca8 <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
3400bc92:	687b      	ldr	r3, [r7, #4]
3400bc94:	681b      	ldr	r3, [r3, #0]
3400bc96:	689b      	ldr	r3, [r3, #8]
3400bc98:	f423 5100 	bic.w	r1, r3, #8192	@ 0x2000
3400bc9c:	687b      	ldr	r3, [r7, #4]
3400bc9e:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3400bca0:	687b      	ldr	r3, [r7, #4]
3400bca2:	681b      	ldr	r3, [r3, #0]
3400bca4:	430a      	orrs	r2, r1
3400bca6:	609a      	str	r2, [r3, #8]
  }
#endif /* HAL_DMA_MODULE_ENABLED */

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
3400bca8:	687b      	ldr	r3, [r7, #4]
3400bcaa:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400bcac:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3400bcb0:	2b00      	cmp	r3, #0
3400bcb2:	d01a      	beq.n	3400bcea <UART_AdvFeatureConfig+0x116>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
3400bcb4:	687b      	ldr	r3, [r7, #4]
3400bcb6:	681b      	ldr	r3, [r3, #0]
3400bcb8:	685b      	ldr	r3, [r3, #4]
3400bcba:	f423 1180 	bic.w	r1, r3, #1048576	@ 0x100000
3400bcbe:	687b      	ldr	r3, [r7, #4]
3400bcc0:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
3400bcc2:	687b      	ldr	r3, [r7, #4]
3400bcc4:	681b      	ldr	r3, [r3, #0]
3400bcc6:	430a      	orrs	r2, r1
3400bcc8:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
3400bcca:	687b      	ldr	r3, [r7, #4]
3400bccc:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400bcce:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3400bcd2:	d10a      	bne.n	3400bcea <UART_AdvFeatureConfig+0x116>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
3400bcd4:	687b      	ldr	r3, [r7, #4]
3400bcd6:	681b      	ldr	r3, [r3, #0]
3400bcd8:	685b      	ldr	r3, [r3, #4]
3400bcda:	f423 01c0 	bic.w	r1, r3, #6291456	@ 0x600000
3400bcde:	687b      	ldr	r3, [r7, #4]
3400bce0:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400bce2:	687b      	ldr	r3, [r7, #4]
3400bce4:	681b      	ldr	r3, [r3, #0]
3400bce6:	430a      	orrs	r2, r1
3400bce8:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
3400bcea:	687b      	ldr	r3, [r7, #4]
3400bcec:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400bcee:	f003 0380 	and.w	r3, r3, #128	@ 0x80
3400bcf2:	2b00      	cmp	r3, #0
3400bcf4:	d00a      	beq.n	3400bd0c <UART_AdvFeatureConfig+0x138>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
3400bcf6:	687b      	ldr	r3, [r7, #4]
3400bcf8:	681b      	ldr	r3, [r3, #0]
3400bcfa:	685b      	ldr	r3, [r3, #4]
3400bcfc:	f423 2100 	bic.w	r1, r3, #524288	@ 0x80000
3400bd00:	687b      	ldr	r3, [r7, #4]
3400bd02:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
3400bd04:	687b      	ldr	r3, [r7, #4]
3400bd06:	681b      	ldr	r3, [r3, #0]
3400bd08:	430a      	orrs	r2, r1
3400bd0a:	605a      	str	r2, [r3, #4]
  }
}
3400bd0c:	bf00      	nop
3400bd0e:	370c      	adds	r7, #12
3400bd10:	46bd      	mov	sp, r7
3400bd12:	f85d 7b04 	ldr.w	r7, [sp], #4
3400bd16:	4770      	bx	lr

3400bd18 <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
3400bd18:	b580      	push	{r7, lr}
3400bd1a:	b098      	sub	sp, #96	@ 0x60
3400bd1c:	af02      	add	r7, sp, #8
3400bd1e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
3400bd20:	687b      	ldr	r3, [r7, #4]
3400bd22:	2200      	movs	r2, #0
3400bd24:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
3400bd28:	f7f5 fe22 	bl	34001970 <HAL_GetTick>
3400bd2c:	6578      	str	r0, [r7, #84]	@ 0x54

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
3400bd2e:	687b      	ldr	r3, [r7, #4]
3400bd30:	681b      	ldr	r3, [r3, #0]
3400bd32:	681b      	ldr	r3, [r3, #0]
3400bd34:	f003 0308 	and.w	r3, r3, #8
3400bd38:	2b08      	cmp	r3, #8
3400bd3a:	d12f      	bne.n	3400bd9c <UART_CheckIdleState+0x84>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
3400bd3c:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
3400bd40:	9300      	str	r3, [sp, #0]
3400bd42:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3400bd44:	2200      	movs	r2, #0
3400bd46:	f44f 1100 	mov.w	r1, #2097152	@ 0x200000
3400bd4a:	6878      	ldr	r0, [r7, #4]
3400bd4c:	f000 f88e 	bl	3400be6c <UART_WaitOnFlagUntilTimeout>
3400bd50:	4603      	mov	r3, r0
3400bd52:	2b00      	cmp	r3, #0
3400bd54:	d022      	beq.n	3400bd9c <UART_CheckIdleState+0x84>
    {
      /* Disable TXE interrupt for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE));
3400bd56:	687b      	ldr	r3, [r7, #4]
3400bd58:	681b      	ldr	r3, [r3, #0]
3400bd5a:	63bb      	str	r3, [r7, #56]	@ 0x38
  __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
3400bd5c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3400bd5e:	e853 3f00 	ldrex	r3, [r3]
3400bd62:	637b      	str	r3, [r7, #52]	@ 0x34
  return (result);
3400bd64:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3400bd66:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
3400bd6a:	653b      	str	r3, [r7, #80]	@ 0x50
3400bd6c:	687b      	ldr	r3, [r7, #4]
3400bd6e:	681b      	ldr	r3, [r3, #0]
3400bd70:	461a      	mov	r2, r3
3400bd72:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3400bd74:	647b      	str	r3, [r7, #68]	@ 0x44
3400bd76:	643a      	str	r2, [r7, #64]	@ 0x40
  __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
3400bd78:	6c39      	ldr	r1, [r7, #64]	@ 0x40
3400bd7a:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
3400bd7c:	e841 2300 	strex	r3, r2, [r1]
3400bd80:	63fb      	str	r3, [r7, #60]	@ 0x3c
  return (result);
3400bd82:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3400bd84:	2b00      	cmp	r3, #0
3400bd86:	d1e6      	bne.n	3400bd56 <UART_CheckIdleState+0x3e>

      huart->gState = HAL_UART_STATE_READY;
3400bd88:	687b      	ldr	r3, [r7, #4]
3400bd8a:	2220      	movs	r2, #32
3400bd8c:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

      __HAL_UNLOCK(huart);
3400bd90:	687b      	ldr	r3, [r7, #4]
3400bd92:	2200      	movs	r2, #0
3400bd94:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

      /* Timeout occurred */
      return HAL_TIMEOUT;
3400bd98:	2303      	movs	r3, #3
3400bd9a:	e063      	b.n	3400be64 <UART_CheckIdleState+0x14c>
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
3400bd9c:	687b      	ldr	r3, [r7, #4]
3400bd9e:	681b      	ldr	r3, [r3, #0]
3400bda0:	681b      	ldr	r3, [r3, #0]
3400bda2:	f003 0304 	and.w	r3, r3, #4
3400bda6:	2b04      	cmp	r3, #4
3400bda8:	d149      	bne.n	3400be3e <UART_CheckIdleState+0x126>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
3400bdaa:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
3400bdae:	9300      	str	r3, [sp, #0]
3400bdb0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3400bdb2:	2200      	movs	r2, #0
3400bdb4:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
3400bdb8:	6878      	ldr	r0, [r7, #4]
3400bdba:	f000 f857 	bl	3400be6c <UART_WaitOnFlagUntilTimeout>
3400bdbe:	4603      	mov	r3, r0
3400bdc0:	2b00      	cmp	r3, #0
3400bdc2:	d03c      	beq.n	3400be3e <UART_CheckIdleState+0x126>
    {
      /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error)
      interrupts for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
3400bdc4:	687b      	ldr	r3, [r7, #4]
3400bdc6:	681b      	ldr	r3, [r3, #0]
3400bdc8:	627b      	str	r3, [r7, #36]	@ 0x24
  __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
3400bdca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3400bdcc:	e853 3f00 	ldrex	r3, [r3]
3400bdd0:	623b      	str	r3, [r7, #32]
  return (result);
3400bdd2:	6a3b      	ldr	r3, [r7, #32]
3400bdd4:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
3400bdd8:	64fb      	str	r3, [r7, #76]	@ 0x4c
3400bdda:	687b      	ldr	r3, [r7, #4]
3400bddc:	681b      	ldr	r3, [r3, #0]
3400bdde:	461a      	mov	r2, r3
3400bde0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3400bde2:	633b      	str	r3, [r7, #48]	@ 0x30
3400bde4:	62fa      	str	r2, [r7, #44]	@ 0x2c
  __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
3400bde6:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
3400bde8:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
3400bdea:	e841 2300 	strex	r3, r2, [r1]
3400bdee:	62bb      	str	r3, [r7, #40]	@ 0x28
  return (result);
3400bdf0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400bdf2:	2b00      	cmp	r3, #0
3400bdf4:	d1e6      	bne.n	3400bdc4 <UART_CheckIdleState+0xac>
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
3400bdf6:	687b      	ldr	r3, [r7, #4]
3400bdf8:	681b      	ldr	r3, [r3, #0]
3400bdfa:	3308      	adds	r3, #8
3400bdfc:	613b      	str	r3, [r7, #16]
  __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
3400bdfe:	693b      	ldr	r3, [r7, #16]
3400be00:	e853 3f00 	ldrex	r3, [r3]
3400be04:	60fb      	str	r3, [r7, #12]
  return (result);
3400be06:	68fb      	ldr	r3, [r7, #12]
3400be08:	f023 0301 	bic.w	r3, r3, #1
3400be0c:	64bb      	str	r3, [r7, #72]	@ 0x48
3400be0e:	687b      	ldr	r3, [r7, #4]
3400be10:	681b      	ldr	r3, [r3, #0]
3400be12:	3308      	adds	r3, #8
3400be14:	6cba      	ldr	r2, [r7, #72]	@ 0x48
3400be16:	61fa      	str	r2, [r7, #28]
3400be18:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
3400be1a:	69b9      	ldr	r1, [r7, #24]
3400be1c:	69fa      	ldr	r2, [r7, #28]
3400be1e:	e841 2300 	strex	r3, r2, [r1]
3400be22:	617b      	str	r3, [r7, #20]
  return (result);
3400be24:	697b      	ldr	r3, [r7, #20]
3400be26:	2b00      	cmp	r3, #0
3400be28:	d1e5      	bne.n	3400bdf6 <UART_CheckIdleState+0xde>

      huart->RxState = HAL_UART_STATE_READY;
3400be2a:	687b      	ldr	r3, [r7, #4]
3400be2c:	2220      	movs	r2, #32
3400be2e:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c

      __HAL_UNLOCK(huart);
3400be32:	687b      	ldr	r3, [r7, #4]
3400be34:	2200      	movs	r2, #0
3400be36:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

      /* Timeout occurred */
      return HAL_TIMEOUT;
3400be3a:	2303      	movs	r3, #3
3400be3c:	e012      	b.n	3400be64 <UART_CheckIdleState+0x14c>
    }
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
3400be3e:	687b      	ldr	r3, [r7, #4]
3400be40:	2220      	movs	r2, #32
3400be42:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
  huart->RxState = HAL_UART_STATE_READY;
3400be46:	687b      	ldr	r3, [r7, #4]
3400be48:	2220      	movs	r2, #32
3400be4a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
3400be4e:	687b      	ldr	r3, [r7, #4]
3400be50:	2200      	movs	r2, #0
3400be52:	66da      	str	r2, [r3, #108]	@ 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
3400be54:	687b      	ldr	r3, [r7, #4]
3400be56:	2200      	movs	r2, #0
3400be58:	671a      	str	r2, [r3, #112]	@ 0x70

  __HAL_UNLOCK(huart);
3400be5a:	687b      	ldr	r3, [r7, #4]
3400be5c:	2200      	movs	r2, #0
3400be5e:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  return HAL_OK;
3400be62:	2300      	movs	r3, #0
}
3400be64:	4618      	mov	r0, r3
3400be66:	3758      	adds	r7, #88	@ 0x58
3400be68:	46bd      	mov	sp, r7
3400be6a:	bd80      	pop	{r7, pc}

3400be6c <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
3400be6c:	b580      	push	{r7, lr}
3400be6e:	b084      	sub	sp, #16
3400be70:	af00      	add	r7, sp, #0
3400be72:	60f8      	str	r0, [r7, #12]
3400be74:	60b9      	str	r1, [r7, #8]
3400be76:	603b      	str	r3, [r7, #0]
3400be78:	4613      	mov	r3, r2
3400be7a:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
3400be7c:	e04f      	b.n	3400bf1e <UART_WaitOnFlagUntilTimeout+0xb2>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
3400be7e:	69bb      	ldr	r3, [r7, #24]
3400be80:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
3400be84:	d04b      	beq.n	3400bf1e <UART_WaitOnFlagUntilTimeout+0xb2>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
3400be86:	f7f5 fd73 	bl	34001970 <HAL_GetTick>
3400be8a:	4602      	mov	r2, r0
3400be8c:	683b      	ldr	r3, [r7, #0]
3400be8e:	1ad3      	subs	r3, r2, r3
3400be90:	69ba      	ldr	r2, [r7, #24]
3400be92:	429a      	cmp	r2, r3
3400be94:	d302      	bcc.n	3400be9c <UART_WaitOnFlagUntilTimeout+0x30>
3400be96:	69bb      	ldr	r3, [r7, #24]
3400be98:	2b00      	cmp	r3, #0
3400be9a:	d101      	bne.n	3400bea0 <UART_WaitOnFlagUntilTimeout+0x34>
      {

        return HAL_TIMEOUT;
3400be9c:	2303      	movs	r3, #3
3400be9e:	e04e      	b.n	3400bf3e <UART_WaitOnFlagUntilTimeout+0xd2>
      }

      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
3400bea0:	68fb      	ldr	r3, [r7, #12]
3400bea2:	681b      	ldr	r3, [r3, #0]
3400bea4:	681b      	ldr	r3, [r3, #0]
3400bea6:	f003 0304 	and.w	r3, r3, #4
3400beaa:	2b00      	cmp	r3, #0
3400beac:	d037      	beq.n	3400bf1e <UART_WaitOnFlagUntilTimeout+0xb2>
3400beae:	68bb      	ldr	r3, [r7, #8]
3400beb0:	2b80      	cmp	r3, #128	@ 0x80
3400beb2:	d034      	beq.n	3400bf1e <UART_WaitOnFlagUntilTimeout+0xb2>
3400beb4:	68bb      	ldr	r3, [r7, #8]
3400beb6:	2b40      	cmp	r3, #64	@ 0x40
3400beb8:	d031      	beq.n	3400bf1e <UART_WaitOnFlagUntilTimeout+0xb2>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
3400beba:	68fb      	ldr	r3, [r7, #12]
3400bebc:	681b      	ldr	r3, [r3, #0]
3400bebe:	69db      	ldr	r3, [r3, #28]
3400bec0:	f003 0308 	and.w	r3, r3, #8
3400bec4:	2b08      	cmp	r3, #8
3400bec6:	d110      	bne.n	3400beea <UART_WaitOnFlagUntilTimeout+0x7e>
        {
          /* Clear Overrun Error flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
3400bec8:	68fb      	ldr	r3, [r7, #12]
3400beca:	681b      	ldr	r3, [r3, #0]
3400becc:	2208      	movs	r2, #8
3400bece:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
3400bed0:	68f8      	ldr	r0, [r7, #12]
3400bed2:	f000 f838 	bl	3400bf46 <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_ORE;
3400bed6:	68fb      	ldr	r3, [r7, #12]
3400bed8:	2208      	movs	r2, #8
3400beda:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
3400bede:	68fb      	ldr	r3, [r7, #12]
3400bee0:	2200      	movs	r2, #0
3400bee2:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

          return HAL_ERROR;
3400bee6:	2301      	movs	r3, #1
3400bee8:	e029      	b.n	3400bf3e <UART_WaitOnFlagUntilTimeout+0xd2>
        }
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
3400beea:	68fb      	ldr	r3, [r7, #12]
3400beec:	681b      	ldr	r3, [r3, #0]
3400beee:	69db      	ldr	r3, [r3, #28]
3400bef0:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3400bef4:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
3400bef8:	d111      	bne.n	3400bf1e <UART_WaitOnFlagUntilTimeout+0xb2>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
3400befa:	68fb      	ldr	r3, [r7, #12]
3400befc:	681b      	ldr	r3, [r3, #0]
3400befe:	f44f 6200 	mov.w	r2, #2048	@ 0x800
3400bf02:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
3400bf04:	68f8      	ldr	r0, [r7, #12]
3400bf06:	f000 f81e 	bl	3400bf46 <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_RTO;
3400bf0a:	68fb      	ldr	r3, [r7, #12]
3400bf0c:	2220      	movs	r2, #32
3400bf0e:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
3400bf12:	68fb      	ldr	r3, [r7, #12]
3400bf14:	2200      	movs	r2, #0
3400bf16:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

          return HAL_TIMEOUT;
3400bf1a:	2303      	movs	r3, #3
3400bf1c:	e00f      	b.n	3400bf3e <UART_WaitOnFlagUntilTimeout+0xd2>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
3400bf1e:	68fb      	ldr	r3, [r7, #12]
3400bf20:	681b      	ldr	r3, [r3, #0]
3400bf22:	69da      	ldr	r2, [r3, #28]
3400bf24:	68bb      	ldr	r3, [r7, #8]
3400bf26:	4013      	ands	r3, r2
3400bf28:	68ba      	ldr	r2, [r7, #8]
3400bf2a:	429a      	cmp	r2, r3
3400bf2c:	bf0c      	ite	eq
3400bf2e:	2301      	moveq	r3, #1
3400bf30:	2300      	movne	r3, #0
3400bf32:	b2db      	uxtb	r3, r3
3400bf34:	461a      	mov	r2, r3
3400bf36:	79fb      	ldrb	r3, [r7, #7]
3400bf38:	429a      	cmp	r2, r3
3400bf3a:	d0a0      	beq.n	3400be7e <UART_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
3400bf3c:	2300      	movs	r3, #0
}
3400bf3e:	4618      	mov	r0, r3
3400bf40:	3710      	adds	r7, #16
3400bf42:	46bd      	mov	sp, r7
3400bf44:	bd80      	pop	{r7, pc}

3400bf46 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
3400bf46:	b480      	push	{r7}
3400bf48:	b095      	sub	sp, #84	@ 0x54
3400bf4a:	af00      	add	r7, sp, #0
3400bf4c:	6078      	str	r0, [r7, #4]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
3400bf4e:	687b      	ldr	r3, [r7, #4]
3400bf50:	681b      	ldr	r3, [r3, #0]
3400bf52:	637b      	str	r3, [r7, #52]	@ 0x34
  __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
3400bf54:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3400bf56:	e853 3f00 	ldrex	r3, [r3]
3400bf5a:	633b      	str	r3, [r7, #48]	@ 0x30
  return (result);
3400bf5c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400bf5e:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
3400bf62:	64fb      	str	r3, [r7, #76]	@ 0x4c
3400bf64:	687b      	ldr	r3, [r7, #4]
3400bf66:	681b      	ldr	r3, [r3, #0]
3400bf68:	461a      	mov	r2, r3
3400bf6a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3400bf6c:	643b      	str	r3, [r7, #64]	@ 0x40
3400bf6e:	63fa      	str	r2, [r7, #60]	@ 0x3c
  __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
3400bf70:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
3400bf72:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
3400bf74:	e841 2300 	strex	r3, r2, [r1]
3400bf78:	63bb      	str	r3, [r7, #56]	@ 0x38
  return (result);
3400bf7a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3400bf7c:	2b00      	cmp	r3, #0
3400bf7e:	d1e6      	bne.n	3400bf4e <UART_EndRxTransfer+0x8>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
3400bf80:	687b      	ldr	r3, [r7, #4]
3400bf82:	681b      	ldr	r3, [r3, #0]
3400bf84:	3308      	adds	r3, #8
3400bf86:	623b      	str	r3, [r7, #32]
  __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
3400bf88:	6a3b      	ldr	r3, [r7, #32]
3400bf8a:	e853 3f00 	ldrex	r3, [r3]
3400bf8e:	61fb      	str	r3, [r7, #28]
  return (result);
3400bf90:	69fb      	ldr	r3, [r7, #28]
3400bf92:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
3400bf96:	f023 0301 	bic.w	r3, r3, #1
3400bf9a:	64bb      	str	r3, [r7, #72]	@ 0x48
3400bf9c:	687b      	ldr	r3, [r7, #4]
3400bf9e:	681b      	ldr	r3, [r3, #0]
3400bfa0:	3308      	adds	r3, #8
3400bfa2:	6cba      	ldr	r2, [r7, #72]	@ 0x48
3400bfa4:	62fa      	str	r2, [r7, #44]	@ 0x2c
3400bfa6:	62bb      	str	r3, [r7, #40]	@ 0x28
  __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
3400bfa8:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400bfaa:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
3400bfac:	e841 2300 	strex	r3, r2, [r1]
3400bfb0:	627b      	str	r3, [r7, #36]	@ 0x24
  return (result);
3400bfb2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3400bfb4:	2b00      	cmp	r3, #0
3400bfb6:	d1e3      	bne.n	3400bf80 <UART_EndRxTransfer+0x3a>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
3400bfb8:	687b      	ldr	r3, [r7, #4]
3400bfba:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
3400bfbc:	2b01      	cmp	r3, #1
3400bfbe:	d118      	bne.n	3400bff2 <UART_EndRxTransfer+0xac>
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
3400bfc0:	687b      	ldr	r3, [r7, #4]
3400bfc2:	681b      	ldr	r3, [r3, #0]
3400bfc4:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
3400bfc6:	68fb      	ldr	r3, [r7, #12]
3400bfc8:	e853 3f00 	ldrex	r3, [r3]
3400bfcc:	60bb      	str	r3, [r7, #8]
  return (result);
3400bfce:	68bb      	ldr	r3, [r7, #8]
3400bfd0:	f023 0310 	bic.w	r3, r3, #16
3400bfd4:	647b      	str	r3, [r7, #68]	@ 0x44
3400bfd6:	687b      	ldr	r3, [r7, #4]
3400bfd8:	681b      	ldr	r3, [r3, #0]
3400bfda:	461a      	mov	r2, r3
3400bfdc:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3400bfde:	61bb      	str	r3, [r7, #24]
3400bfe0:	617a      	str	r2, [r7, #20]
  __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
3400bfe2:	6979      	ldr	r1, [r7, #20]
3400bfe4:	69ba      	ldr	r2, [r7, #24]
3400bfe6:	e841 2300 	strex	r3, r2, [r1]
3400bfea:	613b      	str	r3, [r7, #16]
  return (result);
3400bfec:	693b      	ldr	r3, [r7, #16]
3400bfee:	2b00      	cmp	r3, #0
3400bff0:	d1e6      	bne.n	3400bfc0 <UART_EndRxTransfer+0x7a>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
3400bff2:	687b      	ldr	r3, [r7, #4]
3400bff4:	2220      	movs	r2, #32
3400bff6:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
3400bffa:	687b      	ldr	r3, [r7, #4]
3400bffc:	2200      	movs	r2, #0
3400bffe:	66da      	str	r2, [r3, #108]	@ 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
3400c000:	687b      	ldr	r3, [r7, #4]
3400c002:	2200      	movs	r2, #0
3400c004:	675a      	str	r2, [r3, #116]	@ 0x74
}
3400c006:	bf00      	nop
3400c008:	3754      	adds	r7, #84	@ 0x54
3400c00a:	46bd      	mov	sp, r7
3400c00c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400c010:	4770      	bx	lr

3400c012 <HAL_UARTEx_DisableFifoMode>:
  * @brief  Disable the FIFO mode.
  * @param huart      UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_DisableFifoMode(UART_HandleTypeDef *huart)
{
3400c012:	b480      	push	{r7}
3400c014:	b085      	sub	sp, #20
3400c016:	af00      	add	r7, sp, #0
3400c018:	6078      	str	r0, [r7, #4]

  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));

  /* Process Locked */
  __HAL_LOCK(huart);
3400c01a:	687b      	ldr	r3, [r7, #4]
3400c01c:	f893 3084 	ldrb.w	r3, [r3, #132]	@ 0x84
3400c020:	2b01      	cmp	r3, #1
3400c022:	d101      	bne.n	3400c028 <HAL_UARTEx_DisableFifoMode+0x16>
3400c024:	2302      	movs	r3, #2
3400c026:	e027      	b.n	3400c078 <HAL_UARTEx_DisableFifoMode+0x66>
3400c028:	687b      	ldr	r3, [r7, #4]
3400c02a:	2201      	movs	r2, #1
3400c02c:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  huart->gState = HAL_UART_STATE_BUSY;
3400c030:	687b      	ldr	r3, [r7, #4]
3400c032:	2224      	movs	r2, #36	@ 0x24
3400c034:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
3400c038:	687b      	ldr	r3, [r7, #4]
3400c03a:	681b      	ldr	r3, [r3, #0]
3400c03c:	681b      	ldr	r3, [r3, #0]
3400c03e:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
3400c040:	687b      	ldr	r3, [r7, #4]
3400c042:	681b      	ldr	r3, [r3, #0]
3400c044:	681a      	ldr	r2, [r3, #0]
3400c046:	687b      	ldr	r3, [r7, #4]
3400c048:	681b      	ldr	r3, [r3, #0]
3400c04a:	f022 0201 	bic.w	r2, r2, #1
3400c04e:	601a      	str	r2, [r3, #0]

  /* Disable FIFO mode */
  CLEAR_BIT(tmpcr1, USART_CR1_FIFOEN);
3400c050:	68fb      	ldr	r3, [r7, #12]
3400c052:	f023 5300 	bic.w	r3, r3, #536870912	@ 0x20000000
3400c056:	60fb      	str	r3, [r7, #12]
  huart->FifoMode = UART_FIFOMODE_DISABLE;
3400c058:	687b      	ldr	r3, [r7, #4]
3400c05a:	2200      	movs	r2, #0
3400c05c:	665a      	str	r2, [r3, #100]	@ 0x64

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
3400c05e:	687b      	ldr	r3, [r7, #4]
3400c060:	681b      	ldr	r3, [r3, #0]
3400c062:	68fa      	ldr	r2, [r7, #12]
3400c064:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
3400c066:	687b      	ldr	r3, [r7, #4]
3400c068:	2220      	movs	r2, #32
3400c06a:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
3400c06e:	687b      	ldr	r3, [r7, #4]
3400c070:	2200      	movs	r2, #0
3400c072:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  return HAL_OK;
3400c076:	2300      	movs	r3, #0
}
3400c078:	4618      	mov	r0, r3
3400c07a:	3714      	adds	r7, #20
3400c07c:	46bd      	mov	sp, r7
3400c07e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400c082:	4770      	bx	lr

3400c084 <HAL_UARTEx_SetTxFifoThreshold>:
  *            @arg @ref UART_TXFIFO_THRESHOLD_7_8
  *            @arg @ref UART_TXFIFO_THRESHOLD_8_8
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_SetTxFifoThreshold(UART_HandleTypeDef *huart, uint32_t Threshold)
{
3400c084:	b580      	push	{r7, lr}
3400c086:	b084      	sub	sp, #16
3400c088:	af00      	add	r7, sp, #0
3400c08a:	6078      	str	r0, [r7, #4]
3400c08c:	6039      	str	r1, [r7, #0]
  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
  assert_param(IS_UART_TXFIFO_THRESHOLD(Threshold));

  /* Process Locked */
  __HAL_LOCK(huart);
3400c08e:	687b      	ldr	r3, [r7, #4]
3400c090:	f893 3084 	ldrb.w	r3, [r3, #132]	@ 0x84
3400c094:	2b01      	cmp	r3, #1
3400c096:	d101      	bne.n	3400c09c <HAL_UARTEx_SetTxFifoThreshold+0x18>
3400c098:	2302      	movs	r3, #2
3400c09a:	e02d      	b.n	3400c0f8 <HAL_UARTEx_SetTxFifoThreshold+0x74>
3400c09c:	687b      	ldr	r3, [r7, #4]
3400c09e:	2201      	movs	r2, #1
3400c0a0:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  huart->gState = HAL_UART_STATE_BUSY;
3400c0a4:	687b      	ldr	r3, [r7, #4]
3400c0a6:	2224      	movs	r2, #36	@ 0x24
3400c0a8:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
3400c0ac:	687b      	ldr	r3, [r7, #4]
3400c0ae:	681b      	ldr	r3, [r3, #0]
3400c0b0:	681b      	ldr	r3, [r3, #0]
3400c0b2:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
3400c0b4:	687b      	ldr	r3, [r7, #4]
3400c0b6:	681b      	ldr	r3, [r3, #0]
3400c0b8:	681a      	ldr	r2, [r3, #0]
3400c0ba:	687b      	ldr	r3, [r7, #4]
3400c0bc:	681b      	ldr	r3, [r3, #0]
3400c0be:	f022 0201 	bic.w	r2, r2, #1
3400c0c2:	601a      	str	r2, [r3, #0]

  /* Update TX threshold configuration */
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
3400c0c4:	687b      	ldr	r3, [r7, #4]
3400c0c6:	681b      	ldr	r3, [r3, #0]
3400c0c8:	689b      	ldr	r3, [r3, #8]
3400c0ca:	f023 4160 	bic.w	r1, r3, #3758096384	@ 0xe0000000
3400c0ce:	687b      	ldr	r3, [r7, #4]
3400c0d0:	681b      	ldr	r3, [r3, #0]
3400c0d2:	683a      	ldr	r2, [r7, #0]
3400c0d4:	430a      	orrs	r2, r1
3400c0d6:	609a      	str	r2, [r3, #8]

  /* Determine the number of data to process during RX/TX ISR execution */
  UARTEx_SetNbDataToProcess(huart);
3400c0d8:	6878      	ldr	r0, [r7, #4]
3400c0da:	f000 f84f 	bl	3400c17c <UARTEx_SetNbDataToProcess>

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
3400c0de:	687b      	ldr	r3, [r7, #4]
3400c0e0:	681b      	ldr	r3, [r3, #0]
3400c0e2:	68fa      	ldr	r2, [r7, #12]
3400c0e4:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
3400c0e6:	687b      	ldr	r3, [r7, #4]
3400c0e8:	2220      	movs	r2, #32
3400c0ea:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
3400c0ee:	687b      	ldr	r3, [r7, #4]
3400c0f0:	2200      	movs	r2, #0
3400c0f2:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  return HAL_OK;
3400c0f6:	2300      	movs	r3, #0
}
3400c0f8:	4618      	mov	r0, r3
3400c0fa:	3710      	adds	r7, #16
3400c0fc:	46bd      	mov	sp, r7
3400c0fe:	bd80      	pop	{r7, pc}

3400c100 <HAL_UARTEx_SetRxFifoThreshold>:
  *            @arg @ref UART_RXFIFO_THRESHOLD_7_8
  *            @arg @ref UART_RXFIFO_THRESHOLD_8_8
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_SetRxFifoThreshold(UART_HandleTypeDef *huart, uint32_t Threshold)
{
3400c100:	b580      	push	{r7, lr}
3400c102:	b084      	sub	sp, #16
3400c104:	af00      	add	r7, sp, #0
3400c106:	6078      	str	r0, [r7, #4]
3400c108:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
  assert_param(IS_UART_RXFIFO_THRESHOLD(Threshold));

  /* Process Locked */
  __HAL_LOCK(huart);
3400c10a:	687b      	ldr	r3, [r7, #4]
3400c10c:	f893 3084 	ldrb.w	r3, [r3, #132]	@ 0x84
3400c110:	2b01      	cmp	r3, #1
3400c112:	d101      	bne.n	3400c118 <HAL_UARTEx_SetRxFifoThreshold+0x18>
3400c114:	2302      	movs	r3, #2
3400c116:	e02d      	b.n	3400c174 <HAL_UARTEx_SetRxFifoThreshold+0x74>
3400c118:	687b      	ldr	r3, [r7, #4]
3400c11a:	2201      	movs	r2, #1
3400c11c:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  huart->gState = HAL_UART_STATE_BUSY;
3400c120:	687b      	ldr	r3, [r7, #4]
3400c122:	2224      	movs	r2, #36	@ 0x24
3400c124:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
3400c128:	687b      	ldr	r3, [r7, #4]
3400c12a:	681b      	ldr	r3, [r3, #0]
3400c12c:	681b      	ldr	r3, [r3, #0]
3400c12e:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
3400c130:	687b      	ldr	r3, [r7, #4]
3400c132:	681b      	ldr	r3, [r3, #0]
3400c134:	681a      	ldr	r2, [r3, #0]
3400c136:	687b      	ldr	r3, [r7, #4]
3400c138:	681b      	ldr	r3, [r3, #0]
3400c13a:	f022 0201 	bic.w	r2, r2, #1
3400c13e:	601a      	str	r2, [r3, #0]

  /* Update RX threshold configuration */
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
3400c140:	687b      	ldr	r3, [r7, #4]
3400c142:	681b      	ldr	r3, [r3, #0]
3400c144:	689b      	ldr	r3, [r3, #8]
3400c146:	f023 6160 	bic.w	r1, r3, #234881024	@ 0xe000000
3400c14a:	687b      	ldr	r3, [r7, #4]
3400c14c:	681b      	ldr	r3, [r3, #0]
3400c14e:	683a      	ldr	r2, [r7, #0]
3400c150:	430a      	orrs	r2, r1
3400c152:	609a      	str	r2, [r3, #8]

  /* Determine the number of data to process during RX/TX ISR execution */
  UARTEx_SetNbDataToProcess(huart);
3400c154:	6878      	ldr	r0, [r7, #4]
3400c156:	f000 f811 	bl	3400c17c <UARTEx_SetNbDataToProcess>

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
3400c15a:	687b      	ldr	r3, [r7, #4]
3400c15c:	681b      	ldr	r3, [r3, #0]
3400c15e:	68fa      	ldr	r2, [r7, #12]
3400c160:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
3400c162:	687b      	ldr	r3, [r7, #4]
3400c164:	2220      	movs	r2, #32
3400c166:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
3400c16a:	687b      	ldr	r3, [r7, #4]
3400c16c:	2200      	movs	r2, #0
3400c16e:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  return HAL_OK;
3400c172:	2300      	movs	r3, #0
}
3400c174:	4618      	mov	r0, r3
3400c176:	3710      	adds	r7, #16
3400c178:	46bd      	mov	sp, r7
3400c17a:	bd80      	pop	{r7, pc}

3400c17c <UARTEx_SetNbDataToProcess>:
  *       the UART configuration registers.
  * @param huart UART handle.
  * @retval None
  */
static void UARTEx_SetNbDataToProcess(UART_HandleTypeDef *huart)
{
3400c17c:	b480      	push	{r7}
3400c17e:	b085      	sub	sp, #20
3400c180:	af00      	add	r7, sp, #0
3400c182:	6078      	str	r0, [r7, #4]
  uint8_t rx_fifo_threshold;
  uint8_t tx_fifo_threshold;
  static const uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
  static const uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};

  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
3400c184:	687b      	ldr	r3, [r7, #4]
3400c186:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
3400c188:	2b00      	cmp	r3, #0
3400c18a:	d108      	bne.n	3400c19e <UARTEx_SetNbDataToProcess+0x22>
  {
    huart->NbTxDataToProcess = 1U;
3400c18c:	687b      	ldr	r3, [r7, #4]
3400c18e:	2201      	movs	r2, #1
3400c190:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
    huart->NbRxDataToProcess = 1U;
3400c194:	687b      	ldr	r3, [r7, #4]
3400c196:	2201      	movs	r2, #1
3400c198:	f8a3 2068 	strh.w	r2, [r3, #104]	@ 0x68
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
                               (uint16_t)denominator[tx_fifo_threshold];
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
                               (uint16_t)denominator[rx_fifo_threshold];
  }
}
3400c19c:	e031      	b.n	3400c202 <UARTEx_SetNbDataToProcess+0x86>
    rx_fifo_depth = RX_FIFO_DEPTH;
3400c19e:	2310      	movs	r3, #16
3400c1a0:	73fb      	strb	r3, [r7, #15]
    tx_fifo_depth = TX_FIFO_DEPTH;
3400c1a2:	2310      	movs	r3, #16
3400c1a4:	73bb      	strb	r3, [r7, #14]
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
3400c1a6:	687b      	ldr	r3, [r7, #4]
3400c1a8:	681b      	ldr	r3, [r3, #0]
3400c1aa:	689b      	ldr	r3, [r3, #8]
3400c1ac:	0e5b      	lsrs	r3, r3, #25
3400c1ae:	b2db      	uxtb	r3, r3
3400c1b0:	f003 0307 	and.w	r3, r3, #7
3400c1b4:	737b      	strb	r3, [r7, #13]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
3400c1b6:	687b      	ldr	r3, [r7, #4]
3400c1b8:	681b      	ldr	r3, [r3, #0]
3400c1ba:	689b      	ldr	r3, [r3, #8]
3400c1bc:	0f5b      	lsrs	r3, r3, #29
3400c1be:	b2db      	uxtb	r3, r3
3400c1c0:	f003 0307 	and.w	r3, r3, #7
3400c1c4:	733b      	strb	r3, [r7, #12]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
3400c1c6:	7bbb      	ldrb	r3, [r7, #14]
3400c1c8:	7b3a      	ldrb	r2, [r7, #12]
3400c1ca:	4911      	ldr	r1, [pc, #68]	@ (3400c210 <UARTEx_SetNbDataToProcess+0x94>)
3400c1cc:	5c8a      	ldrb	r2, [r1, r2]
3400c1ce:	fb02 f303 	mul.w	r3, r2, r3
                               (uint16_t)denominator[tx_fifo_threshold];
3400c1d2:	7b3a      	ldrb	r2, [r7, #12]
3400c1d4:	490f      	ldr	r1, [pc, #60]	@ (3400c214 <UARTEx_SetNbDataToProcess+0x98>)
3400c1d6:	5c8a      	ldrb	r2, [r1, r2]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
3400c1d8:	fb93 f3f2 	sdiv	r3, r3, r2
3400c1dc:	b29a      	uxth	r2, r3
3400c1de:	687b      	ldr	r3, [r7, #4]
3400c1e0:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
3400c1e4:	7bfb      	ldrb	r3, [r7, #15]
3400c1e6:	7b7a      	ldrb	r2, [r7, #13]
3400c1e8:	4909      	ldr	r1, [pc, #36]	@ (3400c210 <UARTEx_SetNbDataToProcess+0x94>)
3400c1ea:	5c8a      	ldrb	r2, [r1, r2]
3400c1ec:	fb02 f303 	mul.w	r3, r2, r3
                               (uint16_t)denominator[rx_fifo_threshold];
3400c1f0:	7b7a      	ldrb	r2, [r7, #13]
3400c1f2:	4908      	ldr	r1, [pc, #32]	@ (3400c214 <UARTEx_SetNbDataToProcess+0x98>)
3400c1f4:	5c8a      	ldrb	r2, [r1, r2]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
3400c1f6:	fb93 f3f2 	sdiv	r3, r3, r2
3400c1fa:	b29a      	uxth	r2, r3
3400c1fc:	687b      	ldr	r3, [r7, #4]
3400c1fe:	f8a3 2068 	strh.w	r2, [r3, #104]	@ 0x68
}
3400c202:	bf00      	nop
3400c204:	3714      	adds	r7, #20
3400c206:	46bd      	mov	sp, r7
3400c208:	f85d 7b04 	ldr.w	r7, [sp], #4
3400c20c:	4770      	bx	lr
3400c20e:	bf00      	nop
3400c210:	3400cab0 	.word	0x3400cab0
3400c214:	3400cab8 	.word	0x3400cab8

3400c218 <LL_AHB5_GRP1_IsEnabledClock>:
{
3400c218:	b480      	push	{r7}
3400c21a:	b083      	sub	sp, #12
3400c21c:	af00      	add	r7, sp, #0
3400c21e:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(RCC->AHB5ENR, Periphs) == Periphs) ? 1UL : 0UL);
3400c220:	4b08      	ldr	r3, [pc, #32]	@ (3400c244 <LL_AHB5_GRP1_IsEnabledClock+0x2c>)
3400c222:	f8d3 2260 	ldr.w	r2, [r3, #608]	@ 0x260
3400c226:	687b      	ldr	r3, [r7, #4]
3400c228:	4013      	ands	r3, r2
3400c22a:	687a      	ldr	r2, [r7, #4]
3400c22c:	429a      	cmp	r2, r3
3400c22e:	d101      	bne.n	3400c234 <LL_AHB5_GRP1_IsEnabledClock+0x1c>
3400c230:	2301      	movs	r3, #1
3400c232:	e000      	b.n	3400c236 <LL_AHB5_GRP1_IsEnabledClock+0x1e>
3400c234:	2300      	movs	r3, #0
}
3400c236:	4618      	mov	r0, r3
3400c238:	370c      	adds	r7, #12
3400c23a:	46bd      	mov	sp, r7
3400c23c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400c240:	4770      	bx	lr
3400c242:	bf00      	nop
3400c244:	56028000 	.word	0x56028000

3400c248 <HAL_XSPI_Init>:
  *         in the XSPI_InitTypeDef and initialize the associated handle.
  * @param  hxspi : XSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_Init(XSPI_HandleTypeDef *hxspi)
{
3400c248:	b580      	push	{r7, lr}
3400c24a:	b086      	sub	sp, #24
3400c24c:	af02      	add	r7, sp, #8
3400c24e:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
3400c250:	2300      	movs	r3, #0
3400c252:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart = HAL_GetTick();
3400c254:	f7f5 fb8c 	bl	34001970 <HAL_GetTick>
3400c258:	60b8      	str	r0, [r7, #8]

  /* Check the XSPI handle allocation */
  if (hxspi == NULL)
3400c25a:	687b      	ldr	r3, [r7, #4]
3400c25c:	2b00      	cmp	r3, #0
3400c25e:	d102      	bne.n	3400c266 <HAL_XSPI_Init+0x1e>
  {
    status = HAL_ERROR;
3400c260:	2301      	movs	r3, #1
3400c262:	73fb      	strb	r3, [r7, #15]
3400c264:	e0ec      	b.n	3400c440 <HAL_XSPI_Init+0x1f8>
    assert_param(IS_XSPI_FIFO_THRESHOLD_BYTE(hxspi->Init.FifoThresholdByte));
    assert_param(IS_XSPI_MAXTRAN(hxspi->Init.MaxTran));
    assert_param(IS_XSPI_CSSEL(hxspi->Init.MemorySelect));
    assert_param(IS_XSPI_EXTENDMEM(hxspi->Init.MemoryExtended));
    /* Initialize error code */
    hxspi->ErrorCode = HAL_XSPI_ERROR_NONE;
3400c266:	687b      	ldr	r3, [r7, #4]
3400c268:	2200      	movs	r2, #0
3400c26a:	65da      	str	r2, [r3, #92]	@ 0x5c

    /* Check if the state is the reset state */
    if (hxspi->State == HAL_XSPI_STATE_RESET)
3400c26c:	687b      	ldr	r3, [r7, #4]
3400c26e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3400c270:	2b00      	cmp	r3, #0
3400c272:	f040 80e5 	bne.w	3400c440 <HAL_XSPI_Init+0x1f8>

      /* Init the low level hardware */
      hxspi->MspInitCallback(hxspi);
#else
      /* Initialization of the low level hardware */
      HAL_XSPI_MspInit(hxspi);
3400c276:	6878      	ldr	r0, [r7, #4]
3400c278:	f7f4 ff8c 	bl	34001194 <HAL_XSPI_MspInit>
#endif /* defined (USE_HAL_XSPI_REGISTER_CALLBACKS) && (USE_HAL_XSPI_REGISTER_CALLBACKS == 1U) */

      /* Configure the default timeout for the XSPI memory access */
      (void)HAL_XSPI_SetTimeout(hxspi, HAL_XSPI_TIMEOUT_DEFAULT_VALUE);
3400c27c:	f241 3188 	movw	r1, #5000	@ 0x1388
3400c280:	6878      	ldr	r0, [r7, #4]
3400c282:	f000 f8f1 	bl	3400c468 <HAL_XSPI_SetTimeout>

      /* Configure memory type, device size, chip select high time, free running clock, clock mode */
      MODIFY_REG(hxspi->Instance->DCR1,
3400c286:	687b      	ldr	r3, [r7, #4]
3400c288:	681b      	ldr	r3, [r3, #0]
3400c28a:	689a      	ldr	r2, [r3, #8]
3400c28c:	4b6f      	ldr	r3, [pc, #444]	@ (3400c44c <HAL_XSPI_Init+0x204>)
3400c28e:	4013      	ands	r3, r2
3400c290:	687a      	ldr	r2, [r7, #4]
3400c292:	68d1      	ldr	r1, [r2, #12]
3400c294:	687a      	ldr	r2, [r7, #4]
3400c296:	6912      	ldr	r2, [r2, #16]
3400c298:	0412      	lsls	r2, r2, #16
3400c29a:	4311      	orrs	r1, r2
3400c29c:	687a      	ldr	r2, [r7, #4]
3400c29e:	6952      	ldr	r2, [r2, #20]
3400c2a0:	3a01      	subs	r2, #1
3400c2a2:	0212      	lsls	r2, r2, #8
3400c2a4:	4311      	orrs	r1, r2
3400c2a6:	687a      	ldr	r2, [r7, #4]
3400c2a8:	69d2      	ldr	r2, [r2, #28]
3400c2aa:	4311      	orrs	r1, r2
3400c2ac:	687a      	ldr	r2, [r7, #4]
3400c2ae:	6812      	ldr	r2, [r2, #0]
3400c2b0:	430b      	orrs	r3, r1
3400c2b2:	6093      	str	r3, [r2, #8]
                 (XSPI_DCR1_MTYP | XSPI_DCR1_DEVSIZE | XSPI_DCR1_CSHT | XSPI_DCR1_FRCK | XSPI_DCR1_CKMODE),
                 (hxspi->Init.MemoryType | ((hxspi->Init.MemorySize) << XSPI_DCR1_DEVSIZE_Pos) |
                  ((hxspi->Init.ChipSelectHighTimeCycle - 1U) << XSPI_DCR1_CSHT_Pos) | hxspi->Init.ClockMode));

      /* Configure wrap size */
      MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_WRAPSIZE, hxspi->Init.WrapSize);
3400c2b4:	687b      	ldr	r3, [r7, #4]
3400c2b6:	681b      	ldr	r3, [r3, #0]
3400c2b8:	68db      	ldr	r3, [r3, #12]
3400c2ba:	f423 21e0 	bic.w	r1, r3, #458752	@ 0x70000
3400c2be:	687b      	ldr	r3, [r7, #4]
3400c2c0:	6a1a      	ldr	r2, [r3, #32]
3400c2c2:	687b      	ldr	r3, [r7, #4]
3400c2c4:	681b      	ldr	r3, [r3, #0]
3400c2c6:	430a      	orrs	r2, r1
3400c2c8:	60da      	str	r2, [r3, #12]

      /* Configure chip select boundary */
      MODIFY_REG(hxspi->Instance->DCR3, XSPI_DCR3_CSBOUND, (hxspi->Init.ChipSelectBoundary << XSPI_DCR3_CSBOUND_Pos));
3400c2ca:	687b      	ldr	r3, [r7, #4]
3400c2cc:	681b      	ldr	r3, [r3, #0]
3400c2ce:	691b      	ldr	r3, [r3, #16]
3400c2d0:	f423 11f8 	bic.w	r1, r3, #2031616	@ 0x1f0000
3400c2d4:	687b      	ldr	r3, [r7, #4]
3400c2d6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3400c2d8:	041a      	lsls	r2, r3, #16
3400c2da:	687b      	ldr	r3, [r7, #4]
3400c2dc:	681b      	ldr	r3, [r3, #0]
3400c2de:	430a      	orrs	r2, r1
3400c2e0:	611a      	str	r2, [r3, #16]

      /* Configure maximum transfer */
      MODIFY_REG(hxspi->Instance->DCR3, XSPI_DCR3_MAXTRAN, \
3400c2e2:	687b      	ldr	r3, [r7, #4]
3400c2e4:	681b      	ldr	r3, [r3, #0]
3400c2e6:	691b      	ldr	r3, [r3, #16]
3400c2e8:	f023 01ff 	bic.w	r1, r3, #255	@ 0xff
3400c2ec:	687b      	ldr	r3, [r7, #4]
3400c2ee:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
3400c2f0:	687b      	ldr	r3, [r7, #4]
3400c2f2:	681b      	ldr	r3, [r3, #0]
3400c2f4:	430a      	orrs	r2, r1
3400c2f6:	611a      	str	r2, [r3, #16]
                 (hxspi->Init.MaxTran << XSPI_DCR3_MAXTRAN_Pos));

      /* Configure refresh */
      hxspi->Instance->DCR4 = hxspi->Init.Refresh;
3400c2f8:	687b      	ldr	r3, [r7, #4]
3400c2fa:	681b      	ldr	r3, [r3, #0]
3400c2fc:	687a      	ldr	r2, [r7, #4]
3400c2fe:	6b92      	ldr	r2, [r2, #56]	@ 0x38
3400c300:	615a      	str	r2, [r3, #20]

      /* Configure FIFO threshold */
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FTHRES, ((hxspi->Init.FifoThresholdByte - 1U) << XSPI_CR_FTHRES_Pos));
3400c302:	687b      	ldr	r3, [r7, #4]
3400c304:	681b      	ldr	r3, [r3, #0]
3400c306:	681b      	ldr	r3, [r3, #0]
3400c308:	f423 517c 	bic.w	r1, r3, #16128	@ 0x3f00
3400c30c:	687b      	ldr	r3, [r7, #4]
3400c30e:	685b      	ldr	r3, [r3, #4]
3400c310:	3b01      	subs	r3, #1
3400c312:	021a      	lsls	r2, r3, #8
3400c314:	687b      	ldr	r3, [r7, #4]
3400c316:	681b      	ldr	r3, [r3, #0]
3400c318:	430a      	orrs	r2, r1
3400c31a:	601a      	str	r2, [r3, #0]

      /* Wait till busy flag is reset */
      status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
3400c31c:	687b      	ldr	r3, [r7, #4]
3400c31e:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3400c320:	9300      	str	r3, [sp, #0]
3400c322:	68bb      	ldr	r3, [r7, #8]
3400c324:	2200      	movs	r2, #0
3400c326:	2120      	movs	r1, #32
3400c328:	6878      	ldr	r0, [r7, #4]
3400c32a:	f000 f9d9 	bl	3400c6e0 <XSPI_WaitFlagStateUntilTimeout>
3400c32e:	4603      	mov	r3, r0
3400c330:	73fb      	strb	r3, [r7, #15]

      if (status == HAL_OK)
3400c332:	7bfb      	ldrb	r3, [r7, #15]
3400c334:	2b00      	cmp	r3, #0
3400c336:	f040 8083 	bne.w	3400c440 <HAL_XSPI_Init+0x1f8>
      {
        /* Configure clock prescaler */
        MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_PRESCALER,
3400c33a:	687b      	ldr	r3, [r7, #4]
3400c33c:	681b      	ldr	r3, [r3, #0]
3400c33e:	68db      	ldr	r3, [r3, #12]
3400c340:	f023 01ff 	bic.w	r1, r3, #255	@ 0xff
3400c344:	687b      	ldr	r3, [r7, #4]
3400c346:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
3400c348:	687b      	ldr	r3, [r7, #4]
3400c34a:	681b      	ldr	r3, [r3, #0]
3400c34c:	430a      	orrs	r2, r1
3400c34e:	60da      	str	r2, [r3, #12]
                   ((hxspi->Init.ClockPrescaler) << XSPI_DCR2_PRESCALER_Pos));

        if (IS_XSPI_ALL_INSTANCE(hxspi->Instance))
3400c350:	687b      	ldr	r3, [r7, #4]
3400c352:	681b      	ldr	r3, [r3, #0]
3400c354:	4a3e      	ldr	r2, [pc, #248]	@ (3400c450 <HAL_XSPI_Init+0x208>)
3400c356:	4293      	cmp	r3, r2
3400c358:	d018      	beq.n	3400c38c <HAL_XSPI_Init+0x144>
3400c35a:	687b      	ldr	r3, [r7, #4]
3400c35c:	681b      	ldr	r3, [r3, #0]
3400c35e:	4a3d      	ldr	r2, [pc, #244]	@ (3400c454 <HAL_XSPI_Init+0x20c>)
3400c360:	4293      	cmp	r3, r2
3400c362:	d013      	beq.n	3400c38c <HAL_XSPI_Init+0x144>
3400c364:	687b      	ldr	r3, [r7, #4]
3400c366:	681b      	ldr	r3, [r3, #0]
3400c368:	4a3b      	ldr	r2, [pc, #236]	@ (3400c458 <HAL_XSPI_Init+0x210>)
3400c36a:	4293      	cmp	r3, r2
3400c36c:	d00e      	beq.n	3400c38c <HAL_XSPI_Init+0x144>
3400c36e:	687b      	ldr	r3, [r7, #4]
3400c370:	681b      	ldr	r3, [r3, #0]
3400c372:	4a3a      	ldr	r2, [pc, #232]	@ (3400c45c <HAL_XSPI_Init+0x214>)
3400c374:	4293      	cmp	r3, r2
3400c376:	d009      	beq.n	3400c38c <HAL_XSPI_Init+0x144>
3400c378:	687b      	ldr	r3, [r7, #4]
3400c37a:	681b      	ldr	r3, [r3, #0]
3400c37c:	4a38      	ldr	r2, [pc, #224]	@ (3400c460 <HAL_XSPI_Init+0x218>)
3400c37e:	4293      	cmp	r3, r2
3400c380:	d004      	beq.n	3400c38c <HAL_XSPI_Init+0x144>
3400c382:	687b      	ldr	r3, [r7, #4]
3400c384:	681b      	ldr	r3, [r3, #0]
3400c386:	4a37      	ldr	r2, [pc, #220]	@ (3400c464 <HAL_XSPI_Init+0x21c>)
3400c388:	4293      	cmp	r3, r2
3400c38a:	d10f      	bne.n	3400c3ac <HAL_XSPI_Init+0x164>
        {
          /* The configuration of clock prescaler trigger automatically a calibration process.
          So it is necessary to wait the calibration is complete */
          status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
3400c38c:	687b      	ldr	r3, [r7, #4]
3400c38e:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3400c390:	9300      	str	r3, [sp, #0]
3400c392:	68bb      	ldr	r3, [r7, #8]
3400c394:	2200      	movs	r2, #0
3400c396:	2120      	movs	r1, #32
3400c398:	6878      	ldr	r0, [r7, #4]
3400c39a:	f000 f9a1 	bl	3400c6e0 <XSPI_WaitFlagStateUntilTimeout>
3400c39e:	4603      	mov	r3, r0
3400c3a0:	73fb      	strb	r3, [r7, #15]
          if (status != HAL_OK)
3400c3a2:	7bfb      	ldrb	r3, [r7, #15]
3400c3a4:	2b00      	cmp	r3, #0
3400c3a6:	d001      	beq.n	3400c3ac <HAL_XSPI_Init+0x164>
          {
            return status;
3400c3a8:	7bfb      	ldrb	r3, [r7, #15]
3400c3aa:	e04a      	b.n	3400c442 <HAL_XSPI_Init+0x1fa>
          }
        }
        /* Configure Dual Memory mode and CS Selection */
        MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_DMM | XSPI_CR_CSSEL),
3400c3ac:	687b      	ldr	r3, [r7, #4]
3400c3ae:	681b      	ldr	r3, [r3, #0]
3400c3b0:	681b      	ldr	r3, [r3, #0]
3400c3b2:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
3400c3b6:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
3400c3ba:	687a      	ldr	r2, [r7, #4]
3400c3bc:	6891      	ldr	r1, [r2, #8]
3400c3be:	687a      	ldr	r2, [r7, #4]
3400c3c0:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
3400c3c2:	4311      	orrs	r1, r2
3400c3c4:	687a      	ldr	r2, [r7, #4]
3400c3c6:	6812      	ldr	r2, [r2, #0]
3400c3c8:	430b      	orrs	r3, r1
3400c3ca:	6013      	str	r3, [r2, #0]
                   (hxspi->Init.MemoryMode | hxspi->Init.MemorySelect));

        /* Configure sample shifting */
        MODIFY_REG(hxspi->Instance->TCR, (XSPI_TCR_SSHIFT), hxspi->Init.SampleShifting);
3400c3cc:	687b      	ldr	r3, [r7, #4]
3400c3ce:	681b      	ldr	r3, [r3, #0]
3400c3d0:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
3400c3d4:	f023 4180 	bic.w	r1, r3, #1073741824	@ 0x40000000
3400c3d8:	687b      	ldr	r3, [r7, #4]
3400c3da:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
3400c3dc:	687b      	ldr	r3, [r7, #4]
3400c3de:	681b      	ldr	r3, [r3, #0]
3400c3e0:	430a      	orrs	r2, r1
3400c3e2:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108

        /* Enable XSPI */
        HAL_XSPI_ENABLE(hxspi);
3400c3e6:	687b      	ldr	r3, [r7, #4]
3400c3e8:	681b      	ldr	r3, [r3, #0]
3400c3ea:	681a      	ldr	r2, [r3, #0]
3400c3ec:	687b      	ldr	r3, [r7, #4]
3400c3ee:	681b      	ldr	r3, [r3, #0]
3400c3f0:	f042 0201 	orr.w	r2, r2, #1
3400c3f4:	601a      	str	r2, [r3, #0]

        /* Enable free running clock if needed : must be done after XSPI enable */
        if (hxspi->Init.FreeRunningClock == HAL_XSPI_FREERUNCLK_ENABLE)
3400c3f6:	687b      	ldr	r3, [r7, #4]
3400c3f8:	699b      	ldr	r3, [r3, #24]
3400c3fa:	2b02      	cmp	r3, #2
3400c3fc:	d107      	bne.n	3400c40e <HAL_XSPI_Init+0x1c6>
        {
          SET_BIT(hxspi->Instance->DCR1, XSPI_DCR1_FRCK);
3400c3fe:	687b      	ldr	r3, [r7, #4]
3400c400:	681b      	ldr	r3, [r3, #0]
3400c402:	689a      	ldr	r2, [r3, #8]
3400c404:	687b      	ldr	r3, [r7, #4]
3400c406:	681b      	ldr	r3, [r3, #0]
3400c408:	f042 0202 	orr.w	r2, r2, #2
3400c40c:	609a      	str	r2, [r3, #8]
        }

        if (hxspi->Init.MemoryExtended == HAL_XSPI_CSSEL_HW)
3400c40e:	687b      	ldr	r3, [r7, #4]
3400c410:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400c412:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3400c416:	d107      	bne.n	3400c428 <HAL_XSPI_Init+0x1e0>
        {
          SET_BIT(hxspi->Instance->DCR1, XSPI_DCR1_EXTENDMEM);
3400c418:	687b      	ldr	r3, [r7, #4]
3400c41a:	681b      	ldr	r3, [r3, #0]
3400c41c:	689a      	ldr	r2, [r3, #8]
3400c41e:	687b      	ldr	r3, [r7, #4]
3400c420:	681b      	ldr	r3, [r3, #0]
3400c422:	f442 1200 	orr.w	r2, r2, #2097152	@ 0x200000
3400c426:	609a      	str	r2, [r3, #8]
        }

        /* Initialize the XSPI state */
        if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
3400c428:	687b      	ldr	r3, [r7, #4]
3400c42a:	68db      	ldr	r3, [r3, #12]
3400c42c:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
3400c430:	d103      	bne.n	3400c43a <HAL_XSPI_Init+0x1f2>
        {
          hxspi->State = HAL_XSPI_STATE_HYPERBUS_INIT;
3400c432:	687b      	ldr	r3, [r7, #4]
3400c434:	2201      	movs	r2, #1
3400c436:	659a      	str	r2, [r3, #88]	@ 0x58
3400c438:	e002      	b.n	3400c440 <HAL_XSPI_Init+0x1f8>
        }
        else
        {
          hxspi->State = HAL_XSPI_STATE_READY;
3400c43a:	687b      	ldr	r3, [r7, #4]
3400c43c:	2202      	movs	r2, #2
3400c43e:	659a      	str	r2, [r3, #88]	@ 0x58
        }
      }
    }
  }
  return status;
3400c440:	7bfb      	ldrb	r3, [r7, #15]
}
3400c442:	4618      	mov	r0, r3
3400c444:	3710      	adds	r7, #16
3400c446:	46bd      	mov	sp, r7
3400c448:	bd80      	pop	{r7, pc}
3400c44a:	bf00      	nop
3400c44c:	f8e0c0fc 	.word	0xf8e0c0fc
3400c450:	58025000 	.word	0x58025000
3400c454:	48025000 	.word	0x48025000
3400c458:	5802a000 	.word	0x5802a000
3400c45c:	4802a000 	.word	0x4802a000
3400c460:	5802d000 	.word	0x5802d000
3400c464:	4802d000 	.word	0x4802d000

3400c468 <HAL_XSPI_SetTimeout>:
  * @param  hxspi   : XSPI handle.
  * @param  Timeout : Timeout for the memory access.
  * @retval HAL state
  */
HAL_StatusTypeDef HAL_XSPI_SetTimeout(XSPI_HandleTypeDef *hxspi, uint32_t Timeout)
{
3400c468:	b480      	push	{r7}
3400c46a:	b083      	sub	sp, #12
3400c46c:	af00      	add	r7, sp, #0
3400c46e:	6078      	str	r0, [r7, #4]
3400c470:	6039      	str	r1, [r7, #0]
  hxspi->Timeout = Timeout;
3400c472:	687b      	ldr	r3, [r7, #4]
3400c474:	683a      	ldr	r2, [r7, #0]
3400c476:	661a      	str	r2, [r3, #96]	@ 0x60
  return HAL_OK;
3400c478:	2300      	movs	r3, #0
}
3400c47a:	4618      	mov	r0, r3
3400c47c:	370c      	adds	r7, #12
3400c47e:	46bd      	mov	sp, r7
3400c480:	f85d 7b04 	ldr.w	r7, [sp], #4
3400c484:	4770      	bx	lr
	...

3400c488 <HAL_XSPIM_Config>:
  * @param  pCfg     : Pointer to Configuration of the IO Manager for the instance
  * @param  Timeout : Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPIM_Config(XSPI_HandleTypeDef *hxspi, const XSPIM_CfgTypeDef *pCfg, uint32_t Timeout)
{
3400c488:	b580      	push	{r7, lr}
3400c48a:	b08e      	sub	sp, #56	@ 0x38
3400c48c:	af00      	add	r7, sp, #0
3400c48e:	60f8      	str	r0, [r7, #12]
3400c490:	60b9      	str	r1, [r7, #8]
3400c492:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
3400c494:	2300      	movs	r3, #0
3400c496:	f887 3035 	strb.w	r3, [r7, #53]	@ 0x35
  uint8_t index;
  uint8_t xspi_enabled = 0U;
3400c49a:	2300      	movs	r3, #0
3400c49c:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36

  XSPIM_CfgTypeDef IOM_cfg[XSPI_NB_INSTANCE] = {0};
3400c4a0:	f107 0310 	add.w	r3, r7, #16
3400c4a4:	2224      	movs	r2, #36	@ 0x24
3400c4a6:	2100      	movs	r1, #0
3400c4a8:	4618      	mov	r0, r3
3400c4aa:	f000 f9b3 	bl	3400c814 <memset>
  assert_param(IS_XSPIM_NCS_OVR(pCfg->nCSOverride));
  assert_param(IS_XSPIM_IO_PORT(pCfg->IOPort));
  assert_param(IS_XSPIM_REQ2ACKTIME(pCfg->Req2AckTime));

  /**************** Get current configuration of the instances ****************/
  for (index = 0U; index < XSPI_NB_INSTANCE; index++)
3400c4ae:	2300      	movs	r3, #0
3400c4b0:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
3400c4b4:	e014      	b.n	3400c4e0 <HAL_XSPIM_Config+0x58>
  {
    XSPIM_GetConfig(index + 1U, &(IOM_cfg[index]));
3400c4b6:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
3400c4ba:	3301      	adds	r3, #1
3400c4bc:	b2d8      	uxtb	r0, r3
3400c4be:	f897 2037 	ldrb.w	r2, [r7, #55]	@ 0x37
3400c4c2:	f107 0110 	add.w	r1, r7, #16
3400c4c6:	4613      	mov	r3, r2
3400c4c8:	005b      	lsls	r3, r3, #1
3400c4ca:	4413      	add	r3, r2
3400c4cc:	009b      	lsls	r3, r3, #2
3400c4ce:	440b      	add	r3, r1
3400c4d0:	4619      	mov	r1, r3
3400c4d2:	f000 f93b 	bl	3400c74c <XSPIM_GetConfig>
  for (index = 0U; index < XSPI_NB_INSTANCE; index++)
3400c4d6:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
3400c4da:	3301      	adds	r3, #1
3400c4dc:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
3400c4e0:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
3400c4e4:	2b02      	cmp	r3, #2
3400c4e6:	d9e6      	bls.n	3400c4b6 <HAL_XSPIM_Config+0x2e>
  }

  /********** Disable all XSPI to configure XSPI IO Manager **********/
  if (__HAL_RCC_XSPI1_IS_CLK_ENABLED() != 0U)
3400c4e8:	2020      	movs	r0, #32
3400c4ea:	f7ff fe95 	bl	3400c218 <LL_AHB5_GRP1_IsEnabledClock>
3400c4ee:	4603      	mov	r3, r0
3400c4f0:	2b00      	cmp	r3, #0
3400c4f2:	d011      	beq.n	3400c518 <HAL_XSPIM_Config+0x90>
  {
    if ((XSPI1->CR & XSPI_CR_EN) != 0U)
3400c4f4:	4b76      	ldr	r3, [pc, #472]	@ (3400c6d0 <HAL_XSPIM_Config+0x248>)
3400c4f6:	681b      	ldr	r3, [r3, #0]
3400c4f8:	f003 0301 	and.w	r3, r3, #1
3400c4fc:	2b00      	cmp	r3, #0
3400c4fe:	d00b      	beq.n	3400c518 <HAL_XSPIM_Config+0x90>
    {
      CLEAR_BIT(XSPI1->CR, XSPI_CR_EN);
3400c500:	4b73      	ldr	r3, [pc, #460]	@ (3400c6d0 <HAL_XSPIM_Config+0x248>)
3400c502:	681b      	ldr	r3, [r3, #0]
3400c504:	4a72      	ldr	r2, [pc, #456]	@ (3400c6d0 <HAL_XSPIM_Config+0x248>)
3400c506:	f023 0301 	bic.w	r3, r3, #1
3400c50a:	6013      	str	r3, [r2, #0]
      xspi_enabled |= 0x1U;
3400c50c:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
3400c510:	f043 0301 	orr.w	r3, r3, #1
3400c514:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36
    }
  }
  if (__HAL_RCC_XSPI2_IS_CLK_ENABLED() != 0U)
3400c518:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
3400c51c:	f7ff fe7c 	bl	3400c218 <LL_AHB5_GRP1_IsEnabledClock>
3400c520:	4603      	mov	r3, r0
3400c522:	2b00      	cmp	r3, #0
3400c524:	d011      	beq.n	3400c54a <HAL_XSPIM_Config+0xc2>
  {
    if ((XSPI2->CR & XSPI_CR_EN) != 0U)
3400c526:	4b6b      	ldr	r3, [pc, #428]	@ (3400c6d4 <HAL_XSPIM_Config+0x24c>)
3400c528:	681b      	ldr	r3, [r3, #0]
3400c52a:	f003 0301 	and.w	r3, r3, #1
3400c52e:	2b00      	cmp	r3, #0
3400c530:	d00b      	beq.n	3400c54a <HAL_XSPIM_Config+0xc2>
    {
      CLEAR_BIT(XSPI2->CR, XSPI_CR_EN);
3400c532:	4b68      	ldr	r3, [pc, #416]	@ (3400c6d4 <HAL_XSPIM_Config+0x24c>)
3400c534:	681b      	ldr	r3, [r3, #0]
3400c536:	4a67      	ldr	r2, [pc, #412]	@ (3400c6d4 <HAL_XSPIM_Config+0x24c>)
3400c538:	f023 0301 	bic.w	r3, r3, #1
3400c53c:	6013      	str	r3, [r2, #0]
      xspi_enabled |= 0x2U;
3400c53e:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
3400c542:	f043 0302 	orr.w	r3, r3, #2
3400c546:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36
    }
  }
  if (__HAL_RCC_XSPI3_IS_CLK_ENABLED() != 0U)
3400c54a:	f44f 3000 	mov.w	r0, #131072	@ 0x20000
3400c54e:	f7ff fe63 	bl	3400c218 <LL_AHB5_GRP1_IsEnabledClock>
3400c552:	4603      	mov	r3, r0
3400c554:	2b00      	cmp	r3, #0
3400c556:	d011      	beq.n	3400c57c <HAL_XSPIM_Config+0xf4>
  {
    if ((XSPI3->CR & XSPI_CR_EN) != 0U)
3400c558:	4b5f      	ldr	r3, [pc, #380]	@ (3400c6d8 <HAL_XSPIM_Config+0x250>)
3400c55a:	681b      	ldr	r3, [r3, #0]
3400c55c:	f003 0301 	and.w	r3, r3, #1
3400c560:	2b00      	cmp	r3, #0
3400c562:	d00b      	beq.n	3400c57c <HAL_XSPIM_Config+0xf4>
    {
      CLEAR_BIT(XSPI3->CR, XSPI_CR_EN);
3400c564:	4b5c      	ldr	r3, [pc, #368]	@ (3400c6d8 <HAL_XSPIM_Config+0x250>)
3400c566:	681b      	ldr	r3, [r3, #0]
3400c568:	4a5b      	ldr	r2, [pc, #364]	@ (3400c6d8 <HAL_XSPIM_Config+0x250>)
3400c56a:	f023 0301 	bic.w	r3, r3, #1
3400c56e:	6013      	str	r3, [r2, #0]
      xspi_enabled |= 0x4U;
3400c570:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
3400c574:	f043 0304 	orr.w	r3, r3, #4
3400c578:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36
    }
  }

  /***************** Deactivation of previous configuration *****************/
  CLEAR_REG(XSPIM->CR);
3400c57c:	4b57      	ldr	r3, [pc, #348]	@ (3400c6dc <HAL_XSPIM_Config+0x254>)
3400c57e:	2200      	movs	r2, #0
3400c580:	601a      	str	r2, [r3, #0]

  /******************** Activation of new configuration *********************/
  MODIFY_REG(XSPIM->CR, XSPIM_CR_REQ2ACK_TIME, ((pCfg->Req2AckTime - 1U) << XSPIM_CR_REQ2ACK_TIME_Pos));
3400c582:	4b56      	ldr	r3, [pc, #344]	@ (3400c6dc <HAL_XSPIM_Config+0x254>)
3400c584:	681b      	ldr	r3, [r3, #0]
3400c586:	f423 027f 	bic.w	r2, r3, #16711680	@ 0xff0000
3400c58a:	68bb      	ldr	r3, [r7, #8]
3400c58c:	689b      	ldr	r3, [r3, #8]
3400c58e:	3b01      	subs	r3, #1
3400c590:	041b      	lsls	r3, r3, #16
3400c592:	4952      	ldr	r1, [pc, #328]	@ (3400c6dc <HAL_XSPIM_Config+0x254>)
3400c594:	4313      	orrs	r3, r2
3400c596:	600b      	str	r3, [r1, #0]

  if (hxspi->Instance == XSPI1)
3400c598:	68fb      	ldr	r3, [r7, #12]
3400c59a:	681b      	ldr	r3, [r3, #0]
3400c59c:	4a4c      	ldr	r2, [pc, #304]	@ (3400c6d0 <HAL_XSPIM_Config+0x248>)
3400c59e:	4293      	cmp	r3, r2
3400c5a0:	d110      	bne.n	3400c5c4 <HAL_XSPIM_Config+0x13c>
  {
    IOM_cfg[0].IOPort = pCfg->IOPort ;
3400c5a2:	68bb      	ldr	r3, [r7, #8]
3400c5a4:	685b      	ldr	r3, [r3, #4]
3400c5a6:	617b      	str	r3, [r7, #20]
    if (pCfg->nCSOverride != HAL_XSPI_CSSEL_OVR_DISABLED)
3400c5a8:	68bb      	ldr	r3, [r7, #8]
3400c5aa:	681b      	ldr	r3, [r3, #0]
3400c5ac:	2b00      	cmp	r3, #0
3400c5ae:	d03e      	beq.n	3400c62e <HAL_XSPIM_Config+0x1a6>
    {
      MODIFY_REG(XSPIM->CR, (XSPIM_CR_CSSEL_OVR_O1 | XSPIM_CR_CSSEL_OVR_EN), (pCfg->nCSOverride));
3400c5b0:	4b4a      	ldr	r3, [pc, #296]	@ (3400c6dc <HAL_XSPIM_Config+0x254>)
3400c5b2:	681b      	ldr	r3, [r3, #0]
3400c5b4:	f023 0230 	bic.w	r2, r3, #48	@ 0x30
3400c5b8:	68bb      	ldr	r3, [r7, #8]
3400c5ba:	681b      	ldr	r3, [r3, #0]
3400c5bc:	4947      	ldr	r1, [pc, #284]	@ (3400c6dc <HAL_XSPIM_Config+0x254>)
3400c5be:	4313      	orrs	r3, r2
3400c5c0:	600b      	str	r3, [r1, #0]
3400c5c2:	e034      	b.n	3400c62e <HAL_XSPIM_Config+0x1a6>
    else
    {
      /* Nothing to do */
    }
  }
  else if (hxspi->Instance == XSPI2)
3400c5c4:	68fb      	ldr	r3, [r7, #12]
3400c5c6:	681b      	ldr	r3, [r3, #0]
3400c5c8:	4a42      	ldr	r2, [pc, #264]	@ (3400c6d4 <HAL_XSPIM_Config+0x24c>)
3400c5ca:	4293      	cmp	r3, r2
3400c5cc:	d110      	bne.n	3400c5f0 <HAL_XSPIM_Config+0x168>
  {
    IOM_cfg[1].IOPort = pCfg->IOPort ;
3400c5ce:	68bb      	ldr	r3, [r7, #8]
3400c5d0:	685b      	ldr	r3, [r3, #4]
3400c5d2:	623b      	str	r3, [r7, #32]
    if (pCfg->nCSOverride != HAL_XSPI_CSSEL_OVR_DISABLED)
3400c5d4:	68bb      	ldr	r3, [r7, #8]
3400c5d6:	681b      	ldr	r3, [r3, #0]
3400c5d8:	2b00      	cmp	r3, #0
3400c5da:	d028      	beq.n	3400c62e <HAL_XSPIM_Config+0x1a6>
    {
      MODIFY_REG(XSPIM->CR, (XSPIM_CR_CSSEL_OVR_O2 | XSPIM_CR_CSSEL_OVR_EN), (pCfg->nCSOverride));
3400c5dc:	4b3f      	ldr	r3, [pc, #252]	@ (3400c6dc <HAL_XSPIM_Config+0x254>)
3400c5de:	681b      	ldr	r3, [r3, #0]
3400c5e0:	f023 0250 	bic.w	r2, r3, #80	@ 0x50
3400c5e4:	68bb      	ldr	r3, [r7, #8]
3400c5e6:	681b      	ldr	r3, [r3, #0]
3400c5e8:	493c      	ldr	r1, [pc, #240]	@ (3400c6dc <HAL_XSPIM_Config+0x254>)
3400c5ea:	4313      	orrs	r3, r2
3400c5ec:	600b      	str	r3, [r1, #0]
3400c5ee:	e01e      	b.n	3400c62e <HAL_XSPIM_Config+0x1a6>
    else
    {
      /* Nothing to do */
    }
  }
  else if (hxspi->Instance == XSPI3)
3400c5f0:	68fb      	ldr	r3, [r7, #12]
3400c5f2:	681b      	ldr	r3, [r3, #0]
3400c5f4:	4a38      	ldr	r2, [pc, #224]	@ (3400c6d8 <HAL_XSPIM_Config+0x250>)
3400c5f6:	4293      	cmp	r3, r2
3400c5f8:	d111      	bne.n	3400c61e <HAL_XSPIM_Config+0x196>
  {
    if (pCfg->IOPort == HAL_XSPIM_IOPORT_1)
3400c5fa:	68bb      	ldr	r3, [r7, #8]
3400c5fc:	685b      	ldr	r3, [r3, #4]
3400c5fe:	2b00      	cmp	r3, #0
3400c600:	d104      	bne.n	3400c60c <HAL_XSPIM_Config+0x184>
    {
      IOM_cfg[0].IOPort = HAL_XSPIM_IOPORT_2 ;
3400c602:	2301      	movs	r3, #1
3400c604:	617b      	str	r3, [r7, #20]
      IOM_cfg[1].IOPort = HAL_XSPIM_IOPORT_2 ;
3400c606:	2301      	movs	r3, #1
3400c608:	623b      	str	r3, [r7, #32]
3400c60a:	e010      	b.n	3400c62e <HAL_XSPIM_Config+0x1a6>
    }
    else if (pCfg->IOPort == HAL_XSPIM_IOPORT_2)
3400c60c:	68bb      	ldr	r3, [r7, #8]
3400c60e:	685b      	ldr	r3, [r3, #4]
3400c610:	2b01      	cmp	r3, #1
3400c612:	d10c      	bne.n	3400c62e <HAL_XSPIM_Config+0x1a6>
    {
      IOM_cfg[0].IOPort = HAL_XSPIM_IOPORT_1 ;
3400c614:	2300      	movs	r3, #0
3400c616:	617b      	str	r3, [r7, #20]
      IOM_cfg[1].IOPort = HAL_XSPIM_IOPORT_1 ;
3400c618:	2300      	movs	r3, #0
3400c61a:	623b      	str	r3, [r7, #32]
3400c61c:	e007      	b.n	3400c62e <HAL_XSPIM_Config+0x1a6>
      /* Nothing to do */
    }
  }
  else
  {
    hxspi->ErrorCode |= HAL_XSPI_ERROR_INVALID_PARAM;
3400c61e:	68fb      	ldr	r3, [r7, #12]
3400c620:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
3400c622:	f043 0208 	orr.w	r2, r3, #8
3400c626:	68fb      	ldr	r3, [r7, #12]
3400c628:	65da      	str	r2, [r3, #92]	@ 0x5c
    return HAL_ERROR;
3400c62a:	2301      	movs	r3, #1
3400c62c:	e04c      	b.n	3400c6c8 <HAL_XSPIM_Config+0x240>
  }

  for (index = 0U; index < (XSPI_NB_INSTANCE - 2U); index++)
3400c62e:	2300      	movs	r3, #0
3400c630:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
3400c634:	e02a      	b.n	3400c68c <HAL_XSPIM_Config+0x204>
  {
    if (IOM_cfg[index].IOPort == IOM_cfg[index + 1U].IOPort)
3400c636:	f897 2037 	ldrb.w	r2, [r7, #55]	@ 0x37
3400c63a:	4613      	mov	r3, r2
3400c63c:	005b      	lsls	r3, r3, #1
3400c63e:	4413      	add	r3, r2
3400c640:	009b      	lsls	r3, r3, #2
3400c642:	3338      	adds	r3, #56	@ 0x38
3400c644:	443b      	add	r3, r7
3400c646:	3b24      	subs	r3, #36	@ 0x24
3400c648:	6819      	ldr	r1, [r3, #0]
3400c64a:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
3400c64e:	1c5a      	adds	r2, r3, #1
3400c650:	4613      	mov	r3, r2
3400c652:	005b      	lsls	r3, r3, #1
3400c654:	4413      	add	r3, r2
3400c656:	009b      	lsls	r3, r3, #2
3400c658:	3338      	adds	r3, #56	@ 0x38
3400c65a:	443b      	add	r3, r7
3400c65c:	3b24      	subs	r3, #36	@ 0x24
3400c65e:	681b      	ldr	r3, [r3, #0]
3400c660:	4299      	cmp	r1, r3
3400c662:	d105      	bne.n	3400c670 <HAL_XSPIM_Config+0x1e8>
    {
      /*Mux*/
      SET_BIT(XSPIM->CR, XSPIM_CR_MUXEN);
3400c664:	4b1d      	ldr	r3, [pc, #116]	@ (3400c6dc <HAL_XSPIM_Config+0x254>)
3400c666:	681b      	ldr	r3, [r3, #0]
3400c668:	4a1c      	ldr	r2, [pc, #112]	@ (3400c6dc <HAL_XSPIM_Config+0x254>)
3400c66a:	f043 0301 	orr.w	r3, r3, #1
3400c66e:	6013      	str	r3, [r2, #0]
    }
    else
    {
      /* Nothing to do */
    }
    if (IOM_cfg[0].IOPort == HAL_XSPIM_IOPORT_2)
3400c670:	697b      	ldr	r3, [r7, #20]
3400c672:	2b01      	cmp	r3, #1
3400c674:	d105      	bne.n	3400c682 <HAL_XSPIM_Config+0x1fa>
    {
      /*Mode*/
      SET_BIT(XSPIM->CR, XSPIM_CR_MODE);
3400c676:	4b19      	ldr	r3, [pc, #100]	@ (3400c6dc <HAL_XSPIM_Config+0x254>)
3400c678:	681b      	ldr	r3, [r3, #0]
3400c67a:	4a18      	ldr	r2, [pc, #96]	@ (3400c6dc <HAL_XSPIM_Config+0x254>)
3400c67c:	f043 0302 	orr.w	r3, r3, #2
3400c680:	6013      	str	r3, [r2, #0]
  for (index = 0U; index < (XSPI_NB_INSTANCE - 2U); index++)
3400c682:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
3400c686:	3301      	adds	r3, #1
3400c688:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
3400c68c:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
3400c690:	2b00      	cmp	r3, #0
3400c692:	d0d0      	beq.n	3400c636 <HAL_XSPIM_Config+0x1ae>
      /* Nothing to do */
    }
  }

  /******* Re-enable both XSPI after configure XSPI IO Manager ********/
  if ((xspi_enabled & 0x1U) != 0U)
3400c694:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
3400c698:	f003 0301 	and.w	r3, r3, #1
3400c69c:	2b00      	cmp	r3, #0
3400c69e:	d005      	beq.n	3400c6ac <HAL_XSPIM_Config+0x224>
  {
    SET_BIT(XSPI1->CR, XSPI_CR_EN);
3400c6a0:	4b0b      	ldr	r3, [pc, #44]	@ (3400c6d0 <HAL_XSPIM_Config+0x248>)
3400c6a2:	681b      	ldr	r3, [r3, #0]
3400c6a4:	4a0a      	ldr	r2, [pc, #40]	@ (3400c6d0 <HAL_XSPIM_Config+0x248>)
3400c6a6:	f043 0301 	orr.w	r3, r3, #1
3400c6aa:	6013      	str	r3, [r2, #0]
  }
  if ((xspi_enabled & 0x2U) != 0U)
3400c6ac:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
3400c6b0:	f003 0302 	and.w	r3, r3, #2
3400c6b4:	2b00      	cmp	r3, #0
3400c6b6:	d005      	beq.n	3400c6c4 <HAL_XSPIM_Config+0x23c>
  {
    SET_BIT(XSPI2->CR, XSPI_CR_EN);
3400c6b8:	4b06      	ldr	r3, [pc, #24]	@ (3400c6d4 <HAL_XSPIM_Config+0x24c>)
3400c6ba:	681b      	ldr	r3, [r3, #0]
3400c6bc:	4a05      	ldr	r2, [pc, #20]	@ (3400c6d4 <HAL_XSPIM_Config+0x24c>)
3400c6be:	f043 0301 	orr.w	r3, r3, #1
3400c6c2:	6013      	str	r3, [r2, #0]
  }

  return status;
3400c6c4:	f897 3035 	ldrb.w	r3, [r7, #53]	@ 0x35
}
3400c6c8:	4618      	mov	r0, r3
3400c6ca:	3738      	adds	r7, #56	@ 0x38
3400c6cc:	46bd      	mov	sp, r7
3400c6ce:	bd80      	pop	{r7, pc}
3400c6d0:	58025000 	.word	0x58025000
3400c6d4:	5802a000 	.word	0x5802a000
3400c6d8:	5802d000 	.word	0x5802d000
3400c6dc:	5802b400 	.word	0x5802b400

3400c6e0 <XSPI_WaitFlagStateUntilTimeout>:
  * @param  Tickstart : Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef XSPI_WaitFlagStateUntilTimeout(XSPI_HandleTypeDef *hxspi, uint32_t Flag,
                                                        FlagStatus State, uint32_t Tickstart, uint32_t Timeout)
{
3400c6e0:	b580      	push	{r7, lr}
3400c6e2:	b084      	sub	sp, #16
3400c6e4:	af00      	add	r7, sp, #0
3400c6e6:	60f8      	str	r0, [r7, #12]
3400c6e8:	60b9      	str	r1, [r7, #8]
3400c6ea:	603b      	str	r3, [r7, #0]
3400c6ec:	4613      	mov	r3, r2
3400c6ee:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is in expected state */
  while ((HAL_XSPI_GET_FLAG(hxspi, Flag)) != State)
3400c6f0:	e019      	b.n	3400c726 <XSPI_WaitFlagStateUntilTimeout+0x46>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
3400c6f2:	69bb      	ldr	r3, [r7, #24]
3400c6f4:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
3400c6f8:	d015      	beq.n	3400c726 <XSPI_WaitFlagStateUntilTimeout+0x46>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
3400c6fa:	f7f5 f939 	bl	34001970 <HAL_GetTick>
3400c6fe:	4602      	mov	r2, r0
3400c700:	683b      	ldr	r3, [r7, #0]
3400c702:	1ad3      	subs	r3, r2, r3
3400c704:	69ba      	ldr	r2, [r7, #24]
3400c706:	429a      	cmp	r2, r3
3400c708:	d302      	bcc.n	3400c710 <XSPI_WaitFlagStateUntilTimeout+0x30>
3400c70a:	69bb      	ldr	r3, [r7, #24]
3400c70c:	2b00      	cmp	r3, #0
3400c70e:	d10a      	bne.n	3400c726 <XSPI_WaitFlagStateUntilTimeout+0x46>
      {
        hxspi->State     = HAL_XSPI_STATE_READY;
3400c710:	68fb      	ldr	r3, [r7, #12]
3400c712:	2202      	movs	r2, #2
3400c714:	659a      	str	r2, [r3, #88]	@ 0x58
        hxspi->ErrorCode |= HAL_XSPI_ERROR_TIMEOUT;
3400c716:	68fb      	ldr	r3, [r7, #12]
3400c718:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
3400c71a:	f043 0201 	orr.w	r2, r3, #1
3400c71e:	68fb      	ldr	r3, [r7, #12]
3400c720:	65da      	str	r2, [r3, #92]	@ 0x5c

        return HAL_TIMEOUT;
3400c722:	2303      	movs	r3, #3
3400c724:	e00e      	b.n	3400c744 <XSPI_WaitFlagStateUntilTimeout+0x64>
  while ((HAL_XSPI_GET_FLAG(hxspi, Flag)) != State)
3400c726:	68fb      	ldr	r3, [r7, #12]
3400c728:	681b      	ldr	r3, [r3, #0]
3400c72a:	6a1a      	ldr	r2, [r3, #32]
3400c72c:	68bb      	ldr	r3, [r7, #8]
3400c72e:	4013      	ands	r3, r2
3400c730:	2b00      	cmp	r3, #0
3400c732:	bf14      	ite	ne
3400c734:	2301      	movne	r3, #1
3400c736:	2300      	moveq	r3, #0
3400c738:	b2db      	uxtb	r3, r3
3400c73a:	461a      	mov	r2, r3
3400c73c:	79fb      	ldrb	r3, [r7, #7]
3400c73e:	429a      	cmp	r2, r3
3400c740:	d1d7      	bne.n	3400c6f2 <XSPI_WaitFlagStateUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
3400c742:	2300      	movs	r3, #0
}
3400c744:	4618      	mov	r0, r3
3400c746:	3710      	adds	r7, #16
3400c748:	46bd      	mov	sp, r7
3400c74a:	bd80      	pop	{r7, pc}

3400c74c <XSPIM_GetConfig>:
  * @param  instance_nb : number of the instance
  * @param  pCfg         : configuration of the IO Manager for the instance
  * @retval HAL status
  */
static void XSPIM_GetConfig(uint8_t instance_nb, XSPIM_CfgTypeDef *pCfg)
{
3400c74c:	b480      	push	{r7}
3400c74e:	b085      	sub	sp, #20
3400c750:	af00      	add	r7, sp, #0
3400c752:	4603      	mov	r3, r0
3400c754:	6039      	str	r1, [r7, #0]
3400c756:	71fb      	strb	r3, [r7, #7]
  uint32_t mux;
  uint32_t mode;

  if (instance_nb == 1U)
3400c758:	79fb      	ldrb	r3, [r7, #7]
3400c75a:	2b01      	cmp	r3, #1
3400c75c:	d124      	bne.n	3400c7a8 <XSPIM_GetConfig+0x5c>
  {
    if ((XSPIM->CR & XSPIM_CR_MODE) == 0U)
3400c75e:	4b2c      	ldr	r3, [pc, #176]	@ (3400c810 <XSPIM_GetConfig+0xc4>)
3400c760:	681b      	ldr	r3, [r3, #0]
3400c762:	f003 0302 	and.w	r3, r3, #2
3400c766:	2b00      	cmp	r3, #0
3400c768:	d103      	bne.n	3400c772 <XSPIM_GetConfig+0x26>
    {
      pCfg->IOPort = HAL_XSPIM_IOPORT_1;
3400c76a:	683b      	ldr	r3, [r7, #0]
3400c76c:	2200      	movs	r2, #0
3400c76e:	605a      	str	r2, [r3, #4]
3400c770:	e002      	b.n	3400c778 <XSPIM_GetConfig+0x2c>
    }
    else
    {
      pCfg->IOPort = HAL_XSPIM_IOPORT_2;
3400c772:	683b      	ldr	r3, [r7, #0]
3400c774:	2201      	movs	r2, #1
3400c776:	605a      	str	r2, [r3, #4]
    }

    if ((XSPIM->CR & XSPIM_CR_CSSEL_OVR_EN) != XSPIM_CR_CSSEL_OVR_EN)
3400c778:	4b25      	ldr	r3, [pc, #148]	@ (3400c810 <XSPIM_GetConfig+0xc4>)
3400c77a:	681b      	ldr	r3, [r3, #0]
3400c77c:	f003 0310 	and.w	r3, r3, #16
3400c780:	2b10      	cmp	r3, #16
3400c782:	d003      	beq.n	3400c78c <XSPIM_GetConfig+0x40>
    {
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_DISABLED;
3400c784:	683b      	ldr	r3, [r7, #0]
3400c786:	2200      	movs	r2, #0
3400c788:	601a      	str	r2, [r3, #0]
    else
    {
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_NCS1;
    }
  }
}
3400c78a:	e03a      	b.n	3400c802 <XSPIM_GetConfig+0xb6>
    else if ((XSPIM->CR & XSPIM_CR_CSSEL_OVR_O1) == XSPIM_CR_CSSEL_OVR_O1)
3400c78c:	4b20      	ldr	r3, [pc, #128]	@ (3400c810 <XSPIM_GetConfig+0xc4>)
3400c78e:	681b      	ldr	r3, [r3, #0]
3400c790:	f003 0320 	and.w	r3, r3, #32
3400c794:	2b20      	cmp	r3, #32
3400c796:	d103      	bne.n	3400c7a0 <XSPIM_GetConfig+0x54>
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_NCS2;
3400c798:	683b      	ldr	r3, [r7, #0]
3400c79a:	2270      	movs	r2, #112	@ 0x70
3400c79c:	601a      	str	r2, [r3, #0]
}
3400c79e:	e030      	b.n	3400c802 <XSPIM_GetConfig+0xb6>
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_NCS1;
3400c7a0:	683b      	ldr	r3, [r7, #0]
3400c7a2:	2210      	movs	r2, #16
3400c7a4:	601a      	str	r2, [r3, #0]
}
3400c7a6:	e02c      	b.n	3400c802 <XSPIM_GetConfig+0xb6>
    mux = (XSPIM->CR & XSPIM_CR_MUXEN);
3400c7a8:	4b19      	ldr	r3, [pc, #100]	@ (3400c810 <XSPIM_GetConfig+0xc4>)
3400c7aa:	681b      	ldr	r3, [r3, #0]
3400c7ac:	f003 0301 	and.w	r3, r3, #1
3400c7b0:	60fb      	str	r3, [r7, #12]
    mode = ((XSPIM->CR & XSPIM_CR_MODE) >> XSPIM_CR_MODE_Pos);
3400c7b2:	4b17      	ldr	r3, [pc, #92]	@ (3400c810 <XSPIM_GetConfig+0xc4>)
3400c7b4:	681b      	ldr	r3, [r3, #0]
3400c7b6:	085b      	lsrs	r3, r3, #1
3400c7b8:	f003 0301 	and.w	r3, r3, #1
3400c7bc:	60bb      	str	r3, [r7, #8]
    if (mux != mode)
3400c7be:	68fa      	ldr	r2, [r7, #12]
3400c7c0:	68bb      	ldr	r3, [r7, #8]
3400c7c2:	429a      	cmp	r2, r3
3400c7c4:	d003      	beq.n	3400c7ce <XSPIM_GetConfig+0x82>
      pCfg->IOPort = HAL_XSPIM_IOPORT_1;
3400c7c6:	683b      	ldr	r3, [r7, #0]
3400c7c8:	2200      	movs	r2, #0
3400c7ca:	605a      	str	r2, [r3, #4]
3400c7cc:	e002      	b.n	3400c7d4 <XSPIM_GetConfig+0x88>
      pCfg->IOPort = HAL_XSPIM_IOPORT_2;
3400c7ce:	683b      	ldr	r3, [r7, #0]
3400c7d0:	2201      	movs	r2, #1
3400c7d2:	605a      	str	r2, [r3, #4]
    if ((XSPIM->CR & XSPIM_CR_CSSEL_OVR_EN) != XSPIM_CR_CSSEL_OVR_EN)
3400c7d4:	4b0e      	ldr	r3, [pc, #56]	@ (3400c810 <XSPIM_GetConfig+0xc4>)
3400c7d6:	681b      	ldr	r3, [r3, #0]
3400c7d8:	f003 0310 	and.w	r3, r3, #16
3400c7dc:	2b10      	cmp	r3, #16
3400c7de:	d003      	beq.n	3400c7e8 <XSPIM_GetConfig+0x9c>
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_DISABLED;
3400c7e0:	683b      	ldr	r3, [r7, #0]
3400c7e2:	2200      	movs	r2, #0
3400c7e4:	601a      	str	r2, [r3, #0]
}
3400c7e6:	e00c      	b.n	3400c802 <XSPIM_GetConfig+0xb6>
    else if ((XSPIM->CR & XSPIM_CR_CSSEL_OVR_O2) == XSPIM_CR_CSSEL_OVR_O2)
3400c7e8:	4b09      	ldr	r3, [pc, #36]	@ (3400c810 <XSPIM_GetConfig+0xc4>)
3400c7ea:	681b      	ldr	r3, [r3, #0]
3400c7ec:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3400c7f0:	2b40      	cmp	r3, #64	@ 0x40
3400c7f2:	d103      	bne.n	3400c7fc <XSPIM_GetConfig+0xb0>
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_NCS2;
3400c7f4:	683b      	ldr	r3, [r7, #0]
3400c7f6:	2270      	movs	r2, #112	@ 0x70
3400c7f8:	601a      	str	r2, [r3, #0]
}
3400c7fa:	e002      	b.n	3400c802 <XSPIM_GetConfig+0xb6>
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_NCS1;
3400c7fc:	683b      	ldr	r3, [r7, #0]
3400c7fe:	2210      	movs	r2, #16
3400c800:	601a      	str	r2, [r3, #0]
}
3400c802:	bf00      	nop
3400c804:	3714      	adds	r7, #20
3400c806:	46bd      	mov	sp, r7
3400c808:	f85d 7b04 	ldr.w	r7, [sp], #4
3400c80c:	4770      	bx	lr
3400c80e:	bf00      	nop
3400c810:	5802b400 	.word	0x5802b400

3400c814 <memset>:
3400c814:	4402      	add	r2, r0
3400c816:	4603      	mov	r3, r0
3400c818:	4293      	cmp	r3, r2
3400c81a:	d100      	bne.n	3400c81e <memset+0xa>
3400c81c:	4770      	bx	lr
3400c81e:	f803 1b01 	strb.w	r1, [r3], #1
3400c822:	e7f9      	b.n	3400c818 <memset+0x4>

3400c824 <__libc_init_array>:
3400c824:	b570      	push	{r4, r5, r6, lr}
3400c826:	4d0d      	ldr	r5, [pc, #52]	@ (3400c85c <__libc_init_array+0x38>)
3400c828:	2600      	movs	r6, #0
3400c82a:	4c0d      	ldr	r4, [pc, #52]	@ (3400c860 <__libc_init_array+0x3c>)
3400c82c:	1b64      	subs	r4, r4, r5
3400c82e:	10a4      	asrs	r4, r4, #2
3400c830:	42a6      	cmp	r6, r4
3400c832:	d109      	bne.n	3400c848 <__libc_init_array+0x24>
3400c834:	4d0b      	ldr	r5, [pc, #44]	@ (3400c864 <__libc_init_array+0x40>)
3400c836:	2600      	movs	r6, #0
3400c838:	4c0b      	ldr	r4, [pc, #44]	@ (3400c868 <__libc_init_array+0x44>)
3400c83a:	f000 f825 	bl	3400c888 <_init>
3400c83e:	1b64      	subs	r4, r4, r5
3400c840:	10a4      	asrs	r4, r4, #2
3400c842:	42a6      	cmp	r6, r4
3400c844:	d105      	bne.n	3400c852 <__libc_init_array+0x2e>
3400c846:	bd70      	pop	{r4, r5, r6, pc}
3400c848:	f855 3b04 	ldr.w	r3, [r5], #4
3400c84c:	3601      	adds	r6, #1
3400c84e:	4798      	blx	r3
3400c850:	e7ee      	b.n	3400c830 <__libc_init_array+0xc>
3400c852:	f855 3b04 	ldr.w	r3, [r5], #4
3400c856:	3601      	adds	r6, #1
3400c858:	4798      	blx	r3
3400c85a:	e7f2      	b.n	3400c842 <__libc_init_array+0x1e>
3400c85c:	3400cac8 	.word	0x3400cac8
3400c860:	3400cac8 	.word	0x3400cac8
3400c864:	3400cac8 	.word	0x3400cac8
3400c868:	3400cacc 	.word	0x3400cacc

3400c86c <memcpy>:
3400c86c:	440a      	add	r2, r1
3400c86e:	1e43      	subs	r3, r0, #1
3400c870:	4291      	cmp	r1, r2
3400c872:	d100      	bne.n	3400c876 <memcpy+0xa>
3400c874:	4770      	bx	lr
3400c876:	b510      	push	{r4, lr}
3400c878:	f811 4b01 	ldrb.w	r4, [r1], #1
3400c87c:	4291      	cmp	r1, r2
3400c87e:	f803 4f01 	strb.w	r4, [r3, #1]!
3400c882:	d1f9      	bne.n	3400c878 <memcpy+0xc>
3400c884:	bd10      	pop	{r4, pc}
	...

3400c888 <_init>:
3400c888:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3400c88a:	bf00      	nop
3400c88c:	bcf8      	pop	{r3, r4, r5, r6, r7}
3400c88e:	bc08      	pop	{r3}
3400c890:	469e      	mov	lr, r3
3400c892:	4770      	bx	lr

3400c894 <_fini>:
3400c894:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3400c896:	bf00      	nop
3400c898:	bcf8      	pop	{r3, r4, r5, r6, r7}
3400c89a:	bc08      	pop	{r3}
3400c89c:	469e      	mov	lr, r3
3400c89e:	4770      	bx	lr

Disassembly of section .gnu.sgstubs:

3400cae0 <SECURE_SystemCoreClockUpdate>:
3400cae0:	e97f e97f 	sg
3400cae4:	f7f4 bea0 	b.w	34001828 <__acle_se_SECURE_SystemCoreClockUpdate>

3400cae8 <SECURE_RegisterCallback>:
3400cae8:	e97f e97f 	sg
3400caec:	f7f4 b9d0 	b.w	34000e90 <__acle_se_SECURE_RegisterCallback>
	...
